<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2018-06-19T02:13:17.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>21. Consumer Priorities 消费者优先级</title>
    <link href="http://blog.renyimin.com/2018/06/15/rabbitmq/2018-06-15-rabbitmq-21/"/>
    <id>http://blog.renyimin.com/2018/06/15/rabbitmq/2018-06-15-rabbitmq-21/</id>
    <published>2018-06-15T02:04:26.000Z</published>
    <updated>2018-06-19T02:13:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Consumer-Priorities"><a href="#Consumer-Priorities" class="headerlink" title="Consumer Priorities"></a><a href="https://www.rabbitmq.com/consumer-priority.html" target="_blank" rel="external">Consumer Priorities</a></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li><p>消费者优先级允许你确保高优先级的消费者在活跃时接收消息, 并且消息只有在高优先级消费者阻塞时才会转向低优先级的消费者.</p></li><li><p>通常, 连接到队列的活跃消费者, 是以循环方式接收来自它的消息; 当使用 “消费者优先级” 时, 如果存在多个活跃的消费者具有相同的高优先级, 消息也会被循环传送给它们;</p></li></ol><h3 id="定义活跃消费者"><a href="#定义活跃消费者" class="headerlink" title="定义活跃消费者"></a>定义活跃消费者</h3><ol><li><p>活跃的消费者是可以无需等待就能收到消息的消费者. 假如一个消费者无法接收消息, 它就会变成阻塞状态: 因为它的 channel 在发布 basic.qos 之后已达到 unack消息的最大数量, 或者仅仅是因为网络拥塞;</p></li><li><p>当消费者的 “优先级” 被使用时, 你可以期望你的最高优先级的消费者接收所有的消息, 直到它们被阻塞, 然后较低优先级的消费者才将开始接收一些消息;</p></li><li><p>理解RabbitMQ仍然会优先传递消息是很重要的: 如果有一个活跃着的低优先级消费者已经准备好了, Rabbitmq是不会等待高优先级的阻塞消费者变成非阻塞的(它会将消息发送给已经准备好的低优先级的活跃消费者);</p></li></ol><h3 id="使用消费者-优先级别"><a href="#使用消费者-优先级别" class="headerlink" title="使用消费者 优先级别"></a>使用消费者 优先级别</h3><ol><li><p>将 <code>basic.consume()</code> 方法中的 <code>$arguments</code> 参数的 <code>x-priority</code> 属性设置为整数值, 未指定值的消费者优先级为0, 更大的数字表示更高的优先级, 并且可以使用正数和负数;</p></li><li><p>注意事项: </p><ul><li><p>多个消费者共同绑定同一个队列时, 可以给消费者设置优先级, 这样, 优先级高的消费者会优先拿到消息并进行处理, <strong>除非优先级高的都处于阻塞状态(unack达到Qos设置的上限值)</strong>, 否则优先级低的消费者不会拿到消息;<br>通过运行下面示例(没有设置Qos时)可以发现, 同时启动两个消费者, 然后刷新生产者, 会发现在高优先级的消费者在默认不设置Qos时, 即不阻塞的情况下, 低优先级消费者一条消息也不会收到(没有消费结果);</p></li><li><p>接下来可以模拟高优先级的Consumer阻塞, 会发现, 高优先级的Consumer在拿到第一条消息之后, 优先级低的Consumer会立刻开始进行处理<br>注意, 模拟消费者阻塞时, 不能只通过比如 <code>sleep(50)</code> 这种方式, 因为这样只是消费者的处理速度变慢, 但是<strong>消费者的预取量还是默认的(即不受限制)</strong>, 所以消息还是会被发送给优先级高的消费者, 这样造成的结果就是 优先级高的消费者一直在缓慢地消费, 而优先级低的消费者一直在闲置;<br>所以还需要给优先级高的消费者设定 <code>Qos=1</code> 来进行测试(设定为1是为了测试方便, 也可以设置其他值, 不过这样的话, 就会有qos所设置的数量的消息被优先推送给高优先级的consumer, 直到达到qos量之后才会阻塞), 这样才能使得优先级高的消费者在没有急时ack的情况下被阻塞, 从而让优先级低的Consumer进行消费<br>实例运行(刷新生产者10次尝试一下)可以发现, 高优先级的消费者在拿到第一条消息后, 后面的消息都给了 低优先级的消费者, 但随着高优先级的消费者进行ack而恢复活跃状态, 又会优先拿到消息</p></li></ul></li><li><p>示例可查看: </p><ul><li><a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Http/Controllers/Demo/TestPriorityConsumerController.php" target="_blank" rel="external">生产者 TestPriorityConsumerController.php </a>    </li><li><a href="https://github.com/rymuscle/Laravel-RabbitMQ/tree/master/app/Console/Commands" target="_blank" rel="external">消费者 priorityConsumer1.php, priorityConsumer2.php</a></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Consumer-Priorities&quot;&gt;&lt;a href=&quot;#Consumer-Priorities&quot; class=&quot;headerlink&quot; title=&quot;Consumer Priorities&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.rabbitmq
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>19. 消费者预取 Consumer Prefetch - RabbitMQ关于 吞吐量, 延迟 和 带宽 的一些理论</title>
    <link href="http://blog.renyimin.com/2018/06/12/rabbitmq/2018-06-12-rabbitmq-19/"/>
    <id>http://blog.renyimin.com/2018/06/12/rabbitmq/2018-06-12-rabbitmq-19/</id>
    <published>2018-06-12T03:26:55.000Z</published>
    <updated>2018-06-19T02:12:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ关于吞吐量-延迟和带宽的一些理论"><a href="#RabbitMQ关于吞吐量-延迟和带宽的一些理论" class="headerlink" title="RabbitMQ关于吞吐量,延迟和带宽的一些理论"></a>RabbitMQ关于吞吐量,延迟和带宽的一些理论</h2><ol><li><p>官方文档: <a href="https://www.rabbitmq.com/blog/2012/05/11/some-queuing-theory-throughput-latency-and-bandwidth/" target="_blank" rel="external">https://www.rabbitmq.com/blog/2012/05/11/some-queuing-theory-throughput-latency-and-bandwidth/</a> </p></li><li><p>译文: 网上虽然有很多版本的译文, 在此处还是重新做了翻译</p><ul><li><p>你在Rabbit中有一个队列, 然后有一些客户端从这个队列中进行消费;<br>如果你根本没有设置QoS(basic.qos), 那么Rabbit将尽可能快地按照网络和客户端允许的速度将所有队列的消息推送到客户端; 因此, 消费者所占用的内存将会激增, 因为它们将所有消息都缓存在自己的RAM中;<br>同时, 值得注意的是: 此时如果你询问Rabbit, <strong>队列可能会显示为空</strong>, 但是会有大量的未确认消息在客户端中, 准备被客户端应用程序处理;<br>并且此时如果你添加新的消费者, 由于没有消息留在队列中, 所以队列也无法将消息发送给新的消费者的;<br>尽管有其他消费者可用于更快地处理消息, 但由于消息已经在现有的客户端中缓存, 并且可能在那里很长一段时间, 所以这是相当次优的!</p></li><li><p>所以，默认的QoS预取给客户端(consumer)设置了无限的缓冲区, 这可能导致不良的行为和性能; 那么, 应该将QoS预取缓冲区大小设置为多少呢?<br>目标是让消费者保持工作饱和状态, <strong>但要尽量减少客户端的缓冲区大小, 以便让更多的消息保留在Rabbit的队列中, 这样就可以供新消费者来消费</strong>;</p></li><li><p>比方说, Rabbit从这个队列中拿出一条消息, 把它放到网络上，然后到达消费者, 需要50ms; 客户端处理消息需要4ms;<br>一旦消费者处理了消息, 它就会发送一个ack给Rabbit, 这将再次花费50ms发送给Rabbit并被Rabbit进行处理; 所以我们总共有104ms的往返时间。<br>如果我们消息设置了QoS预取值为1, 那么直到这个往返行程完成之前, Rabbit是不会发送下一个消息给客户端的;<br>因此, <strong>每次往返的104ms中, 客户端只有4ms,或者说只有3.8％的时间忙碌, 而我们希望百分之百的时间都在忙碌中</strong>;</p></li><li><p>如果我们在每个消息的客户端上执行 <code>总的往返时间/处理时间</code>, 会得到 <code>104/4 = 26</code><br>如果我们设置消息的QoS预取值为26, 那就解决了我们的问题: 假设客户端具有26个消息缓冲, 等待处理<br>(这是一个明智的假设:<br>一旦你设置了basic.qos, 然后从一个队列中进行消费, Rabbit将会尽可能多的将消息发送到你订阅该队列的客户端中, 直到QoS的限制;</p></li><li><p>如果你认为消息不是很大, 带宽也很高, 那么Rabbit很可能更快地发送消息到你的客户端, 因此, 从完整的客户端缓冲区的角度来做所有的数学运算是合理的(也更简单的)</p></li><li><p>如果每条消息需要4ms的处理来处理, 那么总共需要 <code>26×4 = 104ms</code> 来处理整个缓冲区(中的消息);<br>第一个4ms是第一个消息的客户端处理消息的时间, 处理完成后, 客户端然后发出一个确认(这一点需要50ms才能到达代理), 然后继续处理缓冲区中的下一条消息, 代理向客户端发出一条新消息, 这需要50ms的时间, 所以到了104ms时间, 客户端已经完成缓冲区的处理, 代理的下一条消息已经到达, 并准备好等待客户端来处理它;<br>因此, 客户端始终处于忙碌状态: 具有较大的QoS预取值也不会使其更快了, 但是我们最大限度地减少了缓冲区的大小, 并且减少了客户端消息的延迟; 事实上, <strong>客户端能够在下一条消息到达之前完全排空缓冲区, 因此缓冲区实际上保持为空</strong>;</p></li><li><p>如果处理时间和网络行为保持不变, 此解决方案绝对没问题<br>但考虑一下如果网络突然间速度减半会发生什么情况(rymuscle:显然, <strong>网络传输时间就加长了</strong>): 此时你的预取缓冲区(也就是你设置的prefetch预取值)就不够大了, 现在客户端会就会闲置, 等待新消息到达, 因为客户端能够处理消息的速度比Rabbit能够提供新消息的速度要快;</p></li><li><p>为了解决这个问题, 我们可能会决定将QoS预取大小加倍(或接近两倍), 如果我们从26开始将它推到51, 那么如果客户端处理保持在每个消息4ms, 我们现在在缓冲区中会有51 <em> 4 = 204ms的消息处理时间, 其中4ms将用于处理消息, 而200ms用于发送消息回复rabbit并收到下一条消息, 因此, 我们现在可以应对网络速度的减半;<br>但是, 如果网络正常运行, 现在将QoS预取加倍, 意味着每个消息都会驻留在客户端缓冲区中一段时间​​, 而不是在到达客户端时立即处理;<br>再次分析: 从现在51条消息的完整缓冲区开始, 我们知道新消息将在客户端完成处理第一条消息之后的100ms处开始出现在客户端, 但在这100毫秒内, 客户只能处理100/4 = 25个消息, 这意味着当新消息到达客户端时, 它会在客户端从缓冲区头部移除时被添加到缓冲区的末尾;<br>而缓冲区将始终保持(50 - 25 = 25)个消息长度, 因此每个消息将在缓冲区中保持 25 </em> 4 = 100ms<br><strong>所以有时候你会看到你的消费者虽然活着没有假死, 但是却有大量的unacked!</strong> 可以考虑一下这个原因!!</p></li><li><p>因此, 我们看到, <strong>增加预取缓冲区大小, 以便客户端可以应对恶化的网络性能, 同时保持客户端繁忙, 大大增加网络正常运行时的延迟!!</strong></p></li><li><p>同样, 如果不是网络性能的恶化, 而是客户端开始花费40ms来处理每条消息而不是之前的4ms, 会发生什么情况?<br>假设原始的预取缓冲区大小设置的是26条消息, 客户端现在需要花40ms处理第一条消息, 然后将确认消息发送回Rabbit并移至下一条消息;<br>ack仍然需要50ms才能到达Rabbit, 而Rabbit发出一条新的消息需要50ms, 但在100ms内, 客户端只处理了 100/40 = 2.5 条消息, 而不是剩余的25条消息;<br>因此当新消息到来时, 缓冲区在这一点上仍然是有 25 - 3 = 22 个消息, 这样的话, 来自Rabbit的新消息就不会被立即处理, 而是位于第23位, 落后于其他22条仍在等待处理的消息;<br>客户端(Consumer)将会有 22 * 40 = 880ms 的时间都不会触及到那个新到的消息, 鉴于从Rabbit到客户端的网络延迟仅为50ms, 这个额外的880ms延迟现在为延迟的95％ (880 / (880 + 50) = 0.946);</p><p><strong>当你决定尝试通过添加更多消费者来处理这种增长的积压时, 需要注意, 现在有消息正在被现有客户端缓冲, 并不是说你增加消费者就能缓解这部分的压力!</strong></p></li><li><p>更糟糕的是, 如果我们将缓冲区大小设置为可以预取51条消息以应对网络性能下降,会发生什么?<br>处理第一条消息后, 将在客户端缓冲另外50条消息, 100ms后(假设网络运行正常), 一条新消息将从Rabbit到达客户端, consumer在100ms中只能处理这50条消息中的两条消息(缓冲区现在为47条消息长),<br>因此新消息将会在缓冲区中是第48位, 这样的话, 知道 47 <em> 40 = 1880ms 之后, 消费者才会开始处理新来的消息, 同样, 考虑到向客户端发送消息的网络延迟仅为50ms, 现在这个1880ms的延迟意味着客户端缓冲占延迟的97％(1880/(1880 + 50)= 0.974);<br>这可能是不可接受的: 数据只能在客户端收到后2秒内立即处理, 才能有效且有用！<br><em>*如果其他消费客户端空闲, 他们无能为力</em></em>: 一旦Rabbit向客户端发送消息, 消息就是客户端的责任, 直到他们拒绝或拒绝消息; 消息发送到客户端后，客户端不能窃取彼此的消息;<br>您希望客户端保持繁忙状态, 但客户端尽可能少地缓存消息, 以便客户端缓冲区不会延迟消息, 因此新消费客户端可以快速接收来自Rabbit队列的消息;</p></li><li><p>因此, 如果网络变慢, 缓冲区太小会导致客户端空闲; 但如果网络正常运行, 缓冲区太大会导致大量额外的延迟;<br>如果客户端突然开始花费更长时间来处理每个缓冲区, 则会导致大量额外的延迟;<br>很明显, 你真正想要的是可以变化的缓冲区大小, 这些问题在网络设备中很常见, 并且一直是很多研究的主题;<br>主动队列管理算法试图尝试放弃或拒绝消息，以避免消息长时间处于缓冲区。当缓冲区保持空闲时（每条消息只遭受网络延迟，并且根本不在缓冲区中），缓冲区在那里吸收峰值，从而实现最低延迟。从网络路由器的角度来看，Jim Gettys一直在研究这个问题：局域网和广域网性能之间的差异会遇到完全相同的问题。实际上，无论何时，在生产者（在我们的例子中为Rabbit）和消费者（客户端应用程序逻辑）之间都有一个缓冲区，双方的性能可以动态变化，您将会遇到这些问题。最近发布了一种名为Controlled Delay的新算法，该算法似乎在解决这些问题方面效果很好。</p></li><li><p>…  未完待续</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RabbitMQ关于吞吐量-延迟和带宽的一些理论&quot;&gt;&lt;a href=&quot;#RabbitMQ关于吞吐量-延迟和带宽的一些理论&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ关于吞吐量,延迟和带宽的一些理论&quot;&gt;&lt;/a&gt;RabbitMQ关于吞吐量,
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>103. 分区管理</title>
    <link href="http://blog.renyimin.com/2018/03/28/mysql/2018-03-28-mysql-103/"/>
    <id>http://blog.renyimin.com/2018/03/28/mysql/2018-03-28-mysql-103/</id>
    <published>2018-03-28T02:41:26.000Z</published>
    <updated>2018-03-28T02:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h2><p>MySQL5.1 提供了许多修改分区表的方式, 添加、删除、重新定义、合并或拆分已经存在的分区是可能的, 所有这些操作都可以通过使用<code>ALTER TABLE</code>命令的分区扩展来实现; 当然, 也有获得分区表和分区信息的方式;</p><h3 id="drop删除分区及数据"><a href="#drop删除分区及数据" class="headerlink" title="drop删除分区及数据"></a>drop删除分区及数据</h3><ol><li><p><code>mysql&gt; alter table user drop partition p4;</code></p></li><li><p><strong>注意</strong>: </p><ul><li><p>只能对每个分区进行删除, 不能针对每个子分区进行删除操作, 删除分区后子分区连同数据一并被删除;</p></li><li><p>删除分区后, 数据也被删除了;</p></li><li><p><strong><code>drop partition</code>删除分区的语法, 只能用于 <code>range/list</code> 分区</strong> (如果用来删除hash分区或者key分区,则会报错)</p></li><li><p>如果要删除 <code>hash/key</code> 分区, 则直接使用下面remove来移除分区即可, 一般也不直接删除数据;</p></li></ul></li></ol><h3 id="remove移除分区"><a href="#remove移除分区" class="headerlink" title="remove移除分区"></a>remove移除分区</h3><ol><li><p>使用remove移除分区, 注意仅仅是移除分区, <strong>并不会删除数据</strong> (和drop PARTITION不一样, 后者会连同数据一起删除)</p></li><li><p><code>ALTER TABLE tablename REMOVE PARTITIONING;</code> 这样就可以将一个原本分区的数据表变成不分区的表</p><ul><li><p>移除分区前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">0B    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p><code>ALTER TABLE</code>user<code>REMOVE PARTITIONING;</code> 移除分区后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user.MYD</div><div class="line">4.0K    user.MYI</div><div class="line">12K    user.frm</div></pre></td></tr></table></figure></li></ul></li><li><p>注意: 该语法是可以适用于 <code>range/list/key/hash</code> 类型的分区的;</p></li></ol><h3 id="创建不同类型分区"><a href="#创建不同类型分区" class="headerlink" title="创建不同类型分区"></a>创建不同类型分区</h3><h3 id="分区创建索引-整表创建索引"><a href="#分区创建索引-整表创建索引" class="headerlink" title="分区创建索引(整表创建索引)"></a>分区创建索引(整表创建索引)</h3><h3 id="新增分区"><a href="#新增分区" class="headerlink" title="新增分区"></a>新增分区</h3><h3 id="新增不同类型分区"><a href="#新增不同类型分区" class="headerlink" title="新增不同类型分区"></a>新增不同类型分区</h3><h3 id="合并分区"><a href="#合并分区" class="headerlink" title="合并分区"></a>合并分区</h3><ol><li><p>原本分区结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">4.0K    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p>合并 p2, p3这两个分区 </p><ul><li>分区并无子分区<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE tb_sub_ev REORGANIZE PARTITION p2,p3 INTO (</div><div class="line">    PARTITION m_p2_p3 VALUES LESS THAN (2000)</div><div class="line">    ( SUBPARTITION n0,</div><div class="line">        SUBPARTITION n1</div><div class="line">    ) </div><div class="line">);</div></pre></td></tr></table></figure></li></ul></li></ol><h3 id="拆分分区"><a href="#拆分分区" class="headerlink" title="拆分分区"></a>拆分分区</h3><h3 id="重新分区"><a href="#重新分区" class="headerlink" title="重新分区"></a>重新分区</h3><h2 id="每日自动新增分区"><a href="#每日自动新增分区" class="headerlink" title="每日自动新增分区"></a>每日自动新增分区</h2><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分区管理&quot;&gt;&lt;a href=&quot;#分区管理&quot; class=&quot;headerlink&quot; title=&quot;分区管理&quot;&gt;&lt;/a&gt;分区管理&lt;/h2&gt;&lt;p&gt;MySQL5.1 提供了许多修改分区表的方式, 添加、删除、重新定义、合并或拆分已经存在的分区是可能的, 所有这些操作都可以
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>102. 分区键, 主键, 唯一索引关系</title>
    <link href="http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-102/"/>
    <id>http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-102/</id>
    <published>2018-03-27T07:46:51.000Z</published>
    <updated>2018-03-28T02:09:40.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>若表有 <code>primary key</code> 或 <code>unique key</code>, 在对表进行分区时, 需要注意: <code>分区键</code> 必须包含在primary key或unique key列内, 这是为了确保主键的效率, 否则同一主键区的数据一个在Ａ分区, 一个在Ｂ分区, 显然会比较麻烦;<br> 可以说: 在分区表上, 用于分区表达式里的每一个字段都必须是<code>唯一性索引</code>的<code>一部分</code>;</p></li><li><p>如何理解上面的概念?</p></li><li><p>如果表中既有<code>主键</code>, 也有<code>唯一索引</code>: 无论<code>单列键</code>还是<code>多列键</code>分区都会失败</p><ul><li><p>单列唯一索引键分区报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `user` (  </div><div class="line">    `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;,  </div><div class="line">    `name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">    `sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男，1为女&apos;,</div><div class="line">`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,</div><div class="line">    PRIMARY KEY (`id`),</div><div class="line">UNIQUE KEY `age_unique` (`age`)</div><div class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8</div><div class="line">PARTITION BY RANGE COLUMNS (`age`)</div><div class="line">(</div><div class="line">PARTITION p0 VALUES LESS THAN (3),  </div><div class="line">PARTITION p1 VALUES LESS THAN (6),</div><div class="line">PARTITION p2 VALUES LESS THAN (9),  </div><div class="line">PARTITION p3 VALUES LESS THAN (12),  </div><div class="line">PARTITION p4 VALUES LESS THAN (MAXVALUE)</div><div class="line">);</div><div class="line">// 1503 - A PRIMARY KEY must include all columns in the table&apos;s partitioning function, Time: 0.011000s</div></pre></td></tr></table></figure></li><li><p>单列主键分区报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>),</p><pre><code>UNIQUE KEY `age_unique` (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);<br>// 1503 - A UNIQUE INDEX must include all columns in the table’s partitioning function, Time: 0.008000s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 多列(主键和唯一索引键)分区报错</div></pre></td></tr></table></figure><p>// 两列做分区也是失败的, 如下会报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>),</p><pre><code>UNIQUE KEY `age_unique` (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>,<code>age</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3, 10),<br>  PARTITION p1 VALUES LESS THAN (6, 15),<br>  PARTITION p2 VALUES LESS THAN (9, 20),<br>  PARTITION p3 VALUES LESS THAN (12, 25),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);<br>// 1503 - A PRIMARY KEY must include all columns in the table’s partitioning function, Time: 0.012000s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">4. 表中只有`主键`: 分区键属于主键内的键即可 (多列分区, 需要将列与主键一起作为主键才行)</div><div class="line">    - 分区键属于主键内的键即可</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 如果想多列分区, 则需要将多余的列与主键一起作为主键</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>, <code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>,<code>age</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3, 10),<br>  PARTITION p1 VALUES LESS THAN (6, 15),<br>  PARTITION p2 VALUES LESS THAN (9, 20),<br>  PARTITION p3 VALUES LESS THAN (12, 25),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">5. 表中只有`唯一索引`: 分区键属于`唯一索引键`内的键即可 (多列分区, 需要将多个列一起作为唯一索引)</div><div class="line">    - 分区键属于`唯一索引键`内的键即可</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  UNIQUE KEY (<code>id</code>, <code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 多列分区报错(竟然是报主键错): 1503 - A PRIMARY KEY must include all columns in the table&apos;s partitioning function, Time: 0.012000s</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br><code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br><code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br><code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,<br>  <code>age</code> int(2) NOT NULL DEFAULT ‘0’ COMMENT ‘年龄’,<br>UNIQUE KEY id_u (<code>id</code>),<br>  UNIQUE KEY age_u (<code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>, <code>age</code>)<br>(<br>PARTITION p0 VALUES LESS THAN (3,10),<br>PARTITION p1 VALUES LESS THAN (6,15),<br>PARTITION p2 VALUES LESS THAN (9,20),<br>PARTITION p3 VALUES LESS THAN (12,25),<br>PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- **多个唯一索引: 无论单列分区还是多列分区, 都会报错**</div></pre></td></tr></table></figure><p>// 单列分区报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  UNIQUE KEY id_u (<code>id</code>),</p><pre><code>UNIQUE KEY age_u (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);<br>```</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li></ul></li></ol><ul><li>要进行分区, 表中不能同时存在<code>主键</code>和<code>唯一索引键</code>, 也不能存在多个唯一索引键;</li><li>分区的键必须包含在<code>主键</code>内 或者 包含在<code>唯一索引键</code>内;</li><li>本篇只是测试了<code>range</code>这种分区类型, 其实上面的限制对于<code>range/list/hash/key</code>类型的分区都适用;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;若表有 &lt;code&gt;primary key&lt;/code&gt; 或 &lt;code&gt;unique key&lt;/code&gt;, 在对表进行分区时, 需要注意: &lt;code&gt;分区键&lt;/code&gt; 必须包含在primary key或unique key列内, 这是为了确保主键
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>101. 分区,分表,分库</title>
    <link href="http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-101/"/>
    <id>http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-101/</id>
    <published>2018-03-27T03:37:12.000Z</published>
    <updated>2018-03-28T02:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>MySQL是从5.1开始支持分区功能的, 在MySQL中, 数据是以文件的形势存在磁盘上的, 默认放在 ‘/mysql/data/‘ 下(可以通过my.cnf中的datadir来指定)</p></li><li><p>MyISAM引擎中, 一张表主要对应着三个文件: </p><ul><li><code>.frm</code>(与表相关的元数据信息都存放在frm文件, 包括表结构的定义信息等)</li><li><code>.myd</code>(存放表数据)</li><li><code>.myi</code>(存表索引)</li></ul></li><li><p>InnoDB引擎中, 一张表也是对应着三个文件: </p><ul><li><code>.frm</code>(和MyISAM差不多)</li><li><code>.ibd</code>文件和<code>.ibdata</code>文件, 都是存放innodb数据的文件, 之所以用两种文件来存放innodb的数据, 是因为innodb的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据, 还是用独享表空间存放存储数据<br>独享表空间存储方式使用.ibd文件,并且每个表一个ibd文件;<br>共享表空间存储方式使用.ibdata文件，所有表共同使用一个ibdata文件<br>可在mysql的配置文件通过<code>innodb_file_per_table</code>进行配置</li></ul></li><li><p>如果一张表的数据量太大, <code>.ibd</code>, <code>.myd</code>, <code>.myi</code> 之类的文件就会变的很大, 查找数据就会变的很慢, 此时就可以利用mysql的分区功能, 在物理上将这一张表对应的三个文件, 分割成许多个小块, 这样之后, 如果查找一条数据时, 就不用全部查找了, 只要知道这条数据在哪一块, 然后在那一块找即可;<br> 如果表的数据太大, 可能一个磁盘放不下, 此时, 还可以把数据分配到不同的磁盘里面去;</p></li></ol><h2 id="查看当前MySQL版本是否支持分区"><a href="#查看当前MySQL版本是否支持分区" class="headerlink" title="查看当前MySQL版本是否支持分区"></a>查看当前MySQL版本是否支持分区</h2><ol><li><p>对于MySQL5.6以下版本, 如果查询结果显示Empty, 表示不支持分区:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show variables like &apos;%partition%&apos;;</div><div class="line">Empty set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>对于mysql5.6以及以上版本, 需要使用下面的查询命令:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show plugins;</div></pre></td></tr></table></figure><p> 上面的查询方法会显示所有插件, 如果有如下插件的话, 表示支持分区:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| partition                  | ACTIVE   | STORAGE ENGINE     | NULL    | GPL     |</div></pre></td></tr></table></figure></li></ol><h2 id="分区的2种方式"><a href="#分区的2种方式" class="headerlink" title="分区的2种方式"></a>分区的2种方式</h2><h3 id="横向分区"><a href="#横向分区" class="headerlink" title="横向分区"></a>横向分区</h3><p>横向分区: 比如, 有1000W条数据, 分成十份, 前10W条数据放到第一个分区, 第二个10W条数据放到第二个分区, 依此类推; </p><ul><li>也就是把表分成了十份(和使用<code>merge</code>来分表有点像, 取出一条数据的时候, 这条数据包含了表结构中的所有字段);</li><li>横向分区, 并没有改变表的结构;</li></ul><h3 id="纵向分区"><a href="#纵向分区" class="headerlink" title="纵向分区"></a>纵向分区</h3><p>纵向分区: 比如, 在设计用户表的时候, 开始的时候没有考虑好, 把用户的所有信息都放到了一张表里面去, 这样这个表里面就会有比较大的字段, 如个人简介..等, 而这些简介也许不会有好多人去看，所以等到有人要看的时候, 再去查找(分表的时候, 可以把这样的大字段与主表分开来);</p><h2 id="横向分区-1"><a href="#横向分区-1" class="headerlink" title="横向分区"></a>横向分区</h2><p>mysql提供的分区属于第一种 <code>横向分区</code>, 并且细分成很多种方式</p><h3 id="range分区"><a href="#range分区" class="headerlink" title="range分区"></a>range分区</h3><ol><li><p>按照<code>RANGE</code>分区的表是通过如下方式进行分区的, 分区表达式的值位于一个给定的连续区间内的那些行, 会被放到一个分区中</p><ul><li><p>创建表同时进行分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `user` (  </div><div class="line">`id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;,  </div><div class="line">`name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">`sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男，1为女&apos;,  </div><div class="line">PRIMARY KEY (`id`)  </div><div class="line">) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1  </div><div class="line">PARTITION BY RANGE (id) (  </div><div class="line">PARTITION p0 VALUES LESS THAN (3),  </div><div class="line">PARTITION p1 VALUES LESS THAN ( 6 ),</div><div class="line">PARTITION p2 VALUES LESS THAN (9),  </div><div class="line">PARTITION p3 VALUES LESS THAN (12),  </div><div class="line">PARTITION p4 VALUES LESS THAN MAXVALUE  </div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>查看分区效果 (到数据表文件的存放处 <code>$ cd /Library/Application\ Support/appsolute/MAMP\ PRO/db/mysql56/</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">0B    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">0B    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">0B    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">0B    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">0B    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p>插入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">INSERT INTO `test`.`user` (`name` ,`sex`)VALUES (&apos;tank&apos;, &apos;0&apos;)  </div><div class="line">,(&apos;zhang&apos;,1),(&apos;ying&apos;,1),(&apos;张&apos;,1),(&apos;映&apos;,0),(&apos;test1&apos;,1),(&apos;tank2&apos;,1)  </div><div class="line">,(&apos;tank1&apos;,1),(&apos;test2&apos;,1),(&apos;test3&apos;,1),(&apos;test4&apos;,1),(&apos;test5&apos;,1),(&apos;tank3&apos;,1)  </div><div class="line">,(&apos;tank4&apos;,1),(&apos;tank5&apos;,1),(&apos;tank6&apos;,1),(&apos;tank7&apos;,1),(&apos;tank8&apos;,1),(&apos;tank9&apos;,1)  </div><div class="line">,(&apos;tank10&apos;,1),(&apos;tank11&apos;,1),(&apos;tank12&apos;,1),(&apos;tank13&apos;,1),(&apos;tank21&apos;,1),(&apos;tank42&apos;,1);</div></pre></td></tr></table></figure></li><li><p>再次查看分区效果<br>如下可以看到, 文件大小都是4.0K, 从这儿我们可以看出<strong>MyISAM引擎下, 分区的最小区块是4K (InnoDB貌似是96k)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">4.0K    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li></ul></li><li><p>数据测试</p><ul><li><p>初始数据为25条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select count(id) as count from user;</div><div class="line">+-------+</div><div class="line">| count |</div><div class="line">+-------+</div><div class="line">|    25 |</div><div class="line">+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>删除第四个分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; alter table user drop partition p4; </div><div class="line">Query OK, 0 rows affected (0.15 sec)</div><div class="line">Records: 0  Duplicates: 0  Warnings: 0</div></pre></td></tr></table></figure></li><li><p>可以发现, 存放在第四个分区里面的14条数据丢失了, 剩下的3个分区只有11条数据  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select count(id) as count from user; </div><div class="line">+-------+</div><div class="line">| count |</div><div class="line">+-------+</div><div class="line">|    11 |</div><div class="line">+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>查看分区文件, 发现第四个分区确实被删除了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li></ul></li><li><p>小结: 可以发现, 在进行range分区后</p><ul><li>会生成一个 <code>.par</code>文件,用来存储分区信息;</li><li>MyISAM/InnoDB引擎, 原有的 <code>.frm</code> 表结构文件没有被分隔;</li><li>MyISAM引擎, 原有的 <code>.MYD</code>数据文件, <code>.MYI</code>索引文件都被分隔了;</li><li>InnoDB引擎, 原有的 <code>.idb</code>数据文件被分隔了;</li></ul></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li></ul></li></ol><h3 id="List分区"><a href="#List分区" class="headerlink" title="List分区"></a>List分区</h3><ol><li><p>RANGE分区是从属于一个连续区间值的集合, 而LIST分区是基于某列的值从属于一个值列表集中的一个值</p></li><li><p>如果不用主键, 如下list分区可以创建成功，一般情况下, 一张表肯定会有一个主键(所以如果需要用其他键来做分区, 参考下一篇博文<a href="2017/12/17/mysql/2017-12-17-mysql-102/">分区键, 主键, 唯一索引关系</a>)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `list_part` (  </div><div class="line">`id` int(11) NOT NULL COMMENT &apos;用户ID&apos;,  </div><div class="line">`province_id` int(2) NOT NULL DEFAULT 0 COMMENT &apos;省&apos;,  </div><div class="line">`name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">`sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男, 1为女&apos;</div><div class="line">) ENGINE=INNODB DEFAULT CHARSET=utf8</div><div class="line">PARTITION BY LIST (province_id) (  </div><div class="line">PARTITION p0 VALUES IN (1,2,3,4,5,6,7,8),  </div><div class="line">PARTITION p1 VALUES IN (9,10,11,12,16,21),  </div><div class="line">PARTITION p2 VALUES IN (13,14,15,19),  </div><div class="line">PARTITION p3 VALUES IN (17,18,20,22,23,24)</div><div class="line">);</div><div class="line"></div><div class="line">// 创建成功, 会看到分区效果 (InnoDB默认分区最小是96k)</div><div class="line">$ ls |grep list_part |xargs du -sh</div><div class="line">96K    list_part#P#p0.ibd</div><div class="line">96K    list_part#P#p1.ibd</div><div class="line">96K    list_part#P#p2.ibd</div><div class="line">96K    list_part#P#p3.ibd</div><div class="line">12K    list_part.frm</div><div class="line">4.0K    list_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="hash分区"><a href="#hash分区" class="headerlink" title="hash分区"></a>hash分区</h3><ol><li><p>HASH分区主要用来确保数据在预先确定数目的分区中平均分布, 你所要做的只是</p><ul><li>对将要被哈希的列值, 指定一个列值或表达式;</li><li>指定被分区的表将要被分割成的分区数量;</li><li>对HASH分区，使用的用户函数必须返回一个大于0的整数值;</li></ul></li><li><p>创建表同时进行hash分区</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `hash_part` (  </div><div class="line">`id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;评论ID&apos;,  </div><div class="line">`comment` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;评论&apos;,  </div><div class="line">`ip` varchar(25) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;来源IP&apos;,  </div><div class="line">PRIMARY KEY (`id`)  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1  </div><div class="line">PARTITION BY HASH(id)  </div><div class="line">PARTITIONS 3;</div></pre></td></tr></table></figure></li><li><p>查看分区效果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ls |grep hash_part |xargs du -sh</div><div class="line">96K    hash_part#P#p0.ibd</div><div class="line">96K    hash_part#P#p1.ibd</div><div class="line">96K    hash_part#P#p2.ibd</div><div class="line">12K    hash_part.frm</div><div class="line">4.0K    hash_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="key分区"><a href="#key分区" class="headerlink" title="key分区"></a>key分区</h3><ol><li><p>按照KEY进行分区, 类似于按照HASH分区</p><ul><li>HASH分区是使用用户定义的表达式</li><li>而KEY分区的哈希函数是由MySQL服务器提供</li></ul></li><li><p>创建表同时进行key分区</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `key_part` (  </div><div class="line">`news_id` int(11) NOT NULL  COMMENT &apos;新闻ID&apos;,  </div><div class="line">`content` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;新闻内容&apos;,  </div><div class="line">`u_id` varchar(25) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;来源IP&apos;,  </div><div class="line">`create_time` DATE NOT NULL DEFAULT &apos;0000-00-00 00:00:00&apos; COMMENT &apos;时间&apos;  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8  </div><div class="line">PARTITION BY LINEAR HASH(YEAR(create_time))  </div><div class="line">PARTITIONS 3;</div></pre></td></tr></table></figure></li><li><p>查看分区效果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ls |grep key_part |xargs du -sh</div><div class="line">96Kkey_part#P#p0.ibd</div><div class="line">96Kkey_part#P#p1.ibd</div><div class="line">96Kkey_part#P#p2.ibd</div><div class="line">12Kkey_part.frm</div><div class="line">4.0Kkey_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h3><ol><li><p>子分区是分区表中每个分区的再次分割, 对于已经通过<code>RANGE</code>或<code>LIST</code>分区了的表再进行子分区是可能的, 子分区既可以使用<code>HASH</code>分区, 也可以使用<code>KEY</code>分区; 这也被称为复合分区(composite partitioning)</p><ul><li>如果一个分区中创建了子分区, 其他分区也要有子分区</li><li>如果创建了子分区, 每个分区中的<strong>子分区数必须相同</strong></li><li>同一分区内的子分区, 名字不相同, 不同分区内的子分区名子可以相同(5.1.50不适用)</li></ul></li><li><p>创建表同时, 进行子分区操作</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `sub_part` (  </div><div class="line">`news_id` int(11) NOT NULL  COMMENT &apos;新闻ID&apos;,  </div><div class="line">`content` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;新闻内容&apos;,  </div><div class="line">`u_id`  int(11) NOT NULL DEFAULT 0 COMMENT &apos;来源IP&apos;,  </div><div class="line">`create_time` DATE NOT NULL DEFAULT &apos;0000-00-00 00:00:00&apos; COMMENT &apos;时间&apos;  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8  </div><div class="line">PARTITION BY RANGE(YEAR(create_time))  </div><div class="line">SUBPARTITION BY HASH(TO_DAYS(create_time))(  </div><div class="line">    PARTITION p0 VALUES LESS THAN (1990)(</div><div class="line">        SUBPARTITION s0,SUBPARTITION s1,SUBPARTITION s2</div><div class="line">    ),  </div><div class="line">    PARTITION p1 VALUES LESS THAN (2000)(</div><div class="line">        SUBPARTITION s3,SUBPARTITION s4,SUBPARTITION good</div><div class="line">    ),  </div><div class="line">    PARTITION p2 VALUES LESS THAN MAXVALUE(</div><div class="line">        SUBPARTITION tank0,SUBPARTITION tank1,SUBPARTITION tank3</div><div class="line">    )  </div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>查看分区后, 数据表文件结构</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ ls |grep sub_part |xargs du -sh</div><div class="line">96K    sub_part#P#p0#SP#s0.ibd</div><div class="line">96K    sub_part#P#p0#SP#s1.ibd</div><div class="line">96K    sub_part#P#p0#SP#s2.ibd</div><div class="line">96K    sub_part#P#p1#SP#good.ibd</div><div class="line">96K    sub_part#P#p1#SP#s3.ibd</div><div class="line">96K    sub_part#P#p1#SP#s4.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank0.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank1.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank3.ibd</div><div class="line">12K    sub_part.frm</div><div class="line">4.0K    sub_part.par</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;MySQL是从5.1开始支持分区功能的, 在MySQL中, 数据是以文件的形势存在磁盘上的, 默认放在 ‘/mysql/d
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Restful</title>
    <link href="http://blog.renyimin.com/2018/03/16/http/2018-03-06-restful/"/>
    <id>http://blog.renyimin.com/2018/03/16/http/2018-03-06-restful/</id>
    <published>2018-03-16T11:36:23.000Z</published>
    <updated>2018-05-09T06:31:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>REST本身并没有创造新的技术, 组件或服务, 主要指的是一组<strong>架构约束条件和原则</strong>, 隐藏在RESTful背后的理念就是<strong>使用Web的现有特征和能力, 更好地使用现有Web标准中的一些准则和约束</strong>; 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。</p><p>虽然REST本身受Web技术的影响很深, 但是理论上REST架构风格并不是绑定在HTTP上, 只不过目前HTTP是唯一与REST相关的实例;</p><p>所以通常描述的REST也是通过HTTP实现的REST;</p><h2 id="URI的设计"><a href="#URI的设计" class="headerlink" title="URI的设计"></a>URI的设计</h2><ol><li><p>URI的设计应该遵循可寻址性原则, 具有<strong>自描述性</strong>, 需要在形式上给人以直觉上的关联; 比如:</p><ul><li><p>用<code>_</code>或<code>-</code>来让URI可读性更好<br>例如国内比较出名的开源中国社区, 它上面的新闻地址就采用这种风格, 如 <a href="http://www.oschina.net/news/38119/oschina-translate-reward-plan" target="_blank" rel="external">http://www.oschina.net/news/38119/oschina-translate-reward-plan</a></p></li><li><p>使用<code>/</code>来表示资源的层级关系<br>例如 <a href="https://github.com/rymuscle/chat/issues" target="_blank" rel="external">https://github.com/rymuscle/chat/issues</a> 就表示了一个多级的资源, 指的是rymuscle用户的chat项目的issues列表</p></li><li><p>使用<code>?</code>用来过滤资源 (如果记录数量很多，服务器不可能都将它们返回给用户, 比如分页等筛选条件)<br>很多人只是把<code>?</code>简单的当做是参数的传递, 很容易造成URI过于复杂、难以理解; 其实可以把<code>?</code>用于对资源的过滤;<br>例如 <code>https://github.com/rymuscle/chat/pulls</code> 用来表示git项目的所有推入请求;<br>而 <code>/pulls?state=closed</code> 用来表示git项目中已经关闭的推入请求, 这种URL通常对应的是一些特定条件的查询结果或算法运算结果;</p></li><li><p><code>,</code>或<code>;</code>可以用来表示同级资源的关系</p></li></ul></li><li><p>URI里带上版本号, 如 <code>https://api.example.com/v1/</code> (Github就是这样做的)<br> 另一种做法是, 将版本号放在HTTP头信息中, 但不如放入URL方便和直观;</p></li><li><p><strong>URI中只应该描述清楚资源的名称</strong>, 而不应该包括资源的操作(因为统一资源接口要求使用标准的HTTP方法对资源进行操作, 方法都是有语义的, 所以已经明确描述了这次的操作含义)</p><ul><li>URI不应该再使用动作来描述, 如下就是一些不符合统一接口要求的URI (它们都在URI中对操作进行了描述):<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET /getUser/1</div><div class="line">POST /createUser</div><div class="line">PUT /updateUser/1</div><div class="line">DELETE /deleteUser/1</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2><p>接口应该使用标准的HTTP方法如GET，PUT和POST，并<strong>遵循这些方法的语义</strong>(通过明确的方法来描述操作), 可以参考博文 <a href="/2016/11/30/http/2016-11-30-HTTP-03/">HTTP各请求方法详解</a> 或者 <a href="http://www.runoob.com/w3cnote/restful-architecture.html" target="_blank" rel="external">Restful架构详解</a></p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>状态码应该使用HTTP标准状态码 可以参考博文 <a href="/2016/11/30/http/2016-11-30-HTTP-01/#状态码详解">HTTP协议预览</a></p><p>更多<a href="http://cizixs.com/2016/12/12/restful-api-design-guide" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;REST本身并没有创造新的技术, 组件或服务, 主要指的是一组&lt;strong&gt;架构约束条件和原则&lt;/strong&gt;, 隐藏在RESTful背
      
    
    </summary>
    
      <category term="Restful" scheme="http://blog.renyimin.com/categories/Restful/"/>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/Restful/HTTP/"/>
    
    
      <category term="Restful" scheme="http://blog.renyimin.com/tags/Restful/"/>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>08. 并行连接, 持久连接</title>
    <link href="http://blog.renyimin.com/2017/12/06/http/2017-12-06-HTTP-08/"/>
    <id>http://blog.renyimin.com/2017/12/06/http/2017-12-06-HTTP-08/</id>
    <published>2017-12-06T12:10:11.000Z</published>
    <updated>2018-05-09T06:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常被误解的Connection首部"><a href="#常被误解的Connection首部" class="headerlink" title="常被误解的Connection首部"></a>常被误解的<code>Connection</code>首部</h2><ol><li><p>HTTP允许在客户端和最终的源端服务器之间存在一串HTTP中间实体(代理, 高速缓存等)。可以从客户端开始, 逐跳地将HTTP报文经过这些中间设备, 转发到源端服务器上去(或者进行反向传递)。</p></li><li><p>HTTP的 <code>Connection</code> 首部字段中有一个由<code>,</code>分隔的连接标签列表;</p></li><li><p>Connection首部可以承载3种不同类型的标签, 因此非常令人费解:</p><ul><li>HTTP首部字段名, 列出了只与此链接有关的首部; </li><li>任意标签值, 用于描述此链接的非标准选项;</li><li>close, 说明操作完成之后需要关闭这条持久连接;</li></ul></li><li><p>如果连接标签中包含了一个HTTP首部字段的名称, 那么这个首部字段就包含了一些连接有关的信息, 不能将其转发出去, 在将报文转发出去之前, 必须删除Connection首部列出的所有首部字段。</p><ul><li>由于Connection首部可以防止无意中对本地首部的转发, 因此将逐跳字首部名放入Connection首部被称为”对首部的保护”。<br>(<strong>Connection首部是个逐跳首部, 只适用于单条传输链路, 不应该沿着传输链路向下传输</strong> (参考P101))<br><img src="/img/http/connection-not-field.png" width="550/"></li></ul></li></ol><h2 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h2><ol><li><p>在串行请求时, 浏览器可以先完整地请求原始的HTML页面, 然后请求第一个嵌入对象, 然后请求第二个嵌入对象等, 以这种简单的方式对每个嵌入式对象进行串行处理, 很明显这样处理很慢!!</p></li><li><p>HTTP允许客户端打开多条连接, 并行地执行多个HTTP事务, 如下图, 并行加载了四幅嵌入式图片, 每个事务都有自己的TCP连接:<br> <img src="/img/http/http-concurrence-request-01.png" width="550/"></p></li><li><p>并行连接可能会提高页面的加载速度</p><ul><li>包含嵌入对象的组合页面如果能通过并行连接克服单条连接的空载时间和带宽限制, 加载速度也会有所提高。时延可以重叠起来, 而且如果单条连接没有充分利用客户端的因特网带宽, 可以将为用带宽分配来装载其他对象。</li><li>如下图, 串行和并行的对比, 并行情况下, 先装载的是封闭的HTML页面, 然后并行处理其余3个事务, 每个事务都有自己的连接。(图片的装载是并行的, 连接的时延也是重叠的)<br><img src="/img/http/chuanxing-01.png" width="550/"><br><img src="/img/http/http-concurrence-request-02.png" width="550/"></li><li>由于软件开销的存在, 每个连接请求之间总会有一些小的时延, 但连接请求和传输时间<strong>基本上</strong>都是重叠起来的!</li></ul></li><li><p>并行连接不一定更快<br> <strong>即使并行连接的速度可能会更快, 但是并不一定总是更快</strong></p><blockquote><p>因为在客户端的网络带宽如果不足时, 大部分的时间可能都是用来传送数据的。在这种情况下, 一个连接到速度较快服务器上的HTTP事务就会很容易耗尽所有可用的Modem带宽。<br> 如果并行加载多个对象, 每个对象都会去竞争这有限的带宽, 每个对象都会以较慢的速度按比例加载, 这样带来的性能提升就很小, 甚至没什么提升。<br> 而且打开大量连接会消耗很多内存资源, 从而引发自身性能问题。<br> 复杂的Web有可能会有数十或数百个内嵌对象, 客户端可能可以打开数百个连接, 但Web服务器通常要同时处理很多其他用户的请求, 所以很少有Web服务器希望出现这样的情况。<br> 一百个用户同时发出申请, 每个用户打开100个连接, 服务器就要负责处理1W个连接, 这会造成服务器性能的严重下降。对高负荷的代理来说也同样如此。<br> 实际上, 浏览器确实使用了并行连接, 但它们会将并行连接的总数限制为一个较小的值(通常是四个)。服务器可以随意关闭来自特定客户端的超量连接。</p></blockquote></li><li><p><strong>并行连接可能让人”感觉”更快一些</strong><br>通过上面的介绍, 我们知道并行连接并不总是能使页面加载更快, 但即使实际上没有加快页面的传输速度, 并行连接通常也会让用户<code>觉得</code>页面加载的更快了,<br>因为多个组件对象同时出现屏幕上时, 用户能够看到加载的进展。如果整个屏幕上有很多动作在进行, 即使实际上整个页面的下载时间更长, 用户也会认为Web页面加载得更快一些。</p></li></ol><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><ol><li><p>HTTP/1.1(以及HTTP/1.0的各种增强版本)允许HTTP设备在事务处理结束之后将TCP连接保持在打开状态, 以便未来的HTTP请求能够重用现存的连接。在事务处理结束之后仍然保持在打开状态的TCP连接被称为<strong>持久连接</strong>。</p></li><li><p>非持久连接会在每个事务结束之后关闭, 持久连接会在不同事务之间保持打开状态, 直到客户端或服务器其决定将其关闭为止。</p></li><li><p>重用已对目标服务器打开的空闲持久连接, 就可以避开缓慢的连接建立阶段。而且已经打开的连接还可以避免慢启动的拥塞使用阶段, 以便更快速地进行数据的传输。</p></li><li><p>持久连接和并行连接</p><blockquote><p>之前已经了解过”并行连接可以提高复合页面的传输速度, 但并行连接也有一些缺点”;<br>而持久连接有一些比并行连接更好的地方,持久连接降低了时延和连接建立的开销, 将连接保持在已调谐状态, 而且减少了打开连接的潜在数量。<br>但是, 管理持久连接时要特别小心, 不然就会积累大量的空闲连接, 耗费本地以及远程客户端和服务器上的资源。</p></blockquote><p> 持久连接与并行连接配合使用可能是更高效的方式。现在, 很多Web应用程序都会打开少量的并行连接, 其中的每一个都是持久连接。</p></li><li><p>持久连接有两种类型: 比较老的 <code>HTTP/1.0+&quot;keep-alive&quot;</code> 连接, 以及现代的 <code>HTTP/1.1 &quot;persistent&quot;</code> 连接。</p></li></ol><h2 id="HTTP-1-0-keep-alive连接"><a href="#HTTP-1-0-keep-alive连接" class="headerlink" title="HTTP/1.0+keep-alive连接"></a>HTTP/1.0+keep-alive连接</h2><ol><li><p>前言:<br>大约从1996年开始, 很多HTTP/1.0浏览器和服务器都进行了扩展, 以支持一种被称为keep-alive连接的早期实验型持久连接。<br>这些早期的持久连接收到了一些互操作性设计方面问题的困扰, 这些问题在后期的HTTP/1.1版本中都得到了修正, 但很多客户端和服务器仍然在使用这些早期的keep-alive连接。</p></li><li><p>下图在”串行连接上实现了4个HTTP事务的时间线” 与 “在一条持久连接上实现同样事务” 所需的时间线进行了比较, <strong>显示了keep-alive连接的一些性能优点</strong><br> <strong>由于去除了创建连接和关闭连接的开销, 所以时间线有所缩减</strong><br> <img src="/img/http/keep-alive-vs-chuanxing.png" width="500/"></p></li></ol><h3 id="Keep-Alive操作"><a href="#Keep-Alive操作" class="headerlink" title="Keep-Alive操作"></a><strong>Keep-Alive操作</strong></h3><p>客户端和服务器要配合</p><ol><li><p>keep-alive已经不再使用了, 而且在当前的HTTP/1.1规范中也已经没有了对它的说明了。但浏览器和服务器对keep-alive握手的使用仍然相当广泛, 因此HTTP的实现者应该做好与之进行交互操作的准备.</p></li><li><p>实现HTTP/1.0 keep alive连接的客户端可以通过包含<code>Connection: Keep-Alive</code>首部请求将一条连接保持在打开状态。</p></li><li><p>如果服务器愿意为下一条请求将连接保持在打开状态, 就在响应中包含相同的首部。如果响应中没有<code>Connection: Keep-Alive</code>首部, 客户端就认为服务器不支持keep-alive, 会在发回响应报文之后关闭连接。</p></li></ol><h3 id="还有keep-alive首部"><a href="#还有keep-alive首部" class="headerlink" title="还有keep-alive首部"></a>还有keep-alive首部</h3><ol><li><p>注意, keep-Alive首部只是请求将连接保持在活跃状态。发出keep-alive请求之后, 客户端和服务器并不一定会同意进行keep-alive会话。<br> 它们可以在任意时刻关闭空闲的keep-alive连接, 并可随意限制keep-alive连接所处理事务的数量。</p></li><li><p>可以用<code>Keep-Alive通用首部字段</code>中指定的, 有逗号分隔的选项来调节keep-alive的行为:</p><ul><li>参数timeout: 是在Keep-Alive响应首部发送的, 它估计了服务器希望将连接保持在活跃状态的时间。这并不是一个承诺值。</li><li>参数max: 是在Keep-Alive响应首部发送的, 它估计了服务器还希望为多少个事务保持此连接的活跃状态。这并不是一个承诺值。</li><li>Keep-Alive首部还可以支持任意未经处理的属性, 这些属性主要用于诊断和调试。语法为 <code>name [=value]</code>。</li></ul></li><li><p>Keep-Alive首部完全是可选的, 但只有在提供了 Connection:Keep-Alive 时才能使用它。<br> 下面这个例子说明服务器最多还会为另外5个事务保持连接的打开状态, 或者将打开状态保持到连接空闲了2分钟之后。</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Connection: Keep-Alive</div><div class="line">Keep-Alive: max=<span class="number">5</span>, timeout=<span class="number">120</span></div></pre></td></tr></table></figure></li></ol><h3 id="keep-alive连接的限制和规则"><a href="#keep-alive连接的限制和规则" class="headerlink" title="keep-alive连接的限制和规则"></a>keep-alive连接的限制和规则</h3><ol><li><p>在HTTP/1.0中, keep-alive并不是默认使用的。客户端必须发送一个 <code>Connection: Keep-Alive</code> 请求首部来激活keep-alive连接。</p></li><li><p>Connection: Keep-Alive 首部必须随所有希望保持持久连接的报文一起发送。<br> 如果客户端没有发送Connection: Keep-Alive首部, 服务器就会在那条请求之后关闭连接。</p></li><li><p>客户端如果探明响应中没有Connection: Keep-Alive响应首部, 就可以知道服务器发出响应之后是否会关闭连接了。</p></li><li><p>一般都是在检测到连接关闭之后, 就可以确定报文实体主体部分的长度。如果想”无需检测到连接关闭 就能确定报文实体主体部分的长度”,<br> 那你的响应报文的实体主体部分必须有正确的Connect-Length, 有多部件媒体类型, 或者用分块传输编码的方式进行了编码。<br> 在一条keep-alive信道中回送错误的 Connection-Length 是很糟糕的事, 这样的话, 事务处理的另一端就无法精确地检测出一条报文的结束和另一条报文的开始了。</p></li><li><p>代理和网关必须执行Connection首部的规则, 代理或网关必须在将报文转发出去或将其高速缓存之前, 删除在Connection首部中命名的所有首部字段以及Connection首部本身。</p></li><li><p>严格来说, 不应该与无法确定是否支持Connection首部的代理服务器建立keep-alive连接, 以防止出现下面要介绍的<code>哑代理</code>问题, 在实际应用中不是总能做到这一点的。 </p></li><li><p>从技术上来讲, 应该忽略所有来自HTTP/1.0设备的Connection首部字段(包括Connection:Keep-Alive), 因为他们可能是由比较老的代理服务器误转发的。<br>但是实际上, 尽管可能会有在老代理上挂起的危险, 有些客户端和服务器还是会违反这条规则。</p></li><li><p>除非重复发送请求会产生其他副作用, 否则 “如果在客户端受到完整响应之前连接就关闭了, 那么客户端一定要做好重试请求的准备”。 </p></li></ol><h3 id="Keep-Alive和哑代理"><a href="#Keep-Alive和哑代理" class="headerlink" title="Keep-Alive和哑代理"></a>Keep-Alive和哑代理</h3><ol><li><p>正常情况下, 如果客户端与一台服务器对话, 客户端可以发送一个 Connection:Keep-Alive 首部来告知服务器它希望保持连接的活跃状态, 如果服务器支持keep-alive, 就回送一个 Connection:Keep-Alive 首部, 否则就不回送。</p></li><li><p>问题是出在代理上 — 尤其是那些不理解Connection首部, 而且不知道在沿着转发链路将报文转发出去之前应该将Connection首部删除的代理。<br> 很多老式或简单的代理都是<code>盲中继(blind relay)</code>, 他们只是将字节从一个连接转发到两一个连接中去, 不对Connection首部进行特殊处理。</p></li><li><p>下图就是一个Web客户端通过一个作为盲中继使用的哑代理与Web服务器进行对话的例子:<br> <img src="/img/http/blind-relay.png" width="500/"><br> 更多参考: P101<br> 盲中继的更多问题参考 4.5.7 (??)</p></li><li><p>为了防止此类代理通信问题的发生, 现在的代理都决不能转发Connection首部和所有名字出现在Connection值中的首部。<br> 另外还有几个不能作为Connection首部的值, 并且也不能被代理转发或作为缓存响应使用的首部:<br> Proxy-Authenticate, Proxy-Connection, Transfer-Encoding 和 Upgrade;</p></li></ol><h2 id="HTTP-1-1-persistent连接"><a href="#HTTP-1-1-persistent连接" class="headerlink" title="HTTP/1.1 persistent连接"></a>HTTP/1.1 persistent连接</h2><ol><li>HTTP/1.1主键停止了对keep-alive连接的支持, 用一种名为持久连接(persistent connection)的改进型设计取代了它。<br> 持久连接的目的与keep-alive连接的目的相同, 但机制更优一些。</li><li><p>与HTTP/1.0的keep-alive连接不同, HTTP/1.1持久连接在默认情况下是激活的。除非特别指明, 否则HTTP/1.1假定所有连接都是持久的。<br> 要在事务处理结束之后将连接关闭, HTTP/1.1应用程序必须向报文中显示地添加一个<code>Connection:close</code>首部。<br> 这是与以前的HTTP协议很重要的区别, 在以前的版本中, keep-alive连接要么是可选的, 要么根本就不支持。</p></li><li><p>HTTP/1.1客户端假定在收到响应后, 除非响应中包含了 <code>Connection:close</code>首部, 不然HTTP/1.1连接就仍维持在打开状态。<br> 但是, 客户端和服务器仍然可以随时关闭空闲的连接。 不发送 <code>Connection:close</code> 并不以为这服务器承诺永远将连接保持在打开状态。</p></li></ol><h3 id="persistent连接的限制和规则"><a href="#persistent连接的限制和规则" class="headerlink" title="persistent连接的限制和规则 (??)"></a>persistent连接的限制和规则 (??)</h3><ol><li>发送了 <code>Connection:close</code> 请求首部之后, 客户端就无法在那条连接上发送更多的请求了。</li><li>如果客户端不想在连接上发送其他请求了, 就应该在最后一条请求中发送一个 <code>Connection:close</code>  请求首部。</li><li>只有当连接上所有的报文都有正确的, 自定义报文长度时 – 也就是, 实体主体部分的长度都和响应 Connect-Length 一致, 或者是用分块传输编码方式编码的 — 连接才能持久保持。</li><li>HTTP/1.1的代理必须能够分别管理与客户端和服务器的持久连接 — 每个持久连接都值适用于一跳传输。</li><li>(由于较老的代理会转发Connection首部, 所以)HTTP/1.1的代理服务器不应该与HTTP/1.0客户端建立持久连接, 除非他们了解客户端的处理能力。<br> 实际上, 这一点是很难做到的, 很多厂商都违背了这一原则。</li><li>尽管服务器不应该试图在传输报文的过程中关闭连接, 而且在关闭连接之前至少应该响应一条请求, 但不管Connection首部取了什么值, HTTP/1.1设备都可以在任意时刻关闭连接。</li><li>HTTP/1.1应用程序必须能够从异步的关闭中恢复出来, 只要不存在可能会累积起来的副作用, 客户端都应该重试这条请求。(??)</li><li>除非重复发送请求会产生其他副作用, 否则 “如果在客户端收到完整响应之前连接就关闭了, 那么客户端必须要重新发送请求”</li><li>一个用户客户端对任何服务器或代理, 最多只能维护两条持久连接, 以防服务器过载。<br> 代理可能需要更多到服务器的连接来支持并发用户的通信, 所以如果有N个用户试图访问服务器的话, 代理最多要维持2N条到任意服务器或父代理的连接。</li></ol><h2 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h2><ol><li>HTTP/1.1允许在持久连接上可选地会用<strong>请求管道</strong>。这是在keep-alive连接上的进一步性能优化。在相应到达之前, 可以将多条请求放入队列。<br> 当第一条请求通过网络流向地球另一端的服务器时, 第二条和第三条也可以开始发送了。<br> 在高时延网络条件下, 这样做可以降低网络的回环时间, 提高性能。</li><li>如下图:<br> <img src="/img/http/pipeline-persistent-connections.png" width="550/"><h3 id="对管道化连接的限制"><a href="#对管道化连接的限制" class="headerlink" title="对管道化连接的限制"></a>对管道化连接的限制</h3></li><li><strong>如果HTTP客户端无法确认连接是持久的, 就不应该使用管道</strong>。</li><li>必须按照与请求相同的顺序回送HTTP响应。<strong>HTTP报文中没有序列号标签, 因此如果收到的响应失序了, 就没办法将其与请求匹配起来了</strong>。</li><li>HTTP客户端必须做好连接会在任意时刻关闭的准备, 还要准备好重发所有未完成的管道化请求。<br> 如果客户端打开了一条持久连接, 并立即发出了10条请求, 服务器可能在只处理了5条请求后关闭了连接, 剩下的5条请求会失败, 客户端必须能够应对这些过早关闭连接的情况, 重新发出这些请求。</li><li>HTTP客户端不应该用管道化的方式发送回产生副作用的请求(比如POST)。<br> 总之, 出错的时候, 管道化方式会阻塞客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全地重试<strong>POST这样的非幂等请求</strong>, 所以出错时, 就存在某些方法永远不会被执行的风险。</li></ol><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><h3 id="“任意”解除连接"><a href="#“任意”解除连接" class="headerlink" title="“任意”解除连接"></a>“任意”解除连接</h3><p>所有HTTP客户端, 服务器或代理都可以在任意时刻关闭一条TCP传输连接, 通常会在一条报文结束时关闭连接, 但出错的时候, 也可能在首部行中间, 或其他奇怪的地方关闭连接。<br>对管道化持久连接来说, 这种情形是很常见的。HTTP应用程序可以在经过任意一段时间之后，关闭持久连接。比如，在持久连接空闲一段时间之后，服务器可能会决定将其关闭。<br>但是，服务器永远都无法确定在它关闭”空闲”连接的那一刻，在线路的那一头的客户端有没有数据要发送。如果出现这种情况，客户端就会在写入半截请求报文时发现出现了连接错误。</p><h3 id="Conetent-Length-及-截尾操作"><a href="#Conetent-Length-及-截尾操作" class="headerlink" title="Conetent-Length 及 截尾操作"></a>Conetent-Length 及 截尾操作</h3><p>每条HTTP响应都应该有精确的Content-Length首部，用来描述响应主体的尺寸。<strong>如果老的HTTP服务器省略了Content-Length或者包含错误的长度指示，这样就要一来服务器发出连接关闭来说明数据的真是末尾</strong>。</p><h3 id="连接关闭容限-重试及幂等性"><a href="#连接关闭容限-重试及幂等性" class="headerlink" title="连接关闭容限,重试及幂等性"></a>连接关闭容限,重试及幂等性</h3><p>即使在非错误情况下,连接也可以在任意时刻关闭。<br>HTTP应用程序要做好正确处理非预期关闭的准备。<br>如果在客户端执行事务的过程中, 传输连接关闭了, 那么, 除非事务处理会带来一些副作用, 否则客户端就应该重新打开连接, 并重试一次。<br>对管道化连接来说, 这种情况更加严重一些。客户端可以将大量请求放入队列中排队, 但源端服务器可以关闭连接, 这样就会留下大量未处理的请求, 需要重新调度。</p><p>副作用是很重要的问题, 如果在发送出一些请求数据之后, 收到返回结果之前, 连接关闭了, 客户端就无法百分之百地确定服务器端实际激活了多少事务。<br>有些事务, 比如GET一个静态的HTML页面, 可以反复执行多次, 也不会有什么变化。而其他一些事务, 比如向一个在线书店POST一张订单, 就不能重复执行, 不然会有下多张订单的危险。</p><p>如果一个事务， 不管是执行一次还是很多次，得到的结果都相同, <strong>这个事务就是幂等的</strong>。实现者们可以认为GET、HEAD、PUT、DELETE、TRACE和OPTIONS方法都共享这一特性。客户端不应该以管道化方式传送非幂等请求(比如POST)。<br>否则，传输连接的过早终止就会造成一些不确定的后果。要发送一条非幂等请求，就需要等待来自前一条清求的响应状态。</p><p>尽管用户Agent代理可能会让操作员来选择是否对请求进行重试，但一定不能自动重试非幂等方法或序列。<br><strong>比如，大多数浏览器都会在重载一个缓存的POST响应时提供一个对话框，询问用户是否希望再次发起事务处理</strong>。</p><h3 id="正常关闭连接"><a href="#正常关闭连接" class="headerlink" title="正常关闭连接"></a>正常关闭连接</h3><ol><li><p>正常关闭连接<br>TCP连接是双向的。TCP连接的每一端都有一个输入队列和一个输出队列, 用于数据的读或写。放入一端输出队列中的数据最终会出现在另一端的输入队列中。</p></li><li><p>完全关闭与半关闭<br>应用程序可以关闭TCP输入和输出信道中的任意一个, 或者将两者都关闭了。<br>套接字调用close()会将TCP连接的输入和输出信道都关闭了, 这被称作 “完全关闭”。<br>还可以用套接字调用shutdown()单独关闭输入或输出信道。这被称为”半关闭”。<br><img src="/img/http/close-shutdown-pipeline.png" width="350/"></p></li><li><p>TCP关闭及重置错误<br>….</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《HTTP权威指南》– 第四章<br>《图解HTTP协议》<br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/HTTP</a><br><a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">https://tools.ietf.org/html/rfc2616</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常被误解的Connection首部&quot;&gt;&lt;a href=&quot;#常被误解的Connection首部&quot; class=&quot;headerlink&quot; title=&quot;常被误解的Connection首部&quot;&gt;&lt;/a&gt;常被误解的&lt;code&gt;Connection&lt;/code&gt;首部&lt;/h2&gt;
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>11. 内容协商与转码</title>
    <link href="http://blog.renyimin.com/2017/12/06/http/2017-12-06-HTTP-11/"/>
    <id>http://blog.renyimin.com/2017/12/06/http/2017-12-06-HTTP-11/</id>
    <published>2017-12-06T10:50:27.000Z</published>
    <updated>2018-05-09T06:26:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>一个URL常常需要代表若干不同的资源</p><blockquote><p>例如那种需要以多种语言提供其内容的网站站点。<br> 如果某个站点有 ‘说法语的’ 和 ‘说英语的’ 两种用户, 它可能想用这两种语言提供网站站点信息;<br> 理想情况下，服务器应当向英语用户发送英文版，向法语用户发送法文版; 而用户只要访问网站主页就可以得到相应语言的内容。</p></blockquote></li><li><p>HTTP提供了 <code>内容协商</code> 方法，允许客户端和服务器作这样的决定。<br> 通过这些方法，单一的URL就可以代表不同的资源(比如，同一个网站页面的法语版和英语版)，这些不同的版本称为<code>变体</code>。</p></li><li><p>除了根据 <code>内容协商</code> 来决定URL代表的是那种版本的资源。另外, 对于有些特定的URL来说, 服务器还可以根据一些<strong>其他原则</strong>来决定发送什么内容给客户端最合适。在有些场合下, 服务器甚至可以自动生成定制的页面。比如，服务器可以为手持设备把HTML页面转换成WML页面，这类动态内容变换被称为<strong>转码</strong>。这些变换动作是HTTP客户端和服务器之间进行内容协商的结果。</p></li></ol><h2 id="内容协商技术"><a href="#内容协商技术" class="headerlink" title="内容协商技术"></a>内容协商技术</h2><ol><li><p>共有3种不同的方法可以决定服务器上哪个页面最适合客户端: <code>让客户端来选择</code>, <code>服务器自动判定</code>, 或 <code>让中间代理来选</code>。这3种技术分别称为<code>客户端驱动的协商</code>、<code>服务器驱动的协商</code> 以及 <code>透明协商</code></p></li><li><p>内容协商技术摘要如下:<br><img src="/img/http/内容协商.png" width="600"></p></li></ol><h3 id="客户端驱动-300"><a href="#客户端驱动-300" class="headerlink" title="客户端驱动 (300)"></a>客户端驱动 (300)</h3><p>1.对于服务器来说，收到客户端请求时只是发回响应，在其中列出可用的页面，让客户端决定要看哪个，这是最容易的事情。</p><ul><li>很显然，这是服务器最容易实现的方式，而且客户端很可能选择到最佳的版本(只要列表中有让客户端选择的足够信息)。</li><li>不利之处是<strong>每个页面都需要两次请求</strong>: <strong>第一次获取列表</strong>，<strong>第二次获取选择的副本</strong>。<br>这种技术速度很慢且过程枯燥乏味，让用户厌烦。</li></ul><p>2.从实现原理上来说，服务器实际上有两种方法为客户端提供选项:</p><ul><li>一是发送回一个HTML文档，里面有到该页面的各种版本的链接和每个版本的描述信息;</li><li>另一种方法是发送回HTTP/1.1响应时，使用 <code>300 Multiple Choices</code> 响应代码。客户端浏览器收到这种响应时，在前一种情况下(发回html文档的情况)，会显示一个带有链接的页面; 在后一种情况下，可能会弹出对话窗口，让用户做选择。不管怎么样，决定是由客户端的浏览器用户作出的</li></ul><p>3.除了增加时延并且对每个页面都要进行繁琐的多次请求之外, 这种方法<strong>还有一个缺点</strong>: 它需要多个URL, 公共页面要一个, 其他每种特殊页面也都要一个。</p><h3 id="服务器驱动"><a href="#服务器驱动" class="headerlink" title="服务器驱动"></a>服务器驱动</h3><p>1.之前已经知道了客户端驱动的协商存在的若干缺点。大部分缺点都涉及客户端和服务器之间通信量的增长, 这些通信量用来决定什么页面才是对请求的最佳响应。</p><p>2.而减少额外通信量的一种方法是<strong>让服务器来决定发送哪个页面回去</strong>，但为了做到这一点，<strong>客户端必须发送有关客户偏好的足够信息</strong>，以便服务器能够作出准确的决策。服务器通过 <code>客户端请求的首部集</code> 来获得这方面的信息(客户偏好)!! 有以下两种机制可供HTTP服务器评估发送什么响应给客户端比较合适：</p><ul><li>检査 客户端请求中的<code>内容协商首部集</code>: 服务器察看客户端发送的 <code>Accept内容协商首部集</code>, 设法用相应的响应首部与之匹配;</li><li>根据其他(非内容协商)首部进行变通, 例如，服务器可以根据客户端发送的 <code>User-Agent</code> 首部来发送响应</li></ul><h4 id="客户端内容协商首部集"><a href="#客户端内容协商首部集" class="headerlink" title="客户端内容协商首部集"></a>客户端内容协商首部集</h4><p>1.客户端可以用下面列出的HTTP首部集发送用户的偏好信息</p><blockquote><p>Accept : 告知服务器发送何种媒体类型<br>Accept-Language : 告知服务器发送何种语言<br>Accept-Charset : 告知服务器发送何种字符集<br>Accept-Encoding : 告知服务器采用何种编码</p></blockquote><p>2.<strong>实体首部集</strong> 和 <strong>内容协商首部集</strong></p><ul><li><strong>注意</strong>: 内容协商首部集与实体首部非常类似(比如 <code>Accept-Encoding</code> 和 <code>Content-Encoding</code>)。不过, 这两种首部的用途截然不同:</li><li><p><code>实体首部集</code>,像运输标签,它们描述了把报文从服务器传输给客户端的过程中必须的各种报文主体属性; 如下列出的实体首部集来匹配客户端的<code>Accept内容协商首部集</code></p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Accet首部            实体首部</div><div class="line">Accept    　　　　　　Content-Type</div><div class="line">Accept-Language     Content-Language</div><div class="line">Accept-Charset      Content-Type</div><div class="line">Accept-Encoding     Content-Encoding</div></pre></td></tr></table></figure><p>  （由于HTTP是无状态的协议，表示服务器不会在不同的请求之间追踪客户端的偏好，所以客户端必须在每个请求中都发送其偏好信息）</p></li><li><p>而<code>内容协商首部集</code>是由客户端发送给服务器用来告知其偏好信息的, 以便服务器可以从文档的不同版本中选择出最符合客户端偏好的那个来提供服务;</p></li></ul><h4 id="内容协商首部中的质量值"><a href="#内容协商首部中的质量值" class="headerlink" title="内容协商首部中的质量值"></a>内容协商首部中的质量值</h4><p>1.HTTP协议中定义了质量值，允许客户端为每种偏好类别列出多种选项，并为每种偏好选项关联一个优先次序。<br>    例如，客户端可以发送下列形式的<code>Accept-Language</code>首部：<code>Accept-Language: en; q=0.5, fr; q=0.0 , nl; q=1.0, tr; q=0.0</code><br>    其中q值的范围从0.0-1.0(0.0是优先级最低的，而1.0是优先级最高的)。<br>    上面列出的那个首部，说明该客户端最愿意接收荷兰语(缩写为nl)文档，但英语(缩写为en)文档也行; 无论如何，这个客户端都不愿意收到法语(缩写为fr)或土耳 其语(缩写为tr)的版本;</p><p>2.<strong>注意</strong>: 偏好的排列顺序并不重要，只有与偏好相关的<code>q值</code>才是重要的;</p><h4 id="客户端其它请求首部集"><a href="#客户端其它请求首部集" class="headerlink" title="客户端其它请求首部集"></a>客户端其它请求首部集</h4><p>1.服务器也可以根据客户端其他请求首部集来匹配响应, 比如 <code>User-Agent</code> 首部。例如, 服务器知道老版本的浏览器不支持JavaScript语言，这样就可以向其发送不含有JavaScript的页面版本。</p><p>2.由于缓存需要尽力提供所缓存文档中正确的”最佳”版本，HTTP协议定义了服务器在响应中发送的 <code>Vary</code> 首部。<br>    这个首部告知<strong>缓存</strong>, <strong>客户端</strong>, 和<strong>所有下游的代理</strong>, 服务器根据哪些首部来决定发送响应的最佳版本。</p><h3 id="透明协商-vary首部"><a href="#透明协商-vary首部" class="headerlink" title="透明协商(vary首部)"></a>透明协商(vary首部)</h3><p>1.了支持<strong>透明内容协商</strong>，服务器必须有能力告知代理，服务器需要检査哪些请求首部，以便对客户端的请求进行最佳匹配。但是HTTP/1.1规范中没有定义任何透明协商机制, 不过却定义了 <code>Vary</code> 首部。服务器在响应中发送了Vary首部，以告知中间节点需要使用哪些请求首部进行内容协商</p><p>2.代理缓存可以为通过单个URL访问的文档保存不同的副本, <strong>如果服务器把它们的决策过程传给代理,这些代理就能代表服务器与客户端进行协商</strong>。<br>（缓存同时也是进行内容转码的好地方，因为部署在缓存里的通用转码器能对任意服务器，而不仅仅是一台服务器传来的内容进行转码）</p><p>3.对内容进行缓存的时候是假设内容以后还可以重用。然而，为了确保对客户端请求回送的是正确的已缓存响应, 缓存必须应用服务器在回送响应时所用到的大部分决策逻辑;</p><p>4.之前我们已经了解了客户端发送的<code>Accept内容协商首部集</code>; 也了解到, 为了给每条请求选择最佳的响应, 服务器使用了哪些与这些首部集匹配的相应<code>实体首部集</code>。其实, 代理缓存也必须使用相同的首部集来决定回送哪个已缓存的响应。</p><p>5.<strong>下图展示了涉及缓存的正确及错误的操作序列</strong>。</p><ul><li>缓存把第一个请求转发给服务器，并存储其响应。</li><li>对于第二个请求，缓存根据URL査找到了匹配的文档。但是，这份文档是法语版的，而请求者想要的是西班牙语版的。如果缓存只是把文档的法语版本发给请求者的话，它就犯了错误;</li><li>像上面2中提到的, 代理缓存也必须要根据客户端发送来的<code>内容协商首部</code>来给客户端返回正确的响应<br>  <img src="/img/http/cache-beiyong-error.png" width="550"></li></ul><h4 id="Vary首部"><a href="#Vary首部" class="headerlink" title="Vary首部"></a>Vary首部</h4><p>1.下面是浏览器和服务器发送的一些典型的请求及响应首部:<br>    <img src="/img/http/vary-01.png" width="490"></p><p>2.然而, 如果服务器的决策不是依据<code>Accept</code>首部集，而是比如<code>User-Agent</code>首部的话，情况会如何？<br>例如, 服务器可能知道老版本的浏览器不支持JavaScript语言, 因此可能会回送不包含JavaScript的页面版本。<br>如果服务器是根据其他首部来决定发送哪个页面的话, <strong>和Accept首部集一样, 缓存也必须知道这些首部是什么, 这样才能在选择回送的页面时做出同样的逻辑判断</strong>。</p><p>3.HTTP的 <code>Vary</code> 响应首部中列出了所有客户端请求首部, 服务器可用这些首部来选择文档或产生定制的内容(在常规的内容协商首部集之外的内容)。例如, 若所提供的文档取决于<code>User-Agent</code>首部, <code>Vary首部</code>就必须包含<code>User-Agent</code>;</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>当新的请求到达时, 代理缓存会根据<code>内容协商首部集</code>来寻找最佳匹配。但在把文档提供给客户端之前, <strong>它还必须检査服务器有没有在已缓存响应中发送Vary首部</strong>。</li><li>如果有Vary首部, 那么新请求中那些首部的值必须与旧的已缓存的响应的请求首部相同。(也就是说,代理缓存也会保存旧的请求的请求首部和响应首部, 下面一句话更加肯定这一点)</li><li>因为服务器可能会根据客户端请求的首部来改变响应, 为了实现透明协商, 代理缓存就必须为每个已缓存变体保存<strong>客户端请求首部</strong>和<strong>相应的服务器响应首部</strong>)<br> <img src="/img/http/vary-02.png" width="650"></li><li>如果某服务器的Vary首部看起来像 <code>Vary: User-Agent, Cookie</code> 这样，大量不同的User-Agent和Cookie值将会产生非常多的变体, 而代理缓存必须为每个变体保存其相应的文档版本。当缓存执行査找时，首先会对内容协商首部集进行内容匹配，然后比较请求的变体与缓存的变体。如果无法匹配，缓存就从原始服务器获取文档</li></ol><h2 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h2><ol><li><p>我们已经讨论了一个机制, 该机制可以让客户端和服务器从某个URL的一系列文档中挑选出最适合客户端的文档。但是, 实现这些机制的前提是，存在一些满足客户端需求的文档—不管是完全满足还是在一定程度上满足;</p></li><li><p>然而, 如果服务器没有能满足客户端需求的文档会怎么样呢？服务器可以给出一个错误响应。但理论上，服务器可以把现存的文档转换成某种客户端可用的文档, 这种选项称为<strong>转码</strong>;</p></li><li><p>下面列出了一些假设的转码</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">转换之前 　　　　　　　　　　　　转换之后</div><div class="line">HTML文档    　　　　　　　　　　WML文档</div><div class="line">高分辨率图像    　　　　　　　　低分辨率图像</div><div class="line">彩色图像    　　　　　　　　　　黑白图像</div><div class="line">有多个框架的复杂页面    　　　　没有很多框架或图像的简单文本页面</div><div class="line">有Java小应用程序的HTML页面    没有Java小应用程序的HTML页面</div><div class="line">有广告的页面    　　　　　　　　去除广告的页面</div></pre></td></tr></table></figure></li><li><p>有3种类别的转码: <strong>格式转换</strong>、<strong>信息综合</strong>以及<strong>内容注入</strong></p></li></ol><h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><ol><li><p>格式转换是指将数据从一种格式转换成另一种格式, 使之可以被客户端査看。通过HTML到WML的转换, 无线设备就可以访问通常供桌面客户端査看的文档了。通过慢速连接访问Web页面的客户端并不需要接收高分辨率图像, 如果通过格式转换降低图像分辨率和颜色来减小图像文件大小的话, 这类客户端就能更容易地査看图像比较丰富的页面了。</p></li><li><p>格式转换可以由如下<code>内容协商首部集</code>来驱动, 但也能由 <code>User-Agent</code> 首部来驱动。注意: <code>内容转换或转码</code> 与 <code>内容编码</code> 或 <code>传输编码</code> 是不同的, 后两者一般用于更高效或安全地传输内容, 而前两者则可使访问设备能够査看内容;</p><pre><code class="php">Accet首部            实体首部Accept    　　　　　　Content-TypeAccept-Language     Content-LanguageAccept-Charset      Content-TypeAccept-Encoding     Content-Encoding</code></pre></li></ol><h3 id="信息综合"><a href="#信息综合" class="headerlink" title="信息综合"></a>信息综合</h3><ol><li><p>从文档中提取关键的信息片段称为信息综合(information synthesis), 这是一种有用的转码操作。这种操作的例子包括根据小节标题生成文档的大纲，或者从页面中删除广告和商标</p></li><li><p>根据内容中的关键字对页面分类是更精细的技术, 有助于总结文档的精髓。这种技术常用于Web页面分类系统中，比如门户网站的Web页面目录</p></li></ol><h3 id="内容注入"><a href="#内容注入" class="headerlink" title="内容注入"></a>内容注入</h3><p>参见P423</p><h3 id="转码与静态预生成的对比"><a href="#转码与静态预生成的对比" class="headerlink" title="转码与静态预生成的对比"></a>转码与静态预生成的对比</h3><ol><li><p>转码的替代做法是在Web服务器上建立Web页面的不同副本, 例如一个是HTML, 一个是WML, 一个图像分辨率高，一个图像分辨率低；一个有多媒体内容，一个没有。</p></li><li><p>但是，这种方法不是很切合实际，原因很多：</p><ul><li>某个页面中的任何小改动都会牵扯很多页面，需要很多空间来存储各页面的不同版本，而且使页面编目和Web服务器编程(以提供正确的版本)变得更加困难。</li><li>有些转码操作，比如广告插入(尤其是定向广告插入)，就不能静态实现, 因为插入什么广告和请求页面的用户有关</li></ul></li><li><p>对单一的根页面进行即时转换，是比静态的预生成更容易的解决方案。<br> 但这样会在提供内容时增加时延。不过有时候其中一些计算可以由第三方进行，这样就减少了Web服务器上的计算负荷——比如可以由代理或缓存中的外部Agent完成转换</p></li><li><p>下图显示了在代理缓存中进行的转码<br> <img src="/img/http/zhuanma-01.png" width="430"></p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><http权威指南></http权威指南>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个URL常常需要代表若干不同的资源&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如那种需要以多种语言提供其内容的网站站点。
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>05. 缓存</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-05/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-05/</id>
    <published>2017-11-30T13:27:36.000Z</published>
    <updated>2018-05-15T09:20:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>关于缓存的概念本文就不详细展开说明了, 这里所说的web缓存其实就是: 为了降低服务器端的访问频率, 减少通信数量, 一些缓存设备, 如客户端或一些中继代理服务器将获取的数据保存下来, 当再次需要时, 就使用所保存的数据; (当请求抵达缓存设备时, 如果缓存设备本地有”已缓存的”副本, 就可以从本地设备而不是原始服务器中提取这个文档)</p><p>使用缓存的优点</p><ul><li>减少了服务器端的通信数量, 可以提升用户访问速度</li><li>在网络断开的状态下, 也可以在某种程度上继续向用户提供服务</li><li>减少了冗余的数据传输, 节省了你的网络费用</li><li>缓解了网络本身的瓶颈问题, 不需要更多的带宽就能够更快地加载页面</li><li>降低了<strong>距离时延</strong>, 因为从较远的地方加载页面会更慢一些<br>(即使带宽不是问题, 距离也可能成为问题。<strong>每台网络路由器都会增加因特网流量的时延</strong>。即使客户端和服务器之间没有太多的路由器, <strong>光速自身也会造成显著的时延</strong>。)</li></ul><p>综上所述, 缓存对用户体验和通信成本都会造成很大的影响, 所以我们要尽可能地去灵活使用缓存机制。</p><h3 id="缓存命中"><a href="#缓存命中" class="headerlink" title="缓存命中"></a>缓存命中</h3><p>如果一些请求到达缓存设备时, 缓存设备可以用本地已有的副本为这些请求提供服务, 就被称为<strong>缓存命中</strong>;</p><h3 id="缓存未命中"><a href="#缓存未命中" class="headerlink" title="缓存未命中"></a>缓存未命中</h3><p>如果一些请求到达缓存设备时, 缓存设备本地没有副本提供给这些请求(或者由于某些策略需要无法将副本提供给请求), 而将请求转发给原始服务器, 这就被称为<strong>缓存未命中</strong>;</p><h3 id="缓存再验证"><a href="#缓存再验证" class="headerlink" title="缓存再验证"></a>缓存再验证</h3><p>文档过期后, 缓存设备并不是直接去原始服务器重新请求文档, 而是尽可能先去原始服务器查看其缓存文档有没有发生变化, 这种 <code>新鲜度检测</code> 被称为 <code>HTTP缓存再验证</code>;</p><h3 id="再验证命中"><a href="#再验证命中" class="headerlink" title="再验证命中"></a>再验证命中</h3><p>参看下文</p><h3 id="再验证未命中"><a href="#再验证未命中" class="headerlink" title="再验证未命中"></a>再验证未命中</h3><p>参看下文</p><h3 id="公有缓存和私有缓存"><a href="#公有缓存和私有缓存" class="headerlink" title="公有缓存和私有缓存"></a>公有缓存和私有缓存</h3><p>通用首部字段(general header fields)<code>Cache-Control</code>有两个缓存响应指令: <code>public</code> 和 <code>private</code> </p><p>缓存可以是<code>单个用户专用的</code>, 也可以是<code>数千名用户共享的</code></p><ul><li>专用缓存被称为<code>私有缓存(private cache)</code>, 私有缓存是个人的缓存, 包含了单个用户最常用的页面 ;</li><li>共享缓存被称为<code>公有缓存(public cache)</code>, 公有缓存包含了某个用户团体常用页面 ;</li></ul><p>私有缓存<br>私有缓存不需要很大的动力或存储空间, 这样就可以将其做的很小, 很便宜;<br>Web浏览器中就有内建的私有缓存—大多数浏览器都会将常用文档缓存在你个人电脑的磁盘和内存中, 并且允许用户去配置缓存的大小和各种设置;</p><p>公有缓存</p><ol><li>公有缓存是特殊的共享代理服务器, 被称为缓存代理服务器(caching proxy server), 或者更常见地被称为代理缓存(proxy cache);</li><li>代理缓存会从自己本地缓存中给用户提供缓存资源, 或者代表用户与服务器进行联系。公有缓存会接受来自多个用户的访问, 所以通过它可以更好地减少冗余流量</li><li>如下图: <ul><li>每个客户端都会重复地访问一个(还不在私有缓存中的)新的”热门”文档。每个私有缓存都要获取同一份文档, 这样它就会多次穿过网络。</li><li>而使用共享的公有缓存时, 对于这个流行的对象, 缓存只要取一次就行了, 它会用共享的副本为所有的请求服务, 以降低网络流量。<br><img src="/img/http/private-public-cache-01.png" width="400/"></li></ul></li></ol><h2 id="缓存模型"><a href="#缓存模型" class="headerlink" title="缓存模型"></a>缓存模型</h2><p>原始服务器的内容不可能是一成不变的, 所以缓存服务器还需要不时地去进行检测, 看看它们保存的副本是否是服务器上最新的副本;</p><p>HTTP的缓存机制在RFC7234中进行了详细的定义, 分为<strong>过期模型(Expiration Model)</strong> 和 <strong>验证模型(Validation Model)</strong> 两类;</p><p>在HTTP协议中, 缓存处于可用状态时称为 <code>fresh(新鲜)</code> 状态, 而处于不可用的状态时则称为 <code>stale(不新鲜)</code> 状态;</p><h3 id="过期模型"><a href="#过期模型" class="headerlink" title="过期模型"></a>过期模型</h3><ol><li><p>过期模型是指预先决定响应数据的保存期限, 当到达期限后, 就会再次访问原始服务器端来重新获得所需的数据;</p></li><li><p>过期模型可以通过在服务器的响应消息里包含何时过期的信息来实现, HTTP1.1中定义了两种实现方法:</p><ul><li><code>Cache-Control:max-age</code> 响应消息首部<blockquote><p>Cache-control 表示从当前时刻开始所经过的秒数; 该首部常用于控制各类缓存, 除了 max-age 外, 还可以进行各种指定; 稍后会进行介绍</p></blockquote></li><li><p><code>Expires</code> 响应消息首部</p><blockquote><p>老式的HTTP/1.0的实体首部字段, <code>Expires</code> 是使用绝对时间, 并使用RFC 1123中定义的时间格式, 依赖于计算机时钟的正确设置</p></blockquote></li><li><p>它们都可以给响应内容加一个过期时间, <code>Cache-Control</code> 首部能使用相对时间, 所以更倾向与使用比较新的 <code>Cache-Control</code> 首部</p></li><li><p>当以上两者同时使用的时候, <code>Cache-Control</code> 将获得优先</p></li></ul></li><li><p><strong>注意</strong>: </p><ul><li>有些服务器会回送一个 <code>Expires:0</code> 响应头, 试图将文档置于永远过期的状态, <strong>但这种语法是非法的</strong>, 可能给某个软件带来问题, 应该试着支持这种结构的输入, 但是不应该产生这种结构的输出;</li><li>而 <code>Cache-Control</code> 的 <code>max-age</code> 则可以设置 <code>Cache-Control: max-age=0</code>;</li></ul></li><li><p>Date 首部</p><ul><li><code>max-age</code>的计算会用到名为<code>Date</code>的首部, 该首部用来显示服务器端生成响应消息的时间信息, 从该时间开始计算, 当经过的时间超过 <code>max-age</code> 值时, 则可以认为缓存已过期;</li><li>文档过期算法为: <code>expirationTime</code>(过期时间) = <code>responseTime(Date头)</code> + <code>freshnessLifetime(max-age/Exprie值)</code> - <code>currentAge(Age头)</code></li></ul></li></ol><h3 id="验证模型"><a href="#验证模型" class="headerlink" title="验证模型"></a>验证模型</h3><ol><li><p>文档过期后, 缓存设备并不是直接去服务器重新请求文档, 而是尽可能先去原始服务器查看其缓存文档有没有发生变化, 这种 <code>新鲜度检测</code> 被称为 <code>HTTP缓存再验证</code>;<br> 当然, 在服务器没有返回”将缓存数据保存多久”的信息, 服务器就需要通过验证模型的两个响应首部字段(<code>Last-Modified</code> 和 <code>ETag</code>)来告知客户端更新相关的信息, 努力减少客户端不必要的访问;</p></li><li><p>所以说, 仅仅是已缓存文档过期了, 还不能说明该过期文档和原始服务器上的文档有实际的区别, 这只是意味着 <strong>到时间进行再验证了</strong> ; 因为客户端还可以设置一些缓存控制项来进行影响;</p></li><li><p>在缓存文档过期之前, 缓存设备可以随意使用这些副本, 而且无需与服务器做任何联系, 除非</p><ul><li>客户端请求中包含 “阻止提供缓存” 的首部 <code>Cache-Control:no-store</code> ;</li><li>或者客户端请求中包含 “只有经过验证才能返回缓存副本”的首部 <code>Cache-Control:no-cache</code> ; </li></ul></li><li><p>但是一旦已缓存文档过期, 缓存设备就必须与服务器进行再验证核对, 除非你设置了 <code>Cache-Control:only-if-cached</code>, 要求只使用缓存;</p></li></ol><h3 id="再验证依据"><a href="#再验证依据" class="headerlink" title="再验证依据"></a>再验证依据</h3><ol><li><p>为了有效地进行再验证, HTTP定义了一些特殊的请求, 不用从服务器上获取整个对象, 就可以快速检测出内容是否是最新的, HTTP的<code>条件方法</code>可以高效地实现再验证;</p></li><li><p>HTTP定义了5个条件请求首部, 对 <code>缓存再验证</code> 来说有用的2个首部是 <code>If-Mofified-Since</code> 和 <code>If-None-Match</code>, 所有的条件首部都以前缀<code>If-</code>开头。<br> <img src="/img/http/revalidate-01.png" width="500/"></p></li><li><p>再验证 请求首部字段 <code>If-Modified-Since</code></p><ul><li>如果自<code>If-Modified-Since</code>指定日期之后, 文档被修改了, <code>If-Modified-Since</code> 条件就为真, 通常GET就会成功执行, 携带新首部的新文档会被返回给缓存, 新首部除了其他信息之外, 还包含了一个新的过期日期;</li><li>如果自<code>If-Modified-Since</code>指定日期之后, 文档没被修改, <code>If-Modified-Since</code> 条件就为假, 会向客户端<strong>返回一个小的 304 Not Modified响应报文</strong>, 为了提高有效性, <strong>不会返回文档主体</strong>; 否则, 如果文档发生了变化, 就返回带有新主体的200响应;</li><li>请求首部字段 <code>If-Modified-Since</code> 和 实体首部字段 <code>Last-Modified</code> 配合工作;</li></ul></li><li><p>再验证 请求首部字段 <code>If-None-Match</code></p><ul><li>有些文档可能会被周期性地重写, 但实际包含的数据常常却是一样的。<strong>尽管内容没有发生变化, 但是修改日期会发生变化</strong>;</li><li>有些文档可能内容被修改了, 但是<strong>所做的修改并不重要</strong>, 不需要让世界范围内的缓存都重装数据(比如对拼写或注释的修改), 涉及到弱验证器;</li><li>有些服务器无法准确地判定其页面的最后修改日期;</li><li><p>有些服务器提供的文档会在亚秒间隙发生变化(比如,实时监视器), 对这些服务器来说, <strong>以秒为粒度的修改日期可能就不够用了</strong>;</p></li><li><p>为了解决上述问题, HTTP有一个被称为 <code>实体标签(ETag)</code> 的 <code>版本标识符</code>, 这个实体标签是附加到文档上的任意标签, 标签可能可能包含了文档序列号或版本名, 或是文档内容的校验及其他指纹信息。<br>当对文档进行修改时, 可以修改文档的实体标签来说明这个新的版本。这样, 如果实体标签被修改了, 缓存就可以用 <code>If-None-Match</code> 条件首部来GET文档的新副本了;</p></li><li><p>如果<code>If-None-Match</code> 与 <code>If-Modified-Since</code> 同时存在, 两个都要进行验证;</p></li><li><p>请求首部字段 <code>If-None-Match</code> 和 响应首部字段 <code>ETag</code> 配合工作;</p></li></ul></li><li><p>再验证命中: 缓存到期后, 在对副本进行再验证时, 会向原始服务器发送一个小的再验证请求。如果发现内容没有变化, 服务器会以一个小的 <code>304 Not Modified</code> 进行响应;</p><ul><li>只要缓存设备知道副本仍然有效, 就会再次将副本标识为暂时新鲜的, 并将副本提供给客户端, 而不用原始服务器重新返回文档, 这被称为<strong>再验证命中(revalidate hit)</strong> 或 <strong>缓慢命中(slow hit)</strong>;<br><img src="/img/http/revalidate-hit-01.png" width="350/"></li><li>缓存再验证命中还是需要与原始服务器进行核对, 所以会比单纯的缓存命中要慢, 但是它并没有从服务器中获取对象数据, 所以要比缓存未命中要快一些。</li></ul></li><li><p>再验证未命中: 如果缓存发现原始服务器对象与已缓存副本不同, 则服务器会向客户端发送一条普通的, 带有完整内容的 <code>HTTP 200 OK</code> 响应;<br> <img src="/img/http/revalidate-not-hit-01.png" width="350/"></p><ul><li>这种方式 不仅需要与原始服务器进行核对, 而且会从服务器中获取对象数据, 所以理论上貌似要比缓存未命中要慢一些;</li><li>如果再验证发现服务器对象已经被删除, 服务器就回送一个 <code>404 Not Found</code> 响应, <strong>缓存也会将其本地副本删除</strong>;</li></ul></li><li><p>弱验证器</p><ul><li>只要原始服务器内容发生变化, 则实体标签就会变化, 正常情况下, 强验证器就会对比失败, 导致服务器会在一个 <code>200 OK</code> 响应中返回新的内容以及新的<code>Etag</code>标签;</li><li>有时, 服务器希望对文档进行一些不重要的修改, 并且不需要使所有已缓存副本都失效<br>HTTP1.1支持的”弱验证器”, 就允许对一些内容做修改, 此时服务器会用前缀 <code>W/</code> 来标识弱验证器</li><li>不管相关的实体值以何种方式发生了变化, 强实体标签都要发生变化, 而相关实体在语义上发生了比较重要的变化时, 弱实体标签页应该发生变化</li></ul></li></ol><h2 id="vary"><a href="#vary" class="headerlink" title="vary"></a>vary</h2><p>//todo</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>再验证命中 比 缓存未命中 要快</strong><br><strong>再验证未命中 几乎和 缓存未命中 速度一样</strong></p><h2 id="Cache-Control-缓存控制字段详解"><a href="#Cache-Control-缓存控制字段详解" class="headerlink" title="Cache-Control 缓存控制字段详解"></a>Cache-Control 缓存控制字段详解</h2><p>1.之前在<a href="/2017/11/30/http/2017-11-30-HTTP-04/">各通用首部字段详解</a>已经对各选项进行了说明;</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>(<a href="https://stackoverflow.com/questions/33818854/what-is-difference-between-max-age-and-max-stale-in-cache-control-mechanism" target="_blank" rel="external">HTTP Cache-Control: max-age和max-stale=s的区别</a>)</li><li><code>immutable</code> : 属于缓存控制的一个扩展属性, <a href="http://www.jdon.com/performance/cache-control-immutable.html" target="_blank" rel="external">参考</a><blockquote><p>当一个支持immutable的客户端浏览器看到这个属性时, 它应该知道, 如果没有超过过期时间，那么服务器端该页面内容将不会改变, 这样浏览器就不应该再发送有条件的重新验证请求(比如通过If-None-Match 或 If-Modified-Since等条件再向服务器端发出更新检查);<br>也就是说, 通常过去我们使用304回复客户端该页面内容没有变化，但是如果用户按浏览器的刷新或F5键，浏览器会再次向服务器端发出该页面内容请求，服务器端如果确认该页面没有变化，那么发回304给客户端，不再发送该页面的实体内容，虽然这样节省了来回流量，但是如果大型网站的很多用户为了得到及时信息，经常会刷新浏览器，这就造成了大量刷新请求，向服务器端求证该页面是否改变，这会影响网站的带宽，也增加服务器端验证压力。<br><strong>而新的选项immutable可以杜绝这种现象</strong>。<br>immutable可以节省HTTP请求,缩短请求时间,这是因为服务器不必再处理304响应了。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存&quot;&gt;&lt;/a&gt;缓存&lt;/h2&gt;&lt;p&gt;关于缓存的概念本文就不详细展开说明了, 这里所说的web缓存其实就是: 为了降低服务器端的访问频率, 减少通信数量, 一些缓存设备, 如客户
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>04. 各通用首部字段详解</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-04/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-04/</id>
    <published>2017-11-30T11:50:02.000Z</published>
    <updated>2018-05-09T06:26:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cache-Control-缓存能力控制"><a href="#Cache-Control-缓存能力控制" class="headerlink" title="Cache-Control 缓存能力控制"></a>Cache-Control 缓存能力控制</h2><p>1.Cache-Control 缓存指令是单向的, 即请求中存在一个指令并不意味着响应中将存在同一个指令;</p><ul><li>该指令是可选的;</li><li>指令可以有多个选项, 选项之间通过 <code>,</code> 分隔;</li></ul><p>2.可以按请求和响应分为(P377)</p><ul><li>缓存请求指令(选项如下)<br><img src="/img/http/cache-control-request.png" width="500/"></li><li>缓存响应指令(选项如下)<br><img src="/img/http/cache-control-response.png" width="500/"></li></ul><p>3.注意 <code>no-cache</code> 和 <code>must-revalidate</code> 的区别</p><ul><li>no-cache: 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验;</li><li>must-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去原始服务器进行有效性校验。(这应该是缓存系统的默认行为, 但must-revalidate指令使得这个要求是明确的<a href="https://stackoverflow.com/questions/2932890/http-cache-control-max-age-must-revalidate" target="_blank" rel="external">参考</a>;</li><li><a href="https://segmentfault.com/a/1190000007317481" target="_blank" rel="external">可参考</a></li></ul><p>更多参考后面的博文<a href="/2016/11/30/http/2016-11-30-HTTP-05-cache/">缓存相关</a>中的介绍</p><h2 id="Pragma-兼容"><a href="#Pragma-兼容" class="headerlink" title="Pragma 兼容"></a>Pragma 兼容</h2><p>Pragma是HTTP1.1之前版本的历史遗留字段, 仅作为与HTTP1.0做向后兼容;<br>除了与只理解 <code>Pragma:no-cache</code> 的HTTP/1.0应用程序进行交互时使用; HTTP/1.1应用程序都应该使用Cache-Control:no-cache;</p><h2 id="Date-当前时间"><a href="#Date-当前时间" class="headerlink" title="Date 当前时间"></a>Date 当前时间</h2><p>简单来说就是HTTP报文的创建日期, 它会参与到缓存的<code>过期时间</code>运算中;</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="external">公式</a>: <code>expirationTime = responseTime(Date头) + freshnessLifetime(max-age/Exprie值) - currentAge(Age头)</code></li><li><p>默认情况下, Date 的值为当前时间</p></li><li><p>而响应首部字段中的 <code>Age</code> 头字段, 是告诉客户端, 源服务器创建的缓存在代理服务器上已经保存了多久, 字段的单位为秒; 代理创建响应时必须加上首部字段<code>Age</code>; </p></li></ul><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><ol><li>该首部字段具备两个作用: <code>控制不再转发给代理的首部字段</code> 和 <code>管理持久连接</code>;</li><li>更多参考<a href="/2017-04-21-HTTP-Connection-Keep-Alive/">HTTP - 并行连接, 持久连接</a></li><li>未完待续…</li></ol><h2 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h2><ol><li><p>使用首部字段Via, 是为了追踪客户端与服务器之间的请求和响应报文的传输路径;<br>报文在经过代理或者网关时, 会先在首部字段Via中附加该服务器的信息, 然后再进行转发。</p><blockquote><p>Via首部是为了追踪传输路径, 所以也经常会和TRACE方法一起使用, 比如代理服务器受到由TRACE方法发送过来的请求(其中Max-Forward:0)时, 代理服务器就不能再转发该请求了,<br>这种情况下, 代理服务器会将自身的信息附加到Via首部后, 返回该请求的响应。</p></blockquote></li><li><p>未完待续…</p></li></ol><h2 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h2><p><strong>传输编码</strong></p><ol><li>该通用首部字段规定了传输报文主体时采用的编码方式;</li><li>HTTP/1.1的传输编码方式仅对分块传输编码有效, 即只能设置为 <code>Transfer-Encoding:chunked</code>;</li><li>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding" target="_blank" rel="external">MDN Doc</a>;</li><li><code>Content-Encoding</code> 和 <code>Transfer-Encoding</code> 二者经常会结合来用, 其实就是针对 Transfer-Encoding 的分块再进行 Content-Encoding 压缩;</li></ol><h3 id="对比-请求首部字段Accept-encoding"><a href="#对比-请求首部字段Accept-encoding" class="headerlink" title="对比 请求首部字段Accept-encoding"></a>对比 请求首部字段Accept-encoding</h3><p><strong>内容编码</strong> (P369)</p><ol><li><p>请求首部字段 <code>Accept-encoding</code> 是将客户端用户代理(浏览器)所<strong>支持的内容编码方式</strong>(通常是某种压缩算法) 及 <strong>内容编码方式的优先级顺序</strong>, 通知给服务器;</p><ul><li>通过内容协商, 服务端会选择一个客户端支持的方式, 使用并在 响应报文的实体首部字段 <code>Content-Encoding</code> 中通知客户端, 服务器选择了哪种内容编码方式;</li><li>另外, 可以一次性指定多种内容编码! </li><li>也可以使用权重q值来表示相对优先级;</li></ul></li><li><p>正常情况下, 主要采用4种编码方式: <code>gzip</code>, <code>compress</code>, <code>deflate</code>, <code>identity</code>;</p></li><li><p>即使客户端和服务器都支持某些相同的压缩算法，但如果<code>Accept-encoding:identity</code>, 表示客户端告诉服务器对响应主体不要进行压缩, 出现的两种情况的常见情形是：</p><ul><li>要发送的数据已经经过压缩, 再次进行压缩不会导致被传输的数据量更小, 一些图像格式的文件会存在这种情况;</li><li>服务器超载, 无法承受压缩需求导致的计算开销, 通常, 如果服务器使用超过80%的计算能力, 微软建议不要压缩;</li></ul></li><li><p>只要identity(表示不需要进行任何编码)没有被明确禁止使用(没有明确通过 <code>identity;q=0</code> 或是 <code>*;q=0</code> 指令明确设置 identity 的权重值为0), 一旦禁止就表示 服务端必须进行编码;</p><ul><li>没有禁止identity, 则服务器禁止返回表示客户端错误的 <code>406 Not Acceptable</code> 响应;</li><li>禁止identity后, 服务器才可能因为实在没有合适的内容编码类型而, 返回表示客户端错误的<code>406 Not Acceptable</code></li></ul></li><li><p>参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Encoding" target="_blank" rel="external">MDN</a></p></li></ol><h3 id="对比-实体首部字段-Content-encoding"><a href="#对比-实体首部字段-Content-encoding" class="headerlink" title="对比 实体首部字段 Content-encoding"></a>对比 实体首部字段 <code>Content-encoding</code></h3><p><strong>内容编码</strong><br>实体首部字段 <code>Content-encoding</code> 会告诉客户端, 服务器对实体的主体部分选用的内容编码方式</p><h3 id="对比-请求首部字段Accept-charset"><a href="#对比-请求首部字段Accept-charset" class="headerlink" title="对比 请求首部字段Accept-charset"></a>对比 <strong>请求首部字段<code>Accept-charset</code></strong></h3><p>请求首部字段 <code>Accept-charset</code> 会告诉服务器, 用户代理(浏览器)所支持的<code>字符集</code>和<code>字符集的相对优先顺序</code>。(P388)</p><ul><li>可以一次性指定多种字符集;</li><li>也可以使用权重q值来表示相对优先级;</li></ul><h2 id="对比-请求首部字段Accept-Language"><a href="#对比-请求首部字段Accept-Language" class="headerlink" title="对比 请求首部字段Accept-Language"></a>对比 <strong>请求首部字段<code>Accept-Language</code></strong></h2><p>请求首部字段 <code>Accept-charset</code> 会告诉服务器, 用户代理(浏览器)所支持的<code>语言</code>和<code>语言的相对优先顺序</code>。</p><ul><li>可以一次性指定多种字符集;</li><li>也可以使用权重q值来表示相对优先级;</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>请求首部字段<code>Accept-encoding</code> 和 实体首部字段<code>Content-encoding</code>来决定内容压缩方式;</li><li>通用首部字段<code>Transfer-Encoding</code>用来决定响应实体是否分块;</li><li>请求首部字段<code>Accept-charset</code>, <code>Accept-Language</code> 是客户端告诉服务端自己能支持的字符编码和语言及其中的优先顺序;</li></ol><h2 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h2><h2 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h2><h2 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h2><p>~~未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Cache-Control-缓存能力控制&quot;&gt;&lt;a href=&quot;#Cache-Control-缓存能力控制&quot; class=&quot;headerlink&quot; title=&quot;Cache-Control 缓存能力控制&quot;&gt;&lt;/a&gt;Cache-Control 缓存能力控制&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>03. HTTP状态码详解</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-03/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-03/</id>
    <published>2017-11-30T06:30:12.000Z</published>
    <updated>2018-05-23T01:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h2><ol><li><code>101</code>: 参考博文<a href="/2017/10/28/WebSocket/2017-10-28-websocket-02/">WebSocket简单示例分析</a> (做协议升级, 还会响应: <code>Connection: Upgrade</code>)<br>~~未完待续</li></ol><h2 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h2><blockquote><p><strong>Web API的设计与开发 P109</strong></p></blockquote><p><strong>200 OK</strong> : 200码非常出名, 似乎没有对它进一步说明的必要;</p><p><strong>201 Created</strong> : 当在服务器端创建数据成功时, 会返回201状态码;</p><ul><li>也就是使用 <code>POST</code> 请求方法的场景 (如:用户登录后添加了新用户, 上传了图片等新创建数据的场景)</li></ul><p><strong>202 Accepted</strong> : 在异步处理客户端请求时, 它用来表示服务器端已经接受了来自客户端的请求, 但处理尚未结束;</p><ul><li>在文件格式转换, 处理远程通知(Apple Push Notification等)这类很耗时的场景中, 如果等到所有处理都结束后才向客户端返回响应消息, 就会花费相当长的时间, 造成应用可用性不高; 这时采用的方法是服务器向客户端返回一次响应消息, 然后立刻开始异步处理。</li><li>202状态码就被用于告知客户端服务器端已经开始处理请求, 但整个处理过程尚未结束;</li><li>比如: 以LinkedIn的参与讨论的API为例<br>如果成功参与讨论并发表意见, 服务器端通常会返回201状态码;<br>但如果需要得到群主的确认, 那么所发表的意见就无法立即在页面显示出来, 这时服务器端就需要返回202状态码; 从广义上来看, 该场景也属于异步处理, 但和程序设计里的异步执行当然不同;</li></ul><p><strong><a href="http://www.laruence.com/2011/01/20/1844.html" target="_blank" rel="external">204 No Content</a></strong> : 正如其字面意思, 当响应消息为空时会返回该状态码。</p><ul><li>其实就是告诉浏览器, 服务端执行成功了, 但是没什么数据返回给你, 所以你不用刷新页面, 也不用导向新的页面; </li><li>在用<code>DELETE</code>方法删除数据时, 服务器端通常会返回204状态码(阮一峰博文也提到过, 对<code>DELETE</code>适用);</li><li>除此之外, 也有人认为在使用 <code>PATCH</code> 方法更新数据时, 因为只是更新已有数据, 所以返回204状态码更加自然;</li><li>关于204状态码的讨论可以参考 p111;</li></ul><p><strong>205 Reset Content</strong> : 告诉浏览器, 页面表单需要被重置; </p><ul><li>205的意思是服务端在接收了浏览器POST请求以后, 处理成功以后, 告诉浏览器, 执行成功了, 请清空用户填写的Form表单, 方便用户再次填写;</li></ul><p><strong>206 Partial Content</strong> : 成功执行了一个部分或Range(范围)的请求; </p><ul><li>206响应中, 必须包含 <code>Content-Range</code>, <code>Date</code> 以及 <code>ETag</code>或<code>Content-Location</code>首部;</li></ul><h2 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h2><p><strong>300 Multiple Choices</strong> : 客户端驱动方式进行内容协商时, 服务器可能返回多个连接供客户端进行选择 (比如多语言网站可能会出现);</p><p><strong>301 Moved Permanently</strong> : 在请求的URL已经被移除时使用, 响应的Location首部中应该包含资源现在所处的URL; (比较适合永久重定向)</p><ul><li>比如你从 www.test.com/location.php 中location跳转到 www.test.com/index.html 时, 如果响应的是301;</li><li><p>则即便稍后取消了location.php中的跳转(或者修改了跳转地址), 由于浏览器还是会认为你之前的跳转是永久性的, 再次访问www.test.com/location.php仍然会跳转到之前的跳转链接(除非清浏览器缓存);</p></li><li><p>另外, 假设你之前是先访问www.test.com/test.html, 然后通过<strong>post</strong>提交到www.test.com/location.php, 最后由location.php再进行跳转的话, 会转成<strong>GET</strong>;</p></li></ul><p><strong>302 Found</strong>: 与301类似, 但是客户端应该使用Location首部给出的URL来进行<strong>临时</strong>定位资源, 将来的请求仍应该使用老的URL;</p><ul><li>比如你从 www.test.com/location.php 中location跳转到 www.test.com/index.html 时, 如果响应的是302;</li><li><p>如果稍后取消了location.php中的跳转, 再次访问www.test.com/location.php, 会发现不会进行跳转, 而是访问到 location.php 修改后的代码 (不用清浏览器缓存);</p></li><li><p>另外, 假设你之前是先访问www.test.com/test.html, 然后通过<strong>post</strong>提交到www.test.com/location.php, 最后由location.php再进行跳转的话, 会转成<strong>GET</strong>;</p></li></ul><p><strong>303 See Other</strong> : HTTP/1.1使用303来实现和302一样的<strong>临时</strong>重定向;</p><p><strong>307 Temporary Redirect</strong></p><ul><li>HTTP/1.1规范要求用307来取代302进行临时重定向; (302临时重定向留给HTTP/1.0)</li><li>所以他也具备302临时重定向的特点;</li><li>但是, 与 302, 303 不同, 它会将客户端的POST请求, 发送给location的目标页; 假设你之前是先访问www.test.com/test.html, 然后通过<strong>post</strong>提交到www.test.com/location.php, 最后由location.php再进行跳转的话, 仍然是<strong>POST</strong>;</li></ul><p><strong><a href="https://tools.ietf.org/html/draft-reschke-http-status-308-07" target="_blank" rel="external">308 Permanent Redirect</a></strong></p><ul><li>貌似不是rfc2616的标准</li><li>具备和301永久重定向的特点, 需要清除浏览器缓存才行;</li><li>但是, 与 301 不同, 它会将客户端的POST请求, 发送给location的目标页; 假设你之前是先访问www.test.com/test.html, 然后通过<strong>post</strong>提交到www.test.com/location.php, 最后由location.php再进行跳转的话, 仍然是<strong>POST</strong>;</li></ul><p><strong>304 Not Modified</strong> : 参考博文<a href="/2017/11/30/http/2017-11-30-HTTP-05/">缓存相关</a></p><h2 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h2><blockquote><p><strong>Web API的设计与开发 P113</strong><br>4字头状态码主要用于描述因客户端请求的问题而引发的错误。<br>也就是说, 服务器端不存在问题, 但服务器端无法理解客户端发送的请求, 或虽然服务器端能够理解但请求却没有被执行, 当遇到这些情况引发的错误时, 服务器端便会向客户端返回这一类别的状态码。<br>因此, 当服务器端返回4字头的状态码时, 就表示客户端的访问方式发生了问题, 用户需要检查一下客户端的访问方式或访问的目标资源等。</p></blockquote><p><strong>400 Bad Request</strong> : 表示其他错误的意思, 即其他4字头状态码都无法描述的错误类型;</p><p><strong>401 Unauthorized</strong> : 表示<code>认证(Authentication)</code>类型的错误</p><ul><li>比如当需要先进行登录操作, 而却没有告诉服务器端所需的会话信息(比如token..), 服务器端就会返回401状态码, 告知客户端出错的大致原因;</li></ul><p><strong>403 Forbidden</strong> : 和401状态码比较相似, 所以也经常被混淆; 其实403表示的是<code>授权(Authotization)</code>类型的错误, 授权和认证的不同之处是:</p><ul><li><code>认证</code>表示”识别前来访问的是谁”, 而<code>授权</code>则表示”赋予特定用户执行特定操作的权限”</li><li>通俗地说: 401状态码表示”我不知道你是谁”, 403状态码表示”虽然知道你是谁, 但你没有执行该操作的权限”</li></ul><p><strong>404 Not Found</strong> : 表示访问的数据不存在, 但是</p><ul><li>例如当客户端湿度获取不存在的用户信息时, 或者试图访问原本就不存在的端点时, 服务器就会返回404状态码;</li><li>所以, 如果客户端想要获取用户信息, 却得到服务器端返回的404状态码, 客户端仅凭”404 Not Found”将难以区分究竟是用户不存在, 还是端点URI错误导致访问了原本不存在的URI;</li></ul><p><strong>405 Method Not Allowed</strong> : 表示虽然访问的端点存在, 但客户端使用的HTTP方法不被服务器端允许;</p><ul><li>比如客户端使用了POST方法来访问只支持GET方法的信息检索专用的API;</li><li>又比如客户端用了GET方法来访问更新数据专用的API等;</li></ul><p><strong>406 Not Acceptable</strong> : 服务器端API不支持客户端指定的数据格式时, 服务器端所返回的状态码; </p><ul><li>比如, 服务器端只支持JSON和XML输出的API被客户端指定返回YAML的数据格式时, 服务器端就会返回406状态码;</li></ul><p><strong>408 Request Timeout</strong> : 当客户端发送请求至服务器端所需的时间过长时, 就会触发服务器端的超时处理, 从而使服务器端返回该状态码;</p><p><strong>409 Conflict</strong>: 用于表示资源发生冲突时的错误 (est中就会有该错误码)</p><ul><li>比如通过指定ID等唯一键值信息来调用注册功能的API时, 倘若已有相同ID的数据存在, 就会导致服务器端返回409状态码;</li><li>在使用邮箱地址及Facebook ID等信息进行新用户注册时, 如果该邮箱地址或者ID已经被其他用户注册, 就会引起冲突, 这时服务器端就会返回409状态码告知客户端该邮箱地址或ID已被使用;</li></ul><p><strong>410 Gone</strong> : 和 404状态码 相同, 都表示访问资源不存在, 只是410状态码不单表示资源不存在, 还进一步告知<strong>资源曾经存在</strong>, 只是目前已经消失了;</p><ul><li>因此服务器端常在访问被删除的数据时返回该状态码, 但是为了返回该状态码, 服务器必须保存该数据已被删除的信息, 而且客户端也应该知晓服务器端保存了这样的信息;</li><li>但是在通过邮箱地址搜索用户信息的API中, 从保护个人信息的角度来说, <strong>返回410状态码的做法也会受到质疑</strong>; (所以在此种资源不存在的情况下, 为了稍微安全一些, 返回410状态码需要慎重)</li></ul><p><strong>413 Request Entity Too Large</strong> : 413也是比较容易出现的一种状态码, 表示请求实体过大而引发的错误</p><ul><li>请求消息体过长是指, 比如在上传文件这样的API中, 如果发送的数据超过了所允许的最大值, 就会引发这样的错误;</li></ul><p><strong>414 Request-URI Too Large</strong> : 414是表示请求首部过长而引发的错误</p><ul><li>如果在进行GET请求时, 查询参数被指定了过长的数据, 就会导致服务器端返回414状态码</li></ul><p><strong>415 Unsupported Media Type</strong> : 和406比较相似</p><ul><li>406我们知道是表示服务器端不支持客户端想要接收的数据格式</li><li>而415表示的是服务器端不支持客户端请求首部 <code>Content-Type</code> 里指定的数据格式, 也就是说, 当客户端通过POST,PUT,PATCH等方法发送的请求消息体的数据格式不被服务器支持时, 服务器端就会返回415状态码;</li><li>例如在只接收JSON格式的API里, 如果客户端请求时发送的是XML格式的数据去请求服务器端, 或者在 <code>Content-Type</code> 首部指定 <code>application/xml</code>, 都会导致该类型错误;</li></ul><p><strong>429 Too Many Requests</strong> : 是2012年RFC6585文档中新定义的状态码, 表示访问次数超过了所允许的范围;</p><ul><li>例如某API存在一小时内只允许访问100次的访问限制, 这种情况下入股哦客户端视图进行第101次访问, 服务器便会返回该状态码;</li><li>表示在一定的时间内用户发送了太多的请求, 即超出了”频次限制”, 在响应中，可以提供一个 <code>Retry-After</code> 首部来提示用户需要等待多长时间之后再发送新的请求;</li></ul><h2 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h2><blockquote><p>5字头状态码表示错误不发生在客户端, 而是由服务器自身问题引发的。</p></blockquote><p><strong>500 Internal Server Error</strong> : 是web应用程序开发里非常常见的错误, 当服务器代码里存在bug, 输出错误信息并停止运行等情况下, 就会返回该类型的错误;</p><ul><li>因此, 不仅限于API, 对于5字头状态码的错误, 都要认真监视错误日志, 使系统在出错时及时告知管理员, 以便在错误发生时做好应对措施, 防止再次发生。</li></ul><p><strong>501 Not Implemented</strong> : ???</p><p><strong>502 Bad GateWay</strong> : ???</p><p><strong>503 Service Unavaliable</strong> : 用来表示服务器当前处于<strong>暂</strong>不可用状态</p><ul><li>可以回送:响应首部 <code>Retry-After</code> 表示多久恢复;</li><li>不同的客户端与服务器端应用对于 Retry-After 首部的支持依然不太一致;</li><li>不过，一些爬虫程序，比如谷歌的爬虫程序Googlebot, 会遵循Retry-After响应首部的规则, 将其与503(Service Unavailable,当前服务不存在)响应一起发送有助于互联网引擎做出判断,在宕机结束之后继续对网站构建索引。</li><li>参考:<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Retry-After" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Retry-After</a></li></ul><p><strong>504 Gateway Time-out</strong>: 复现这个错误码比较简单, 让你的php程序模拟耗时请求, 如下代码<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">sleep(70);//模拟耗时，睡70秒</div><div class="line">echo &quot;睡醒了&quot;;</div></pre></td></tr></table></figure></p><pre><code>就会返回```504 Gateway Time-outnginx/1.11.4``` </code></pre><p><strong>505 HTTP Version Not Supported</strong>: 服务器收到的请求, 使用的是它无法支持的HTTP协议版本;</p><p>参考:《HTTP权威指南》、《Web API的设计与开发》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1xx&quot;&gt;&lt;a href=&quot;#1xx&quot; class=&quot;headerlink&quot; title=&quot;1xx&quot;&gt;&lt;/a&gt;1xx&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;101&lt;/code&gt;: 参考博文&lt;a href=&quot;/2017/10/28/WebSocket/2017-10
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>02. HTTP各请求方法详解</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-02/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-02/</id>
    <published>2017-11-30T03:29:12.000Z</published>
    <updated>2018-05-09T06:27:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>HTTP/1.1 中实现的method, <a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">参考RFC2616</a>, 可以看到有: <code>OPTIONS</code>, <code>GET</code>, <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>, <code>CONNECT</code></p></li><li><p>RFC2616中提到: PATCH，LINK，UNLINK方法被定义，但并不常见;(&lt;图解http协议&gt;中也提到 <code>LINK</code>, <code>UNLINK</code>已经被http1.1废弃);</p></li><li><p>不同应用各自的实现不同, 有些应用会完整实现, 有些还会扩展, 有些可能会实现一部分;</p></li></ol><h2 id="PUT-对比POST"><a href="#PUT-对比POST" class="headerlink" title="PUT(对比POST)"></a>PUT(对比POST)</h2><ol><li><p><code>PUT</code>: 对已有资源进行更新操作, 所以是 update 操作;</p></li><li><p>put和post的区别<br> 在HTTP中, PUT被定义为 <a href="https://tools.ietf.org/html/rfc2616#section-9.1.2" target="_blank" rel="external"><code>idempotent(幂等性)</code></a> 的方法，POST则不是，<strong>这是一个很重要的区别</strong></p></li><li><p>应该用PUT还是POST ？</p></li></ol><ul><li><strong>取决于这个REST服务的行为是否是idempotent(幂等)的</strong><br>  假如发送两个请求, 希望服务器端是产生两个新数据，那就说明这个服务不是idempotent的, 因为多次使用产生了副作用了, 那就应该使用<code>POST</code>方法;<br>  但如果是希望后一个请求把第一个请求覆盖掉(这不正是修改么), 那这个服务就是idempotent的, 那就应该使用<code>PUT</code>方法;</li><li>虽然POST和PUT差别不大, 用错了也没关系, 但是你的服务一放到internet上，如果不遵从HTTP协议的规范，就可能给自己带来麻烦</li></ul><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><ol><li><p><code>POST</code>: 上面已经提过了, <strong>POST是非幂等的</strong>;</p></li><li><p>POST和PUT都可以上传文件或者创建新信息, 但主要看你的REST服务行为是否是幂等的;</p></li></ol><h2 id="PATCH-对比PUT"><a href="#PATCH-对比PUT" class="headerlink" title="PATCH(对比PUT)"></a>PATCH(对比PUT)</h2><p><strong>PATCH不是HTTP标准方法的，服务端需要考虑客户端是否能够支持的问题</strong></p><ol><li><p>对已有资源的操作</p><ul><li>用于资源的<strong>部分内容</strong>进行更新 (例如更新某一个字段, 具体比如说只更新用户信息的电话号码字段);   </li><li>而<code>PUT</code>则用于更新某个资源较完整的内容, 比如说用户要重填完整表单更新所有信息, 后台处理更新时可能只是保留内部记录ID不变;</li></ul></li><li><p>当资源不存在时: PATCH 可能会去创建一个新的资源, 这个意义上像是 saveOrUpdate 操作。</p></li><li><p>参考:</p><ul><li><a href="https://segmentfault.com/q/1010000005685904/" target="_blank" rel="external">https://segmentfault.com/q/1010000005685904/</a></li><li><a href="https://unmi.cc/restful-http-patch-method/" target="_blank" rel="external">https://unmi.cc/restful-http-patch-method/</a></li><li><a href="http://restcookbook.com/HTTP%20Methods/patch/" target="_blank" rel="external">http://restcookbook.com/HTTP%20Methods/patch/</a></li><li><a href="https://tools.ietf.org/html/rfc5789" target="_blank" rel="external">https://tools.ietf.org/html/rfc5789</a></li></ul></li></ol><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD和 <code>GET</code> 本质是一样的, 区别在于如果使用HEAD, 响应体将不会被返回，而仅仅返回HTTP头信息;<br>比如: 欲判断某个资源是否存在, 我们通常使用GET, <strong>但这里用HEAD则意义更加明确</strong>。</p><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>比较简单, 直接获取资源;</p><h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><p>这个方法使用比较少, 它用于获取当前URL所支持的方法;<br>若请求成功, 则它会在HTTP头中包含一个名为 <code>Allow</code> 的头, 值是服务器所支持的方法, 如 GET, POST;<br>之前跨域相关博文 <a href="/2016/09/18/2016-09-18-sameoriginpolicy-06/">CORS方案 not-so-simple request</a> 中的”预检”请求用的请求方法就是 <code>OPTIONS</code>;</p><h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><p>要求用隧道协议连接代理, 如使用SSL</p><h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><p>~~未完待续</p><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p><a href="https://tools.ietf.org/html/rfc2616#section-9.7" target="_blank" rel="external">参考</a></p><h2 id="PURGE"><a href="#PURGE" class="headerlink" title="PURGE"></a>PURGE</h2><p>非规范中定义的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;HTTP/1.1 中实现的method, &lt;a href=&quot;https://tools.ietf.org/html/rfc
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>01. HTTP协议预览</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-01/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-01/</id>
    <published>2017-11-30T03:25:12.000Z</published>
    <updated>2018-05-09T06:27:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p><a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">HTTP</a>(Hypertext Transfer Protocol 超文本传输协议), 是在万维网上进行通信时所使用的协议;</p></li><li><p>协议版本</p><ul><li>HTTP/0.9 有很多设计缺, 很快就被HTTP/1.0所取代了;(…只支持GET方法…)</li><li>HTTP/1.0 第一个得到广泛应用的HTTP版本;</li><li>HTTP/1.O+ 在HTTP/1.0上扩展了很多非官方的特性, 是非正式的HTTP扩展版本;(支持持久的keep-alivel连接)</li><li><strong>HTTP/1.1</strong> 是当前使用的版本</li><li>HTTP-NG(HTTP/2.0) 关注的是性能提升, 目前还未普及</li></ul></li><li><p>用于HTTP协议交互的信息被称为<code>HTTP报文</code></p><ul><li>请求端(客户端)的报文叫 <code>请求报文</code>;</li><li>响应端(服务器端)的叫 <code>响应报文</code>;</li></ul></li></ol><h2 id="请求报文结构"><a href="#请求报文结构" class="headerlink" title="请求报文结构"></a>请求报文结构</h2><h3 id="报文首部"><a href="#报文首部" class="headerlink" title="报文首部"></a>报文首部</h3><ol><li><p><strong>请求行</strong> : 包含了 <code>请求方法</code>,  <code>请求URL</code>, <code>客户端请求报文使用的HTTP协议版本</code> (如: <code>GET / HTTP/1.1</code>)</p></li><li><p>首部块</p><ul><li><p>请求首部字段</p></li><li><p>通用首部字段</p></li><li><p>实体首部字段</p></li><li><p>其他</p></li></ul></li></ol><h3 id="空行-CRLF"><a href="#空行-CRLF" class="headerlink" title="空行(CRLF)"></a>空行(CRLF)</h3><h3 id="报文主体"><a href="#报文主体" class="headerlink" title="报文主体"></a>报文主体</h3><h2 id="响应报文结构"><a href="#响应报文结构" class="headerlink" title="响应报文结构"></a>响应报文结构</h2><h3 id="报文首部-1"><a href="#报文首部-1" class="headerlink" title="报文首部"></a>报文首部</h3><ol><li><p><strong>状态行</strong> : 包含了 <code>服务端响应报文使用的HTTP协议版本</code>, <code>状态码</code>, <code>原因短语</code> (如: <code>HTTP/1.1 200 OK</code>)</p></li><li><p>首部块</p><ul><li>响应首部字段</li><li>通用首部字段</li><li>实体首部字段</li><li>其他 </li></ul></li></ol><h3 id="空行-CRLF-1"><a href="#空行-CRLF-1" class="headerlink" title="空行(CRLF)"></a>空行(CRLF)</h3><h3 id="报文主体-1"><a href="#报文主体-1" class="headerlink" title="报文主体"></a>报文主体</h3><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a><a href="/2016/11/30/http/2016-11-30-HTTP-03/">请求方法</a></h2><p>上面已经了解到, 在 “请求报文” -&gt; “报文首部” -&gt; “请求行” 中, 包含了 <code>请求方法</code>, 具体可参考 <a href="/2016/11/30/http/2016-11-30-HTTP-03/">各请求方法详解</a></p><h2 id="首部字段"><a href="#首部字段" class="headerlink" title="首部字段"></a>首部字段</h2><p>从上面还可以看到, 报文中的首部块有如下几种<code>首部字段</code></p><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><p>Cache-Control 缓存能力控制<br>Pragma 兼容Cache-control<br>Date 当前时间<br>Transfer-Encoding 传输编码<br>Accept-encoding 内容编码  (请求首部字段) (可能会导致服务器返回 <code>406 Not Acceptable</code>)<br>Content-encoding 内容编码 (实体首部字段)<br>Accept-charset  请求首部字段<br>可参考博文：<a href="/2016/11/30/http/2016-11-30-HTTP-04/">各通用首部字段详解</a></p><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><h2 id="状态码详解"><a href="#状态码详解" class="headerlink" title="状态码详解"></a>状态码详解</h2><p>可参考博文：<a href="/2016/11/30/http/2016-11-30-HTTP-03/">HTTP状态码详解</a></p><p>~~未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>70. 查询性能优化</title>
    <link href="http://blog.renyimin.com/2017/09/27/mysql/2017-09-27-mysql-70/"/>
    <id>http://blog.renyimin.com/2017/09/27/mysql/2017-09-27-mysql-70/</id>
    <published>2017-09-27T12:50:37.000Z</published>
    <updated>2018-03-08T06:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前已经了解了<code>索引优化</code>的相关内容, 它对于高性能是必不可少的, 但还不够, 还需要<code>合理设计查询</code>;</p><ul><li>如果查询写的很糟糕, 即使库表结构再合理, 索引再合适, 也无法实现高性能;</li><li>查询优化, 库表结构优化, 索引优化需要齐头并进, 一个不落;</li></ul><h2 id="慢查询基础"><a href="#慢查询基础" class="headerlink" title="慢查询基础"></a>慢查询基础</h2><h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><ul><li>确认应用程序是否在检索大量超过需要的数据, 你可能访问了太多的行, 也可能是太多的列;<br>比如: 总是返回全部的列; 只展示5条数据,你却查出100条;</li><li>确认<code>MySQL服务器层</code>是否在分析大量超过需要的数据行; (注意: 索引是在存储引擎层, 一旦服务器层分析的数据过多, 可能你的索引不太合适, 没有在存储引擎层过滤掉数据)<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>未完待续~~</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前已经了解了&lt;code&gt;索引优化&lt;/code&gt;的相关内容, 它对于高性能是必不可少的, 但还不够, 还需要&lt;code&gt;合理设计查询&lt;/co
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="查询性能优化" scheme="http://blog.renyimin.com/tags/%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>50. EXPLAIN 分析</title>
    <link href="http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-50/"/>
    <id>http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-50/</id>
    <published>2017-09-25T13:23:08.000Z</published>
    <updated>2018-03-16T06:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `user_info` (</div><div class="line">  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,</div><div class="line">  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">  `age`  INT(11) DEFAULT NULL,</div><div class="line">  PRIMARY KEY (`id`),</div><div class="line">  KEY `name_index` (`name`)</div><div class="line">) ENGINE = InnoDB, DEFAULT CHARSET = utf8;</div><div class="line"></div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);</div><div class="line"></div><div class="line">CREATE TABLE `order_info` (</div><div class="line">  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,</div><div class="line">  `user_id`      BIGINT(20)           DEFAULT NULL,</div><div class="line">  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">  `productor`    VARCHAR(30)          DEFAULT NULL,</div><div class="line">  PRIMARY KEY (`id`),</div><div class="line">  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</div><div class="line">)ENGINE = InnoDB,</div><div class="line">DEFAULT CHARSET = utf8;</div><div class="line"></div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);</div></pre></td></tr></table></figure></code></pre><h2 id="EXPLAIN-输出"><a href="#EXPLAIN-输出" class="headerlink" title="EXPLAIN 输出"></a>EXPLAIN 输出</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from user_info where id = 2;</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref   | rows | Extra |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">|  1 | SIMPLE      | user_info | const | PRIMARY       | PRIMARY | 8       | const |    1 | NULL  |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></code></pre><h2 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h2><ol><li><p>select_type 表示了查询的类型, 它的常用取值有:</p><ul><li><code>SIMPLE</code>, 表示此查询不包含 UNION 查询或子查询 (最常见的查询类别就是 <code>SIMPLE</code> 了)</li><li><code>PRIMARY</code>, 表示此查询是最外层的查询</li><li><code>UNION</code>, 表示此查询是 UNION 的第二或随后的查询</li><li><code>DEPENDENT UNION</code>, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li><code>UNION RESULT</code>, UNION 的结果</li><li><code>SUBQUERY</code>, 子查询中的第一个 SELECT</li><li><code>DEPENDENT SUBQUERY</code>: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li></ul></li><li><p>如果使用了<code>UNION</code>查询, 那么EXPLAIN 输出结果类似如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN ( SELECT * FROM user_info WHERE id IN ( 1, 2, 3 ) ) UNION</div><div class="line">( SELECT * FROM user_info WHERE id IN ( 3, 4, 5 ) );</div><div class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</div><div class="line">| id   | select_type  | table      | type  | possible_keys | key     | key_len | ref  | rows | Extra           |</div><div class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</div><div class="line">|    1 | PRIMARY      | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where     |</div><div class="line">|    2 | UNION        | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where     |</div><div class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | ALL   | NULL          | NULL    | NULL    | NULL | NULL | Using temporary |</div><div class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li></ol><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><ol><li>type 字段比较重要, 它<strong>提供了判断查询是否高效的重要依据依据</strong>; 通过 type 字段, 我们判断此次查询是 <strong>全表扫描</strong> 还是 <strong>索引扫描</strong> 等;</li><li><p>type 常用的取值有:</p><ul><li><p><code>system</code>: 表中只有一条数据, 这个类型是特殊的 <code>const</code> 类型; ??</p></li><li><p><code>const</code>: 针对<strong>主键</strong>或<strong>唯一索引</strong>的<strong>等值查询扫描</strong>, 最多只返回一行数据(const 查询速度非常快, 因为它仅仅读取一次即可)</p></li><li><p><code>eq_ref</code>: 此类型通常出现在多表的join查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果, 并且查询的比较操作通常是 =, <strong>查询效率较高</strong>, 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id;</div><div class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</div><div class="line">| id | select_type | table      | type   | possible_keys             | key                       | key_len | ref                     | rows | Extra                    |</div><div class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | order_info | index  | user_product_detail_index | user_product_detail_index | 254     | NULL                    |    9 | Using where; Using index |</div><div class="line">|  1 | SIMPLE      | user_info  | eq_ref | PRIMARY                   | PRIMARY                   | 8       | test.order_info.user_id |    1 | NULL                     |</div><div class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询, 例如下面这个例子中, 就使用到了 ref 类型的查询:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5;</div><div class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</div><div class="line">| id | select_type | table      | type  | possible_keys             | key                       | key_len | ref   | rows | Extra       |</div><div class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info  | const | PRIMARY                   | PRIMARY                   | 8       | const |    1 | NULL        |</div><div class="line">|  1 | SIMPLE      | order_info | ref   | user_product_detail_index | user_product_detail_index | 9       | const |    1 | Using index |</div><div class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>range: 表示使用<code>索引范围查询</code>, 通过索引字段范围获取表中部分数据记录; 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL (没用到索引), 并且 key_len 字段是此次查询中使用到的索引的最长的那个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT * FROM user_info WHERE id BETWEEN 2 AND 8;</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | range | PRIMARY       | PRIMARY | 8       | NULL |    7 | Using where |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>下面对比, 都使用了范围查询, 但是一个可以使用<strong>索引范围查询</strong>, 另一个不能使用索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name&gt;&apos;nihao&apos;;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra                    |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | user_info | range | name_index    | name_index | 152     | NULL |    1 | Using where; Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age&gt;10;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>另外, 可参考 P185: in语句虽然有时候 type结果也是range (不过, 对于真正的范围查询, 确实是无法使用范围列后面的其他索引了, 但是对于”多个等值条件查询”则没有这个限制)</p></li><li><p>index: 表示<strong>全索引扫描(full index scan)</strong>, 和 ALL 类型类似, 只不过ALL类型是全表扫描, <strong>而 index 类型则仅仅扫描所有的索引, 而不扫描数据</strong><br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据, 即 做的是<strong>覆盖索引</strong>, 当是这种情况时, Extra 字段会显示 <code>Using index</code></p><p>下面的例子中, 查询的 <code>name</code> 字段恰好是一个索引(<strong>做到了覆盖索引</strong>), 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据;<br>因此这样的情况下, type 的值是 <code>index</code>, 并且 Extra 的值是 Using index;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM user_info;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | index | NULL          | name_index | 152     | NULL |   10 | Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>下面不但使用了<code>全索引扫描</code>, 而且使用了<code>where条件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name=&apos;nihao&apos;;</div><div class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                    |</div><div class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using where; Using index |</div><div class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>但是, 如果不使用索引的话, 下面type就是<code>ALL</code>, 表示使用了<code>全表扫描</code>, 并且使用了where条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age=10;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age&gt;10;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name&gt;&apos;nihao&apos;;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra                    |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | user_info | range | name_index    | name_index | 152     | NULL |    1 | Using where; Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一, 通常来说, 我们的查询<strong>不应该出现 ALL 类型的查询</strong>, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难<br>如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</p></li><li></li></ul></li></ol><h2 id="type小结"><a href="#type小结" class="headerlink" title="type小结"></a>type小结</h2><p><strong>type 类型的性能比较</strong> : 通常来说, 不同的 type 类型的性能关系如: <code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code></p><ol><li>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的;</li><li>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快;</li><li>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了;</li></ol><h2 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h2><p>possible_keys 表示 MySQL 在查询时, 能够使用到的索引;<br>注意: 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到;(MySQL 在查询时具体使用了哪些索引, 由 key 字段决定)</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>此字段是 MySQL 在当前查询时所真正使用到的索引</p><h2 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h2><p>rows 也是一个重要的字段, MySQL 查询优化器根据统计信息, <strong>估算SQL要查找到结果集需要到表中扫描读取的数据行数</strong>(上面的例子可以看到, 基本上使用到了索引的话, 真正扫描的行数都很少); 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好</p><h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><p>Explain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ol><li><p><strong>Using filesort</strong>: 当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. </p><ul><li><p>一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</p></li><li><p>比如下面, <code>使用索引扫描做排序</code> 和 <code>不使用索引扫描做排序</code> 的效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM user_info ORDER BY name;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | index | NULL          | name_index | 152     | NULL |   10 | Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; EXPLAIN SELECT name FROM user_info ORDER BY age;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra          |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using filesort |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li></ul></li><li><p><code>Using index</code> 与 <code>Using index condition</code></p><ul><li>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li><li><p>比如下面, 第一个做到了<code>覆盖索引</code>扫描, 后面两个都没做到</p><pre><code>mysql&gt; EXPLAIN SELECT name FROM user_info where name=&apos;haha&apos;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                    |+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using where; Using index |+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+1 row in set (0.00 sec)mysql&gt; EXPLAIN SELECT name,age FROM user_info where name=&apos;haha&apos;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                 |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using index condition |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+1 row in set (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM user_info where name=&apos;haha&apos;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                 |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using index condition |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+1 row in set (0.00 sec)</code></pre></li></ul></li><li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备环境&quot;&gt;&lt;a href=&quot;#准备环境&quot; class=&quot;headerlink&quot; title=&quot;准备环境&quot;&gt;&lt;/a&gt;准备环境&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>49. 索引和锁</title>
    <link href="http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-49/"/>
    <id>http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-49/</id>
    <published>2017-09-25T13:10:40.000Z</published>
    <updated>2018-03-08T02:57:03.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>索引可以让查询锁定更少的行</strong> <blockquote><p>因为InnoDB只有在访问行的时候才会对其加锁, 而索引能够减少InnoDB访问的行数, 从而减少锁的数量;<br>但这只有当InnoDB在存储引擎层就能过滤掉所有不需要的行时才行, 如果索引(处在存储引擎层)无法过滤掉无效的行, 那么在InnoDB检索到数据并发送给服务器层以后, 服务器层才能应用where子句, 这时已经无法避免锁定行了;<br>虽然InnoDB的行锁效率很高, 内存使用也很少, 但是锁定行的时候仍然会带来额外开销;<br>锁定超过需要的行会增加锁争用并减少并发性;</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;strong&gt;索引可以让查询锁定更少的行&lt;/strong&gt; &lt;blockquote&gt;
&lt;p&gt;因为InnoDB只有在访问行的时候才会对其加锁, 而索引能够减少InnoDB访问的行数, 从而减少锁的数量;&lt;br&gt;但这只有当InnoDB在存储引擎层就能过滤掉所有不需
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>48. 冗余和重复索引</title>
    <link href="http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-48/"/>
    <id>http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-48/</id>
    <published>2017-09-25T10:27:40.000Z</published>
    <updated>2018-03-08T02:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><code>重复索引</code> 是指在相同的列上按照相同的顺序创建的相同类型的索引; 应该避免这样的重复索引, 发现后也应该立即删除;</p></li><li><p>MySQL允许在相同的列上创建多个索引, 但是MySQL需要单独维护重复的索引, 并且优化器在优化查询的时候也需要逐个地进行考虑, 这会影响性能;</p></li><li><p><code>冗余索引</code> 和 <code>重复索引</code> 不同, 如果创建了索引(A,B), 在创建索引(A)就是冗余索引, 因为这只是(A,B)索引的前缀索引; <strong>大多数情况下都不需要冗余索引</strong>;</p><ul><li>因此索引(A,B)也可以当做索引(A)来使用</li><li>但是如果再创建索引(B,A), (B) 则都不是冗余索引</li><li>有时候为了让两个查询都变快, 也会需要冗余索引 (P179)</li></ul></li><li>应该尽量扩展已有的索引而不是创建新的索引</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;重复索引&lt;/code&gt; 是指在相同的列上按照相同的顺序创建的相同类型的索引; 应该避免这样的重复索引, 发现后也应该立即删除;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MySQL允许在相同的列上创建多个索引, 但是MySQL需要单独维护重复的索引, 
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>47. 使用索引扫描来做排序</title>
    <link href="http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-47/"/>
    <id>http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-47/</id>
    <published>2017-09-25T10:25:11.000Z</published>
    <updated>2018-03-08T05:38:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>只有<strong>当索引的列顺序 和 ORDER BY 子句的顺序完全一致</strong>, 并且<strong>所有列的排序方向都一样时(要么都是正序, 要么都是倒序)</strong>, MySQL才能够使用索引来对结果做排序;</p></li><li><p>如果查询需要关联多张表, 则只有当 <strong>ORDER BY 子句引用的字段全部为第一个表时</strong>, 才能使用索引做排序;</p></li><li><p>ORDER BY 子句 和 查找型查询的限制是一样的, 需要满足索引的最左前缀的要求, 否则, MySQL都需要亲自去执行排序操作, 而<strong>无法利用索引排序</strong>;</p></li><li><p>有一种情况下, ORDER BY 子句可以不用满足最左前缀的要求, 那就是前导列为常量的时候;<br> 比如一张表的索引是 <code>key(a,b,c)</code> , 而 查询语句是 <code>... where a=100 order by b,c</code>, 即使 order by 不满足最左前缀的要求, 也可以<strong>使用索引做排序</strong>;</p></li><li><p>P177 列出了很多不可以使用索引做排序的查询;</p></li></ol><h2 id="当查询同时有-ORDER-BY-和-LIMIT-子句的时候"><a href="#当查询同时有-ORDER-BY-和-LIMIT-子句的时候" class="headerlink" title="当查询同时有 ORDER BY 和 LIMIT 子句的时候"></a>当查询同时有 ORDER BY 和 LIMIT 子句的时候</h2><ol><li><p>像<code>select &lt;col...&gt; from profiles where sex=&#39;m&#39; order by rating limit 10;</code>这种查询语句, 同时使用了<code>order by</code>和<code>limit</code>, 如果没有索引就会很慢;<br> 即使有索引, 如果用户界面有翻页, 翻页比较靠后时, 也会非常慢, 因为随着偏移量的增加, MySQL需要花费大量的时间来扫描需要丢弃的数据;</p></li><li><p>但是sex的选择性又很低, 如何优化呢?</p></li></ol><ul><li>对于选择性非常低的列, 如果要做排序的话, 可以增加一些特殊的索引来做排序, 例如, 可以创建 (sex, rating)索引</li><li>然后采用 <code>延迟关联</code> , 通过覆盖索引先查询返回需要的主键, 在根据这些主键关联原表获得需要的行;<br><code>select &lt;col...&gt; from profiles INNER JOIN (select &lt;primart key&gt; from profiles where x.sex=&#39;m&#39; order by rating limit 100000, 10) as x using(primary key)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;只有&lt;strong&gt;当索引的列顺序 和 ORDER BY 子句的顺序完全一致&lt;/strong&gt;, 并且&lt;strong&gt;所有
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>46. 覆盖索引</title>
    <link href="http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-46/"/>
    <id>http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-46/</id>
    <published>2017-09-25T09:30:26.000Z</published>
    <updated>2018-03-08T02:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol><li><p>通常, 大家都会根据查询的WHERE条件来创建合适的索引, 不过这只是索引优化的一个方面, <strong>设计优秀的索引应该考虑到整个查询, 而不单单是where条件部分</strong>。</p></li><li><p><strong>覆盖索引</strong></p><ul><li>索引确实是一种查找数据的高效方式, 但是MySQL也可以使用索引就能直接获取列的数据, 这样就不需要再去读取数据行;</li><li>如果叶子节点中已经包含了要查询的数据, 那么就没有必要再回表查询了;</li><li>即, 如果一个索引包含(或者说覆盖)所有需要查询的字段值, 我们就称之为 <code>覆盖索引</code>;</li></ul></li><li><p>覆盖索引是非常有用的工具, 能够极大地提高性能; </p><ul><li>拿InnoDB来说, 覆盖索引就非常有用, 如果你的查询能够做到覆盖你的二级索引列, 那么只需要遍历一次B-Tree(可以直接在二级索引中找到数据), <strong>可以避免对聚簇索引的二次查询</strong>; </li><li>其他更多参考 P171</li></ul></li><li><p><strong>注意:</strong> 覆盖索引<strong>必须要保存索引列的值</strong>, 而 哈希索引, 空间索引 和 全文索引 等都不存储索引列的值; 所以MySQL只能使用B-Tree索引做覆盖索引;</p></li><li><p>如果索引不能覆盖查询所需的全部列, 那就不得不每扫描一次索引记录, 就回表查询一次对应的行, </p></li></ol><h2 id="优化小案例"><a href="#优化小案例" class="headerlink" title="优化小案例"></a>优化小案例</h2><ol><li><p><code>select * ....</code> : 因为查询从表中选择了所有的列, 而一般你不会创建覆盖了所有列的二级索引, 所以这种局域肯定不会用到覆盖索引;</p></li><li><p><code>.... where title LIKE &#39;%ren&#39;</code>: Mysql只能在where条件中做索引的 <code>最左前缀匹配的LIKE比较</code>, 而这里的where条件是以通配符开头的LIKE查询;</p></li><li><p>查看 (P171) 的优化案例 (做表的自关联, 子句使用覆盖索引, 外部不用)<br> 这样虽然无法使用索引覆盖整个查询, 但总算比完全无法利用覆盖索引要好</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通常, 大家都会根据查询的WHERE条件来创建合适的索引, 不过这只是索引优化的一个方面, &lt;strong&gt;设计优秀的索引
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>45. 聚簇索引</title>
    <link href="http://blog.renyimin.com/2017/09/24/mysql/2017-09-24-mysql-45/"/>
    <id>http://blog.renyimin.com/2017/09/24/mysql/2017-09-24-mysql-45/</id>
    <published>2017-09-24T12:10:31.000Z</published>
    <updated>2018-03-07T13:32:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>聚簇索引并不是一种单独的索引类型, 而是一种 <strong>数据存储方式</strong>; </p></li><li><p>因为是存储引擎负责实现索引, 所以不是所有的存储引擎都支持聚簇索引, 这里主要讨论的是 <code>InnoDB引擎的聚簇索引</code>;</p></li><li><p>InnoDB的 <code>聚簇索引</code> 实际上在同一个结构中保存了 <code>B-Tree索引</code> 和 <code>数据行</code></p><ul><li>当表有聚簇索引时, 它的数据行实际上存放在索引的叶子页中(叶子页包含了数据行的 <code>全部列数据</code>)</li><li>因为无法同时把数据行存放在两个不同的地方, 所以一个表只能有一个聚簇索引</li><li>不过<code>覆盖索引</code>, 可以模拟多个聚簇索引的情况</li></ul></li><li><p><strong>InnoDB默认会创建聚簇索引</strong>: InnoDB通过主键来作为聚簇索引, 如果没有定义主键, 则会选择一个唯一的非空索引代替, 如果连非空索引都没有, <strong>InnoDB会隐式定义一个主键来作为聚簇索引</strong>;</p><ul><li>将主键组织到一棵B+树中, 而行数据就储存在叶子节点上，若使用<code>where id = 14</code>这样的条件查找数据;<br><img src="/img/mysql/index/jucusuoyin.png" width="500"></li><li>则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据;</li></ul></li><li><p>InnoDB只聚集 在同一个磁盘页面中的记录, 因此, 如果数据在物理上是相邻的, 那么在索引上就也是相邻的;</p><ul><li>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的;</li><li>但是包含相邻键值的页面可能物理上会相距甚远;</li></ul></li></ol><h2 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h2><ol><li>访问速度更快: 聚簇索引将索引和数据保存在同一个B-Tree中, 因此从聚簇索引中获取数据通常比在非聚簇索引中查询要快;</li><li>使用覆盖索引的查询, 可以直接使用页节点中的<strong>主键值</strong>;</li></ol><h2 id="聚簇索引缺点"><a href="#聚簇索引缺点" class="headerlink" title="聚簇索引缺点"></a>聚簇索引缺点</h2><ol><li>聚簇索引最大限度地提高了I/O密集型应用的性能, 但如果数据全部都放在内存中, 则访问顺序就没那么重要了, 聚簇索引也就没什么优势了;</li><li>插入速度严重依赖于插入顺序, 按照主键的顺序插入是速度最快的方式, 但如果不是按照主键顺序, 在完成操作后最好执行 <code>OPTIMIZE TABLE</code> 命令重新组织一下表;</li><li>更新聚簇索引的代价很高, 因为会强制InnoDB将每个被更新的行移动到新的位置;<br> 基于聚簇索引的表在插入新行, 或者主键被更新导致需要移动行的时候, 可能面临 “页分裂” 问题;<br> 当前主键值要求必须将这一行插入到某个已满的页中时, 存储引擎会将该页分裂成两个页面来容纳该行, 这就是一次页分裂操作。<br> 页分裂操作会导致表占用更多的磁盘空间</li><li>聚簇索引会导致全表扫描变慢, 尤其是行比较稀疏, 或者由于页分裂导致数据存储不连续的时候;</li><li>二级索引(非聚簇索引)可能比想象的要更大, 因为在二级索引的叶子节点包含了引用行的主键列;</li><li><strong>二级索引访问需要两次索引查找, 而不是一次</strong><ul><li>二级索引叶子几点保存的 “行指针” 是行的主键; 这意味着通过二级索引查找行, 存储引擎需要找到二级索引叶子节点获得对应的主键值;</li><li>然后根据这个主键值去聚簇索引中查找对应的行数据;</li><li>这里做了重复工作, 两次 B-Tree 查找, 而不是一次。</li></ul></li></ol><h2 id="InnoDB-和-MyISAM-索引对比"><a href="#InnoDB-和-MyISAM-索引对比" class="headerlink" title="InnoDB 和 MyISAM 索引对比"></a>InnoDB 和 MyISAM 索引对比</h2><ol><li>InnoDB支持聚簇索引, 而MyISAM不支持;</li><li>MyISAM中主键索引和其他索引在索引结构上没有区别; 而InnoDB中 <code>(主键)聚簇索引</code> 和 <code>二级索引(普通索引)</code> 是有区别的;(P167)</li></ol><h2 id="上图总结"><a href="#上图总结" class="headerlink" title="上图总结"></a>上图总结</h2><p><img src="/img/mysql/index/index_duibi.png" width="600"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;聚簇索引并不是一种单独的索引类型, 而是一种 &lt;strong&gt;数据存储方式&lt;/strong&gt;; &lt;/p&gt;
&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
</feed>
