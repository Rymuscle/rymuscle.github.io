<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2018-02-28T03:46:56.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>08. Dockerfile 定制镜像</title>
    <link href="http://blog.renyimin.com/2018/05/02/2018-05-02-08-docker/"/>
    <id>http://blog.renyimin.com/2018/05/02/2018-05-02-08-docker/</id>
    <published>2018-05-02T13:32:08.000Z</published>
    <updated>2018-02-28T03:46:56.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Dockerfile 是一个文本文件, 其内包含了一条条的指令(Instruction), 每一条指令构建一层, 因此每一条指令的内容, 就是描述该层应当如何构建。</p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Dockerfile 是一个文本文件, 其内包含了一条条的指令(Instruction), 每一条指令构建一层, 因此每一条指令的内容, 就是描述该层应当如何构建。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/categories/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/tags/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>06. 高级网络配置</title>
    <link href="http://blog.renyimin.com/2018/04/29/2018-04-29-07-docker/"/>
    <id>http://blog.renyimin.com/2018/04/29/2018-04-29-07-docker/</id>
    <published>2018-04-29T05:20:31.000Z</published>
    <updated>2018-02-28T03:45:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考: <a href="https://yeasy.gitbooks.io/docker_practice/content/advanced_network/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/advanced_network/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考: &lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/content/advanced_network/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://yeasy.gitbooks.i
      
    
    </summary>
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/categories/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/tags/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>06. Docker中的网络功能</title>
    <link href="http://blog.renyimin.com/2018/04/28/2018-04-28-06-docker/"/>
    <id>http://blog.renyimin.com/2018/04/28/2018-04-28-06-docker/</id>
    <published>2018-04-28T10:15:23.000Z</published>
    <updated>2018-02-28T03:42:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><ol><li><p>容器中可以运行一些网络应用, 要让外部也可以访问这些应用, 可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 8090:80 --name testVip --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div></pre></td></tr></table></figure></li><li><p>使用 <code>docker ps</code> 可以看到本地主机的 8090 被映射到了容器的 80 端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                       NAMES</div><div class="line">27863a3a8f70        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   39 minutes ago      Up 39 minutes       3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   testVip</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure><p>此时访问本机的 8090 端口即可访问容器内 web 应用提供的界面。</p></li></ol><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><ol><li><p>使用 <code>docker port 容器名</code>  来查看当前映射的端口配置, 也可以查看到绑定的地址</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                       NAMES</div><div class="line">27863a3a8f70        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   45 minutes ago      Up 45 minutes       3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   testVip</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker port testVip</div><div class="line">80/tcp -&gt; 0.0.0.0:8090</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></li><li><p>注意:</p><ul><li><code>-p</code> 可以多次使用来绑定多个端口</li><li>容器有自己的内部网络和 ip 地址(使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置)</li></ul></li></ol><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>容器的连接(linking)系统是除了端口映射外, 另一种跟容器中应用交互的方式。该系统会在源和接收容器之间创建一个隧道, 接收容器可以看到源容器指定的信息。<br>相对于端口映射, 这种方式主要用来做内部链接, 不暴露链接接口给外部</p><h3 id="自定义容器命名"><a href="#自定义容器命名" class="headerlink" title="自定义容器命名"></a><strong>自定义容器命名</strong></h3><ol><li>连接系统依据<strong>容器的名称</strong>来执行。因此，首先需要自定义一个好记的容器命名。虽然当创建容器的时候, 系统默认会分配一个名字。</li><li>自定义命名容器有2个好处:<ul><li>自定义的命名，比较好记，比如一个web应用容器我们可以给它起名叫web</li><li>当要连接其他容器时候，可以作为一个有用的参考点，比如连接web容器到db容器</li></ul></li><li>使用 <code>--name</code> 标记可以为容器自定义命名(使用 docker ps 来验证设定的命名)<ul><li>注意:<strong>容器的名称是唯一的</strong>。如果已经命名了一个叫 web 的容器，当你要再次使用 web 这个 名称的时候，需要先用 docker rm 来删除之前创建的同名容器。<h3 id="–rm"><a href="#–rm" class="headerlink" title="–rm"></a>–rm</h3>在执行 <code>docker run</code> 的时候如果添加 <code>--rm</code> 标记，则容器在终止后会立刻删除。注意, <code>--rm</code> 和 <code>-d</code> 参数不能同时使用。</li></ul></li></ol><h2 id="容器互联-1"><a href="#容器互联-1" class="headerlink" title="容器互联"></a>容器互联</h2><p>使用 <code>--link name:alias</code> 参数可以让容器之间安全的进行交互, 其中 <code>name</code> 是要链接的容器的名称, <code>alias</code> 是这个连接的别名;</p><ol><li><p>下面先创建一个新的数据库容器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 3307:3306 --name db --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div><div class="line">fd29cafa699da868a57f559630c6fb7f5dcf30705f884c9fa7feb4a373bba37c</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></li><li><p>然后创建一个新的 web 容器，并将它连接到 db 容器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 8090:80 --name web --link db:db --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div><div class="line">0e20f11d0f57fedb9d5fee96c8d9d56b67a7c62ded101fd92abf12bba04d09e4</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></li><li><p>使用 <code>docker ps</code> 来查看容器的连接</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                                       NAMES</div><div class="line">0e20f11d0f57        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   About a minute ago   Up About a minute   3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   web</div><div class="line">fd29cafa699d        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   About a minute ago   Up About a minute   80/tcp, 15672/tcp, 0.0.0.0:3307-&gt;3306/tcp   db</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure><p> (理论上可以看到自定义命名的容器 db 和 web, db 容器的 names 列有 db 也有 web/db。这表示 web 容器链接到 db 容器，web 容器将被允许访问 db 容器的信息。)<br> 但实际上貌似没有在names列看到有web/db</p></li><li><p>Docker 在两个互联的容器之间创建了一个安全隧道，而且不用映射它们的端口到宿主主机 上。在启动 db 容器的时候可以不用使用 -p 和 -P 标记，从而避免了暴露数据库端口到外部网络上。</p></li><li><p>Docker 通过 2 种方式为容器公开连接信息:</p><ul><li>环境变量</li><li>更新 /etc/hosts 文件</li></ul></li><li><p>使用 <code>env</code> 命令来查看 web 容器的环境变量</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run --rm --name web2 --link db:db vipservice env</div></pre></td></tr></table></figure><p> 更多参考书上…</p></li><li><p>除了环境变量, Docker 还添加 host 信息到父容器的 <code>/etc/hosts</code> 的文件。下面是父容器 web 的 <code>hosts</code> 文件</p><ul><li><p>这里有 2 个 hosts，第一个是 web 容器，web 容器用 id 作为他的主机名，第二个是 db 容器 的 ip 和主机名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                       NAMES</div><div class="line">297c83c40bc4        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   9 minutes ago       Up 8 minutes        3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   web</div><div class="line">46985aa1ab7b        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   9 minutes ago       Up 9 minutes        80/tcp, 15672/tcp, 0.0.0.0:3307-&gt;3306/tcp   db</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker exec -it web /bin/sh</div><div class="line">sh-4.2# cat /etc/hosts</div><div class="line">127.0.0.1localhost</div><div class="line">::1localhost ip6-localhost ip6-loopback</div><div class="line">fe00::0ip6-localnet</div><div class="line">ff00::0ip6-mcastprefix</div><div class="line">ff02::1ip6-allnodes</div><div class="line">ff02::2ip6-allrouters</div><div class="line">172.17.0.2db 46985aa1ab7b</div><div class="line">172.17.0.3297c83c40bc4</div><div class="line">sh-4.2#</div></pre></td></tr></table></figure></li><li><p>可以在 web 容器中安装 ping 命令来测试跟db容器的连通, 用 ping 来测试db容器，它会解析成 172.17.0.2 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sh-4.2# ping db</div><div class="line">PING db (172.17.0.2) 56(84) bytes of data.</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=1 ttl=64 time=0.243 ms</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=2 ttl=64 time=0.330 ms</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=3 ttl=64 time=0.136 ms</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=4 ttl=64 time=0.129 ms</div></pre></td></tr></table></figure></li><li><p>用户可以链接多个父容器到子容器，比如可以链接多个 web 到 db 容器上。</p></li></ul></li></ol><p>参考: <a href="https://yeasy.gitbooks.io/docker_practice/content/network/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/network/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;外部访问容器&quot;&gt;&lt;a href=&quot;#外部访问容器&quot; class=&quot;headerlink&quot; title=&quot;外部访问容器&quot;&gt;&lt;/a&gt;外部访问容器&lt;/h2&gt;&lt;h3 id=&quot;端口映射&quot;&gt;&lt;a href=&quot;#端口映射&quot; class=&quot;headerlink&quot; title=&quot;端
      
    
    </summary>
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/categories/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/tags/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>05. Docker数据管理</title>
    <link href="http://blog.renyimin.com/2018/04/26/2018-04-26-05-docker/"/>
    <id>http://blog.renyimin.com/2018/04/26/2018-04-26-05-docker/</id>
    <published>2018-04-26T10:15:23.000Z</published>
    <updated>2018-02-28T02:33:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>容器中管理数据主要有两种方式：<code>数据卷(Volumes)</code> 和 <code>挂载主机目录(Bind mounts)</code></p><h2 id="数据卷-Volumes"><a href="#数据卷-Volumes" class="headerlink" title="数据卷(Volumes)"></a>数据卷(Volumes)</h2><ol><li>数据卷 是一个可供<strong>一个或多个</strong>容器使用的特殊目录, 它绕过UFS, 可以提供很多有用的特性:<ul><li>数据卷 可以在容器之间共享和重用</li><li>对 数据卷 的修改会立马生效</li><li>对 数据卷 的更新，不会影响镜像</li><li>数据卷 默认会一直存在，即使容器被删除</li></ul></li><li>注意: 数据卷 的使用, 类似于 Linux 下对目录或文件进行 <code>mount</code>，镜像中的被指定为挂载点的目录中的文件会隐藏掉, 能显示看的是挂载的数据卷。</li></ol><h2 id="数据卷操作"><a href="#数据卷操作" class="headerlink" title="数据卷操作"></a>数据卷操作</h2><p>(在主机里使用)</p><ol><li>创建一个数据卷: <code>docker volume create my-vol</code> (其实还有一种方式就是在docker run的时候直接指定一个数据卷名, 就会自动帮你创建数据卷)</li><li>查看所有数据卷: <code>docker volume ls</code></li><li>查看指定数据卷的信息: <code>docker volume inspect my-vol</code><br> 查看容器的数据卷挂载信息: <code>docker inspect 容器名</code></li><li><p>删除数据卷 <code>$ docker volume rm my-vol</code></p><ul><li>数据卷 是被设计用来<strong>持久化</strong>数据的, 它的生命周期独立于容器, Docker不会在容器被删除后自动删除数据卷, 并且<strong>也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷</strong>。</li><li>如果需要在删除容器的同时移除数据卷, 可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令, <strong>这个命令貌似只是移除该容器和数据卷之间的关系</strong>, 除非这个数据卷没有任何容器引用了, 才可以使用下面介绍的命令来删除掉。</li></ul></li><li><p><strong>无主的数据卷</strong>可能会占据很多空间，要清理请使用命令 <code>$ docker volume prune</code></p><ul><li>可以看到清除时会提醒你 <code>WARNING! This will remove all volumes not used by at least one container</code></li><li>清除的是没有被<strong>至少一个</strong>容器使用的数据卷!</li></ul></li></ol><h2 id="创建并启动容器时-挂载数据卷"><a href="#创建并启动容器时-挂载数据卷" class="headerlink" title="创建并启动容器时,挂载数据卷"></a>创建并启动容器时,挂载数据卷</h2><ol><li>在使用 <code>docker run</code> 命令的时候, 还可以使用 <code>--mount</code> 参数来将<code>数据卷</code>挂载到容器里, 另外, 在一次 <code>docker run</code> 中可以挂载多个数据卷。</li><li><p>下面创建一个名为 <code>my-first-vol</code> 的数据卷</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">localhost:~ renyimin$ docker volume create my-first-vol</div><div class="line">my-first-vol</div><div class="line">localhost:~ renyimin$ </div><div class="line">localhost:~ renyimin$ docker volume inspect my-first-vol</div><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;CreatedAt&quot;: &quot;2017-04-26T13:43:16Z&quot;,</div><div class="line">        &quot;Driver&quot;: &quot;local&quot;,</div><div class="line">        &quot;Labels&quot;: &#123;&#125;,</div><div class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-first-vol/_data&quot;,</div><div class="line">        &quot;Name&quot;: &quot;my-first-vol&quot;,</div><div class="line">        &quot;Options&quot;: &#123;&#125;,</div><div class="line">        &quot;Scope&quot;: &quot;local&quot;</div><div class="line">    &#125;</div><div class="line">]</div><div class="line">localhost:~ renyimin$</div></pre></td></tr></table></figure></li><li><p>创建并运行一个名为 <code>web</code> 的容器, 同时加载上面的<code>数据卷</code>到容器内的 <code>/test-vol</code> 目录</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">localhost:~ renyimin$ docker run -d -p 5000:5000 --name myFirstRegistry --mount source=my-first1-vol,target=/test-vol registry</div><div class="line">45e2da7a8ee3c51ae682ff78d02c9779531a79fe2f7a58739023cd19ab48b09d</div><div class="line">localhost:~ renyimin$ docker exec -it myFirstRegistry /bin/sh</div><div class="line">/ # ls</div><div class="line">bin            entrypoint.sh  home           linuxrc        mnt            root           sbin           sys            tmp            var</div><div class="line">dev            etc            lib            media          proc           run            srv            test-vol       usr</div><div class="line">/ #</div></pre></td></tr></table></figure><ul><li>容器中会自动创建虚拟机中的挂载目录;</li><li>另外, 之前我们创建的数据卷是 <code>my-first-vol</code>, 此次运行容器时, 加载的数据卷<strong>却是</strong> <code>my-first1-vol</code>,<br>后面通过查看容器在<code>&quot;Mounts&quot;</code>key下面的数据卷信息, 会发现在启动容器时如果指定的数据卷不存在, 则会自动创建;<br>通过<code>docker volume ls</code>也可以看到现在有<code>my-first-vol</code> 和 <code>my-first1-vol</code> 这两个我们创建的数据卷;</li></ul></li><li><p>可以在主机里使用以下命令查看 <code>myFirstRegistry</code> 容器的信息, 数据卷信息在 <code>&quot;Mounts&quot;</code> Key 下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ docker inspect myFirstRegistry</div><div class="line">&quot;Mounts&quot;: [</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;volume&quot;,</div><div class="line">        &quot;Name&quot;: &quot;my-first1-vol&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-first1-vol/_data&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/test-vol&quot;,</div><div class="line">        &quot;Driver&quot;: &quot;local&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;z&quot;,</div><div class="line">        &quot;RW&quot;: true,</div><div class="line">        &quot;Propagation&quot;: &quot;&quot;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;volume&quot;,</div><div class="line">        &quot;Name&quot;: &quot;4fde6460059e4f0f07bc1c91ed852da7884b872dffc66bc4e237a260c7248250&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/4fde6460059e4f0f07bc1c91ed852da7884b872dffc66bc4e237a260c7248250/_data&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/var/lib/registry&quot;,</div><div class="line">        &quot;Driver&quot;: &quot;local&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;&quot;,</div><div class="line">        &quot;RW&quot;: true,</div><div class="line">        &quot;Propagation&quot;: &quot;&quot;</div><div class="line">    &#125;</div><div class="line">],</div></pre></td></tr></table></figure></li></ol><h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><ol><li><p>挂载一个主机目录作为数据卷: 使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 8090:80 --name testVip --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha vipservice</div><div class="line">2dea428aa379aaf415e5eff38b76f43d64e77b6b34d25bb5e353354ba897cee6</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker exec -it 2dea428aa379aaf415e5eff38b76f43d64e77b6b34d25bb5e353354ba897cee6 /bin/sh</div><div class="line">sh-4.2# cd /</div><div class="line">sh-4.2# ls</div><div class="line">anaconda-post.log  bindata  dev  etchaha  home  lib  lib64lost+found  media  mntopt  proc  root  run  run.sh  sbin  srv  sys  tmp  usrvar</div><div class="line">sh-4.2# cd haha</div><div class="line">sh-4.2# ls</div><div class="line">myfirstregistry  registry.tar</div><div class="line">sh-4.2#</div></pre></td></tr></table></figure></li><li><p>上面的命令会加载主机的 <code>/Users/renyimin/Desktop/testVip</code> 目录到容器的 <code>/haha</code> 目录, 这个功能在进行测试的时候十分方便, 比如, 你可以放置一些程序到本地目录中,来查看容器是否正常工作。<strong>本地目录的路径必须是绝对路径</strong>, 以前使用 <code>-v</code> 参数时, 如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在, Docker 会报错。</p></li><li><p>查看容器的挂载信息, 发现和数据卷相比, <code>Type</code>信息是<code>bind</code>而不是<code>volume</code>, 并且没有数据卷的<code>name</code>信息, <code>docker volume ls</code> 也不会看到有新的数据卷被创建, 所以…可以认为只是一次简单的目录绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker inspect testVip</div><div class="line">&quot;Mounts&quot;: [</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;bind&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/Users/renyimin/Desktop/testVip&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/haha&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;&quot;,</div><div class="line">        &quot;RW&quot;: true,</div><div class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure></li><li><p>选择 <code>-v</code> 还是 <code>--mount</code> 参数?<br> Docker 新用户应该选择 <code>--mount</code> 参数，经验丰富的 Docker 使用者对 <code>-v</code> 或者 <code>--volume</code> 已经很熟悉了，但是推荐使用 <code>--mount</code> 参数, 可以理解为, <strong><code>--mount</code> 参数应该可以挂载数据卷, 也可以代替-v来进行目录关联</strong>。</p></li><li><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <strong>只读</strong></p><ul><li><p>加了 readonly 之后，就挂载为 只读 了。如果你在容器内 /haha 目录新建文件，会显示如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 8090:80 --name testVip --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div><div class="line">27863a3a8f70fa4bddb9c97fabfee2db7f35d5615d4b90ad0be13717dc23d092</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker exec -it 27863a3a8f70fa4bddb9c97fabfee2db7f35d5615d4b90ad0be13717dc23d092 /bin/sh</div><div class="line">sh-4.2# </div><div class="line">sh-4.2# cd /</div><div class="line">sh-4.2# ls</div><div class="line">anaconda-post.log  bindata  dev  etchaha  home  lib  lib64lost+found  media  mntopt  proc  root  run  run.sh  sbin  srv  sys  tmp  usrvar</div><div class="line">sh-4.2# cd haha</div><div class="line">sh-4.2# ls</div><div class="line">myfirstregistry  registry.tar</div><div class="line">// 可以看到报错了</div><div class="line">sh-4.2# touch a.txt</div><div class="line">touch: cannot touch &apos;a.txt&apos;: Read-only file system</div><div class="line">sh-4.2#</div></pre></td></tr></table></figure></li><li><p>查看数据卷的具体信息 <code>$ docker inspect testVip</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&quot;Mounts&quot;: [</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;bind&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/Users/renyimin/Desktop/testVip&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/haha&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;&quot;,</div><div class="line">        &quot;RW&quot;: false,</div><div class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</div><div class="line">    &#125;</div><div class="line">],</div></pre></td></tr></table></figure></li></ul></li></ol><p>参考: <a href="https://yeasy.gitbooks.io/docker_practice/content/data_management/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/data_management/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;容器中管理数据主要有两种方式：&lt;code&gt;数据卷(Volumes)&lt;/code&gt; 和 &lt;code&gt;挂载主机目录(Bind mounts)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据卷-Volumes&quot;&gt;&lt;a href=&quot;#数据卷-Volumes&quot; class=&quot;header
      
    
    </summary>
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/categories/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/tags/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>04. 容器</title>
    <link href="http://blog.renyimin.com/2018/04/25/2018-04-25-04-docker/"/>
    <id>http://blog.renyimin.com/2018/04/25/2018-04-25-04-docker/</id>
    <published>2018-04-25T13:30:08.000Z</published>
    <updated>2018-02-28T02:33:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ol><li><p>镜像(Image)和容器(Container)的关系, 就像是面向对象程序设计中的 类 和 实例 的关系一样, 镜像是静态的定义, 容器是镜像运行时的实体。容器可以被 <code>创建</code>、<code>启动</code>、<code>停止</code>、<code>删除</code>、<code>暂停</code>等。</p></li><li><p>容器的实质是<strong>进程</strong>，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。<br> 因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。<br> 容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会把容器和虚拟机搞混。</p></li><li><p>前面讲过镜像使用的是<strong>分层存储</strong>，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。<br> 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。<br> 因此，<strong>任何保存于容器存储层的信息都会随容器的删除而丢失</strong>。</p></li><li><p>按照 Docker 最佳实践的要求, 容器不应该向其存储层内写入任何数据，<strong>容器存储层要保持无状态化</strong></p><ul><li>所有的文件写入操作，都应该使用<code>数据卷(Volume)</code>、或者<code>绑定宿主目录</code>，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</li><li>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</li></ul></li></ol><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a><strong>容器操作</strong></h2><p>启动容器有两种方式：<strong>一种是基于镜像新建一个容器并启动</strong>, <strong>另外一个是将在终止状态(stopped)的容器启动</strong></p><h3 id="创建并启动"><a href="#创建并启动" class="headerlink" title="创建并启动"></a>创建并启动</h3><ol><li><p>因为 Docker 的容器<strong>实在太轻量级了</strong>, 很多时候用户都是<strong>随时删除和新创建容器</strong>。 </p></li><li><p>新建并启动一个容器, 所需要的命令主要为 <code>docker run</code>, 例如: <code>$ docker run -d -p 5000:5000 --name myFirstRegistry registry</code>, 是根据名为registry的镜像创建并运行一个名为myFirstRegistry容器;</p></li><li><p>当利用 <code>docker run</code> 来创建容器时, Docker 在后台运行的标准操作包括:</p><ul><li>检查本地是否存在指定的镜像, 不存在就从公有仓库下载  (之前在<a href="">镜像</a>一节中也提到过:docker运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像)</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统, 并在只读的镜像层外面挂载一层可读写层 </li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 </li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul></li></ol><h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker start [containerID or NAME]</code> 命令, 直接将一个已经终止的容器启动运行。 </p><h3 id="守护态运行容器"><a href="#守护态运行容器" class="headerlink" title="守护态运行容器"></a>守护态运行容器</h3><p>其实更多时候, 我们需要让容器在后台运行, 而不是直接运行容器并展示出结果, 此时只用在运行时加上 <code>-d 参数</code>即可; (在容器的第一种启动方式中已经介绍过了)</p><h3 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h3><ol><li>可以通过 <code>docker ps</code> 命令来查看正在运行的容器信息</li><li>可以通过 <code>docker ps -a</code> 命令来查看 正在运行的和终止的 容器信息</li></ol><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>可以使用 <code>docker stop [containerID or NAME]</code> 来终止一个运行中的容器</p><h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><p>可以使用 <code>docker restart [containerID or NAME]</code> 来重启一个运行中的容器</p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><ol><li><p>可以使用 <code>docker rm 容器ID/容器NAME</code> 来删除一个<strong>处于终止状态</strong>的容器。 </p></li><li><p>如果要删除一个运行中的容器，可以添加 <code>-f参数</code>。</p></li></ol><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>可参考<a href="https://yeasy.gitbooks.io/docker_practice/content/container/attach_exec.html" target="_blank" rel="external">书中介绍</a></p><p>..通常使用 <code>docker exec -it [containerID or NAME] /bin/sh</code>    </p><h2 id="导出导入-镜像-容器"><a href="#导出导入-镜像-容器" class="headerlink" title="导出导入 镜像/容器"></a>导出导入 镜像/容器</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://yeasy.gitbooks.io/docker_practice/content/image/other.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/image/other.html</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/content/container/import_export.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/container/import_export.html</a><h3 id="镜像-save-load"><a href="#镜像-save-load" class="headerlink" title="镜像 (save/load)"></a>镜像 (save/load)</h3></li></ul><ol><li><code>docker save images_name</code>：将指定<strong>镜像</strong>导出为 <code>镜像存储文件</code>;<ul><li>例: <code>docker save -o vipservice_test.tar vipservice:latest</code> 会将本地镜像vipservice:latest保存成归档文件vipservice_test.tar</li></ul></li><li>再使用 <code>docker load</code> 命令将 <code>镜像存储文件</code> 导入到 本地镜像库;</li></ol><h3 id="容器-export-import"><a href="#容器-export-import" class="headerlink" title="容器(export/import)"></a>容器(export/import)</h3><ol><li><code>docker export container_id</code>：将一个<strong>容器</strong>导出为 <code>容器快照文件</code>;</li><li>再使用 <code>docker import</code> 命令将 <code>容器快照文件</code> 导入为一个新的镜像到本地镜像库;</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>用户既可以使用 <code>docker load</code> 来导入<code>镜像存储文件</code>到本地镜像库。</li><li>也可以使用 <code>docker import</code> 来导入一个<code>容器快照文件</code>到本地镜像库。</li><li>这两者的区别在于<code>镜像存储文件</code>将保存完整记录,体积也要大，而<code>容器快照文件</code>将丢弃所有的历史记录和元数据信息(即仅保存容器当时的快照状态)。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</li><li>另外, 使用<code>docker save</code>保存的<code>镜像存储文件</code>, 不能使用 <code>docker import</code> 来导入成镜像, 这样导入的镜像无法运行起来</li></ol><h2 id="最新管理容器命令"><a href="#最新管理容器命令" class="headerlink" title="最新管理容器命令"></a>最新管理容器命令</h2><p>在 Docker 1.13+ 版本中推荐使用 <code>docker container</code> 来管理容器, 如下:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker container run ubuntu:17.10 /bin/echo &apos;Hello world&apos;</div><div class="line">$ docker container start</div></pre></td></tr></table></figure></p><p><a href="https://yeasy.gitbooks.io/docker_practice/content/container/run.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/container/run.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;容器&quot;&gt;&lt;a href=&quot;#容器&quot; class=&quot;headerlink&quot; title=&quot;容器&quot;&gt;&lt;/a&gt;容器&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;镜像(Image)和容器(Container)的关系, 就像是面向对象程序设计中的 类 和 实例 的关系一样, 镜像是静态
      
    
    </summary>
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/categories/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/tags/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>03. 仓库(私有仓库)</title>
    <link href="http://blog.renyimin.com/2018/04/23/2018-04-23-03-docker/"/>
    <id>http://blog.renyimin.com/2018/04/23/2018-04-23-03-docker/</id>
    <published>2018-04-23T12:15:28.000Z</published>
    <updated>2018-02-28T07:15:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h2><p>1.Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。</p><ul><li>一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</li><li>最常使用的Registry公开服务是官方的 <code>Docker Hub</code>, 这也是默认的 Registry，并拥有大量的高质量的官方镜像。</li><li>除此以外，还有 CoreOS 的 Quay.io，CoreOS 相关的镜像存储在这里; Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务。</li></ul><p>2.由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务(Registry Mirror)，这些镜像服务被称为<strong>加速器</strong>。</p><p>3.但是, 有时候使用 Docker Hub 或其他公共仓库可能不方便(比如, 有时候我们的服务器无法访问互联网 或者 你不希望将自己的镜像放到公网当中)，则可以创建一个 <code>本地仓库供</code> 私人使用。</p><h2 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h2><p>1.除了使用公开服务外, 用户还可以在本地搭建私有Docker Registry, <a href="https://docs.docker.com/registry/" target="_blank" rel="external"><code>docker-registry</code></a>是官方提供的工具, 可以用于构建私有的镜像仓库。</p><p>2.安装运行 <code>docker-registry</code></p><ul><li><p>你可以通过获取官方<code>registry</code>镜像来在本地运行一个自己的私有镜像仓库 (如 <code>$ docker run -d -p 5000:5000 --restart=always --name registry registry</code>, 将使用官方的registry镜像来启动一个私有仓库)</p></li><li><p>默认情况下, 仓库中的镜像会被创建在容器的 <code>/var/lib/registry</code> 目录下, 你可以通过 <code>-v</code> 参数来将镜像文件存放到本地的指定路径中。</p></li><li><p>另外, 可以将私有仓库的配置文件指定到本地的路径下 (如 ~/Desktop/registry-config/ 下 )</p></li></ul><p>3.我们大可不必这么麻烦, 只是简单运行一个私有仓库服务 <code>$ docker run -d -p 5000:5000 --restart=always --name registry registry</code></p><h3 id="查看私有仓库中镜像"><a href="#查看私有仓库中镜像" class="headerlink" title="查看私有仓库中镜像"></a>查看私有仓库中镜像</h3><ol><li><p>用 <code>curl</code> 查看仓库中的镜像, 可以看到你的私有仓库暂时还是空的</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl 127.0.0.1:5000/v2/_catalog</div><div class="line">&#123;&quot;repositories&quot;:[]&#125;</div><div class="line">$</div></pre></td></tr></table></figure></li><li><p>还可以在浏览器中直接查看私有仓库中的镜像(并且内网其他机器也可以通过内网地址来访问你所搭建的私有仓库的镜像):<br> <img src="/img/docker/private_registry_01.png" width="200/"><br> <img src="/img/docker/private_registry_02.png" width="200/"></p></li></ol><h3 id="上传镜像到私有仓库中"><a href="#上传镜像到私有仓库中" class="headerlink" title="上传镜像到私有仓库中"></a>上传镜像到私有仓库中</h3><ol><li><p>之前我们已经通过获取官方 <code>registry镜像</code> 来创建好了自己的私有仓库, 接下来就可以使用 <code>docker tag</code> 来标记一个镜像, 然后推送它到仓库。</p></li><li><p>先查看一下本地已有的镜像 <code>docker image ls</code> :</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div></pre></td></tr></table></figure></li><li><p>使用 <code>docker tag</code> 将 <code>registry:lates</code> 这个镜像标记为一个新的本地镜像 <code>127.0.0.1:5000/registry:latest</code> ; </p><ul><li><p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker tag registry:latest 127.0.0.1:5000/registry:latest</div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div></pre></td></tr></table></figure></li><li><p>这样, 假设你的小组成员需要尝试在本地搭建自己的私有仓库的话，就不用去公共镜像仓库去下载了, 只用在内网就可以方便地下载registry镜像</p></li></ul></li><li><p>使用 docker push 上传标记的镜像</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker push 127.0.0.1:5000/registry:latest</div><div class="line">The push refers to a repository [127.0.0.1:5000/registry]</div><div class="line">9113493eaae1: Pushed </div><div class="line">621c2399d41a: Pushed </div><div class="line">59e80739ed3f: Pushed </div><div class="line">febf19f93653: Pushed </div><div class="line">e53f74215d12: Pushed </div><div class="line">latest: digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c size: 1364</div></pre></td></tr></table></figure></li><li><p>然后查看仓库中的镜像，可以看到镜像已经被成功上传了</p><ul><li><p>curl 查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl 127.0.0.1:5000/v2/_catalog</div><div class="line">&#123;&quot;repositories&quot;:[&quot;registry&quot;]&#125;</div></pre></td></tr></table></figure></li><li><p>浏览器查看<br><img src="/img/docker/private_registry_03.png" width="200/"><br><img src="/img/docker/private_registry_04.png" width="200/"></p></li></ul></li></ol><h3 id="上传私有仓库问题"><a href="#上传私有仓库问题" class="headerlink" title="上传私有仓库问题"></a>上传私有仓库问题</h3><ol><li><p>如果上传的时候, 打包的镜像使用的是本机的内网地址, 最后在上传的时候, 你会发现<strong>如下报错信息</strong>:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker push 192.168.1.3:5000/registry:latest</div><div class="line">The push refers to a repository [192.168.1.3:5000/registry]</div><div class="line">Get https://192.168.1.3:5000/v2/: http: server gave HTTP response to HTTPS client</div><div class="line">renyimindembp:vipvip renyimin$</div></pre></td></tr></table></figure></li><li><p>此时, 你需要将内网地址配置到本机docker的 <code>insecure registries</code> 中, 如下:<br> <img src="/img/docker/insecure_registries_01.png" width="300"></p></li><li><p>之后, 无论本机还是在同一内网中的其他机器也都可以推送镜像到仓库中了</p><ul><li>之前打包好的两个镜像, 都可以成功推送到私有仓库中:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ docker push 192.168.1.3:5000/registry</div><div class="line">The push refers to a repository [192.168.1.3:5000/registry]</div><div class="line">9113493eaae1: Pushed </div><div class="line">621c2399d41a: Pushed </div><div class="line">59e80739ed3f: Pushed </div><div class="line">febf19f93653: Pushed </div><div class="line">e53f74215d12: Pushed </div><div class="line">latest: digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c size: 1364</div><div class="line">   </div><div class="line">$ docker push 127.0.0.1:5000/registry</div><div class="line">The push refers to a repository [127.0.0.1:5000/registry]</div><div class="line">9113493eaae1: Layer already exists </div><div class="line">621c2399d41a: Layer already exists </div><div class="line">59e80739ed3f: Layer already exists </div><div class="line">febf19f93653: Layer already exists </div><div class="line">e53f74215d12: Layer already exists </div><div class="line">latest: digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c size: 1364</div></pre></td></tr></table></figure></li></ul></li></ol><h3 id="从私有仓库中下载镜像"><a href="#从私有仓库中下载镜像" class="headerlink" title="从私有仓库中下载镜像"></a>从私有仓库中下载镜像</h3><ol><li><p>先删除已有镜像</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">192.168.1.3:5000/registry                             latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line"></div><div class="line">$ docker image rm 127.0.0.1:5000/registry:latest 192.168.1.3:5000/registry:latest</div><div class="line">Untagged: 127.0.0.1:5000/registry:latest</div><div class="line">Untagged: 127.0.0.1:5000/registry@sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line">Untagged: 192.168.1.3:5000/registry:latest</div><div class="line">Untagged: 192.168.1.3:5000/registry@sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line"></div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">renyimindembp:vipvip renyimin$</div></pre></td></tr></table></figure></li><li><p>再尝试从私有仓库中下载这个镜像 (两个地址都可以下载, 也是因为之前配置了 <code>Insecure registries</code>, 这里最后才可以使用内网地址来下载)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">$ docker pull 127.0.0.1:5000/registry:latest</div><div class="line">latest: Pulling from registry</div><div class="line">Digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line">Status: Downloaded newer image for 127.0.0.1:5000/registry:latest</div><div class="line"></div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line"></div><div class="line">$ docker pull 192.168.1.3:5000/registry:latest</div><div class="line">latest: Pulling from registry</div><div class="line">Digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line">Status: Downloaded newer image for 192.168.1.3:5000/registry:latest</div><div class="line"></div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">192.168.1.3:5000/registry                             latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div></pre></td></tr></table></figure></li></ol><h2 id="几个简单问题"><a href="#几个简单问题" class="headerlink" title="几个简单问题"></a>几个简单问题</h2><ol><li><a href="https://docs.docker.com/registry/spec/api/#deleting-an-image" target="_blank" rel="external">删除<code>仓库</code>镜像</a><br> 自己的docker仓库中存放的镜像, 时间长了难免存在一些废弃的镜像在里面, 如果不删除就造成空间的浪费。下面简单看下如何删除仓库中的镜像;</li><li><p>容器启动之后, 如果忘记挂载某个目录, 能否再进行挂载? 其实没有必要, 直接停止删除, 重开一个即可！</p></li><li><p><del>~~未完待续</del>~~</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker-Registry-公开服务&quot;&gt;&lt;a href=&quot;#Docker-Registry-公开服务&quot; class=&quot;headerlink&quot; title=&quot;Docker Registry 公开服务&quot;&gt;&lt;/a&gt;Docker Registry 公开服务&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/categories/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/tags/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>02. 镜像</title>
    <link href="http://blog.renyimin.com/2018/04/22/2018-04-22-02-docker/"/>
    <id>http://blog.renyimin.com/2018/04/22/2018-04-22-02-docker/</id>
    <published>2018-04-22T11:40:07.000Z</published>
    <updated>2018-02-28T06:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像;</p><h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><ol><li><p><a href="https://hub.docker.com/explore/" target="_blank" rel="external">Docker Hub</a>上有大量的高质量的镜像可以用, 如何获取这些镜像呢?</p></li><li><p>从Docker镜像仓库获取镜像的命令是 <code>docker pull</code>, 其命令格式为：<code>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code></p></li><li><p>docker pull命令的具体选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式;</p><ul><li><p><strong>Docker镜像仓库地址</strong>: 地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code> (默认地址是 Docker Hub)</p></li><li><p><strong>仓库名</strong>: 仓库名是<strong>两段式名称</strong>, 即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code><br>对于 Docker Hub, 如果不给出用户名, 则默认为 library, 也就是官方镜像。<br>(//TODO 难道自己也能注册账号, 然后创建自己的镜像仓库, 并传上自己的镜像文件??)</p></li><li><p>比如 <code>$ docker pull ubuntu:16.04</code> :<br>由于没有给出Docker镜像仓库地址, 因此将会从Docker Hub获取镜像, 而镜像名称是 <code>ubuntu:16.04</code>(没有用户名), 因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>16.04</code> 的镜像;</p></li></ul></li><li><p>另外, 如果从 Docker Hub 下载镜像非常缓慢，可以<code>配置加速器</code>。</p></li></ol><h3 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h3><ol><li>国内从 Docker Hub 拉取镜像有时会遇到困难, 此时可以配置镜像加速器, Docker 官方和国内很多云服务商都提供了<strong>国内加速器服务</strong>, 例如:<ul><li><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror" target="_blank" rel="external">Docker 官方提供的中国 registry mirror</a></li><li><a href="https://cr.console.aliyun.com/?accounttraceid=d520cfad-1577-4905-91cd-09aa8b4964cd#/imageSearch" target="_blank" rel="external">阿里云加速器</a></li><li><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="external">DaoCloud 加速器</a></li></ul></li><li>此处以 Docker 官方加速器为例进行介绍(由于本人使用macOS系统,下面只列出macOS上如何配置镜像加速器, 其他系统请<a href="https://yeasy.gitbooks.io/docker_practice/content/install/mirror.html" target="_blank" rel="external">参考</a>)<ul><li>在任务栏点击<code>Docker for mac</code> 应用图标 -&gt; <code>Perferences</code>… -&gt; <code>Daemon</code> -&gt; <code>Registry mirrors</code></li><li>在列表中填写加速器地址即可, 修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像地址了   </li></ul></li><li>如果在添加加速器地址后出现 <code>registry-mirrors no certs for egistry.docker-....</code><br> <img src="/img/docker/jiasuqi-error-macOS.png" width="300">  </li><li>网上查找资料后, <a href="https://yq.aliyun.com/articles/29941" target="_blank" rel="external">有人说是证书问题</a>, 尝试修改https为http后正常<br> <img src="/img/docker/jiasuqi-macOS.png" width="300"> </li><li>检查加速器是否生效<ul><li>配置加速器之后,如果拉取镜像仍然十分缓慢,请手动检查加速器配置是否生效,在命令行执行 <code>docker info</code></li><li>由于我配置的是docker hub提供的中国镜像站点, 所以如果从结果中看到了如下内容，说明配置成功(你看到的可能和我的不一样)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Registry Mirrors:</div><div class="line">http://registry.docker-cn.com/</div></pre></td></tr></table></figure></li></ul></li></ol><h3 id="列出已存在镜像"><a href="#列出已存在镜像" class="headerlink" title="列出已存在镜像"></a>列出已存在镜像</h3><ol><li><p><code>docker images</code> ：列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>;</p></li><li><p>虽然 <code>镜像 ID</code> 是镜像的唯一标识, 但是一个镜像可以对应多个标签 (所以有些镜像的ID一样, 但是tag会不一样);</p></li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在 Docker 1.13+ 版本中推荐使用 <code>docker image</code> 来管理镜像。 (比如 <code>docker image ls</code> 会列出所有镜像);</p><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><ol><li>如果要删除本地的镜像, 可以使用 <code>docker image rm 镜像名</code> 命令; (<code>$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code>)</li></ol><h2 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li>严格来说，镜像并非是像一个ISO那样的打包文件, 镜像只是一个虚拟的概念, 其实际体现并非由一个文件组成, 而是由一组文件系统组成, 或者说, 由多层文件系统联合组成。</li><li>镜像构建时, 会一层层构建, 前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</li></ol><h3 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h3><ol><li><p>当我们运行一个容器的时候(如果不使用卷的话), 我们做的任何文件修改都会被记录于 <code>容器存储</code> 层里。后面会知道: <strong>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡</strong>;</p></li><li><p>而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。</p><ul><li>换句话说，就是在原有镜像的基础上，再<strong>叠加上容器的存储层</strong>，并构成新的镜像。</li><li>以后我们运行这个新镜像的时候, 就会拥有原有容器最后的文件变化。</li></ul></li><li><p>docker commit 的语法格式为: <code>docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></p></li><li><p>我们可以用下面的命令将容器保存为镜像:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker commit --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; --message &quot;修改了默认网页&quot; webserver nginx:v2</div></pre></td></tr></table></figure><p> 其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。</p></li></ol><h3 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用 docker commit"></a>慎用 docker commit</h3><ol><li><p>注意: <code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，<strong>不要使用 docker commit 定制镜像，定制镜像应该使用 Dockerfile 来完成</strong>。</p></li><li><p>镜像是容器的基础, 每次执行 <code>docker run</code> 的时候都会指定哪个镜像作为容器运行的基础。在之前的例子中, 我们所使用的都是来自于Docker Hub的镜像, 直接使用这些镜像是可以满足一定的需求, 而当这些镜像无法直接满足需求时, 我们就需要定制这些镜像。<br> 接下来将讲解如何定制镜像。</p></li></ol><h3 id="定制镜像"><a href="#定制镜像" class="headerlink" title="定制镜像"></a>定制镜像</h3><ol><li><p>回顾一下之前我们学到的知识，镜像是多层存储，每一层是在前一层的基础上进行的修改; 而容器同样也是多层存储，是在以镜像为基础层，<strong>在其基础上加一层作为容器运行时的存储层</strong>。</p></li><li><p>现在让我们以定制一个 Web 服务器为例子, 来讲解镜像是如何构建的:</p><ul><li><code>$ docker run --name webserver -d -p 80:80 nginx</code> 这条命令会用 nginx 镜像启动一个容器，命名为 webserver，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器。(直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面)</li><li>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 docker exec 命令进入容器，修改其内容。之后, 我们再刷新浏览器的话，会发现内容被改变了。</li><li>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</li></ul></li><li><p>现在我们定制好了变化，我们希望能<strong>将其保存下来形成我们自己的一个新镜像</strong></p><ul><li>要知道，当我们运行一个容器的时候(如果不使用卷的话)，我们做的任何文件修改都会被记录于<strong>容器存储层里</strong>。</li><li>而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</li><li>我们可以在 <code>docker image ls</code> 中看到这个新定制的镜像：</li><li><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 nginx:latest 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ docker history nginx:v2</div><div class="line">    IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</div><div class="line">    07e334659748        54 seconds ago      nginx -g daemon off;                            95 B                修改了默认网页</div><div class="line">    e43d811ce2f4        4 weeks ago         /bin/sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon    0 B</div><div class="line">    &lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop)  EXPOSE 443/tcp 80/tcp        0 B</div><div class="line">    &lt;missing&gt;           4 weeks ago         /bin/sh -c ln -sf /dev/stdout /var/log/nginx/   22 B</div><div class="line">    &lt;missing&gt;           4 weeks ago         /bin/sh -c apt-key adv --keyserver hkp://pgp.   58.46 MB</div><div class="line">    &lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop)  ENV NGINX_VERSION=1.11.5-1   0 B</div><div class="line">    &lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop)  MAINTAINER NGINX Docker Ma   0 B</div><div class="line">    &lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0 B</div><div class="line">    &lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop) ADD file:23aa4f893e3288698c   123 MB</div></pre></td></tr></table></figure></li><li><p>新的镜像定制好后，我们也可以来运行这个镜像。至此，我们第一次完成了定制镜像，使用的是 <code>docker commit</code> 命令，<strong>手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉</strong>。</p></li></ul></li></ol><h3 id="慎用-docker-commit-1"><a href="#慎用-docker-commit-1" class="headerlink" title="慎用 docker commit"></a>慎用 docker commit</h3><p>使用 docker commit 命令虽然可以比较直观的帮助理解镜像分层存储的概念, <strong>但是实际环境中并不会这样使用</strong>。</p><ol><li>首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 /usr/share/nginx/html/index.html 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。</li><li>此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是<strong>黑箱操作</strong>，生成的镜像也被称为<strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 docker diff 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</li><li>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 docker commit 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</li></ol><h2 id="使用Dockerfile定制镜像"><a href="#使用Dockerfile定制镜像" class="headerlink" title="使用Dockerfile定制镜像"></a>使用Dockerfile定制镜像</h2><ol><li>从上面的 docker commit 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 <code>Dockerfile</code>。</li><li>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，<strong>每一条指令构建一层</strong>，因此每一条指令的内容，就是描述该层应当如何构建。</li><li><p>还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。</p><ul><li><p>在一个空白目录中，建立一个文本文件，并命名为 Dockerfile, 其内容为如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FROM nginx</div><div class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</div></pre></td></tr></table></figure></li><li><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code></p></li></ul></li></ol><h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><ol><li><p>所谓定制镜像, 是以一个镜像为基础, 在其上进行定制。而 FROM 就是指定基础镜像, 因此一个 Dockerfile 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><ul><li>在 Docker Store 上有非常多的高质量的官方镜像, 有可以直接拿来使用的服务类的镜像, 如 nginx、redis、mongo、mysql、httpd、php、tomcat 等, 也有一些方便开发、构建、运行各种语言应用的镜像, 如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像<strong>做为基础镜像</strong>进行定制。</li><li>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</li><li><p>除了选择现有镜像为基础镜像外，<strong>Docker 还存在一个特殊的镜像，名为 scratch</strong>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FROM scratch</div></pre></td></tr></table></figure><p>如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p></li></ul></li><li>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm、coreos/etcd。<br> 对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。<br> <strong>使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一</strong>。</li></ol><h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><ol><li><p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li>shell 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。之前写的 Dockerfile 中的 RUN 指令就是这种格式。</li><li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ul></li><li><p>既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN apt-get update</div><div class="line">RUN apt-get install -y gcc libc6-dev make</div><div class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</div><div class="line">RUN mkdir -p /usr/src/redis</div><div class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</div><div class="line">RUN make -C /usr/src/redis</div><div class="line">RUN make -C /usr/src/redis install</div></pre></td></tr></table></figure></li><li><p>之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。</p><ul><li>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。<strong>这是很多初学 Docker 的人常犯的一个错误</strong>。</li><li>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</li></ul></li><li><p>上面的 Dockerfile 正确的写法应该是这样：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN buildDeps=&apos;gcc libc6-dev make&apos; \</div><div class="line">    &amp;&amp; apt-get update \</div><div class="line">    &amp;&amp; apt-get install -y $buildDeps \</div><div class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \</div><div class="line">    &amp;&amp; mkdir -p /usr/src/redis \</div><div class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</div><div class="line">    &amp;&amp; make -C /usr/src/redis \</div><div class="line">    &amp;&amp; make -C /usr/src/redis install \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</div><div class="line">    &amp;&amp; rm redis.tar.gz \</div><div class="line">    &amp;&amp; rm -r /usr/src/redis \</div><div class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</div></pre></td></tr></table></figure></li></ol><ol><li>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。<strong>在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建</strong>。<ul><li>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。<br>良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</li><li>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。<br>这是很重要的一步，我们之前说过，<strong>镜像是多层存储，每一层的东西并不会在下一层被删除</strong>，会一直跟随着镜像。<br>因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。<br>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</li></ul></li></ol><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><ol><li><p>在 Dockerfile 文件所在目录执行:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ docker build -t nginx:v3 .</div><div class="line">Sending build context to Docker daemon 2.048 kB</div><div class="line">Step 1 : FROM nginx</div><div class="line">---&gt; e43d811ce2f4</div><div class="line">Step 2 : RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</div><div class="line"> ---&gt; Running in 9cdc27646c7b</div><div class="line"> ---&gt; 44aa4490ce2c</div><div class="line">Removing intermediate container 9cdc27646c7b</div><div class="line">Successfully built 44aa4490ce2c</div></pre></td></tr></table></figure><ul><li>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前 所说的那样， RUN 指令启动了一个容器 9cdc27646c7b ，执行了所要求的命令，并最后提交 了这一层 44aa4490ce2c ，随后删除了所用到的这个容器 9cdc27646c7b 。</li></ul></li><li><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为: <code>docker build [选项] &lt;上下文路径/URL/-&gt;</code><br> 在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code> ，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。</p></li></ol><h3 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h3><h3 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="其它 docker build 的用法"></a>其它 docker build 的用法</h3><p>更多参考: <a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a><br>… 未完待续 </p><p>参考 : <a href="https://yeasy.gitbooks.io/docker_practice/content/image/commit.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/image/commit.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像;&lt;/p&gt;
&lt;h2 id=&quot;基础部分&quot;&gt;&lt;a href=&quot;#基础部分&quot; class=&quot;headerlink&quot; title=&quot;基础部分&quot;&gt;&lt;/a&gt;基础部分&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/categories/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/tags/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>01. 认识Docker</title>
    <link href="http://blog.renyimin.com/2018/04/22/2018-04-22-01-docker/"/>
    <id>http://blog.renyimin.com/2018/04/22/2018-04-22-01-docker/</id>
    <published>2018-04-22T11:30:41.000Z</published>
    <updated>2018-02-28T02:33:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p><code>Docker</code>使用Google公司推出的Go语言实现; 属于<strong>操作系统层面的虚拟化技术</strong>; 也称其为容器; </p></li><li><p>docker 和 传统虚拟机技术 对比</p></li></ol><ul><li><p>传统虚拟机技术是: 虚拟出一套硬件后; 在其上运行一个完整操作系统; 最后在该系统上再运行所需应用进程;</p></li><li><p>而容器内的应用进程直接运行于宿主的内核, 容器内没有自己的内核, 而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便;</p></li><li><p>如下图, 可以看到有<code>应用A</code>和<code>应用B</code>两个应用, 相比于传统虚拟技术, docker少了<code>Hypervisor</code>(所有虚拟化技术的核心)和<code>Guest OS</code>这两层<br>  <img src="/img/docker/docker-vs-virtualmachines.png" width="600"></p></li></ul><h2 id="为什么使用docker"><a href="#为什么使用docker" class="headerlink" title="为什么使用docker?"></a><a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/why.html" target="_blank" rel="external">为什么使用docker?</a></h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势</p><h3 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h3><p>由于容器不需要进行 <code>硬件虚拟</code> 以及 <code>运行完整操作系统</code> 等额外开销, 所以其实<strong>Docker对系统资源的利用率更高</strong>。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。<br>因此，相比虚拟机技术，<strong>一个相同配置的主机，往往可以运行更多数量的应用</strong>。</p><h3 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h3><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，<strong>由于直接运行于宿主内核，无需启动完整的操作系统</strong>，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h3 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h3><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。<br>而 Docker 的镜像提供了<strong>除内核外完整的运行时环境</strong>，确保了应用运行环境一致性，从而不会再出现 <code>「这段代码在我机器上没问题啊」</code> 这类问题。</p><p>更多好处请参考(<a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/why.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/introduction/why.html</a>)</p><h2 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h2><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">容器</th><th style="text-align:center">虚拟机</th></tr></thead><tbody><tr><td style="text-align:center">启动</td><td style="text-align:center">秒级</td><td style="text-align:center">分钟级</td></tr><tr><td style="text-align:center">硬盘使用</td><td style="text-align:center">一般为MB</td><td style="text-align:center">一般为GB</td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">接近原生</td><td style="text-align:center">弱于原生</td></tr><tr><td style="text-align:center">系统支持量</td><td style="text-align:center">单机支持上千个容器</td><td style="text-align:center">一般几十个</td></tr></tbody></table><h2 id="Docker三个基本概念"><a href="#Docker三个基本概念" class="headerlink" title="Docker三个基本概念"></a>Docker三个基本概念</h2><p>理解了这三个概念，就理解了 Docker 的整个生命周期</p><h3 id="镜像-Image"><a href="#镜像-Image" class="headerlink" title="镜像 (Image)"></a>镜像 (Image)</h3><h3 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器 (Container)"></a>容器 (Container)</h3><h3 id="仓库-Repository"><a href="#仓库-Repository" class="headerlink" title="仓库 (Repository)"></a>仓库 (Repository)</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt;使用Google公司推出的Go语言实现; 属于&lt;strong&gt;操作系统层面的虚拟化技
      
    
    </summary>
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/categories/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
    
      <category term="《Docker从入门到实战》" scheme="http://blog.renyimin.com/tags/%E3%80%8ADocker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>mysql(InnoDB)事务隔离级别(REPEATABLE READ) 与 锁,MVCC</title>
    <link href="http://blog.renyimin.com/2017/12/31/2017-12-31-mysql_transaction-05/"/>
    <id>http://blog.renyimin.com/2017/12/31/2017-12-31-mysql_transaction-05/</id>
    <published>2017-12-31T08:30:11.000Z</published>
    <updated>2018-01-19T01:43:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h3><p>(可重复读)</p><ol><li><p>之前已经了解到, 该隔离级别可以解决<code>不可重复读问题</code> (当然, 也能解决<code>脏读问题</code>), 那么如果单纯用锁来实现, 可能会是如下这样子:</p><ul><li>既然<code>REPEATABLE READ</code> 隔离级别可以解决<code>脏读</code>, <code>不可重复读</code>的问题, 也就是它既可以让事务只能读其他事务已提交的的记录, 又能在同一事务中保证多次读取的数据即使被其他事务修改, 也是一致的。</li><li>解决<code>脏读问题</code>:<br>  试想一下, 当在事务A中读取数据D的时候, 假设D之前已经在事务B中了, 并且事务B中对数据D做了修改, 但是事务B还没有完成(commit/rollback), 那如何让事务A无法读取数据D呢?<br>  当事务B在对数据D做写操作的时候, 假设给数据D加上了行级的排他锁(X lock), 那事务A自然只能阻塞等事务A完成后才能读取数据D了, 这样就解决了<code>脏读问题</code>。</li><li>解决 <code>不可重复读问题</code>:<br>  试想一下, 当在事务A中第一次读取了数据D之后, 直接给该数据D加S共享锁, 那其他事务自然只能阻塞等事务A完成后才能对数据D做修改操作了, 这样就解决了<code>不可重复读</code>, 在事务A中多次读取数据D, 都是一样的。</li></ul></li><li><p>上面使用<code>S锁+X锁</code>确实可以实现 <code>READ COMMITTED</code> 隔离级别的效果, 也就避免了<code>脏读问题</code>和<code>不可重复读问题</code>, 当然, 这里的问题仍然是低效！！！！</p></li><li><p>因为 MySQL 在事务隔离级别Read committed 、Repeatable Read下，InnoDB 存储引擎采用<code>非锁定</code>的<code>一致性读</code>－－即读取数据不用加锁，即采用的是MVCC中<code>一致性非锁定读</code>模式, 所以, InnoDB的做法是: <strong>读不影响写，写不影响读</strong>。</p><ul><li>读不影响写: 当数据正在执行读操作时，其他事务的写操作不会因此去等待当前事务行上S锁的释放，而是会去读取行的一个快照数据。   </li><li>写不影响读：当数据正在执行写操作时，其他事务的读操作不会因此去等待当前事务行上X锁的释放，而是会去读取行的一个快照数据。    </li></ul></li><li><p>所以总结来看, <code>READ UNCOMMITTED</code> 和 <code>REPEATABLE READ</code> 这两个隔离级别都是使用 <code>写用排他锁 + 读用MVCC</code>, 区别可以参考 <a href="/2017/12/28/2017-12-28-mysql_mvcc/">MySQL-InnoDB-MVCC多版本并发控制</a></p></li></ol><ul><li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html" target="_blank" rel="external">MySQL官方文档</a></li><li><a href="https://www.imooc.com/article/17290" target="_blank" rel="external">慕课mark_rock同学手记</a></li><li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="external">美团技术博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;REPEATABLE-READ&quot;&gt;&lt;a href=&quot;#REPEATABLE-READ&quot; class=&quot;headerlink&quot; title=&quot;REPEATABLE READ&quot;&gt;&lt;/a&gt;REPEATABLE READ&lt;/h3&gt;&lt;p&gt;(可重复读)&lt;/p&gt;
&lt;ol&gt;
&lt;l
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="事务" scheme="http://blog.renyimin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="MVCC" scheme="http://blog.renyimin.com/tags/MVCC/"/>
    
      <category term="隔离级别与锁" scheme="http://blog.renyimin.com/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>mysql(InnoDB)事务隔离级别(READ COMMITTED) 与 锁,MVCC</title>
    <link href="http://blog.renyimin.com/2017/12/31/2017-12-31-mysql_transaction-04/"/>
    <id>http://blog.renyimin.com/2017/12/31/2017-12-31-mysql_transaction-04/</id>
    <published>2017-12-31T02:01:47.000Z</published>
    <updated>2018-01-02T01:33:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h3><p>(提交读)</p><ol><li><p>了解了<a href="/2017/12/29/2017-12-29-mysql_transaction-02/">之前 <code>READ UNCOMMITTED</code> 隔离级别是如何加锁的</a>, 并且在文章中, 已经知道 <code>READ COMMITTED</code> 隔离级别可以解决脏读的问题, 那接下来, 对于 <code>READ COMMITTED</code> 隔离级别, 试想一下如果让你用锁来设计, 你会怎么做?</p><ul><li>既然<code>READ COMMITTED</code> 隔离级别可以解决<code>脏读</code>的问题, 也就是他可以让事务只能读其他事务已提交的的记录。</li><li>如果用锁机制来实现该隔离级别:<br>  试想一下, 当在事务A中读取数据D的时候, 假设D之前已经在事务B中了, 并且事务B中对数据D做了修改, 但是事务B还没有完成(commit/rollback), 那如何让事务A无法读取数据D呢?<br>  当事务B在对数据D做写操作的时候, 假设给数据D加上了行级的排他锁(X lock), 那事务A自然只能阻塞等事务A完成后才能读取数据D了!</li><li>数据库这样做的话确实实现了<code>READ COMMITTED</code>隔离级别的效果, 也就避免了<code>脏读</code>, 但问题是这是一种很低效的做法, 因为对于大部分应用来说, 读操作是多于写操作的, 当写操作加锁时, 那么读操作全部被阻塞, 这样在大用户量高并发的情况下, 会直接降低数据库的读效率。</li></ul></li><li><p>那么, 既然用锁机制实现该隔离级别是低效的做法, 数据库是如何做的?<br> 之前在相关<a href="/2017/12/28/2017-12-28-mysql_mvcc/">MVCC的文章</a>中可以得到答案: 数据库是使用了 <strong>排他锁+MVCC</strong> 的机制来实现该隔离级别的, 而不是单纯的使用锁或者单纯的使用MVCC</p></li></ol><h3 id="READ-COMMITTED与锁-测试"><a href="#READ-COMMITTED与锁-测试" class="headerlink" title="READ COMMITTED与锁 测试"></a>READ COMMITTED与锁 测试</h3><ol><li><p>数据表结构如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+---------------+-----+--------+--------------------+</div><div class="line">| id | user_name     | age | gender | desctiption        |</div><div class="line">+----+---------------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼     | 127 |      2 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠-rym | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人     |   0 |      2 | 我有一身肉    |</div><div class="line">+----+---------------+-----+--------+--------------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li><li><p>重新设置<code>客户端1</code>事务隔离级别为read committed: <code>SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @@SESSION.tx_isolation;</div><div class="line">+------------------------+</div><div class="line">| @@SESSION.tx_isolation |</div><div class="line">+------------------------+</div><div class="line">| REPEATABLE-READ        |</div><div class="line">+------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; SELECT @@SESSION.tx_isolation;</div><div class="line">+------------------------+</div><div class="line">| @@SESSION.tx_isolation |</div><div class="line">+------------------------+</div><div class="line">| READ-COMMITTED         |</div><div class="line">+------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li><li><p>再重新打开一个<code>客户端2</code>并设置事务隔离级别为read committed;</p></li><li><p>在<code>客户端1</code>中打开事务, 然后更改数据, 先不提交; 然后在<code>客户端2</code>中打开事务, 读取<code>客户端1</code>中尚未提交的那条被修改数据<br> <img src="/img/mysql/transaction/committed_result_01.png" width="470" height="660"></p></li><li><p>结果发现在<code>客户端2</code>中可以正常读取到那条数据, 只不过, 那条数据并不是被<code>客户端1</code>事务中修改后的数据, 而是最初的<code>稳定数据</code>, 这就避免了<code>脏读</code>!!  </p></li><li><p>对于该隔离级别修改数据时使用的锁类型, 其分析方法, 和之前一篇<a href="2017/12/29/2017-12-29-mysql_transaction-02/">MySQL(INNODB引擎)事务READ UNCOMMITTED隔离级别和锁的关系</a> 是一样的：</p><ul><li>可以在<code>客户端1</code>的事务在修改数据并且未提交时, 在<code>客户端2</code>中对同一数据进行修改, 然后在<code>客户端2</code>阻塞阶段通过<br><code>查看表的加锁情况: select * from information_schema.INNODB_LOCKS;</code>,<br><code>事务状态: select * from information_schema.INNODB_TRX;</code>,<br>进行分析, 结果就不展示了, 可以自行测试一下, 该隔离级别修改数据时使用的也是排他锁, 并且<code>客户端2</code>的修改语句会锁等待~<br>(和之前分析READ UNCOMMITTED隔离级别一样, 既然使用了排他锁, 竟然别的事务还能读取, 这特么不就又违反了排他锁的特性么? 还是那句话, 另一个事务在读取的时候并不会加锁, 而是用的MVCC机制读取的镜像)</li></ul></li><li><p>小结:<br> InnoDB在该隔离级别(READ COMMITTED)写数据是使用排他锁, 读取数据不加锁而是使用了MVCC机制, 这样就可以大大提高并发读写效率, 写不影响读, <strong>因为读并未加锁, 读的是记录的镜像版本</strong>!!</p></li></ol><ul><li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html" target="_blank" rel="external">MySQL官方文档</a></li><li><a href="https://www.imooc.com/article/17289" target="_blank" rel="external">慕课mark_rock同学手记</a></li><li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="external">美团技术博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;READ-COMMITTED&quot;&gt;&lt;a href=&quot;#READ-COMMITTED&quot; class=&quot;headerlink&quot; title=&quot;READ COMMITTED&quot;&gt;&lt;/a&gt;READ COMMITTED&lt;/h3&gt;&lt;p&gt;(提交读)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="事务" scheme="http://blog.renyimin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="MVCC" scheme="http://blog.renyimin.com/tags/MVCC/"/>
    
      <category term="隔离级别与锁" scheme="http://blog.renyimin.com/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>mysql(InnoDB)事务隔离级别(READ UNCOMMITTED) 与 锁</title>
    <link href="http://blog.renyimin.com/2017/12/29/2017-12-29-mysql_transaction-02/"/>
    <id>http://blog.renyimin.com/2017/12/29/2017-12-29-mysql_transaction-02/</id>
    <published>2017-12-29T11:12:11.000Z</published>
    <updated>2018-01-04T01:56:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先针对自己以前错误的思维做个记录, 可以直接跳过</p><ol><li>由于以前看到很多资料在谈到并发控制的时候, 都会提到用<code>锁</code>来控制并发, MySQL也不例外, 也有很多和锁相关的概念(留到后面会单独整理一篇笔记出来), 所以一提到高并发产生的问题, 我会不自觉地提出一个疑问: <code>现在并发出问题了, 那怎么用锁的相关知识来解决?</code>;</li><li>而且近期一段时间也一直在看很多有关MySQL锁相关的资料,书籍, 于是乎 <code>死锁</code>, <code>锁冲突</code>, <code>行锁</code>,<code>表锁</code>, <code>读锁</code>, <code>写锁</code>, <code>乐观锁</code>, <code>悲观锁</code> ……等等 N多锁相关的名词(后面的笔记会把所有自己遇到的, 全部整理并进行分析), 大量的篇幅, 高深晦涩的描述, 直接导致我意识里认为<code>嗯, 锁真tm高大上, 真tm高端, 肯定tm就是它了</code>; </li><li>于是就进入了思想误区, 认为在解决<code>脏读</code>,<code>不可重复读</code>,<code>幻读</code>的资料中, 应该大篇幅的描述如何用锁相关的知识来解决这些问题, 然而略失落了, 资料倒是提了点儿锁的知识, 但更多的是用事务的哪个隔离级别来解决这些问题, <code>锁</code>哪儿去了?</li><li><p>尤其是在分析<code>脏读</code>,<code>不可重复读</code>,<code>幻读</code>这几个问题的时候, 一上去就全乱了, 比如 <code>脏读</code>, 如果总是以MySQL锁的相关知识作为前提来分析, <strong>就会陷入误区</strong> ‘事务A读取数据的时候肯定会加S锁的, 事务B自然是无法对未完成的事务A中的数据进行修改的, 我Ca, <strong>这种脏读的场景根本就不成立嘛!</strong>‘, 那为什么不提锁, 而是用隔离级别来解决。<br> <img src="/img/mysql/transaction/022_zangdu.png" width="609" height="175"><br>……<br>……</p></li><li><p>晕了几天之后,终于稍微醒了点……</p><blockquote><p><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="external">参考美团技术博客</a><br> <img src="/img/mysql/transaction/meituan_suo.png" width="609" height="313"></p></blockquote></li><li><p>显然, <strong>事务隔离级别的核心就是锁, 各隔离级别使用了不同的加锁策略</strong>，在分析之前的几个高并发事务问题的时候, <code>隔离级别(锁)</code>自然是不能作为前置知识点的, 而是最终问题的解决方案! </p></li></ol><h2 id="“READ-UNCOMMITTED与锁”的困惑"><a href="#“READ-UNCOMMITTED与锁”的困惑" class="headerlink" title="“READ UNCOMMITTED与锁”的困惑"></a>“READ UNCOMMITTED与锁”的困惑</h2><p>(未提交读)</p><ol><li><p>在READ UNCOMMITTED级别, 事务中的修改, 即使还没有提交, 对其他事务也都是可见的; 也就是说事务可以读取未提交的数据, 这也就造成了 <code>脏读(Dirty Read)</code> 的出现。</p></li><li><p>这个级别会导致很多问题, 而且从性能上来说, READ COMMITTED 并不会比其他的级别好太多, 却缺乏其他级别的很多好处, 在实际应用中一般很少使用。</p></li><li><p>虽然很少使用, 但还是有必要了解一下, <strong>它这个隔离级别究竟是怎么隔离的, 竟然还能容许很多问题的存在？</strong> (老兄亏你还算个隔离级别, 怎么办事儿的…) 网上相关资料五花八门, 下面列几个出来(希望你看完不要激动):</p><ul><li><p><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="external">美团技术博客</a>:<br><img src="/img/mysql/transaction/meituan_readuncommitted.png" width="550" height="229"></p></li><li><p><a href="https://segmentfault.com/a/1190000004469395#articleHeader10" target="_blank" rel="external">segmentfault一篇文章</a><br><img src="/img/mysql/transaction/seg_readuncommitted.png" width="550" height="300"></p></li><li><p><a href="http://blog.csdn.net/flyingfalcon/article/details/53045672" target="_blank" rel="external">CSDN一篇文章</a><br><img src="/img/mysql/transaction/csdn_readuncommitted.png" width="550" height="86"></p></li><li><p><a href="http://blog.csdn.net/ozwarld/article/details/8259796" target="_blank" rel="external">CSDN一篇文章</a><br><img src="/img/mysql/transaction/csdn_readuncommitted_02.png" width="550" height="151"></p></li></ul></li><li><p>说实话, 资料查到这份儿上, 我已经快崩溃了, 就<code>READ UNCOMMITTED</code>这个隔离级别:</p><ul><li>有说读写都不加锁的</li><li>有说’修改完数据立即加S锁的, 修改时撤掉S锁’</li><li>有说’写加S锁,事务结束释放’的</li><li>有说’写加X锁,事务结束释放’的</li></ul></li><li><p><strong>行啦, 不查了, 再查就崩溃了, 自己去测一下吧!!!</strong></p></li></ol><ul><li>本次测试是使用MAMP PRO中mysql5.6版本</li><li><p>先准备一张测试表<code>test_transaction</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">DROP TABLE IF EXISTS `test_transaction`;</div><div class="line">CREATE TABLE `test_transaction` (</div><div class="line">  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;,</div><div class="line">  `user_name` char(20) NOT NULL COMMENT &apos;姓名&apos;,</div><div class="line">  `age` tinyint(3) NOT NULL COMMENT &apos;年龄&apos;,</div><div class="line">  `gender` tinyint(1) NOT NULL COMMENT &apos;1:男, 2:女&apos;,</div><div class="line">  `desctiption` text NOT NULL COMMENT &apos;简介&apos;,</div><div class="line">  PRIMARY KEY (`id`),</div><div class="line">  KEY `name_age_gender_index` (`user_name`,`age`,`gender`)</div><div class="line">) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;</div><div class="line"></div><div class="line">INSERT INTO `test_transaction` VALUES (1, &apos;金刚狼&apos;, 127, 1, &apos;我有一双铁爪&apos;);</div><div class="line">INSERT INTO `test_transaction` VALUES (2, &apos;钢铁侠&apos;, 120, 1, &apos;我有一身铁甲&apos;);</div><div class="line">INSERT INTO `test_transaction` VALUES (3, &apos;绿巨人&apos;, 0, 2, &apos;我有一身肉&apos;);</div></pre></td></tr></table></figure></li><li><p>如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼 | 127 |      2 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">3 rows in set (0.00 sec)</div></pre></td></tr></table></figure></li></ul><h2 id="READ-UNCOMMITTED与锁-测试"><a href="#READ-UNCOMMITTED与锁-测试" class="headerlink" title="READ UNCOMMITTED与锁 测试"></a>READ UNCOMMITTED与锁 测试</h2><h3 id="演示该隔离级别脏读效果"><a href="#演示该隔离级别脏读效果" class="headerlink" title="演示该隔离级别脏读效果"></a>演示该隔离级别脏读效果</h3><ol><li><p>先查看当前会话(当前客户端)事务的隔离级别: <code>SELECT @@SESSION.tx_isolation;</code><br> 可以看到: <code>REPEATABLE READ</code> 是InnoDB存储引擎的默认事务隔离级别</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @@SESSION.tx_isolation;</div><div class="line">+------------------------+</div><div class="line">| @@SESSION.tx_isolation |</div><div class="line">+------------------------+</div><div class="line">| REPEATABLE-READ        |</div><div class="line">+------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li><li><p>重新设置当前客户端事务隔离级别为read uncommitted: <code>SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code><br> 注意, 此时只是当前会话端的隔离级别被改, 其余客户端连接自然还是默认的REPEATABLE READ隔离级别<br> <img src="/img/mysql/transaction/set_transaction_level.png" width="535" height="811"></p></li><li><p>接下来将客户端2的事务隔离级别也设置为read uncommitted;<br> <img src="/img/mysql/transaction/set_transaction_level_02.png" width="535" height="740"></p></li><li><p>客户端1开启事务,并执行一个查询’读取数据’:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @@SESSION.tx_isolation;</div><div class="line">+------------------------+</div><div class="line">| @@SESSION.tx_isolation |</div><div class="line">+------------------------+</div><div class="line">| READ-UNCOMMITTED       |</div><div class="line">+------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; begin;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; select * from test_transaction where id=2;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure><p> <strong>注意, 客户端1此时的事务并未提交</strong></p></li><li><p>客户端2开启事务, 并修改客户端1查询的数据</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @@SESSION.tx_isolation;</div><div class="line">+------------------------+</div><div class="line">| @@SESSION.tx_isolation |</div><div class="line">+------------------------+</div><div class="line">| READ-UNCOMMITTED       |</div><div class="line">+------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; begin;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; update test_transaction set user_name=&apos;钢铁侠-托尼&apos; where id=2;</div><div class="line">Query OK, 1 row affected (0.00 sec)</div><div class="line">Rows matched: 1  Changed: 1  Warnings: 0</div><div class="line">mysql&gt;</div></pre></td></tr></table></figure><ul><li>此时发现, 客户端2可以对客户端1正在读取的记录进行修改, 而根据锁相关知识, <code>如果说客户端1在读取记录的时候加了S锁, 那么客户端2是不能加X锁对该记录进行更改的</code>, 所以可以得出结论: 要么是客户端1读取记录的时候没有加S锁, 要么是客户端2更改该记录的时候没有加X锁(这样即使客户端1加了S锁,对它这个不加锁的事务也无可奈何), 那么究竟是哪种情况导致的? 下面继续进行分析…</li><li><strong>注意, 客户端2此时的事务也并未提交</strong></li></ul></li><li><p>切换到客户端1, 再次查询数据, 发现数据已经变成了’钢铁侠-托尼’; 然后客户端2 <code>rollback</code> 事务, 再到客户端1中查询,发现user_name又变成了’钢铁侠’, 那之前独到’钢铁侠-托尼’就是脏数据了, 这就是一次 <code>脏读</code><br> <img src="/img/mysql/transaction/result_01.png" width="515" height="845"></p></li></ol><h3 id="测试-分析该隔离级别如何加锁"><a href="#测试-分析该隔离级别如何加锁" class="headerlink" title="测试,分析该隔离级别如何加锁"></a>测试,分析该隔离级别如何加锁</h3><ol><li>重新构造测试条件<br> <img src="/img/mysql/transaction/qianti_02.png" width="525" height="930"></li><li><p>客户端1开启事务, 然后对数据做修改</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; begin;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; update test_transaction set user_name=&apos;钢铁侠-rymuscle&apos; where id=2;</div><div class="line">Query OK, 1 row affected (0.00 sec)</div><div class="line">Rows matched: 1  Changed: 1  Warnings: 0</div><div class="line">mysql&gt;</div></pre></td></tr></table></figure><p> <strong>注意, 客户端1此时的事务并未提交</strong></p></li><li><p>客户端2开启事务, 对相同的数据行做修改</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mysql&gt; begin;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; update test_transaction set user_name=&apos;钢铁侠-rym&apos; where id=2;</div><div class="line">....阻塞等待了</div></pre></td></tr></table></figure><p> 最终会如下:<br> <img src="/img/mysql/transaction/zuse.png" width="555" height="290"></p></li><li><p><strong>注意:</strong> 在上面的过程, 在客户端2阻塞阶段, 你可以通过一个新的客户端来分析, 客户端2在锁等待的情况下的 <code>加锁情况</code> 和 <code>事务状态</code>:</p><ul><li><p>查看表的加锁情况: <code>select * from information_schema.INNODB_LOCKS;</code></p><p><img src="/img/mysql/transaction/lock_result.png" width="605" height="340"></p></li><li>事务状态 <code>select * from information_schema.INNODB_TRX;</code><br><img src="/img/mysql/transaction/transaction_state_01.png" width="805" height="880"></li></ul></li><li><p>所以, <strong>READ UNCOMMITTED 隔离级别下, 写操作是会加锁的, 而且是X排他锁, 直到客户端1事务完成, 锁才释放, 客户端2才能进行写操作</strong></p></li><li><p>接下来你肯定会纳闷 “既然该隔离级别下事务在修改数据的时候加的是x锁, 并且是事务完成后才释放, 那之前的测试客户端2在事务中修改完数据之后, 为什么事务还没完成, 也就是x锁还在, 结果客户端1却能读取到客户端2修改的数据”？<strong>这完全不符合排他锁的特性啊(要知道,排他锁会阻塞除当前事务之外的其他事务的读,写操作)</strong></p><ul><li><p>其实网上已经有人在sqlserver的官网上找到了相关资料:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ansactions running at the READ UNCOMMITTED level do not issue shared locks to prevent other transactions from modifying data read by the current transaction. </div><div class="line">READ UNCOMMITTED transactions are also not blocked by exclusive locks that would prevent the current transaction from reading rows that have been modified but not committed by other transactions. </div><div class="line">When this option is set, it is possible to read uncommitted modifications, which are called dirty reads. Values in the data can be changed and rows can appear or disappear in the data set before the end of the transaction. </div><div class="line">This option has the same effect as setting NOLOCK on all tables in all SELECT statements in a transaction. </div><div class="line">This is the least restrictive of the isolation levels.</div></pre></td></tr></table></figure></li><li><p>翻译翻译, 在思考思考, 其实说的是<br>在 READ UNCOMMITTED 级别运行的事务不会发出共享锁来防止其他事务修改当前事务读取的数据, 既然不加共享锁了, 那么当前事务所读取的数据自然就可以被其他事务来修改。<br>而且当前事务要读取其他事务未提交的修改, 也不会被排他锁阻止, 因为排他锁会阻止其他事务再对其锁定的数据加读写锁, <strong>但是可笑的是, 事务在该隔离级别下去读数据的话根本什么锁都不加, 这就让排他锁无法排它了, 因为它连锁都没有</strong>。<br>这就导致了事务可以读取未提交的修改, 称为脏读。</p></li></ul></li></ol><p><strong>所以可以得出</strong>: <code>READ UNCOMMITTED</code>隔离级别下, 读不会加任何锁。而写会加排他锁，并到事务结束之后释放。</p><p>参考资料:<br>-《高性能MySQL》</p><ul><li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html" target="_blank" rel="external">MySQL官方文档</a></li><li><a href="https://www.imooc.com/article/17291" target="_blank" rel="external">慕课mark_rock同学手记</a></li><li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="external">美团技术博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;先针对自己以前错误的思维做个记录, 可以直接跳过&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于以前看到很多资料在谈到并发控制的时候, 都会提到用&lt;code
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="事务" scheme="http://blog.renyimin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="隔离级别与锁" scheme="http://blog.renyimin.com/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-InnoDB-MVCC多版本并发控制</title>
    <link href="http://blog.renyimin.com/2017/12/28/2017-12-28-mysql_mvcc/"/>
    <id>http://blog.renyimin.com/2017/12/28/2017-12-28-mysql_mvcc/</id>
    <published>2017-12-28T13:07:12.000Z</published>
    <updated>2018-01-18T13:22:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>(Multiversion Concurrency Control)</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近正在啃《高性能MySQL》这本书, 当看到事务相关知识时, 决定对该知识点稍微深入一下, 这里主要先说一下本人在啃相关知识点时的曲折之路:<br>1.首先是事务相关ACID特性, 之前已经有相关笔记进行过介绍, 这里不再重复;</p><p>2.接下来是高并发事务相关的问题, 像是 <code>脏读</code>, <code>不可重复读</code>, <code>幻读</code>, <code>更新丢失</code>等问题之前也有介绍;</p><p>3.再下来就是MySQL应对高并发事务的诸多问题是如何给出解决方案的(其中包含各个隔离级别的简介);</p><p>4.然后就是各个隔离级别的具体介绍及与锁的关系, 也就是在这部分知识点, 发现了之前并没有过多关心的知识点 <code>MVCC多版本并发控制</code>, 然后一发不可收拾了…</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><p><a href="http://mysql.taobao.org/monthly/2017/12/01/" target="_blank" rel="external">阿里数据库内核’2017/12’月报</a>中对MVCC的解释是:</p><blockquote><p><strong>多版本控制</strong>: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。</p></blockquote></li><li><p>&lt;高性能MySQL&gt;中对MVCC的部分介绍</p><blockquote><p>MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。<strong>基于提升并发性能的考虑</strong>, 它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL, 包括Oracle,PostgreSQL等其他数据库系统也都实现了MVCC, 但各自的实现机制不尽相同, 因为MVCC没有一个统一的实现标准。<br>可以认为MVCC是行级锁的一个变种, 但是它在很多情况下避免了加锁操作, 因此开销更低。虽然实现机制有所不同, 但大都实现了非阻塞的读操作，写操作也只锁定必要的行。<br>MVCC的实现方式有多种, 典型的有乐观(optimistic)并发控制 和 悲观(pessimistic)并发控制。<br>MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 <code>READ UNCOMMITTED</code> 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 <code>SERIALIZABLE</code> 则会对所有读取的行都加锁。</p></blockquote><p> 从书中可以了解到:</p><ul><li>MVCC是被Mysql中 <code>事务型存储引擎InnoDB</code> 所支持的;</li><li><strong>应对高并发事务, MVCC比单纯的行锁更高效</strong>; </li><li>MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;</li><li>MVCC可以使用 <code>乐观(optimistic)锁</code> 和 <code>悲观(pessimistic)锁</code>来实现;</li><li>各数据库中MVCC实现并不统一</li><li>但是书中提到 “InnoDB的MVCC是通过在每行记录后面保存<strong>两个隐藏的列</strong>来实现的”(网上也有很多此类观点), 但其实并不准确, 可以参考<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html" target="_blank" rel="external">MySQL官方文档</a>, 可以看到, InnoDB存储引擎在数据库每行数据的后面添加了<strong>三个字段</strong>, 不是两个!!</li></ul></li></ol><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><code>read view</code>, <code>快照snapshot</code><br>1.<a href="http://mysql.taobao.org/monthly/2017/10/01/" target="_blank" rel="external">淘宝数据库内核月报/2017/10/01/</a><br>此文虽然是以PostgreSQL进行的说明, 但并不影响理解, 在”事务快照的实现”该部分有细节需要注意:</p><pre><code>- **事务快照是用来存储数据库的事务运行情况。** - 一个事务快照的创建过程可以概括为：查看当前所有的未提交并活跃的事务，存储在数组中选取未提交并活跃的事务中最小的XID，记录在快照的xmin中选取所有已提交事务中最大的XID，**加1**后记录在xmax中</code></pre><p>2.注意: 上文中在PostgreSQL中<code>snapshot</code>的概念, 对应MySQL中, 其实就是你在网上看到的<code>read view</code>,<code>快照</code>这些概念;<br>    比如<a href="http://hedengcheng.com/?p=148#_Toc322691905" target="_blank" rel="external">何登成</a>就有关于<code>Read view</code>的介绍;<br>    而 <a href="https://www.cnblogs.com/digdeep/p/4947694.html" target="_blank" rel="external">此文</a> 却仍是使用<code>快照</code>来介绍;</p><p>3.read view 主要是用来做可见性判断的, 比较普遍的解释便是”本事务不可见的当前其他活跃事务”, 但正是该解释, 可能会造成一节理解上的误区, 所以此处提供两个参考, 供给大家<strong>避开理解误区</strong>:</p><pre><code>- read view中的`高水位low_limit_id`可以参考 &quot;https://github.com/zhangyachen/zhangyachen.github.io/issues/68&quot;, &quot;https://www.zhihu.com/question/66320138(呵呵一笑百媚生)&quot;- 如果单纯按照&apos;https://www.jianshu.com/p/fd51cb8dc03b&apos;中的read view介绍来理解, 在rc级别下做演示, 就会发现使用该算法会出错!- 其实上面第1点中加粗部分也是相关高水位的介绍( 注意进行了+1 )</code></pre><p>4.另外, 对于read view快照的生成时机, 也非常关键, <strong>也正是因为生成时机的不同, 造成了RC,RR两种隔离级别的不同可见性</strong>, 可以参考 <a href="http://www.sohu.com/a/194511597_610509" target="_blank" rel="external">http://www.sohu.com/a/194511597_610509</a>, <a href="https://www.cnblogs.com/digdeep/p/4947694.html" target="_blank" rel="external">https://www.cnblogs.com/digdeep/p/4947694.html</a> 两篇文章;</p><pre><code>- 在innodb中(默认repeatable read级别), 事务在begin/start transaction之后的第一条select读操作后, 会创建一个快照(read view), 将当前系统中活跃的其他事务记录记录起来;- 在innodb中(默认repeatable committed级别), 事务中每条select语句都会创建一个快照(read view);- [参考](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_consistent_read)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">With REPEATABLE READ isolation level, the snapshot is based on the time when the first read operation is performed.</div><div class="line"> 使用REPEATABLE READ隔离级别，快照是基于执行第一个读操作的时间。</div><div class="line">With READ COMMITTED isolation level, the snapshot is reset to the time of each consistent read operation.</div><div class="line">使用READ COMMITTED隔离级别，快照被重置为每个一致的读取操作的时间。</div></pre></td></tr></table></figure></code></pre><p>5.undo-log </p><ul><li><p>可以参考<a href="http://mysql.taobao.org/monthly/2015/04/01/" target="_blank" rel="external">数据库内核月报2015/04/01</a></p><blockquote><p>前言 </p><ul><li>Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。</li><li>Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作（例如bug#69812）。</li><li>大多数对数据的变更操作包括INSERT/DELETE/UPDATE，其中INSERT操作在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除（谁会对刚插入的数据有可见性需求呢！！），而对于UPDATE/DELETE则需要维护多版本信息，在InnoDB里，UPDATE和DELETE操作产生的Undo日志被归成一类，即update_undo</li></ul></blockquote></li><li><p>另外, 在回滚段中的undo logs分为: <code>insert undo log</code> 和 <code>update undo log</code></p><ul><li>insert undo log : 事务对insert新记录时产生的undolog, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。</li><li>update undo log : 事务对记录进行delete和update操作时产生的undo log, 不仅在事务回滚时需要, 一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。</li></ul></li></ul><p>6.InnoDB存储引擎在数据库每行数据的后面添加了三个字段</p><ul><li><p>6字节的<code>事务ID</code>(<code>DB_TRX_ID</code>)字段: 用来标识最近一次对本行记录做修改(insert|update)的事务的标识符, 即最后一次修改(insert|update)本行记录的事务id。<br>  至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted, <strong>并非真正删除</strong>。</p></li><li><p>7字节的<code>回滚指针</code>(<code>DB_ROLL_PTR</code>)字段: 指写入回滚段(rollback segment)的 <code>undo log</code> record (撤销日志记录记录)。<br>  如果一行记录被更新, 则 <code>undo log</code> record 包含 ‘重建该行记录被更新之前内容’ 所必须的信息。</p></li><li><p>6字节的<code>DB_ROW_ID</code>字段: 包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。<br>  结合聚簇索引的相关知识点, 我的理解是, 如果我们的表中没有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 但聚簇索引会使用DB_ROW_ID的值来作为主键; 如果我们有自己的主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID 了 。<br>  关于聚簇索引, 《高性能MySQL》中的篇幅对我来说已经够用了, 稍后会整理一下以前的学习笔记, 然后更新上来。</p></li></ul><p>7.可见性比较算法（这里每个比较算法后面的描述是建立在rr级别下，rc级别也是使用该比较算法,此处未做描述）<br>设要读取的行的最后提交事务id(即当前数据行的稳定事务id)为 <code>trx_id_current</code><br>当前新开事务id为 <code>new_id</code><br>当前新开事务创建的快照<code>read view</code> 中最早的事务id为<code>up_limit_id</code>, 最迟的事务id为<code>low_limit_id</code>(注意这个low_limit_id=未开启的事务id=当前最大事务id+1)<br>比较:</p><ul><li>1.<code>trx_id_current &lt; up_limit_id</code>, 这种情况比较好理解, 表示, 新事务在读取该行记录时, 该行记录的稳定事务ID是小于, 系统当前所有活跃的事务, 所以当前行稳定数据对新事务可见, 跳到步骤5.</li><li>2.<code>trx_id_current &gt;= trx_id_last</code>, 这种情况也比较好理解, 表示, 该行记录的稳定事务id是在本次新事务创建之后才开启的, 但是却在本次新事务执行第二个select前就commit了，所以该行记录的当前值不可见, 跳到步骤4。</li><li>3.<code>trx_id_current &lt;= trx_id_current &lt;= trx_id_last</code>, 表示: 该行记录所在事务在本次新事务创建的时候处于活动状态，从up_limit_id到low_limit_id进行遍历，如果trx_id_current等于他们之中的某个事务id的话，那么不可见, 调到步骤4,否则表示可见。</li><li>4.从该行记录的 DB_ROLL_PTR 指针所指向的回滚段中取出最新的undo-log的版本号, 将它赋值该 <code>trx_id_current</code>，然后跳到步骤1重新开始判断。</li><li>5.将该可见行的值返回。</li></ul><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>1.下面是一个非常简版的演示事务对某行记录的更新过程, 当然, InnoDB引擎在内部要做的工作非常多:<br><img src="/img/mysql/mvcc/yanshi_01.png" width="600" height="819/"></p><p>2.下面是一套比较算法的应用过程<br><img src="/img/mysql/mvcc/yanshi_02.png" width="602/"><br><img src="/img/mysql/mvcc/yanshi_03.png" width="602/"><br>也可参考<a href="https://github.com/zhangyachen/zhangyachen.github.io/issues/68中的案例" target="_blank" rel="external">https://github.com/zhangyachen/zhangyachen.github.io/issues/68中的案例</a></p><h2 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h2><p>1.MySQL的InnoDB存储引擎默认事务隔离级别是RR(可重复读), 是通过 “行排他锁+MVCC” 一起实现的, 不仅可以保证可重复读, 还可以<strong>部分</strong>防止幻读;</p><p>2.为什么是部分防止幻读, 而不是完全防止?</p><ul><li>效果: 在如果事务B在事务A执行中, insert了一条数据并提交, 事务A再次查询, 虽然读取的是undo中的旧版本数据(防止了部分幻读), 但是事务A中执行update或者delete都是可以成功的!!</li><li>因为在innodb中的操作可以分为<code>当前读(current read)</code>和<code>快照读(snapshot read)</code>:</li></ul><p>3.快照读(snapshot read)<br>    简单的select操作(当然不包括 select … lock in share mode, select … for update)</p><p>4.当前读(current read) <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" target="_blank" rel="external">官网文档 Locking Reads</a></p><ul><li>select … lock in share mode</li><li>select … for update</li><li>insert</li><li>update</li><li>delete<br>在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。<br>innodb在快照读的情况下并没有真正的避免幻读, 但是在当前读的情况下避免了不可重复读和幻读!!! </li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>一般我们认为MVCC有下面几个特点：</p><ul><li>每行数据都存在一个版本，每次数据更新时都更新该版本</li><li>修改时Copy出当前版本, 然后随意修改，各个事务之间无干扰</li><li>保存时比较版本号，如果成功(commit)，则覆盖原记录, 失败则放弃copy(rollback)</li><li>就是每行都有版本号，保存时根据版本号决定是否成功，<strong>听起来含有乐观锁的味道, 因为这看起来正是，在提交的时候才能知道到底能否提交成功</strong></li></ul></li><li><p>而InnoDB实现MVCC的方式是:</p><ul><li>事务以排他锁的形式修改原始数据</li><li>把修改前的数据存放于undo log，通过回滚指针与主数据关联</li><li>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</li></ul></li><li><p><strong>二者最本质的区别是</strong>: 当修改数据时是否要<code>排他锁定</code>，如果锁定了还算不算是MVCC？</p></li></ol><ul><li>Innodb的实现真算不上MVCC, 因为并没有实现核心的多版本共存, <code>undo log</code> 中的内容只是串行化的结果, 记录了多个事务的过程, 不属于多版本共存。但理想的MVCC是难以实现的, 当事务仅修改一行记录使用理想的MVCC模式是没有问题的, 可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的MVCC就无能为力了。</li><li>比如, 如果事务A执行理想的MVCC, 修改Row1成功, 而修改Row2失败, 此时需要回滚Row1, 但因为Row1没有被锁定, 其数据可能又被事务B所修改, 如果此时回滚Row1的内容，则会破坏事务B的修改结果，导致事务B违反ACID。 这也正是所谓的 <code>第一类更新丢失</code> 的情况。</li><li>也正是因为InnoDB使用的MVCC中结合了排他锁, 不是纯的MVCC, 所以第一类更新丢失是不会出现了, 一般说更新丢失都是指第二类丢失更新。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.jianshu.com/p/fd51cb8dc03b" target="_blank" rel="external">最初读的一篇文章</a></li><li>关于read view创建时机: <ul><li><a href="http://www.sohu.com/a/194511597_610509" target="_blank" rel="external">http://www.sohu.com/a/194511597_610509</a></li><li><a href="https://www.cnblogs.com/digdeep/p/4947694.html" target="_blank" rel="external">https://www.cnblogs.com/digdeep/p/4947694.html</a></li><li><a href="https://www.zhihu.com/question/265280455/answer/292022808" target="_blank" rel="external">https://www.zhihu.com/question/265280455/answer/292022808</a></li></ul></li><li>关于比较算法 low_limit_id 高水位事务: <ul><li><a href="https://github.com/zhangyachen/zhangyachen.github.io/issues/68" target="_blank" rel="external">https://github.com/zhangyachen/zhangyachen.github.io/issues/68</a></li><li><a href="https://www.zhihu.com/question/66320138" target="_blank" rel="external">https://www.zhihu.com/question/66320138</a></li><li><a href="https://www.zhihu.com/question/265280455/answer/292022808" target="_blank" rel="external">https://www.zhihu.com/question/265280455/answer/292022808</a></li></ul></li><li>大咖问答:<a href="https://www.zhihu.com/inbox/4577674200" target="_blank" rel="external">https://www.zhihu.com/inbox/4577674200</a></li><li>更多可以参考数据库内核月报:<ul><li><a href="https://yq.aliyun.com/articles/303200?spm=5176.100240.searchblog.9.271fd153pQ9FgV" target="_blank" rel="external">https://yq.aliyun.com/articles/303200?spm=5176.100240.searchblog.9.271fd153pQ9FgV</a></li></ul></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html" target="_blank" rel="external">官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(Multiversion Concurrency Control)&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近正在啃《高性能MySQL》这本书, 当看到事务相关知
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="事务" scheme="http://blog.renyimin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="MVCC" scheme="http://blog.renyimin.com/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>MySQL(INNODB引擎)高并发事务问题及解决方案</title>
    <link href="http://blog.renyimin.com/2017/12/27/2017-12-27-mysql_transaction-01/"/>
    <id>http://blog.renyimin.com/2017/12/27/2017-12-27-mysql_transaction-01/</id>
    <published>2017-12-27T13:01:07.000Z</published>
    <updated>2018-01-18T12:39:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h2><ol><li><p>事务：可以理解为一个 <strong>独立的</strong> 工作单元, <strong>在这个独立的工作单元中, 可以有一组操作; 放在这个独立工作单元中的一组操作, 要么全部执行成功, 要么全部执行失败</strong>。</p></li><li><p>仍然通过最经典的银行转账应用来解释一下: 假设有两个角色 ‘Iron Man’(余额500), ‘Wolverine’(余额15), 现在 ‘Iron Man’ 通过该银行应用给 ‘Wolverine’ 转账100元, 那么本次转账操作至少需要三个步骤</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">检查`Iron Man`余额`&gt;=100`元</div><div class="line">从`Iron Man`余额中`-100`元</div><div class="line">给`Wolverine`余额`+100`元</div></pre></td></tr></table></figure></li><li><p><strong>注意</strong>: 上面的三个步操作，其实就需要打包在一个事务中, 这样就可以保证一组操作可以作为一个 <code>独立的工作单元</code> 来执行。并且在 <code>独立工作单元</code>(即事务) 中的这三个操作, 只要有任何一个操作失败, 则事务就整体就是失败的, 那就必须回滚所有已经执行的步骤。<br> 假设第二步操作成功, 但是第三步操作失败, 那么整个事务也就应该是失败的, 那就必须将第二步的操作也回滚。(其实这里也体现了事务最基本的一个特性: <strong>保证数据的一致性</strong>)</p></li><li><p>当然, 在真实高并发场景下, 事务需要做的事情其实还很多, 因为高并发会出现很多意想不到的问题, 后面会简要分析一下可能会出现的一些问题。</p></li></ol><h2 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h2><p>在分析高并发事务的问题前, 我们要先熟悉一下<strong>事务的几个标准特性</strong>, 因为一个运行良好的事务处理系统必须具备这些标准特性, 而且这些高并发问题的解决也离不开事务的这几个标准特性!!! </p><ol><li><p>Atomicity 原子性<br> 一个事务必须被视为<code>一个不可分割的最小工作单元</code>, 整个事务中的所有操作要么全部提交成功, 要么全部失败回滚。<br> 对于一个事务来说, 不能只成功执行其中的一部分操作, 这就是事务的原子性。</p></li><li><p>Consistency 一致性<br> 你大概可以这样来理解: 虽然数据表中的数据可能一直在变化, 但是事务的<code>一致性</code>特性总是能够保证 <strong>数据库总是从一个一致性的状态 转换到 另一个一致性的状态</strong>; 比如在之前的转账例子:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">转账前的一致性状态是: &apos;Iron Man&apos;(余额500), &apos;Wolverine&apos;(余额15)</div><div class="line">转账成功后的一致性状态是: &apos;Iron Man&apos;(余额400), &apos;Wolverine&apos;(余额115)</div><div class="line">转账如果失败的话, 一致性的状态应该回滚到转账前的状态: &apos;Iron Man&apos;(余额500), &apos;Wolverine&apos;(余额15)</div></pre></td></tr></table></figure></li><li><p><strong>Isolation 隔离性</strong></p><ul><li><p><strong>通常来说</strong>, 一个事务所做的修改在最终提交以前, 对其他事务是不可见的;<br>比如在之前的转账例子中, 在执行完成第二步, 但是第三步还没开始的时候, 此时有另一个账户汇总的程序开始运行, <strong>那么这个程序所拿到的A账户余额应该是没有被减100的余额才对</strong></p></li><li><p>后面我们还会详细讨论事务<code>隔离性</code>的 <code>隔离级别</code>, 到时候就知道这里为什么说<code>通常来说</code>对其他事务是不可见的; (也就是还有特例, 比如最低隔离级别 <code>READ UNCOMMITTED</code>, 对其他事务的可见就造成了<code>脏读问题</code>的出现)</p></li><li><p>事务有四种隔离级别(从低到高: <code>READ UNCOMMITTED</code>, <code>READ COMMITTED</code>, <code>REPEATABLE READ</code>, <code>SERIALIZABLE</code>)</p></li></ul></li><li><p>Durability 持久性<br> 一旦事务被最终提交, 则在事务这个独立单元中的所有操作所做的修改将会 <code>永久保存到数据库中</code>; (这里所说的<code>永久</code>可以理解为 被事务修改的数据 是真正存放到了表中, 而不是存放在了诸如临时表之类的地方。)</p></li></ol><h2 id="高并发事务的问题"><a href="#高并发事务的问题" class="headerlink" title="高并发事务的问题"></a>高并发事务的问题</h2><p>在并发量比较大的时候, 很容易出现 <strong>多个事务同时进行</strong> 的情况。假设有两个事务正在同时进行, <strong>值得注意的是</strong>: 它们两者之间是互相不知道对方的存在的, 各自都对自身所处的环境<strong>过分乐观</strong>, 从而并没有对自己所操作的数据做一定的保护处理, 所以<strong>最终导致了一些问题的出现</strong>;</p><p>接下来, 在分析高并发事务的问题时, 你可能已经了解过一些关于锁的概念, 但是接下来分析这些高并发问题时, 暂时不会带入锁的概念, 只会列出问题, 并直接告诉你各个问题是使用事务隔离性的哪个隔离级别来解决掉的;</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><ol><li><p>如果mysql中一个事务A读取了另一个并行事务B未最终提交的写数据, 那事务A的这次读取就是<code>脏读</code>。(因为事务A读取的是’脏数据’, 是’非持久性’的数据)</p><ul><li>之所以说是’非持久性数据’, ‘脏数据’, 是因为事务B最终可能会因为内部其他后续操作的失败或者系统后续突然崩溃等原因, 导致事务最终整体提交失败, 那么事务A此时读取到的数据在表中其实会被回滚, 那事务A拿到的自然就是脏的数据了。</li><li>图示:<br><img src="/img/mysql/transaction/dirty_read.png" width="608" height="190"></li></ul></li><li><p>事务A在T4阶段读取库存为20, 这个库存其实就属于<code>脏数据</code>, 因为事务B最终会回滚这个数据, 所以如果事务A使用库存20进行后续的操作, 就会引发问题, 因为事务A拿到的数据已经和表中的真实数据不一致了。</p></li><li><p>那么这个问题如何解决呢?<br> 在MySQL中, 其实事务已经用自身特性(<code>隔离性</code>的 – <code>READ COMMITED</code>或以上隔离级别)解决了这个问题;<br> <strong><code>READ COMMITED</code>级别保证了, 只要是当前语句执行前已经提交的数据都是可见的</strong>。</p></li></ol><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><ol><li><p>假设现在上面的 <code>脏读问题</code> 已经被完全解决了, 那就意味着事务中每次读取到的数据都是 <code>持久性</code> 的数据(被别的事务最终 提交/回滚 完成后的数据)。</p></li><li><p>但是你需要知道的是: 解决了脏读问题, 只是能保证你在事务中每次读到的数据都是持久性的数据而已!!!!</p></li><li><p>如果在一个事务中多次读取同一个数据, 正好在两次读取之间, 另外一个事务确实已经完成了对该数据的修改并提交, 那问题就来了: 可能会出现多次读取结果不一致的现象。<br><img src="/img/mysql/transaction/bukechongfudu.png" width="607" height="204"></p></li><li><p>那么这个问题如何解决呢?<br> 在MySQL中, 事务已经用自身特性(<code>隔离性</code>的 – <code>REPEATABLE READ</code>或以上隔离级别)解决了这个问题;<br> <strong><code>REPEATABLE READ</code>级别保证了, 只要是当前事务执行前已经提交的数据都是可见的</strong>。</p></li></ol><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><ol><li><p>由于很多人(当然也包括本人), 容易搞混 <code>不可重复读</code> 和 <code>幻读</code>, 这两者确实非常相似。</p><ul><li>但 <code>不可重复读</code> 主要是说多次读取一条记录, 发现该记录中某些列值被修改过。 </li><li>而 <code>幻读</code> 主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计), 发现结果不一致(比如发现增加/减少了一条记录)。(可以参考<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html" target="_blank" rel="external">MySQL官方文档对 Phantom Rows 的介绍</a>)</li></ul></li><li><p>其实对于 <code>幻读</code>, MySQL的InnoDB引擎默认的<code>RR</code>级别已经通过<code>MVCC自动帮我们解决了</code>(并非完全解决), 所以该级别下, 你也模拟不出幻读的场景; 退回到 <code>RC</code> 隔离级别的话, 你又容易把<code>幻读</code>和<code>不可重复读</code>搞混淆, 所以这可能就是比较头痛的点吧!</p><p> 另外可以参考《高性能MySQL》对 <code>RR</code> 隔离级别的描述 </p><blockquote><p>理论上RR级别是无法解决幻读的问题, 但是由于InnoDB引擎的RR级别还使用了MVCC, 所以也就避免了幻读的出现!</p></blockquote></li></ol><h3 id="幻读的延伸"><a href="#幻读的延伸" class="headerlink" title="幻读的延伸"></a>幻读的延伸</h3><p>MVCC虽然解决了<code>幻读</code>问题, 但严格来说, MVCC只是<strong>部分</strong>解决幻读问题, 接下来进行演示:</p><ol><li><p>打开客户端1查看隔离级别及初始数据</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @@SESSION.tx_isolation;</div><div class="line">+------------------------+</div><div class="line">| @@SESSION.tx_isolation |</div><div class="line">+------------------------+</div><div class="line">| REPEATABLE-READ        |</div><div class="line">+------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li><li><p>打开客户端2查看隔离级别及初始数据</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @@SESSION.tx_isolation;</div><div class="line">+------------------------+</div><div class="line">| @@SESSION.tx_isolation |</div><div class="line">+------------------------+</div><div class="line">| REPEATABLE-READ        |</div><div class="line">+------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li><li><p>在客户端2中开启事务, 然后查询数据</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mysql&gt; begin;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li><li><p>在客户端1中插入一条id为4的新数据 (直接自动提交)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mysql&gt; insert into test_transaction (`id`,`user_name`,`age`,`gender`,`desctiption`) values (4, &apos;死侍&apos;, 18, 0, &apos;A bad boy&apos;);</div><div class="line">Query OK, 1 row affected (0.00 sec)</div><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</div><div class="line">|  4 | 死侍    |  18 |      0 | A bad boy          |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">4 rows in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li><li><p>在客户端2事务中再次查询数据, 发现数据没有变化(表示<strong>可以重复读, 并且克服了幻读</strong>)!! <strong>但是在客户端2事务中插入一条id为4的新数据, 发现提示数据已经存在!!!</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">mysql&gt; begin;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; insert into test_transaction (`id`,`user_name`,`age`,`gender`,`desctiption`) values (4, &apos;死侍&apos;, 18, 0, &apos;A bad boy&apos;);</div><div class="line">1062 - Duplicate entry &apos;4&apos; for key &apos;PRIMARY&apos;    //( 后面会看到: 其实是因为insert是当前读)</div><div class="line">mysql&gt; </div><div class="line"></div><div class="line">//并且, 此时`update/delete`也是可以操作这条在事务中看不到的记录的! //( 后面会看到: update，delete也都是当前读)</div></pre></td></tr></table></figure></li><li><p>那么这是什么问题呢?</p><ul><li>可以参考<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="external">MySQL官方文档 – 一致性非阻塞读</a><blockquote><p>The snapshot of the database state applies to SELECT statements within a transaction, not necessarily to DML statements. If you insert or modify some rows and then commit that transaction, a DELETE or UPDATE statement issued from another concurrent REPEATABLE READ transaction could affect those just-committed rows, even though the session could not query them. If a transaction does update or delete rows committed by a different transaction, those changes do become visible to the current transaction.<br>个人认为应该翻译为: 数据库状态的快照适用于事务中的SELECT语句, 而不一定适用于所有DML语句。 如果您插入或修改某些行, 然后提交该事务, 则从另一个并发REPEATABLE READ事务发出的DELETE或UPDATE语句就可能会影响那些刚刚提交的行, 即使该事务无法查询它们。 如果事务更新或删除由不同事务提交的行, 则这些更改对当前事务变得可见。</p></blockquote></li></ul></li><li><p>其实, MVCC并发控制中的读操作分为两类: <code>快照读 (snapshot read)</code> 与 <code>当前读 (current read)</code></p><ul><li><a href="https://www.cnblogs.com/cat-and-water/p/6427612.html" target="_blank" rel="external">参考</a></li><li><p>在RR级别下, 快照读是通过MVVC(多版本控制)和undo log来实现的, 而当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。如果需要实时显示数据，还是需要通过加锁来实现。这个时候会使用next-key技术来实现。</p></li><li><p>快照读, 读取专门的快照 (对于RC，快照（ReadView）会在每个语句中创建。对于RR，快照是在事务启动时创建的), 快照读的操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">简单的select操作 (不包括: select ... lock in share mode, select ... for update)</div></pre></td></tr></table></figure></li><li><p>当前读, 读取最新版本的记录, 没有快照。 在InnoDB中，当前读取根本不会创建任何快照。当前读的操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select ... lock in share mode</div><div class="line">select ... for update</div><div class="line">insert</div><div class="line">update</div><div class="line">delete</div></pre></td></tr></table></figure></li></ul></li><li><p>当然, 使用<code>隔离性</code>的最高隔离级别<code>SERIALIZABLE</code>也可以解决<code>幻读</code>, 但该隔离级别在实际中很少使用!</p></li></ol><h2 id="更新丢失"><a href="#更新丢失" class="headerlink" title="更新丢失"></a>更新丢失</h2><ol><li><p>最后聊一下<code>高并发事务</code>的另一个问题 – <code>丢失更新问题</code>, 该问题和之前几个问题需要区分开, 因为解决方案不是一类!</p></li><li><p>第一类丢失更新: A事务撤销时, 把已经提交的B事务的更新数据覆盖了。<br> <img src="/img/mysql/transaction/diushigengxin_01.png" width="608" height="243"><br> 不过, 通过后面<a href="/2017/08/01/2017-08-01-mysql_mvcc/">MVCC相关文章</a>最后的小结你会了解到, 这类更新丢失问题是不会出现的, 因为InnoDB存储引擎的隔离级别都使用了排他锁, 即使是 MVCC也不是纯MVCC, 也用到了排他锁! 这样的话事务A在未完成的时候, 其他事务是无法对事务A涉及到的数据做修改并提交的。</p></li><li><p>第二类丢失更新: A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失。<br> <img src="/img/mysql/transaction/diushigengxin_02.png" width="608" height="246"><br> 此类更新丢失问题, 无法依靠前三种隔离级别来解决, 只能用最高隔离级别 <code>Serializable</code> 或者手动使用<code>乐观锁</code>, <code>悲观锁</code>来解决。<br> 当然, 更新操作不是在所有情况下都会导致丢失更新问题, 如果你更改的最终状态是确定的, 而不是类似递减或者递增, 那是不会造成丢失更新问题的!!</p></li><li><p>最高隔离级别<code>Serializable</code>在实际应用场景中并不被采用, 对于手动使用<code>乐观锁</code>, <code>悲观锁</code>的方案, 将会在以后关于锁的文章中一并给出!</p></li></ol><p>参考资料:</p><ul><li><a href="http://mysql.taobao.org/monthly/2017/06/07/" target="_blank" rel="external">淘宝数据库内核6月报</a></li><li>《高性能MySQL》</li><li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="external">美团技术博客</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/" target="_blank" rel="external">MySQL官方文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事务的概念&quot;&gt;&lt;a href=&quot;#事务的概念&quot; class=&quot;headerlink&quot; title=&quot;事务的概念&quot;&gt;&lt;/a&gt;事务的概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;事务：可以理解为一个 &lt;strong&gt;独立的&lt;/strong&gt; 工作单元, &lt;strong&gt;在这个
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="事务" scheme="http://blog.renyimin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>&lt;HTTP权威指南&gt;学习--第17章 内容协商与转码 (300)</title>
    <link href="http://blog.renyimin.com/2017/12/06/2017-12-06-HTTP-06-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E4%B8%8E%E8%BD%AC%E7%A0%81%20/"/>
    <id>http://blog.renyimin.com/2017/12/06/2017-12-06-HTTP-06-内容协商与转码 /</id>
    <published>2017-12-06T10:50:27.000Z</published>
    <updated>2018-02-06T14:30:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p><strong>一个URL常常需要代表若干不同的资源</strong>: 例如那种需要以多种语言提供其内容的网站站点。<br> 如果某个站点有 ‘说法语的’ 和 ‘说英语的’ 两种用户, 它可能想用这两种语言提供网站站点信息;<br> 理想情况下，服务器应当向英语用户发送英文版，向法语用户发送法文版; 而用户只要访问网站主页就可以得到相应语言的内容。</p></li><li><p>HTTP提供了 <code>内容协商</code> 方法，允许客户端和服务器作这样的决定。<br> 通过这些方法，单一的URL就可以代表不同的资源(比如，同一个网站页面的法语版和英语版)，这些不同的版本称为<code>变体</code>。</p></li><li><p>除了根据 <code>内容协商</code> 来决定URL代表的是那种版本的资源。另外, 对于有些特定的URL来说, 服务器还可以根据一些<strong>其他原则</strong>来决定发送什么内容给客户端最合适。在有些场合下, 服务器甚至可以自动生成定制的页面。比如，服务器可以为手持设备把HTML页面转换成WML页面，这类动态内容变换被称为<strong>转码</strong>。这些变换动作是HTTP客户端和服务器之间进行内容协商的结果。</p></li></ol><h2 id="内容协商技术"><a href="#内容协商技术" class="headerlink" title="内容协商技术"></a>内容协商技术</h2><ol><li><p>共有3种不同的方法可以决定服务器上哪个页面最适合客户端: <code>让客户端来选择</code>, <code>服务器自动判定</code>, 或 <code>让中间代理来选</code>。这3种技术分别称为<code>客户端驱动的协商</code>、<code>服务器驱动的协商</code> 以及 <code>透明协商</code></p></li><li><p>内容协商技术摘要如下:<br><img src="/img/http/内容协商.png" width="600"></p></li></ol><h3 id="客户端驱动-300"><a href="#客户端驱动-300" class="headerlink" title="客户端驱动 (300)"></a>客户端驱动 (300)</h3><p>1.对于服务器来说，收到客户端请求时只是发回响应，在其中列出可用的页面，让客户端决定要看哪个，这是最容易的事情。</p><ul><li>很显然，这是服务器最容易实现的方式，而且客户端很可能选择到最佳的版本(只要列表中有让客户端选择的足够信息)。</li><li>不利之处是<strong>每个页面都需要两次请求</strong>: <strong>第一次获取列表</strong>，<strong>第二次获取选择的副本</strong>。<br>这种技术速度很慢且过程枯燥乏味，让用户厌烦。</li></ul><p>2.从实现原理上来说，服务器实际上有两种方法为客户端提供选项:</p><ul><li>一是发送回一个HTML文档，里面有到该页面的各种版本的链接和每个版本的描述信息;</li><li>另一种方法是发送回HTTP/1.1响应时，使用 <code>300 Multiple Choices</code> 响应代码。客户端浏览器收到这种响应时，在前一种情况下(发回html文档的情况)，会显示一个带有链接的页面; 在后一种情况下，可能会弹出对话窗口，让用户做选择。不管怎么样，决定是由客户端的浏览器用户作出的</li></ul><p>3.除了增加时延并且对每个页面都要进行繁琐的多次请求之外, 这种方法<strong>还有一个缺点</strong>: 它需要多个URL, 公共页面要一个, 其他每种特殊页面也都要一个。</p><h3 id="服务器驱动"><a href="#服务器驱动" class="headerlink" title="服务器驱动"></a>服务器驱动</h3><p>1.之前已经知道了客户端驱动的协商存在的若干缺点。大部分缺点都涉及客户端和服务器之间通信量的增长, 这些通信量用来决定什么页面才是对请求的最佳响应。</p><p>2.而减少额外通信量的一种方法是<strong>让服务器来决定发送哪个页面回去</strong>，但为了做到这一点，<strong>客户端必须发送有关客户偏好的足够信息</strong>，以便服务器能够作出准确的决策。服务器通过 <code>客户端请求的首部集</code> 来获得这方面的信息(客户偏好)!! 有以下两种机制可供HTTP服务器评估发送什么响应给客户端比较合适：</p><ul><li>检査 客户端请求中的<code>内容协商首部集</code>: 服务器察看客户端发送的 <code>Accept内容协商首部集</code>, 设法用相应的响应首部与之匹配;</li><li>根据其他(非内容协商)首部进行变通, 例如，服务器可以根据客户端发送的 <code>User-Agent</code> 首部来发送响应</li></ul><h4 id="客户端内容协商首部集"><a href="#客户端内容协商首部集" class="headerlink" title="客户端内容协商首部集"></a>客户端内容协商首部集</h4><p>1.客户端可以用下面列出的HTTP首部集发送用户的偏好信息</p><blockquote><p>Accept : 告知服务器发送何种媒体类型<br>Accept-Language : 告知服务器发送何种语言<br>Accept-Charset : 告知服务器发送何种字符集<br>Accept-Encoding : 告知服务器采用何种编码</p></blockquote><p>2.<strong>实体首部集</strong> 和 <strong>内容协商首部集</strong></p><ul><li><strong>注意</strong>: 内容协商首部集与实体首部非常类似(比如 <code>Accept-Encoding</code> 和 <code>Content-Encoding</code>)。不过, 这两种首部的用途截然不同:</li><li><p><code>实体首部集</code>,像运输标签,它们描述了把报文从服务器传输给客户端的过程中必须的各种报文主体属性; 如下列出的实体首部集来匹配客户端的<code>Accept内容协商首部集</code></p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Accet首部            实体首部</div><div class="line">Accept    　　　　　　Content-Type</div><div class="line">Accept-Language     Content-Language</div><div class="line">Accept-Charset      Content-Type</div><div class="line">Accept-Encoding     Content-Encoding</div></pre></td></tr></table></figure><p>  （由于HTTP是无状态的协议，表示服务器不会在不同的请求之间追踪客户端的偏好，所以客户端必须在每个请求中都发送其偏好信息）</p></li><li><p>而<code>内容协商首部集</code>是由客户端发送给服务器用来告知其偏好信息的, 以便服务器可以从文档的不同版本中选择出最符合客户端偏好的那个来提供服务;</p></li></ul><p>3.如果两个客户端都发送了 <code>Accept-Language</code> 首部来描述它们感兴趣的语言信息, 服务器就能够决定发送www.joes-hardware.com的何种版本给哪个客户端了。<strong>让服务器选择发送回去的文档</strong>，减少了往返通信的时延，这种时延是<code>客户端驱动模型中</code>无法避免的。</p><p>4.然而, 假设某个客户端偏好西班牙文，那服务器应当回送哪个版本的页面呢？英语还是法语？<br>服务器只有两种选择：猜测 或 回退到客户端驱动模型,问客户端选择哪个。假如这个西班牙人碰巧懂一点英语，他可能会选择英文页面，这不是最理想的，但它能解决问题。<br>在这种情况下，这个西班牙人需要有办法传达更多与其偏好有关的信息，也就是他的确对英语略知一二，在没有西班牙语的时候，英语也行。</p><p>5.幸运的是，HTTP提供了一种机制，可以让与这个西班牙人情况类似的客户端更详细地描述其偏好。这种机制就是<strong>质量值(简称q值)</strong></p><h4 id="内容协商首部中的质量值"><a href="#内容协商首部中的质量值" class="headerlink" title="内容协商首部中的质量值"></a>内容协商首部中的质量值</h4><p>1.HTTP协议中定义了质量值，允许客户端为每种偏好类别列出多种选项，并为每种偏好选项关联一个优先次序。</p><ul><li>例如，客户端可以发送下列形式的<code>Accept-Language</code>首部：<code>Accept-Language: en; q=0.5, fr; q=0.0 , nl; q=1.0, tr; q=0.0</code><br>  其中q值的范围从0.0-1.0(0.0是优先级最低的，而1.0是优先级最高的)。<br>  上面列出的那个首部，说明该客户端最愿意接收荷兰语(缩写为nl)文档，但英语(缩写为en)文档也行; 无论如何，这个客户端都不愿意收到法语(缩写为fr)或土耳 其语(缩写为tr)的版本;</li></ul><p>2.<strong>注意</strong>: 偏好的排列顺序并不重要，只有与偏好相关的<code>q值</code>才是重要的;</p><h4 id="客户端其它请求首部集"><a href="#客户端其它请求首部集" class="headerlink" title="客户端其它请求首部集"></a>客户端其它请求首部集</h4><p>1.服务器也可以根据客户端其他请求首部集来匹配响应, 比如 <code>User-Agent</code> 首部。例如, 服务器知道老版本的浏览器不支持JavaScript语言，这样就可以向其发送不含有JavaScript的页面版本。</p><p>2.在这种情况下，没有q值机制可供査找”最近似”的匹配。服务器或者去找完全匹配，或者简单地有什么就给什么，这取决于服务器的实现。</p><p>3.由于缓存需要尽力提供所缓存文档中正确的”最佳”版本，HTTP协议定义了服务器在响应中发送的 <code>Vary</code> 首部。这个首部告知<strong>缓存</strong>,<strong>客户端</strong>,和<strong>所有下游的代理</strong>, 服务器根据哪些首部来决定发送响应的最佳版本。</p><h3 id="透明协商-vary首部"><a href="#透明协商-vary首部" class="headerlink" title="透明协商(vary首部)"></a>透明协商(vary首部)</h3><p>1.了支持<strong>透明内容协商</strong>，服务器必须有能力告知代理，服务器需要检査哪些请求首部，以便对客户端的请求进行最佳匹配。但是HTTP/1.1规范中没有定义任何透明协商机制, 不过却定义了 <code>Vary</code> 首部。服务器在响应中发送了Vary首部，以告知中间节点需要使用哪些请求首部进行内容协商<br>2.代理缓存可以为通过单个URL访问的文档保存不同的副本, <strong>如果服务器把它们的决策过程传给代理,这些代理就能代表服务器与客户端进行协商</strong>。<br>（缓存同时也是进行内容转码的好地方，因为部署在缓存里的通用转码器能对任意服务器，而不仅仅是一台服务器传来的内容进行转码）</p><p>3.对内容进行缓存的时候是假设内容以后还可以重用。然而，为了确保对客户端请求回送的是正确的已缓存响应, 缓存必须应用服务器在回送响应时所用到的大部分决策逻辑;</p><p>4.之前我们已经了解了客户端发送的<code>Accept内容协商首部集</code>; 也了解到, 为了给每条请求选择最佳的响应, 服务器使用了哪些与这些首部集匹配的相应<code>实体首部集</code>。其实, 代理缓存也必须使用相同的首部集来决定回送哪个已缓存的响应。</p><p>5.<strong>下图展示了涉及缓存的正确及错误的操作序列</strong>。</p><ul><li>缓存把第一个请求转发给服务器，并存储其响应。</li><li>对于第二个请求，缓存根据URL査找到了匹配的文档。但是，这份文档是法语版的，而请求者想要的是西班牙语版的。如果缓存只是把文档的法语版本发给请求者的话，它就犯了错误;</li><li>像上面2中提到的, 代理缓存也必须要根据客户端发送来的<code>内容协商首部</code>来给客户端返回正确的响应<br>  <img src="/img/http/cache-beiyong-error.png" width="550"></li></ul><h4 id="Vary首部"><a href="#Vary首部" class="headerlink" title="Vary首部"></a>Vary首部</h4><p>1.下面是浏览器和服务器发送的一些典型的请求及响应首部:<br>    <img src="/img/http/vary-01.png" width="490"></p><p>2.然而, 如果服务器的决策不是依据<code>Accept</code>首部集，而是比如<code>User-Agent</code>首部的话，情况会如何？<br>例如, 服务器可能知道老版本的浏览器不支持JavaScript语言, 因此可能会回送不包含JavaScript的页面版本。<br>如果服务器是根据其他首部来决定发送哪个页面的话, <strong>和Accept首部集一样, 缓存也必须知道这些首部是什么, 这样才能在选择回送的页面时做出同样的逻辑判断</strong>。</p><p>3.HTTP的 <code>Vary</code> 响应首部中列出了所有客户端请求首部, 服务器可用这些首部来选择文档或产生定制的内容(在常规的内容协商首部集之外的内容)。例如, 若所提供的文档取决于<code>User-Agent</code>首部, <code>Vary首部</code>就必须包含<code>User-Agent</code>;</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>当新的请求到达时, 代理缓存会根据<code>内容协商首部集</code>来寻找最佳匹配。但在把文档提供给客户端之前, <strong>它还必须检査服务器有没有在已缓存响应中发送Vary首部</strong>。</li><li>如果有Vary首部, 那么新请求中那些首部的值必须与旧的已缓存的响应的请求首部相同。(也就是说,代理缓存也会保存旧的请求的请求首部和响应首部, 下面一句话更加肯定这一点)</li><li>因为服务器可能会根据客户端请求的首部来改变响应, 为了实现透明协商, 代理缓存就必须为每个已缓存变体保存<strong>客户端请求首部</strong>和<strong>相应的服务器响应首部</strong>)<br> <img src="/img/http/vary-02.png" width="650"></li><li>如果某服务器的Vary首部看起来像 <code>Vary: User-Agent, Cookie</code> 这样，大量不同的User-Agent和Cookie值将会产生非常多的变体, 而代理缓存必须为每个变体保存其相应的文档版本。当缓存执行査找时，首先会对内容协商首部集进行内容匹配，然后比较请求的变体与缓存的变体。如果无法匹配，缓存就从原始服务器获取文档</li></ol><h2 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h2><ol><li><p>我们已经讨论了一个机制, 该机制可以让客户端和服务器从某个URL的一系列文档中挑选出最适合客户端的文档。但是, 实现这些机制的前提是，存在一些满足客户端需求的文档—不管是完全满足还是在一定程度上满足;</p></li><li><p>然而, 如果服务器没有能满足客户端需求的文档会怎么样呢？服务器可以给出一个错误响应。但理论上，服务器可以把现存的文档转换成某种客户端可用的文档, 这种选项称为<strong>转码</strong>;</p></li><li><p>下面列出了一些假设的转码</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">转换之前 　　　　　　　　　　　　转换之后</div><div class="line">HTML文档    　　　　　　　　　　WML文档</div><div class="line">高分辨率图像    　　　　　　　　低分辨率图像</div><div class="line">彩色图像    　　　　　　　　　　黑白图像</div><div class="line">有多个框架的复杂页面    　　　　没有很多框架或图像的简单文本页面</div><div class="line">有Java小应用程序的HTML页面    没有Java小应用程序的HTML页面</div><div class="line">有广告的页面    　　　　　　　　去除广告的页面</div></pre></td></tr></table></figure></li><li><p>有3种类别的转码: <strong>格式转换</strong>、<strong>信息综合</strong>以及<strong>内容注入</strong></p></li></ol><h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><ol><li><p>格式转换是指将数据从一种格式转换成另一种格式, 使之可以被客户端査看。通过HTML到WML的转换, 无线设备就可以访问通常供桌面客户端査看的文档了。通过慢速连接访问Web页面的客户端并不需要接收高分辨率图像, 如果通过格式转换降低图像分辨率和颜色来减小图像文件大小的话, 这类客户端就能更容易地査看图像比较丰富的页面了。</p></li><li><p>格式转换可以由如下<code>内容协商首部集</code>来驱动, 但也能由 <code>User-Agent</code> 首部来驱动。注意: <code>内容转换或转码</code> 与 <code>内容编码</code> 或 <code>传输编码</code> 是不同的, 后两者一般用于更高效或安全地传输内容, 而前两者则可使访问设备能够査看内容;</p><pre><code class="php">Accet首部            实体首部Accept    　　　　　　Content-TypeAccept-Language     Content-LanguageAccept-Charset      Content-TypeAccept-Encoding     Content-Encoding</code></pre></li></ol><h3 id="信息综合"><a href="#信息综合" class="headerlink" title="信息综合"></a>信息综合</h3><ol><li><p>从文档中提取关键的信息片段称为信息综合(information synthesis), 这是一种有用的转码操作。这种操作的例子包括根据小节标题生成文档的大纲，或者从页面中删除广告和商标</p></li><li><p>根据内容中的关键字对页面分类是更精细的技术, 有助于总结文档的精髓。这种技术常用于Web页面分类系统中，比如门户网站的Web页面目录</p></li></ol><h3 id="内容注入"><a href="#内容注入" class="headerlink" title="内容注入"></a>内容注入</h3><p>参见P423</p><h3 id="转码与静态预生成的对比"><a href="#转码与静态预生成的对比" class="headerlink" title="转码与静态预生成的对比"></a>转码与静态预生成的对比</h3><ol><li><p>转码的替代做法是在Web服务器上建立Web页面的不同副本, 例如一个是HTML, 一个是WML, 一个图像分辨率高，一个图像分辨率低；一个有多媒体内容，一个没有。</p></li><li><p>但是，这种方法不是很切合实际，原因很多：</p><ul><li>某个页面中的任何小改动都会牵扯很多页面，需要很多空间来存储各页面的不同版本，而且使页面编目和Web服务器编程(以提供正确的版本)变得更加困难。</li><li>有些转码操作，比如广告插入(尤其是定向广告插入)，就不能静态实现, 因为插入什么广告和请求页面的用户有关</li></ul></li><li><p>对单一的根页面进行即时转换，是比静态的预生成更容易的解决方案。<br> 但这样会在提供内容时增加时延。不过有时候其中一些计算可以由第三方进行，这样就减少了Web服务器上的计算负荷——比如可以由代理或缓存中的外部Agent完成转换</p></li><li><p>下图显示了在代理缓存中进行的转码<br> <img src="/img/http/zhuanma-01.png" width="430"></p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><http权威指南></http权威指南>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;一个URL常常需要代表若干不同的资源&lt;/strong&gt;: 例如那种需要以多种语言提供其内容的网站站点。&lt;b
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP -- 实体和编码 (400, 411, 206)</title>
    <link href="http://blog.renyimin.com/2017/12/04/2017-12-04-HTTP-04-Entity-Header-Fields%20/"/>
    <id>http://blog.renyimin.com/2017/12/04/2017-12-04-HTTP-04-Entity-Header-Fields /</id>
    <published>2017-12-04T04:50:27.000Z</published>
    <updated>2018-02-07T11:35:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>主要讲解一些实体首部字段的相关知识</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1.要知道, 每天都有数以万计的各种媒体对象经由HTTP传送, 如图像, 文本, 影片以及软件程序等。只要你能叫出名字, HTTP就可以传送。<br>2.更重要的是: HTTP还会确保它的报文被正确传送, 识别, 提取以及适当处理</p><p>3.具体来说, <strong>HTTP要确保它所承载的”货物”满足以下条件</strong>:</p><ul><li><strong>符合用户的需要</strong>(基于<code>Accept</code>系列的内容协商首部)</li><li><strong>在网络上可以快速有效地传输</strong>(通过<code>范围请求</code>, <code>差异编码</code>以及<code>其他数据压缩方法</code>)</li><li><strong>完整到达, 未被篡改</strong>(通过传输编码首部和<code>Content-MD5</code>校验和首部)</li><li><strong>可以被正确识别</strong>(比如:通过<code>Content-Type</code>首部说明媒体格式, <code>Content-Language</code>首部说明语言), 以便浏览器和其他客户端能正确处理内容。</li><li><strong>可以被正确地解包</strong>(比如:通过<code>Content-Length</code>首部和<code>Content-Encoding</code>首部)。</li><li><strong>是最新的</strong>(通过实体验证码和缓存过期控制, 这一点第7章 缓存相关知识点已经介绍过)</li></ul><p>可以看到, HTTP要保证它所承载的货物完好的话, 会用到各种首部字段;</p><h2 id="报文实体"><a href="#报文实体" class="headerlink" title="报文实体"></a>报文实体</h2><p>1.HTTP响应报文中的报文实体由 <code>实体首部</code> 和 <code>实体主体</code> 组成; </p><ul><li>实体首部和实体主体之间以一个空白的CRLF行分隔;</li><li>实体主体中是原始数据, 所以需要 <code>实体首部</code> 来描述数据的意义;(例如 <code>Content-Type实体首部</code> 告诉我们数据的媒体格式…)。</li></ul><p>2.如下一个简单的HTTP响应报文:<br>    <img src="/img/http/15-01.png" width="350"></p><p>3.上面报文中:</p><ul><li>实体首部<code>Content-Type:text/plain</code>指出这是一个纯文本文档</li><li><code>Content-Length</code>首部指出它只有18个字节</li><li>一行空白(CRLF)把首部字段 和 主体的开始部分分隔开来</li></ul><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><ul><li>HTTP/1.1几个基本实体首部字段如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Content-Type : 实体中所承载对象的类型</div><div class="line">Content-Length 所传送实体主体的长度或大小</div><div class="line">Content-Encoding 对象数据所做的任意变换(比如,压缩)</div><div class="line">Content-Location 一个备用位置, 请求时可通过它获得对象</div><div class="line">Content-Range 如果这是部分实体, 这个首部说明它是整体的哪个部分</div><div class="line">Content-MD5 实体主体内容的校验和</div><div class="line">Last-Modified 所传输内容在服务器上创建或最后修改的日期时间</div><div class="line">Expires 实体数据将要失效的日期时间（为了兼容HTTP/1.0, 1.1中可以使用Cache-Control:max-age=..）</div><div class="line">Allow 该资源所允许的各种请求方法, 例如：GET和HEAD</div></pre></td></tr></table></figure></li></ul><h3 id="实体主体"><a href="#实体主体" class="headerlink" title="实体主体"></a>实体主体</h3><p>1.实体主体就是原始数据, 所以需要<code>实体首部</code>告诉我们如何去解释数据(content-type是图像还是文本,content-encoding是已被压缩或者重编码)<br>2.实体首部字段最后一以一个空白的CRLF行结束, 随后就是实体主体的原始内容, 不管内容是什么, 文本或二进制,文档或图像,压缩的或未压缩的, 英语,法语或日语,都紧随这个CRLF之后。</p><h2 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h2><p>1.<code>实体首部 Content-Length</code> 指示出报文主中实体主体的字节大小。</p><p>2.<strong>注意</strong>: 如果对文本文件进行了gzip压缩的话, Content-Length首部就是压缩后的大小, 而不是原始大小(后面在介绍<a href="http://localhost:4000/2017/12/04/2017-12-04-HTTP-04-Entity-Header-Fields%20/#%E5%86%85%E5%AE%B9%E7%BC%96%E7%A0%81%E8%BF%87%E7%A8%8B" target="_blank" rel="external">内容编码过程</a>的时候还会提及)。<br>    某些HTTP应用程序在这方面搞错了, 发送的是数据编码之前的大小, 这会导致严重的错误, 尤其是用在持久连接上。</p><p>3.除非使用了<code>分块编码</code>, 否则 <code>Content-Length</code> 实体首部就是带有实体主体的报文必须使用的; </p><ul><li>当然, 短连接自然也用不上content-length, 它依靠关闭连接就可以知道实体的大小</li><li><strong>使用Content-Length首部是为了能够检测出服务器崩溃而导致的<code>报文截尾</code>;</strong></li><li><strong>并对共享持久连接的多个报文进行正确分段</strong>。</li></ul><h3 id="检测截尾"><a href="#检测截尾" class="headerlink" title="检测截尾"></a>检测截尾</h3><p>1.HTTP早期版本采用<code>关闭连接</code>的办法来划定报文的结束; 但是, 没有 Content-Length 的话, 客户端无法区分到底是报文结束而导致正常的连接关闭, 还是在报文传输中由于服务器崩溃而导致的连接关闭; <strong>所以客户端需要 Content-Length 实体首部, 来监测报文截尾</strong></p><p>2.<code>报文截尾的问题</code> 对<strong>缓存服务器</strong>来说尤其严重, 如果缓存服务器收到被截尾的报文却没有识别出截尾的话, 它可能会存储不完整的内容并多次使用它来提供服务。<br>    <strong>缓存代理服务器通常不会为没有显示 Content-Length 首部的HTTP主体做缓存</strong>, 以此来减小缓存截尾报文的风险。</p><h3 id="Content-Length与持久连接"><a href="#Content-Length与持久连接" class="headerlink" title="Content-Length与持久连接"></a>Content-Length与持久连接</h3><p>1.<strong>Content-Length首部对于持久链接是必不可少的</strong>: 如果响应通过持久连接传送, 就可能有另一条HTTP响应紧随其后。客户端通过Content-Length首部就可以知道报文在何处结束,下一条报文从何处开始。因为连接是持久的, 客户端无法依赖连接关闭来判断报文的结束。<strong>所以需要有Content-Length来说明实体大小</strong></p><p>2.有一种情况, <strong>使用持久连接可以没有Content-Length首部</strong>，即<code>采用分块编码(chunked encoding)时</code>。</p><ul><li>在分块编码的情况下, 数据是分为一系列的块来发送的, <strong>每块都有大小说明</strong>。</li><li>哪怕服务器在生成首部的时候不知道整个实体的大小(通常是因为实体是动态生成的), 仍然可以使用分块编码传输若干已知大小的块。 </li></ul><h3 id="确定实体长度的规则"><a href="#确定实体长度的规则" class="headerlink" title="确定实体长度的规则"></a>确定实体长度的规则</h3><ul><li>Content-Length如果存在并且有效的话，则必须和消息内容的传输长度完全一致;</li><li>如果存在Transfer-Encoding(重点是chunked), 则在header中不能有Content-Length，有也会被忽视;</li><li>如果采用短连接，则直接可以通过<code>服务器关闭连接</code>来确定消息的传输长度。（这个很容易懂）<br>  在Http 1.0及之前版本中，content-length字段可有可无。因为这之前都不支持长连接.</li><li>在http1.1及之后版本, 如果是keep alive，<strong>则content-length和chunk必然是二选一</strong><br>  若是非keep alive，则和http1.0一样。content-length可有可无.</li></ul><p>为了和使用HTTP/1.0的应用程序兼容，任何带有实体主体的HTTP/1.1请求都必须带有正确的Content-Length首部字段(除非已经知道服务器兼容HTTP/1.1)<br>HTTP/1.1规范中建议对于带有主体但没有Content-Length首部的请求，服务器如果无法确定报文的长度，就应当发送 <code>400 Bad Request响应</code> 或 <code>411 Length Required</code> 响应，后一种情况表明服务器要求收到正确的Content-Length首部;</p><h2 id="实体摘要"><a href="#实体摘要" class="headerlink" title="实体摘要"></a>实体摘要</h2><h3 id="Content-MD5-数据的校验和"><a href="#Content-MD5-数据的校验和" class="headerlink" title="Content-MD5 数据的校验和"></a>Content-MD5 数据的校验和</h3><ol><li><p>尽管HTTP通常都是在像TCP/IP这样的可靠传输协议之上实现的, 但仍有很多因素会导致报文的一部分在传输过程中被修改;比如有不兼容的转码代理, 或者中间代理有误等等;</p></li><li><p>为检测实体主体的数据是否被不经意地修改, 发送方可以在生成初始的主体时, <strong>生成一个数据的 <code>校验和</code></strong>, 这样接收方就可以通过检査这个<code>校验和</code>来捕获所有意外的实体修改了;</p></li><li><p>服务器使用<code>Content-MD5</code>首部, 来发送对实体主体运行MD5算法的结果。</p><ul><li>只有产生响应的原始服务器可以计算并发送Content-MD5首部, <strong>中间代理和缓存不应当修改或添加这个首部</strong>, 否则就会与验证端到端完整性的这个最终目的相冲突。</li><li><code>Content-MD5</code>实体首部是在对内容做了所有需要的<code>内容编码</code>(content-encoding)之后, 还没有做任何<code>传输编码</code>(transfer-encoding)之前计算出来的。<br>  为了验证报文的完整性, 客户端必须先进行传输编码的解码, 然后计算所得到的未进行传输编码的实体主体的MD5;<br>  如果一份文档使用gzip算法进行压缩, 然后用分块编码发送, 那么就对整个经gzip压缩的主体进行MD5计算</li></ul></li><li><p>一般不常用到Content-MD5首部</p></li><li><p>作为对HTTP的扩展, 在IETF的草案中提出了其他一些摘要算法。这些扩展建议增加新的 <code>Want-Digest</code> 首部, 它允许客户端说明期望响应中使用的摘要类型，并使用质量值来建议多种摘要算法并说明优先顺序;</p></li></ol><h2 id="媒体类型和字符集简介"><a href="#媒体类型和字符集简介" class="headerlink" title="媒体类型和字符集简介"></a>媒体类型和字符集简介</h2><p><strong>Content-Type</strong></p><ol><li><p><code>Content-Type</code>实体首部字段说明了实体主体的MIME类型。MIME类型是标椎化的名字, 用于说明作为运载实体的基本媒体类型(比如:HTML文件, Microsoft Word文档或是MPEG视频等)。客户端应用程序使用MIME类型来解释和处理其内容。</p></li><li><p><code>Content-Type</code> 的值就是标椎化的MIME类型, 都在互联网号码分配机构IANA中注册。MIME类型由一个主媒体类型(比如:text,image或audio等)后面跟一条斜线一级一个子类型组成, 子类型用于进一步描述媒体类型。</p><ul><li>后面会详细讨论<a href="">MIME类型</a></li></ul></li><li><p><strong>要注意</strong>: <code>Content-Type</code> 实体首部, 说明的是原始实体主体的媒体类型, 例如, 经过内容编码的实体, <code>Content-Type</code> 首部说明的仍然是编码之前的实体主体的类型。</p></li><li><p>文本的字符编码</p><ul><li><code>Content-Type</code>首部还支持可选的参数来进一步说明内容的类型。charset(字符集)参数就是个例子, 它说明把实体中的比特转换为文本文件中的字符的方法:<code>Content-type:text/html;charset=iso-8859-4</code></li><li>后面会详细讨论<a href="">字符集</a></li></ul></li></ol><h2 id="内容编码-Content-Encoding"><a href="#内容编码-Content-Encoding" class="headerlink" title="内容编码 - Content-Encoding"></a>内容编码 - Content-Encoding</h2><p>HTTP应用程序有时在发送之前需要对内容进行编码。例如会把很大的HTML文档发送给通过慢速连接连上来的客户端之前, 服务器可能会对它进行<strong>压缩</strong>。</p><ul><li>这样有助于减少传输实体的时间。</li><li>服务器还可以把内容搅乱或加密,以此来防止未经授权的第三方看到文档的内容。</li><li>这种类型的编码是在发送方(可能是服务器也可能是代理缓存,下篇文章会看到 “缓存同时也是进行内容转码的好地方” 这句话)应用到内容之上的,当内容经过内容编码之后, 编好码的数据就放在实体主体中,像往常一样发送给接收方。 <h3 id="内容编码过程"><a href="#内容编码过程" class="headerlink" title="内容编码过程"></a>内容编码过程</h3></li></ul><ol><li>网站服务器生成原始响应报文, 其中有原始的 <code>Content-Type</code> 和 <code>Content-Length</code>首部;</li><li><p>内容编码服务器(也可能就是原始的服务器或下行的代理)创建编码后的报文。(编码后的报文Content-Type仍然和编码前相同, 但是Content-Length可能不同,比如主体被压缩了)。</p></li><li><p><strong>注意</strong>:</p><ul><li>Content-Type实体首部还需要出现在报文中, 因为它说明了实体的原始格式, 一旦实体被编码, 要显示的时候 ， 可能还是需要该信息才行的。、</li><li>Content-Length是编码之后的主体长度</li></ul></li><li><p>接收程序得到编码后的报文, 进行解码, 或得原始报文。    </p></li><li>可以参考下图:<br> <img src="/img/http/Content-Encoding-01.png" width="500"></li></ol><h3 id="内容编码类型"><a href="#内容编码类型" class="headerlink" title="内容编码类型"></a>内容编码类型</h3><h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a><code>Content-Encoding</code></h4><ol><li>HTTP定义了一些标准的内容编码类型, 并允许用扩展的形式添加更多的编码。由互联网号码分配机构(IANA)对各种编码进行标准化, 它给每个内容编码算法分配了唯一的代号。</li><li><code>Content-Encoding</code> 实体响应首部就用这些标准化的代号来说明编码时使用的算法;</li><li><p>编码算法(Content-Encoding值)如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gzip　　表明实体采用GNU zip编码</div><div class="line">compress 表明实体采用Unix的文件压缩程序</div><div class="line">deflate　　表明实体是用zlib的格式压缩的</div><div class="line">identity　　表明没有对实体进行编码。当没有Content-Encoding header时， 就默认为这种情况</div></pre></td></tr></table></figure><p> gzip, compress, 以及deflate编码都是无损压缩算法，用于减少传输报文的大小，不会导致信息损失。 其中gzip通常效率最高， 使用最为广泛。</p></li></ol><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a><code>Accept-Encoding</code></h4><ol><li>为了避免服务器使用客户端不支持的编码方式, 客户端就把自己支持的内容编码方式列表放在请求的 <code>Accept-Encoding</code> 首部里面发出去。</li><li>如果HTTP请求中没有包含 <code>Accept-Encoding</code> 首部, 服务器可以假设客户端能够接受任何编码方式(等价于发送<code>Accept-Encoding:*</code>)</li><li>如下展示了HTTP事务中对 <code>Accept-Encoding</code> 请求首部的使用<br> <img src="/img/http/accept-encoding-01.png" width="500"></li><li><code>Accept-Encoding</code> 字段包含用逗号分隔的的支持编码的列表, 下面是一些例子 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Accept-Encoding: compress,gzip</div><div class="line">Accept-Encoding: </div><div class="line">Accept-Encoding: *</div><div class="line">Accept-Encoding: compress;q=0.5, gzip;q=1.0</div><div class="line">Accept-Encoding: gzip;q=1.0, identity;q=0.5, *;q=0</div></pre></td></tr></table></figure></li></ol><h2 id="传输编码与分块编码"><a href="#传输编码与分块编码" class="headerlink" title="传输编码与分块编码"></a>传输编码与分块编码</h2><p><a href="http://localhost:4000/2017/11/30/2017-11-30-HTTP-04-General-Header-Fields/#Transfer-Encoding" target="_blank" rel="external">已经在通用首部字段中进行过介绍了</a><br>更多参考P375</p><h2 id="范围请求-断点续传"><a href="#范围请求-断点续传" class="headerlink" title="范围请求 - 断点续传"></a>范围请求 - 断点续传</h2><h3 id="accept-ranges-content-range-range"><a href="#accept-ranges-content-range-range" class="headerlink" title="accept-ranges, content-range, range"></a>accept-ranges, content-range, range</h3><ol><li><p>HTTP允许客户端只请求文档的一部分或者说某个范围。假设你正通过慢速的调制解调器连接下载最新的热门软件, 已经下了四分之三, 忽然因为一个网络故障, 连接中断了。你已经为等待下载完成耽误了很久, 而现在被迫要全部重头再来, 那多倒霉。</p></li><li><p>有了范围请求, HTTP客户端可以通过请求<strong>曾获取失败的实体</strong>的一个范围(或者说一部分), 来恢复下载该实体。当然这有一个前提，那就是从客户端上一次请求该实体到这次发出范围请求的时段内，该对象在服务器中没有改变过</p></li><li><p>例如:</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET /bigfile.html HTTP/<span class="number">1.1</span></div><div class="line">Host: www.joes-hardware.com </div><div class="line">Range: bytes=<span class="number">4000</span>-</div><div class="line">User-Agent: Mozilla/<span class="number">4.61</span> [en] (WinNT; I)</div></pre></td></tr></table></figure><p> 在本例中, 客户端请求的是文档开头4000字节之后的部分(不必给出结尾字节数, 因为请求方可能还不知道文档的大小)。（在客户端收到了开头的4000字节之后就失败的情况下, 可以使用这种形式的范围请求）</p></li><li><p>还可以用<code>Rang请求首部字段</code>来<strong>请求多个范围</strong>(这些范围可以按任意顺序给出, 也可以相互重叠)。</p><ul><li>例如,假设客户端同时连接到多个服务器, 为了加速下载文档<strong>而从不同的服务器下载同一个文档的不同部分</strong>。</li><li>对于客户端在一个请求内请求多个不同范围的情况, 返回的响应也是单个实体, 不过它会有一个<strong>多部分主体</strong>及<strong>Content-Type:multipart/byteranges首部</strong>。</li></ul></li><li><p>并不是所有服务器都接受范围请求，但很多服务器可以。</p><ul><li><p><strong>服务器可以通过在响应中包含响应首部字段<code>Accept-Ranges</code></strong>, 向客户端说明可以接受的范围请求。这个首部的值是计算范围的单位，通常是以字节计算的。例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> <span class="number">0</span>K</div><div class="line">Date: Fri, <span class="number">05</span> Nov <span class="number">2016</span> <span class="number">22</span>:<span class="number">35</span>:<span class="number">15</span> GMT</div><div class="line">Server: Apache/<span class="number">1.2</span><span class="number">.4</span></div><div class="line">Accept-Ranges: bytes</div></pre></td></tr></table></figure></li><li><p>服务器响应中的 <code>响应首部字段 accept-ranges</code>告诉客户端可以使用范围请求</p></li><li>对应的 客户端请求的 <code>请求首部字段range</code> 可以告知服务器此次请求的范围 (可以是多个范围)<br>接收到客户端请求中包含<code>range首部字段</code>的服务器, 会在处理请求之后返回状态码为 <code>206 Partial Content</code>的响应;<br>无法处理该范围请求时,则会返回状态码 200 ok响应及全部资源。</li><li>服务器响应中的 <code>Content-Range实体首部字段</code> 能告诉客户端作为响应返回的实体的哪个部分符合范围请求。<br>字段值以字节为单位(和服务器之前发回的accept-ranges首部字段说明的单位一样,都是字节)<br>还会告知当前发送的部分及整个实体大小；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Content-Range: bytes 5001-10000/1000</div></pre></td></tr></table></figure></li></ul></li><li><p>下图展示了范围请求的一系列HTTP事务的例子<br> <img src="/img/http/content-range_accept_ranges.png" width="500"></p></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>Range首部在流行的<code>点对点(Peer-to-Peer，P2P)</code>文件共享客户端软件中得到广泛应用, 它们从不同的对等实体同时下载多媒体文件的不同部分。</li><li>注意, 范围请求也属于一类实例操控, 因为它们是在客户端和服务器之间针对特定的对象实例来交换信息的。也就是说, 客户端的范围请求仅当客户端和服务器拥有文档的<strong>同一个版本</strong>时才有意义。**</li></ol><h2 id="扩展-–-差异编码"><a href="#扩展-–-差异编码" class="headerlink" title="扩展 – 差异编码"></a>扩展 – 差异编码</h2><ol><li><p>我们曾把网站页面的<strong>不同版本看作页面的不同实例</strong>。如果客户端有一个页面的已过期副本, 就要请求页面的最新实例。如果服务器有该页面更新的实例, 就要把它发给客户端, <strong>哪怕页面上只有一小部分发生了改变,也要把完整的新页面实例发给客户端</strong></p></li><li><p>若改变的地方比较少, 与其发送完整的新页面给客户端, <strong>客户端更愿意服务器只发送页面发生改变的部分</strong>, 这样就可以更快地得到最新的页面。</p></li><li><p><code>差异编码</code>是HTTP协议的一个扩展, 它通过交换对象改变的部分而不是完整的对象来优化传输性能。<br> 差异编码和范围请求一样, 也是<code>一类实例操控</code>, 因为它依赖客户端和服务器之间针对特定的对象实例来交换信息。</p></li></ol><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><ol><li><p>下图清楚地展示了差异编码的结构:包括请求、生成、接收和装配文档的全过程。<br> <img src="/img/http/A-IM--226.png" width="550"></p></li><li><p>客户端必须告诉服务器:</p><ul><li>它有页面的哪个版本</li><li>它愿意接受页面最新版的差异(<code>A-IM:diffe</code>)</li><li>它懂得哪些将差异应用于现有版本的算法</li></ul></li><li><p>服务器必须:</p><ul><li>检査它是否有这个页面的客户端现有版本</li><li>计算客户端现有版本与最新版之间的差异(有若干算法可以计算两个对象之间的差异), 然后服务器必须计算差异, 发送给客户端, 告知客户端所发送的是差异(<code>IM:diffe</code>), 并说明最新版页面的新标识(ETag), 因为客户端将差异应用于其老版本之后就会得到这个版本</li></ul></li><li><p>客户端在<code>If-None-Match</code>首部中使用的是它所持有页面版本的唯一标识, 这个标识是服务器之前响应客户端时在ETag首部中发送的。</p><ul><li>客户端是在对服务器说:”如果你那里页面的最新版本标识和这个ETag不同, 就把这个页面的最新版本发给我”。</li><li>如果只有<code>If-None-Match</code>首部，服务器将会把该页面的最新版本完整地发给客户端。(假设最新版和客户端持有的版本不同)</li></ul></li><li><p>不过, 如果客户端想告诉服务器它<strong>愿意接受该页面的差异</strong>, 那发送<code>A-IM</code>首部就可以了。</p><ul><li><code>A-IM</code>是<code>Accept-Instance-Manipulation(接受实例操控)</code>的缩写。</li><li>形象比喻的话, 客户端相当于这样说:”哦对了, 我能接受某些形式的实例操控, 如果你会其中一种的话, 就不用发送完整的文档给我了”。</li><li>在<code>A-IM</code>首部中, 客户端会说明<strong>它知道哪些算法可以把差异应用于老版本而得到最新版本</strong>, 服务端发送回下面这些内容:<br>  一个特殊的响应代码 —— <code>226 IM Used</code>, 告知客户端它正在发送的是所请求对象的实例操控, 而不是那个完整的对象自身;<br>  一个<code>IM(Instance-Manipulation的缩写)</code>首部, 说明用于计算差异的算法;<br>  新的 <code>ETag</code> 首部<br>  <code>Delta-Base</code> 首部, 说明用于计算差异的基线文档的ETag(理论上, 它应该和客户端之前请求里的if-None-Match首部中的ETag相同)</li></ul></li><li>下表总结了差异编码使用的首部<br> <img src="/img/http/A-IM_IM_Delta-Base.png" width="600"></li></ol><h3 id="实例操控-差异生成器-差异应用器"><a href="#实例操控-差异生成器-差异应用器" class="headerlink" title="实例操控,差异生成器,差异应用器"></a>实例操控,差异生成器,差异应用器</h3><ol><li>客户端可以使用<code>A-IM</code>首部说明可以接受的一些实例操控的类型。(比如有<code>diffe</code>)</li><li><p>而服务器在<code>IM</code>首部中说明使用的是何种实例操控。(比如是<code>diffe</code>)</p></li><li><p>不过到底哪些实例操控类型是可接受的呢？它们又是做什么的呢？下表中列出了一些在IANA注册的实例操控类型<br> <img src="/img/http/IANA.png" width="600"></p></li><li><p>更多差异编码相关的 <code>实例操控类型</code>, 可以查看P384</p></li><li><p>差异编码可以减少传输次数，但实现起来可能比较麻烦。</p></li></ol><ul><li>设想一下页面改动频繁，而且有很多不同的人都在访问的情形。支持差异编码的服务器必须保存页面随时间变化的所有不同版本，这样才能指出最新版本与所请求的客户端持有的任意版本之间的差异</li><li>如果文档变化频繁，而且有很多客户端都在请求文档，那它们就会获得文档的不同实例。随后当它们再向服务器发起请求时，它们将请求它们所持有的版本与最新版本之间的差异。为了能够只向它们发送变化的部分，服务器必须保存所有客户端曾经持有过的版本</li><li>要降低提交文档时的延迟时间，服务器必须增加磁盘空间来保存文档的各种旧的实例。实现差异编码所需的额外磁盘空间可能很快就会将减少传输量获得的好处抵消掉</li></ul><blockquote><p><http权威指南>学习–第15章</http权威指南></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;主要讲解一些实体首部字段的相关知识&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;1.要知道, 每天都有数以万计的各种媒体对象经由HTTP
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP -- cookie机制 (401)</title>
    <link href="http://blog.renyimin.com/2017/12/02/2017-12-02-HTTP-06-cookie/"/>
    <id>http://blog.renyimin.com/2017/12/02/2017-12-02-HTTP-06-cookie/</id>
    <published>2017-12-02T02:27:36.000Z</published>
    <updated>2018-02-28T08:56:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>HTTP最初是一个 <strong>匿名</strong>, <strong>无状态</strong> 的请求/响应协议; 服务器处理来自客户端的请求, 然后向客户端回送一条响应。Web服务器几乎没有什么信息可以用来判断是哪个用户发送的消息, 也无法记录来访用户的请求序列。</p></li><li><p>对于现代的Web站点我们, 我们知道, Web服务器可能会同时与成千上万个不同的客户端进行对话, 这些服务器通常都要记录下它们与谁交谈, 而不会认为所有的请求都来自匿名的客户端。因为现代的Web站点希望能够提供个性化的接触, 它希望对连接另一端的用户有更多的了解, 并且能在用户浏览页面时对其进行跟踪。</p></li><li><p>比如, Amazon.com可以通过以下几种方式实现站点的个性化:</p><ul><li>个性化问候 (专门为用户生成的欢迎词和页面内容, 使购物体验更加个性化)</li><li><strong>有的放矢的推荐</strong> (通过了解客户的兴趣, 推荐一些他们认为客户可能会感兴趣的商品。还可以在临近客户生日或其他一些重要日子的时候提供生日特定的商品)</li><li>管理信息的存档 (站点可以将用户的如地址,信用卡信息保存在一个数据库中, 只要他们识别出用户, 就可以使用该用户存档的管理信息, 而不是用户在购物时一次次地填写繁琐的地址和信用卡信息)</li><li>记录会话 (HTTP事务是无状态的, 每条请求/响应都是独立进行的。而很多Web站点希望能在用户与站点交互的过程中, 比如使用在线购物车的时候, 构建增量状态。要做到这一功能, <strong>Web站点就需要有一种方式来区分来自不同用户的HTTP事务</strong>)</li></ul></li><li><p>简而言之就是: HTTP无状态协议, 希望识别每个来自不同用户的HTTP事务; </p></li></ol><h2 id="HTTP识别用户的几种技巧"><a href="#HTTP识别用户的几种技巧" class="headerlink" title="HTTP识别用户的几种技巧"></a>HTTP识别用户的几种技巧</h2><ol><li>承载用户身份信息的HTTP首部</li><li>客户端IP地址跟踪, 通过用户的IP按地址对其进行识别</li><li>用户登录, 用认证方式来识别用户</li><li>胖URL, 一种在URL中嵌入识别信息的技术</li><li>cookie, 一种功能强大且高效的持久身份识别技术</li></ol><h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><ol><li><p>下面给出了7种最常见的用来承载用户相关信息的HTTP首部, 此处先讨论前3个, 后面4个首部用于更高级的识别技术</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Form请求首部字段, 用户的Email地址</div><div class="line">User-Agent请求首部字段, 用户的浏览器软件</div><div class="line">Refer请求首部字段, 用户是从这个页面上依照连接跳转过来的</div><div class="line">Authorization请求首部字段, 用户名和密码(稍后讨论)</div></pre></td></tr></table></figure></li><li><p><code>Form请求首部字段</code>: 包含了用户的Email地址, 每个用户都有不同的Email地址, 所以在理想情况下, 可以将这个地址作为可行的源端来识别用户。</p><ul><li>但是由于担心那些不讲道德的服务器会搜索这些E-mail地址, 用于垃圾邮件的发送, 所以<strong>很少有浏览器会发送Form首部</strong>;</li><li>实际上Form首部是由自动化机器人或蜘蛛发送的, 这样在出现问题时, 网管还有个地方可以发送愤怒的投诉邮件??</li></ul></li><li><p><code>User-Agent请求首部字段</code>：可以将用户所用的浏览器的相关信息告知服务器, 包括程序的名称和版本, 通常还包含操作系统的相关信息。</p><ul><li>要实现定制内容与特定的浏览器及其属性间的良好互操作时, 这个首部是非常有用的, 但<strong>它并没有为识别特定的用户提供太多有意义的帮助</strong>。</li></ul></li><li><p><code>Referer请求首部字段</code>: 提供了用户来源页面的URL</p><ul><li>Referer首部自身并不能完全标识用户, 但它确实说明了用户之前访问过哪个页面。</li><li>通过它可以更好地理解用户的浏览器行为, 以及用户的兴趣所在, 比如, 如果你是从一个篮球网站抵达某个Web服务器的,这个Web服务器可能会推断你是个篮球迷。</li></ul></li><li><p>总之, <code>Form</code>，<code>User-Agent</code>, <code>Referer</code> 这几个请求首部字段都<strong>不足以实现可靠的识别特定用户</strong>。</p></li></ol><h3 id="客户端IP地址"><a href="#客户端IP地址" class="headerlink" title="客户端IP地址"></a>客户端IP地址</h3><ol><li>通常HTTP首部并不提供客户端的IP地址, 但Web服务器可以通过其他方法找到另一端的IP地址。</li><li>但是, 使用客户端IP地址来识别用户存在很多缺点, 限制了将其作为用户识别技术的效能:<ul><li>客户端IP地址描述的是所用的机器，而不是用户。如果多个用户共享同一台计算机，就无法对其进行区分了；</li><li>很多因特网服务提供商都会在用户登录时为其动态分配IP地址。用户每次登录时，都会得到一个不同的地址，因此Web服务器不能假设IP地址可以在各登录会话之间标识用户；</li><li>为了提高安全性，并对稀缺的地址资源进行管理，很多用户都是通过网络地址转换(Network Address Translation, NAT)防火墙来浏览网络内容的。这些NAT设备隐藏了防火墙后面那些实际客户端的IP地址，将实际的客户端IP地址转换成了一个共享的防火墙IP地址和不同的端口号；</li><li>HTTP代理和网关通常会打开一些新的、到原始服务器的TCP连接。<strong>Web服务器看到的将是代理服务器的IP地址，而不是客户端的</strong>。有些代理为了绕过这个问题会添加特殊的<code>Client-IP</code>或<code>X-Forwarded-For</code>扩展首部来保存原始的IP地址，但并不是所有的代理都支持这种行为</li></ul></li></ol><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><ol><li>Web服务器无需被动地根据用户的IP地址来猜测他的身份，它可以要求用户通过用户名和密码进行认证登录来显式地询问用户是谁。</li><li><p>为了使Web站点的登录更加简便，HTTP中包含了一种内建机制，可以用 <code>www-Authenticate响应首部</code> 和 <code>Authorization请求首部</code> 向Web站点传送用户的相关信息。<br> 一旦登录，浏览器就可以不断地在每条发往这个站点的请求中发送这个登录信息了。这样，就总是有登录信息可用了</p></li><li><p>如果服务器希望在为用户提供对站点的访问之前，先行登录，可以向浏览器回送一条HTTP响应代码 <code>401 Login Required</code>。<br> 然后，浏览器会显示一个登录对话框，并用<code>Authorization首部</code>在下一条对服务器的请求中提供这些信息</p></li><li><p>如下图<br> <img src="/img/http/authorization-01.png" width="600/"></p><ul><li>在图a中，浏览器对站点www.joes-hardware.com发起了一条请求；</li><li>站点并不知道这个用户的身份，因此在图b中，服务器会返回 <code>401 Login Required HTTP响应码</code>，并添加 <code>www-Authentication响应首部</code>，要求用户登录。<br>这样浏览器就会弹出一个登录对话框；<br>只要用户输入了用户名和密码(对其身份进行完整性检査)，浏览器就会继续原来的请求。这次它会添加一个 <code>Authorization请求首部</code>，说明用户名和密码。对用户名和密码进行加密，防止那些有意无意的网络观察者看到；</li><li>现在，服务器已经知道用户的身份了，今后的请求要使用用户名和密码时，浏览器会自动将存储下来的值发送出去，甚至在站点没有要求发送的时候也经常会向其发送。浏览器在每次请求中都向服务器发送Authorization首部作为一种身份的标识，这样，只要登录一次，就可以在整个会话期间维持用户的身份了</li><li>但是，登录多个Web站点是很繁琐的。从一个站点浏览到另一个站点的时候，需要在每个站点上登录。更糟的是，很可能要为不同的站点记住不同的用户名和密码。访问很多站点，喜欢的用户名可能已经被其他人用过了，而且有些站点为用户名和密码的长度和组成设置了不同的规则</li></ul></li></ol><h2 id="胖URL"><a href="#胖URL" class="headerlink" title="胖URL"></a>胖URL</h2><ol><li><p>有些Web站点会<strong>为每个用户生成特定版本的URL来追踪用户的身份</strong>。通常, 会对真正的URL进行扩展, 在URL路径开始或结束的地方添加一些状态信息。<br> 用户浏览站点时, Web服务器会动态生成一些超链, 继续维护URL中的状态信息.</p></li><li><p>改动后包含了用户状态信息的URL被称为<code>胖URL(fat URL)</code>。下面是Amazon.com使用的一些胖URL实例, 每个URL后面都附加了一个用户特有的标识码, 在这个例子中就是002-1145265-8016838，这个标识码有助于在用户浏览商店内容时对其进行跟踪</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;/exec/obidos/tg/browse/-/229220/ref=gr_gifts/002-1145265-8016838&quot;&gt;All Gifts&lt;/a&gt;&lt;br&gt;</div><div class="line">&lt;a href=&quot;/exec/obidos/wishlist/ref=gr_pll_/002-1145265-8016838&quot;&gt;Wish List&lt;/a&gt;&lt;br&gt;</div></pre></td></tr></table></figure></li><li><p>可以通过胖URL将Web服务器上若干个独立的HTTP事务捆绑成一个”会话”或”访问”。<br> 用户首次访问这个Web站点时，会生成一个唯一的ID，用服务器可以识别的方式将这个ID添加到URL中去，然后服务器就会将客户端重新导向这个胖URL。<br> 不论什么时候，只要服务器收到了对胖URL的请求，就可以去査找与那个用户ID相关的所有增量状态(购物车、简介等)，然后重写所有的输出超链，使其成为胖URL，以维护用户的ID</p></li><li><p>可以在用户浏览站点时，用胖URL对其进行识别。但这种技术存在几个<strong>很严重的问题</strong>：</p><ul><li>丑陋的URL – 浏览器中显示的胖URL会给新用户带来困扰；</li><li>无法共享URL – 胖URL中包含了与特定用户和会话有关的状态信息。如果将这个URL发送给其他人，可能就在无意中将个人信息都共享出去了；</li><li>破坏缓存 – 为每个URL生成用户特有的版本就意味着不再有可供公共访问的URL需要缓存了；</li><li>额外的服务器负荷 – 服务器需要重写HTML页面使URL变胖；</li><li>逃逸口 – 用户跳转到其他站点或者请求一个特定的URL时，就很容易在无意中”逃离”胖URL会话, 只有当用户严格地追随预先修改过的链接时，胖URL才能工作。如果用户逃离此链接，就会丢失他的进展(可能是一个已经装满了东西的购物车)信息，得重新开始；</li><li>在会话间是非持久的，除非用户收藏了特定的胖URL，否则用户退出登录时，所有的信息都会丢失</li></ul></li></ol><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ol><li>cookie是当前识别用户，实现持久会话的最好方式。</li><li>cookie最初是由网景公司开发的, 但现在所有主要的浏览器都支持它。</li><li>cookie非常重要，而且它定义了一些新的HTTP首部。</li><li>cookie的存在也影响了缓存，大多数缓存和浏览器都不允许对任何cookie的内容进行缓存。</li></ol><h3 id="cookie的类型"><a href="#cookie的类型" class="headerlink" title="cookie的类型"></a>cookie的类型</h3><ol><li><p>可以笼统地将cookie分为两类：<code>会话cookie</code> 和 <code>持久cookie</code>。</p><ul><li><code>会话cookie</code> 是一种临时cookie，它记录了用户访问站点时的设置和偏好，用户退出浏览器时，会话cookie就被删除了。</li><li><code>持久cookie</code> 的生存时间更长一些，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。</li></ul></li><li><p>通常会用 <code>持久cookie</code> 维护某个用户会周期性访问的站点的配置文件或登录名。</p></li><li><p><code>会话cookie</code> 和 <code>持久cookie</code> 之间唯一的区别就是它们的过期时间。如果设置了 <code>Discard</code> 参数，或者没有设置 <code>Expires</code> 或 <code>Max-Age</code> 参数来说明扩展的过期时间，这个cookie就是一个会话cookie</p></li></ol><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ol><li><p>用户首次访问Web站点时, Web服务器对用户一无所知。Web服务器希望这个用户会再次回来，所以想给这个用户”拍上”一个独有的cookie, 这样以后它就可以识别出这个用户了。</p></li><li><p>cookie中包含了一个由 <code>名字=值(name=value)</code> 这样的信息构成的任意列表, 并通过 <code>Set-Cookie</code> 或 <code>Set-Cookie2</code> HTTP响应(扩展)首部将其贴到用户身上去</p></li><li><p>cookie中可以包含任意信息, 但它们通常都只包含一个服务器为了进行跟踪而产生的独特的识别码。比如, 服务器会将一个表示id=”34294”的cookie贴到用户上去。<br> 服务器可以用这个数字来查找服务器为其访问者积累的数据库信息(购物历史、地址信息等)</p></li><li><p>但是, cookie<strong>并不仅限于ID号</strong>, 很多Web服务器都会将信息直接保存在cookie中, 比如: <code>Cookie： name &quot;Brian Totty&quot;; phone=&quot;555-1212&quot;</code></p></li><li><p>浏览器会记住从服务器返回的 <code>Set-Cookie</code> 或 <code>Set-Cookie2</code> 首部中的cookie内容，并将cookie集存储在浏览器的cookie数据库中。将来用户返回同一站点时，浏览器会挑中那个服务器贴到用户上的那些cookie，并在一个cookie请求首部中将其传回去。</p></li></ol><h3 id="cookie罐-客户端的状态"><a href="#cookie罐-客户端的状态" class="headerlink" title="cookie罐: 客户端的状态"></a>cookie罐: 客户端的状态</h3><ol><li><p>cookie的基本思想就是让浏览器积累一组服务器特有的信息，每次访问服务器时都将这些信息提供给它。因为浏览器要负责存储cookie信息，所以此系统被称为<strong>客户端侧状态(client-side state)</strong>。</p></li><li><p>不同的浏览器会以不同的方式来存储cookie。（更多参考P218）</p></li></ol><h3 id="不同的站点使用不同的cookie"><a href="#不同的站点使用不同的cookie" class="headerlink" title="不同的站点使用不同的cookie"></a>不同的站点使用不同的cookie</h3><ol><li><p>浏览器内部的 <code>cookie罐</code> 中可以有成百上千个cookie，但<strong>浏览器不会将每个cookie都发送给所有的站点</strong>。实际上，它们通常只向每个站点发送2-3个cookie, 原因如下：</p><ul><li>对所有这些cookie字节进行传输会严重降低性能。浏览器实际传输的cookie字节数要比实际的内容字节数多; </li><li>cookie中包含的是各服务器特有的名值对，所以对大部分站点来说，大多数cookie都是自己无法识别的无用数据;</li><li><strong>将所有的cookie发送给所有站点会引发潜在的隐私问题，那些不信任的站点也会获得只想发给其他站点的信息</strong>;</li></ul></li><li><p>总之，**浏览器只会向服务器发送由同一服务器产生的那些cookie。如：joes-hardware.com产生的cookie会被发送给joes-hardware.com, 不会发送给bobs-books.com 或 marys-movies.com</p></li><li><p>很多Web站点都会与第三方厂商达成协议，由其来管理广告。<br> 这些广告被做得像Web站点的一个组成部分，而且它们确实发送了持久cookie。<br> 用户访问另一个由同一广告公司提供服务的站点时，由于域是匹配的，浏览器就会再次回送早先设置的持久cookie。<br> 营销公司可以将此技术与Referer首部结合，暗地里构建一个用户档案和浏览习惯的详尽数据集。<br> 现代的浏览器都允许用户对隐私特性进行设置，以限制第三方cookie的使用</p></li></ol><h3 id="cookie的域属性"><a href="#cookie的域属性" class="headerlink" title="cookie的域属性"></a>cookie的域属性</h3><ol><li><p>产生cookie的服务器可以向 <code>Set-Cookie响应首部</code> 添加一个 <code>Domain属性</code> 来控制哪些站点可以看到那个cookie。</p></li><li><p>比如，下面的HTTP响应首部就是在告诉浏览器将 cookie user= “maryl7” 发送给域为 “.airtravelbargains.com” 的所有站点：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Set-cookie: user=&quot;maryl7&quot;; domain=&quot;airtravelbargains.com&quot;</div><div class="line">如果用户访问的是www.airtravelbargains.com </div><div class="line">或者 specials.airtravelbargains.com</div><div class="line">或任意以.airtravelbargains.com结尾的站点，</div><div class="line"></div><div class="line">下列Cookie首部都会被发布出去：</div><div class="line">Cookie: user=&quot;maryl7&quot;</div></pre></td></tr></table></figure></li></ol><h2 id="cookie路径属性"><a href="#cookie路径属性" class="headerlink" title="cookie路径属性"></a>cookie路径属性</h2><ol><li><p>cookie规范甚至允许用户将cookie与部分Web站点关联起来, 可以通过 <code>Path属性</code> 来实现这一功能, 在这个属性列出的URL路径前缀下所有cookie都是有效的</p></li><li><p>例如, 某个Web服务器可能是由两个组织共享的，每个组织都有独立的cookie, 站点www.airtravelbargains.com可能会将部分Web站点用于汽车租赁<br> 比如，<a href="http://www.airtravelbargains.com`/autos/`" target="_blank" rel="external">http://www.airtravelbargains.com`/autos/`</a> – 用一个独立的cookie来记录用户喜欢的汽车尺寸, 可能会生成一个如下所示的特殊汽车租赁cookie:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Set-cookie: pref=compact; domain=&quot;airtravelbargains.com&quot;; path=/autos/</div><div class="line"></div><div class="line">如果用户访问http://www.airtravelbargains.com/specials.html，就只会获得这个cookie：</div><div class="line">Cookie: user=&quot;maryl7&quot; (结合前面域属性的例子)</div><div class="line"></div><div class="line">但如果访问http://www.airtravelbargains.com/autos/cheapo/index.html，就会获得这两个cookie:</div><div class="line">Cookie: user=&quot;maryl7&quot;</div><div class="line">Cookie: pref=compact</div></pre></td></tr></table></figure></li><li><p>因此，cookie就是由服务器贴到客户端上，由客户端维护的状态片段，只会回送给那些合适的站点。下面我们来更仔细地看看cookie的技术和标准。</p></li></ol><h2 id="cookie的成分"><a href="#cookie的成分" class="headerlink" title="cookie的成分"></a>cookie的成分</h2><p>现在使用的cookie规范有两个不同的版本: <code>cookies版本0</code>(有时被称为Netscape cookies) 和 <code>cookies版本1</code>(RFC 2965)。cookies版本1 是对cookies版本0的扩展，应用不如后者广泛。</p><h3 id="Cookies版本0"><a href="#Cookies版本0" class="headerlink" title="Cookies版本0"></a>Cookies版本0</h3><p>参考P284</p><h3 id="Cookies版本1"><a href="#Cookies版本1" class="headerlink" title="Cookies版本1"></a>Cookies版本1</h3><p>参考P285</p><h4 id="版本1的cookie2请求首部和版本协商"><a href="#版本1的cookie2请求首部和版本协商" class="headerlink" title="版本1的cookie2请求首部和版本协商"></a>版本1的cookie2请求首部和版本协商</h4><h2 id="cookie与缓存"><a href="#cookie与缓存" class="headerlink" title="cookie与缓存"></a>cookie与缓存</h2><h2 id="cookie安全性和隐私"><a href="#cookie安全性和隐私" class="headerlink" title="cookie安全性和隐私"></a>cookie安全性和隐私</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;HTTP最初是一个 &lt;strong&gt;匿名&lt;/strong&gt;, &lt;strong&gt;无状态&lt;/strong&gt; 的请求/响应协议;
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP -- 缓存 (200, 304)</title>
    <link href="http://blog.renyimin.com/2017/11/30/2017-11-30-HTTP-05-cache/"/>
    <id>http://blog.renyimin.com/2017/11/30/2017-11-30-HTTP-05-cache/</id>
    <published>2017-11-30T06:27:36.000Z</published>
    <updated>2018-02-08T02:10:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web缓存简介"><a href="#Web缓存简介" class="headerlink" title="Web缓存简介"></a>Web缓存简介</h2><ol><li>Web缓存是指可以自动保存常见文档副本的HTTP设备。当Web请求抵达缓存设备时, 如果缓存设备本地有”已缓存的”副本, 就可以从本地设备而不是原始服务器中提取这个文档。</li><li><p>使用缓存的优点:</p><ul><li><p>减少了冗余的数据传输, 节省了你的网络费用</p><blockquote><p>有很多客户端访问一个流行的原始服务器页面时, 服务器会多次传输同一份文档, 每次传送给一个客户端。<br>这样就会导致一些相同的字节在网络中一遍遍地传输, 这些冗余的数据传输会耗尽昂贵的网络带宽, 降低传输速度, 加重Web服务器的负载。<br>有了缓存, 就可以保留第一条服务器响应的副本, 后继请求就可以由缓存的副本来应对了, 这样可以减少那些流入/流出原始服务器而被浪费掉了的重复流量。</p></blockquote></li><li><p>缓解了网络本身的瓶颈问题, 不需要更多的带宽就能够更快地加载页面</p><blockquote><p>很多网络为本地网络客户端提供的带宽比为远程度服务器提供的带宽要宽。(这个大家应该有深有体会, 局域网内传输是很快的!!!)<br>如果客户端能够从一个快速局域网的缓存中得到一份副本, 那么缓存就可以提高性能—尤其是要传输比较大的文件时。</p></blockquote></li><li><p>降低了对原始服务器的要求, 服务器可以更快地响应, 避免过载的出现</p><blockquote><p>瞬间拥塞: 突发事件(爆发性新闻, 抢购等)使很多人几乎同时去访问一个Web文档时, 就会出现瞬间拥塞, 由此造成的过多流量峰值可能会使网络和Web服务器产生灾难性的崩溃。<br>而缓存在应对瞬间拥塞时就显得非常重要。</p></blockquote></li><li><p>降低了<strong>距离时延</strong>, 因为从较远的地方加载页面会更慢一些<br>即使带宽不是问题, 距离也可能成为问题。<strong>每台网络路由器都会增加因特网流量的时延</strong>。即使客户端和服务器之间没有太多的路由器, <strong>光速自身也会造成显著的时延</strong>。</p><blockquote><p>比如波士顿到旧金山的直线距离大约为2700英里, 在最好的情况下, 以光速传输(186000英里/秒)的信号可以在大约15毫秒从波士顿传送到旧金山, 并在30毫秒内完成一个往返。<br>假设某个Web页面包含了20个小图片, 都在旧金山的一台服务器上, 如果波士顿的一个客户端打开了4条到服务器的并行连接, 而且保持着连接的活跃状态, 光速自身就要消耗大约1/4秒(240毫秒)的下载时间。如果服务器位于(距离旧金山6700英里)的东京, 时延就会变成600毫秒。<br>中等复杂的web页面会带来几秒钟的光速时延。<br>况且实际应用中, 信号的传输速度会比光速低一些, 因此距离时延会更加严重。</p></blockquote><p>而将缓存放在附近的机房里可以将文件传输距离从数千英里缩短为数十米。</p></li></ul></li></ol><h2 id="‘缓存命中’、’未命中’-的概念"><a href="#‘缓存命中’、’未命中’-的概念" class="headerlink" title="‘缓存命中’、’未命中’ 的概念"></a>‘缓存命中’、’未命中’ 的概念</h2><ol><li><p>如果一些请求到达缓存设备时, 缓存设备可以用本地已有的副本为这些请求提供服务, 就被称为<strong>缓存命中</strong>。</p></li><li><p>如果一些请求到达缓存设备时, 缓存设备本地没有副本提供给这些请求, 而将请求转发给原始服务器, 这就被称为<strong>缓存未命中</strong>。</p></li><li><p>后面还有 <strong>再验证命中</strong> 和 <strong>再验证未命中</strong> 的概念;</p></li></ol><h2 id="引出文档过期-和-服务器再验证"><a href="#引出文档过期-和-服务器再验证" class="headerlink" title="引出文档过期 和 服务器再验证"></a>引出文档过期 和 服务器再验证</h2><ol><li><p><strong>已缓存的数据要与服务器数据保持一致</strong>:<br> 缓存设备本地的副本 并不是时刻都与原始服务器上的文档一样, 毕竟服务器中的这些文档会随着时间发生变化(比如有些报告可能每个月都会变化, 而在线报纸每天都会变化, 财经数据可能每过几秒就会发生变化)。<br> 所以, 如果缓存提供的总是老的数据, 就会变得毫无用处。</p></li><li><p>HTTP通过一些简单的机制, 可以做到: 在不要求服务器记住有哪些缓存设备拥有其文档副本的情况下, 保持已缓存数据与服务器数据之间的充分一致。<br> HTTP将这些简单的机制称为 <strong>文档过期(document expiration)</strong>(也就是缓存副本的过期时间) 和 <strong>服务器再验证(server revalidation)</strong>。</p></li></ol><h2 id="缓存副本的过期时间"><a href="#缓存副本的过期时间" class="headerlink" title="缓存副本的过期时间"></a>缓存副本的过期时间</h2><ol><li><p>原始服务器通过 老式的HTTP/1.0+的实体首部字段<code>Expires</code> 或 新式的HTTP/1.1的通用首部字段<code>Cache-Control:max-age</code> 可以向每个文档附加一个<strong>过期日期</strong>。</p><ul><li><code>Expires</code> 和 <code>Cache-Control:max-age</code> 所做的事情本质上是一直的, 但由于 <code>Cache-Control</code> 首部使用的是相对时间而不是绝对时间, 所以我们更倾向与使用比较新的 <code>Cache-Control</code> 首部。</li><li><code>Expires</code> 绝对日期依赖于计算机时钟的正确设置</li><li>如下图:<br><img src="/img/http/expire-max-age.png" width="550/"></li></ul></li><li><p><strong>在缓存文档过期之前, 缓存设备可以随意使用这些副本, 而且无需与服务器做任何联系!!</strong> 当然, 除非</p><ul><li>客户端请求中包含 “阻止提供缓存” 的首部 <code>Cache-Control:no-store</code>;</li><li><p>或者客户端请求中包含”只有经过验证才能返回缓存副本”的首部<code>Cache-Control:no-cache</code><em>*</em>), </p><p>但是一旦已缓存文档过期, 缓存设备就必须与服务器进行核对(<strong><em>当然, 除非你设置了<code>Cache-Control:only-if-cached</code>要求只使用缓存</em></strong>), 询问文档是否被修改过, 如果被修改过, 就要获取一份新鲜(带有新的过期日期)的副本。</p></li></ul></li><li><p><strong>注意</strong>: </p><ul><li>不推荐使用Expires首部, 它指定的是实际的过期日期而不是秒数。HTTP设计者后来认为, 由于很多服务器的时钟都不同步, 或者不正确, 所以最好还是用剩余秒数, 而不是绝对时间来表示过期时间。</li><li>有些服务器还会回送一个<code>Expires:0</code>响应头,视图将文档置于永远过期的状态, <strong>但这种语法是非法的</strong>, 可能给某个软件带来问题, 应该试着支持这种结构的输入, 但是不应该产生这种结构的输出。</li><li>而 <code>Cache-Control</code> 的 <code>max-age</code> 则可以设置 <code>Cache-Control: max-age=0</code></li></ul></li><li><p>另外, 注意 <code>no-cache</code> 和 <code>must-revalidate</code> 的区别</p><ul><li>no-cache: 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验。</li><li>must-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。(这应该是缓存系统的默认行为, 但must-revalidate指令使得这个要求是明确的<a href="https://stackoverflow.com/questions/2932890/http-cache-control-max-age-must-revalidate" target="_blank" rel="external">参考</a>)</li><li><a href="https://segmentfault.com/a/1190000007317481" target="_blank" rel="external">可参考</a></li></ul></li></ol><h2 id="副本过期算法测试"><a href="#副本过期算法测试" class="headerlink" title="副本过期算法测试"></a>副本过期算法测试</h2><ol><li>FireFox测试过期时间算法( Date + Expire/max-age - Age) <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 主要测试浏览器确实是根据 expirationTime = responseTime(Date头) + freshnessLifetime(max-age/Exprie值) - currentAge(Age头)</span></div><div class="line"><span class="comment"> * 来计算失效时间的</span></div><div class="line"><span class="comment"> * chrome好像不太正常(会交替显示 123 和 456789)</span></div><div class="line"><span class="comment"> * firefox 进行回车测试, 结果发现完全正常</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>($_SERVER[<span class="string">'HTTP_IF_MODIFIED_SINCE'</span>])) &#123;</div><div class="line">    header(<span class="string">"HTTP/1.1 200"</span>);</div><div class="line">    header(<span class="string">'Cache-Control: max-age=30'</span>); <span class="comment">// 放到下一行就不生效了(响应头还特么还有顺序?)</span></div><div class="line">    header(<span class="string">'Age:10'</span>);</div><div class="line">    <span class="comment">// 发现浏览器确实拿着这个日期去判断有没有过期</span></div><div class="line">    header(<span class="string">'Date:'</span>. date(<span class="string">'D, d M Y H:i:s'</span>, time()<span class="number">-10</span>).<span class="string">' GMT'</span>);</div><div class="line">    header(<span class="string">'Last-Modified:'</span>. date(<span class="string">'D, d M Y H:i:s'</span>, time()<span class="number">-20000</span>).<span class="string">' GMT'</span>);</div><div class="line">    <span class="keyword">echo</span> <span class="number">123</span>;</div><div class="line">    <span class="keyword">exit</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//算法: expirationTime = responseTime(Date头) + freshnessLifetime(max-age/Exprie值) - currentAge(Age头)</span></div><div class="line"><span class="comment">// 此处浏览器判断 date + 30 - 10 , 由于date是当前时间, 所以差不多有20秒的过期时间</span></div><div class="line"><span class="comment">// 如果是Age:0的话, date + 30 -0, 由于date是当前时间, 所以差不多有30秒的过期时间</span></div><div class="line"><span class="comment">// 如果是Date-10, Age:0的话, date-10 + 30 -10, 所以差不多有10秒的过期时间 (不太好抓, 不过肯定是10秒过期)</span></div><div class="line"></div><div class="line"><span class="comment">//发现只有超时之后, 才会显示出下面的信息   (firefox准确无误地实现,在未过期之前, 是不会带If-Modified-Since头去请求的)</span></div><div class="line"><span class="keyword">echo</span> <span class="number">456789</span>;<span class="keyword">die</span>;</div></pre></td></tr></table></figure></li></ol><h2 id="缓存副本过期后的”再验证”"><a href="#缓存副本过期后的”再验证”" class="headerlink" title="缓存副本过期后的”再验证”"></a>缓存副本过期后的”再验证”</h2><ol><li><p>原始服务器上的内容可能会发生变化, 缓存要不时地对其进行检测, 看看自己保存的副本是否仍是服务器上最新的副本。这种”新鲜度检测”就被称为HTTP再验证(revalidation)。</p></li><li><p>虽然缓存可以在任意时刻, 以任意的频率从对副本进行再验证, 但是由于缓存中通常会包含数百万的文档, 而且网络带宽是很珍贵的, 所以大部分缓存<strong>只有在客户端发起请求</strong>,并且<strong>副本旧的足以需要再次检测的时候</strong>, 才会对副本进行再验证。</p></li><li><p><strong>副本旧的足以需要再次检测的时候?</strong> 也就是缓存副本的过期时间已到!!</p></li><li><p>但是仅仅是已缓存文档过期了, 还不能说明该过期文档和原始服务器上的文档有实际的区别, 这只是意味着<strong>到时间进行再验证了</strong>！</p></li></ol><h3 id="再验证命中-缓慢命中"><a href="#再验证命中-缓慢命中" class="headerlink" title="再验证命中(缓慢命中)"></a>再验证命中(缓慢命中)</h3><ol><li><p>缓存对副本进行再验证时, 会向原始服务器发送一个小的再验证请求。如果发现内容没有变化, 服务器会以一个小的 <code>304 Not Modified</code> 进行响应。<br> 只要缓存知道副本仍然有效, 就会再次将副本标识为暂时新鲜的, 并将副本提供给客户端, 这被称为<strong>再验证命中(revalidate hit)</strong> 或 <strong>缓慢命中(slow hit)</strong>。<br> <img src="/img/http/revalidate-hit-01.png" width="300/"></p></li><li><p><strong>当然, 这种方式确实还是需要与原始服务器进行核对, 所以会比单纯的缓存命中要慢, 但是它并没有从服务器中获取对象数据, 所以要比缓存未命中要快一些。</strong></p></li></ol><h3 id="再验证未命中"><a href="#再验证未命中" class="headerlink" title="再验证未命中"></a>再验证未命中</h3><ol><li><p>缓存对副本进行再验证时, 会向原始服务器发送一个小的再验证请求。如果缓存发现服务器对象与已缓存副本不同, 则服务器会向客户端发送一条普通的, 带有完整内容的 <code>HTTP 200 OK</code> 响应;<br> <img src="/img/http/revalidate-not-hit-01.png" width="300/"></p></li><li><p><strong>当然, 这种方式确实不仅需要与原始服务器进行核对, 而且会从服务器中获取对象数据, 所以理论上貌似要比缓存未命中要慢一些, 但其实差不多</strong></p></li></ol><h3 id="再验证-–-服务器对象被删除"><a href="#再验证-–-服务器对象被删除" class="headerlink" title="再验证 – 服务器对象被删除"></a>再验证 – 服务器对象被删除</h3><p>如果再验证发现服务器对象已经被删除, 服务器就回送一个 <code>404 Not Found</code> 响应, 缓存也会将其副本删除。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>成功的再验证 比 缓存未命中 要快</strong><br><strong>失败的再验证 几乎和 缓存未命中 速度一样</strong></p><h3 id="再验证依靠-–-条件方法"><a href="#再验证依靠-–-条件方法" class="headerlink" title="再验证依靠 – 条件方法"></a>再验证依靠 – 条件方法</h3><ol><li><p>为了有效地进行再验证, HTTP定义了一些特殊的请求, <strong>不用从服务器上获取整个对象, 就可以快速检测出内容是否是最新的</strong>。</p></li><li><p>HTTP的<code>条件方法</code>可以高效地实现再验证。<br> HTTP允许缓存向原始服务器发送一个 “条件GET”, 请求只有在服务器文档与缓存中现有的副本不同时, web服务器才会回送对象主体;<br> 通过这种方式, 将新鲜度检测和对象获取结合成了单个条件GET。<br> 向GET请求报文中添加一些特殊的<code>条件首部</code>, 就可以发起<code>条件GET</code>。</p></li><li><p>HTTP定义了5个条件请求首部, 对 <code>缓存再验证</code> 来说有用的2个首部是 <code>If-Mofified-Since</code> 和 <code>If-None-Match</code>, 所有的条件首部都以前缀<code>If-</code>开头。<br> <img src="/img/http/revalidate-01.png" width="500/"></p></li></ol><h3 id="If-Modified-Since-Date-再验证"><a href="#If-Modified-Since-Date-再验证" class="headerlink" title="If-Modified-Since:Date 再验证"></a>If-Modified-Since:Date 再验证</h3><ol><li><p>最常见的缓存再验证首部是 <code>请求首部字段 If-Modified-Since</code>, <code>If-Modified-Since</code>再验证请求通常被称为IMS请求。</p><ul><li>如果自If-Modified-Since指定日期之后, 文档被修改了, <code>If-Modified-Since</code> 条件就为真, 通常GET就会成功执行, <strong>携带新首部的新文档</strong>会被返回给缓存, 新首部除了其他信息之外, 还包含了一个新的过期日期;</li><li>如果自If-Modified-Since指定日期之后, 文档没被修改, <code>If-Modified-Since</code> 条件就为假, 会向客户端<strong>返回一个小的 304 Not Modified响应报文</strong>, 为了提高有效性, <strong>不会返回文档主体</strong>。<br>这些首部是放在响应中返回的, 但是只会返回哪些需要在源端更新的首部, 比如, Content-Type首部通常不会被修改, 所以通常不需要发送。一般会发送一个新的过期日期。</li></ul></li><li><p>请求首部字段<code>If-Modified-Since</code> 和 实体首部字段<code>Last-Modified</code> 配合工作。</p><ul><li>原始服务器会将最后的修改日期附加到所提供的文档上去, 当缓存要对已缓存文档进行再验证时, 就会包含一个<code>If-Modified-Since</code>首部, 其中携带有最后修改已缓存副本的日期: <code>If-Modified-Since:&lt;cached last-modified date&gt;</code></li><li>如果在此期间原始服务器文档被修改了, 最后的修改日期就会不同了, 这样<code>If-Modified-Since</code>条件就为真, 原始服务器就会回送新的文档；</li><li>否则, 服务器会注意到缓存的最后修改日期与服务器文档当前的最后修改日期相符合, 则会返回一个 <code>304 Not Modified</code> 响应。</li></ul></li><li><p>小结: 如果在验证发现原始服务器内容未发生变化, If-Modified-Since在验证会返回304响应, 如果发生了变化, 就返回带有新主体的200响应。</p></li></ol><h3 id="If-None-Match-实体标签再验证"><a href="#If-None-Match-实体标签再验证" class="headerlink" title="If-None-Match 实体标签再验证"></a>If-None-Match 实体标签再验证</h3><h4 id="实体标签"><a href="#实体标签" class="headerlink" title="实体标签"></a>实体标签</h4><ol><li><p>有些情况下使用最后修改日期进行再验证是不够的:</p><ul><li>有些文档可能会被周期性地重写, 但实际包含的数据常常却是一样的。<strong>尽管内容没有发生变化, 但是修改日期会发生变化</strong>。</li><li>有些文档可能内容被修改了, 但是<strong>所做的修改并不重要</strong>, 不需要让世界范围内的缓存都重装数据(比如对拼写或注释的修改)。<br>  <strong>涉及到弱验证器</strong></li><li>有些服务器无法准确地判定其页面的最后修改日期。</li><li>有些服务器提供的文档会在亚秒间隙发生变化(比如,实时监视器), 对这些服务器来说, <strong>以秒为粒度的修改日期可能就不够用了</strong>。</li></ul></li><li><p>为了解决上述问题, HTTP有一个被称为 <code>实体标签(ETag)</code> 的 <code>版本标识符</code>, 这个实体标签是附加到文档上的任意标签, 标签可能可能包含了文档序列号或版本名, 或是文档内容的校验及其他指纹信息。<br> 当对文档进行修改时, 可以修改文档的实体标签来说明这个新的版本。这样, 如果实体标签被修改了, 缓存就可以用 <code>If-None-Match</code> 条件首部来GET文档的新副本了。</p></li><li><p>假设缓存中有一个文档已经过(Expires:, Cache-Control:max-age)期, 或者其他配置导致需要再次验证, 如果缓存中有一个实体标签为v2.6, 则它会与原始服务器进行再验证:</p><ul><li>如果服务器上的实体标签已经发生了变化(可能变成了v3.0, 和v2.6不再匹配), 服务器则会在一个 <code>200 OK</code> 响应中返回新的内容以及新的Etag标签 ;</li><li>如果标签仍然与原始服务器标签匹配, 则会返回一条304 Not Modified响应;</li></ul></li></ol><h4 id="弱验证器"><a href="#弱验证器" class="headerlink" title="弱验证器"></a>弱验证器</h4><ol><li><p>只要原始服务器内容发生变化, 则实体标签就会变化, 正常情况下, 强验证器就会对比失败, 导致服务器会在一个 <code>200 OK</code> 响应中返回新的内容以及新的Etag标签;</p></li><li><p>有时, 服务器希望对文档进行一些不重要的修改, 并且不需要使所有已缓存副本都失效<br>HTTP1.1支持的”弱验证器”, 就允许对一些内容做修改, 此时服务器会用前缀 <code>W/</code> 来标识弱验证器。</p></li><li><p>不管相关的实体值以何种方式发生了变化, 强实体标签都要发生变化, 而相关实体在语义上发生了比较重要的变化时, 弱实体标签页应该发生变化。</p></li></ol><h3 id="实体标签-和-最近修改日期"><a href="#实体标签-和-最近修改日期" class="headerlink" title="实体标签 和 最近修改日期"></a>实体标签 和 最近修改日期</h3><blockquote><p>如果服务器回送了一个实体标签, HTTP/1.1客户端就必须使用实体标签验证器。<br>如果服务器只回送了一个Last-Modified值, 客户端就可以使用 If-Modified-Since 验证。<br>如果实体标签和最后修改日期都提供了, 客户端就应该使用这两种再验证方案, 这样HTTP1.0和HTTP1.1换成你都可以正确响应了。</p></blockquote><p>除非HTTP/1.1原始服务器无法生成实体标签验证器, 否则就应该发送一个出去, 如果使用弱实体标签有优势的话, 发送的可能就是个弱实体标签, 而不是强实体标签。而且最好同时发送一个最近修改值。<br>如果HTTP/1.1缓存或服务器受到的请求既带有 If-Modified-Since, 又带有实体标签条件首部, <strong>那么只有这两个条件都满足时, 才能返回 <code>304 Not Modified</code> 响应</strong>(也就是两个都做验证)。</p><h2 id="缓存状态码-200-和-304"><a href="#缓存状态码-200-和-304" class="headerlink" title="缓存状态码 200 和 304"></a>缓存状态码 200 和 304</h2><p>参考P176: HTTP没有为用户提供一种手段来区分响应是缓存命中的, 还是访问原始服务器得到的。<strong>在这两种情况下, 响应状态码都是200OK</strong>, 说明响应有主体部分。</p><ul><li>你从public公共缓存中可能直接得到未过期的资源, 此时会返回 200 ok;</li><li>你也可能到公共缓存后发现要再验证, 此时发现文本已变更, 服务器也会返回 200 ok;</li></ul><ol><li><p>缓存命中(这里指的是公共的代理缓存命中) 返回 <code>200 ok</code></p><ul><li>客户端第一次访问资源, 浏览器和服务器之间有代理服务器, 这样的话, 由于这个代理服务器是个公共代理, 所以里面可能已经有了服务器响应的资源副本, 所以代理服务器会直接响应 资源副本和200 ok给客户端;<br><img src="/img/http/cdn-public-proxy-200.png" width="600/"></li></ul></li><li><p>访问原始服务器, 返回 <code>200 ok</code></p><ul><li>浏览器和服务器之间没有代理服务器, 这样的话, 客户端第一次请求资源, 则服务器直接 响应 200 ok 和 资源对象 给客户端;</li><li>客户端多次访问资源, 浏览器和服务器之间有代理服务器, 但是由于种种原因, 缓存需要再验证, 并且结果发现<strong>再验证未命中</strong>, 则服务器会响应资源对象和200 ok给代理缓存, 然后代理再响应”服务器响应的资源和200 ok副本”给客户端;</li></ul></li><li><p>浏览器直接取的自己的本地缓存, 返回 <code>200 ok (from disk/memory cache)</code><br> 此处由于浏览器之前缓存了 代理缓存服务器cdn 上的缓存副本, <strong>所以浏览器缓存的副本和上面cdn代理缓存的副本一样</strong>(age缓存时间都没变), 只不过会标注”已缓存”来表示没有响应主体部分<br> <img src="/img/http/cdn-private-200.png" width="600/"></p></li><li><p><code>304 Not Modified</code> 是缓存和服务器多确认了一次缓存有效性检测后, 发现<strong>缓存再验证命中</strong>, 但是用的还是缓存。</p></li><li><p>小结: <code>304 Not Modified</code> 比 <code>再验证未命中返回200 OK</code> 快, 但是比 <code>private缓存命中返回 200 ok from disk/memory cache</code> 慢;</p></li><li><p>参考 http权威指南176页</p></li></ol><h2 id="公有和私有缓存"><a href="#公有和私有缓存" class="headerlink" title="公有和私有缓存"></a>公有和私有缓存</h2><ol><li><p>通用首部字段(general header fields)<code>Cache-Control</code>有两个缓存响应指令: <code>public</code> 和 <code>private</code> </p></li><li><p>缓存可以是<code>单个用户专用的</code>, 也可以是<code>数千名用户共享的</code> ;</p></li></ol><ul><li>专用缓存被称为<code>私有缓存(private cache)</code>, 私有缓存是个人的缓存, 包含了单个用户最常用的页面 ;</li><li>共享缓存被称为<code>公有缓存(public cache)</code>, 公有缓存包含了某个用户团体常用页面 ;</li></ul><h3 id="私有缓存"><a href="#私有缓存" class="headerlink" title="私有缓存"></a>私有缓存</h3><p>私有缓存不需要很大的动力或存储空间, 这样就可以将其做的很小, 很便宜。<br>Web浏览器中就有内建的私有缓存—大多数浏览器都会将常用文档缓存在你个人电脑的磁盘和内存中, 并且允许用户去配置缓存的大小和各种设置;</p><h3 id="公有缓存"><a href="#公有缓存" class="headerlink" title="公有缓存"></a>公有缓存</h3><ol><li>公有缓存是特殊的共享代理服务器, 被称为缓存代理服务器(caching proxy server), 或者更常见地被称为代理缓存(proxy cache)。</li><li>代理缓存会从自己本地缓存中给用户提供缓存资源, 或者代表用户与服务器进行联系。公有缓存会接受来自多个用户的访问, 所以通过它可以更好地减少冗余流量。</li><li>如下图: </li></ol><ul><li>每个客户端都会重复地访问一个(还不在私有缓存中的)新的”热门”文档。每个私有缓存都要获取同一份文档, 这样它就会多次穿过网络。</li><li>而使用共享的公有缓存时, 对于这个流行的对象, 缓存只要取一次就行了, 它会用共享的副本为所有的请求服务, 以降低网络流量。<br><img src="/img/http/private-public-cache-01.png" width="416/"></li></ul><h2 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h2><ol><li><p>客户端可以用 <code>Cache-Control</code> 请求首部来 <strong>强化</strong> 或 <strong>放松</strong> 对过期时间的限制。</p><ul><li>有些应用程序对文档的新鲜度要求很高, 对于这些应用程序, 客户端可以用 Cache-Control 首部使过期时间更严格;</li><li>另一方面, 为了提高性能, 可靠性或开支的一种折中方式, 客户端可能会放松新鲜度要求;</li></ul></li><li><p>如下对 <code>Cache-Control</code> 的请求指令进行了小结:<br><img src="/img/http/cache-control-01.png" width="600/"><br><a href="https://stackoverflow.com/questions/33818854/what-is-difference-between-max-age-and-max-stale-in-cache-control-mechanism" target="_blank" rel="external">HTTP Cache-Control: max-age和max-stale=s的区别</a></p></li><li><p><code>Pagma:no-cache</code> 和 <code>Cache-Control:no-cache</code> 一样, 不过是为了兼容HTTP/1.0;</p></li></ol><p>参考:<br>HTTP权威指南 – 第七章 缓存<br>《图解HTTP协议》<br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/HTTP</a><br><a href="https://tools.ietf.org/html/rfc2616#section-4.5" target="_blank" rel="external">RFC 2616</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="external">MDN Web docs</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web缓存简介&quot;&gt;&lt;a href=&quot;#Web缓存简介&quot; class=&quot;headerlink&quot; title=&quot;Web缓存简介&quot;&gt;&lt;/a&gt;Web缓存简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Web缓存是指可以自动保存常见文档副本的HTTP设备。当Web请求抵达缓存设备时, 如果
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP - General Header Fields</title>
    <link href="http://blog.renyimin.com/2017/11/30/2017-11-30-HTTP-04-General-Header-Fields/"/>
    <id>http://blog.renyimin.com/2017/11/30/2017-11-30-HTTP-04-General-Header-Fields/</id>
    <published>2017-11-30T03:50:02.000Z</published>
    <updated>2018-02-08T02:10:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>通用首部字段 general-header</p><h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><ol><li><p><code>Cache-Control</code> 的指令是可选的,可以有多个, 多个指令之间通过 <code>,</code> 分隔;</p></li><li><p>缓存指令是单向的, 即请求中存在一个指令并不意味着响应中将存在同一个指令;</p></li><li><p>可以按请求和响应分为:</p><ul><li><p>缓存请求指令<br><img src="/img/http/cache-control-request.png" width="600/"></p></li><li><p>缓存响应指令<br><img src="/img/http/cache-control-response.png" width="600/"></p></li></ul></li><li><p>更多参考<a href="/2017/11/30/2017-11-30-HTTP-05-cache/">HTTP - 缓存</a></p></li><li><p><code>immutable</code><br>属于缓存控制的一个扩展属性, <a href="http://www.jdon.com/performance/cache-control-immutable.html" target="_blank" rel="external">http://www.jdon.com/performance/cache-control-immutable.html</a></p><blockquote><p>当一个支持immutable的客户端浏览器看到这个属性时, 它应该知道, 如果没有超过过期时间，那么服务器端该页面内容将不会改变, 这样浏览器就不应该再发送有条件的重新验证请求(比如通过If-None-Match 或 If-Modified-Since等条件再向服务器端发出更新检查);<br>也就是说, 通常过去我们使用304回复客户端该页面内容没有变化，但是如果用户按浏览器的刷新或F5键，浏览器会再次向服务器端发出该页面内容请求，服务器端如果确认该页面没有变化，那么发回304给客户端，不再发送该页面的实体内容，虽然这样节省了来回流量，但是如果大型网站的很多用户为了得到及时信息，经常会刷新浏览器，这就造成了大量刷新请求，向服务器端求证该页面是否改变，这会影响网站的带宽，也增加服务器端验证压力。<br><strong>而新的选项immutable可以杜绝这种现象</strong>。<br>immutable可以节省HTTP请求,缩短请求时间,这是因为服务器不必再处理304响应了。</p></blockquote></li></ol><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><ol><li>简单来说就是HTTP报文的创建日期, 它会参与到缓存控制的 过期时间运算中;</li><li>公式: <code>expirationTime = responseTime(Date头) + freshnessLifetime(max-age/Exprie值) - currentAge(Age头)</code></li><li>而响应首部字段中额 <code>Age</code> 头字段, 是告诉客户端, 源服务器在多久之前创建了响应, 字段的单位为秒;<br> 如果创建该响应的服务器是缓存服务器, Age值是指缓存后的响应再次发起认证到认证完成的时间值, 代理创建响应时必须加上首部字段Age。</li></ol><h2 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h2><ol><li>Pragma是HTTP1.1之前版本的历史遗留字段, 仅作为与HTTP1.0做向后兼容;</li><li>也属于和缓存相关的通用首部字段, 但只用在客户端发送的请求当中, 客户端会要求所有的中间服务器不返回缓存的资源(参考Cache-Control:no-cache), 但是并不专用于缓存, 最常用的是<code>Pragma:no-cache</code>;</li></ol><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><ol><li>该首部字段具备两个作用: <code>控制不再转发给代理的首部字段</code> 和 <code>管理持久连接</code>;</li><li>更多参考<a href="/2017-04-21-HTTP-Connection-Keep-Alive/">HTTP - 并行连接, 持久连接</a></li><li>未完待续…</li></ol><h2 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h2><ol><li><p>使用首部字段Via, 是为了追踪客户端与服务器之间的请求和响应报文的传输路径;<br>报文在经过代理或者网关时, 会先在首部字段Via中附加该服务器的信息, 然后再进行转发。</p><blockquote><p>Via首部是为了追踪传输路径, 所以也经常会和TRACE方法一起使用, 比如代理服务器受到由TRACE方法发送过来的请求(其中Max-Forward:0)时, 代理服务器就不能再转发该请求了,<br>这种情况下, 代理服务器会将自身的信息附加到Via首部后, 返回该请求的响应。</p></blockquote></li><li><p>Via通用首部字段不仅用于报文的转发, 还可避免请求回环的发生, 所以必须在经过代理时附加该首部字段;<br> <img src="/img/http/via-01.png" width="300"></p></li><li><p>未完待续…</p></li></ol><h2 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h2><p><strong>传输编码</strong></p><ol><li>该通用首部字段规定了传输报文主体时采用的编码方式;</li><li>HTTP/1.1的传输编码方式仅对分块传输编码有效, 即只能设置为 <code>Transfer-Encoding:chunked</code>;</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding" target="_blank" rel="external">MDN参考</a>;</li><li><code>Content-Encoding</code> 和 <code>Transfer-Encoding</code> 二者经常会结合来用, 其实就是针对 Transfer-Encoding 的分块再进行 Content-Encoding压缩;</li></ol><h3 id="对比-请求首部字段Accept-encoding"><a href="#对比-请求首部字段Accept-encoding" class="headerlink" title="对比 请求首部字段Accept-encoding"></a>对比 <strong>请求首部字段Accept-encoding</strong></h3><p><strong>期望内容编码</strong></p><ol><li><p>请求首部字段Accept-encoding是将客户端用户代理(浏览器)所<strong>支持的内容编码方式</strong>(通常是某种压缩算法) 及 <strong>内容编码方式的优先级顺序</strong>, 通知给服务器;</p><ul><li>通过内容协商, 服务端会选择一个客户端支持的方式, 使用并在 响应报文的实体首部字段 <code>Content-Encoding</code> 中通知客户端服务器选择了哪种内容编码方式;</li><li>另外, 可以一次性指定多种内容编码! </li><li>也可以使用权重q值来表示相对优先级;</li></ul></li><li><p>正常情况下, 主要采用以下4种编码方式:</p><ul><li>gzip</li><li>compress</li><li>deflate</li><li>identity: 不执行压缩或不会变化的默认编码格式;</li></ul></li><li><p>即使客户端和服务器都支持某些相同的压缩算法，但如果<code>Accept-encoding:identity</code>, 表示客户端告诉服务器对响应主体不要进行压缩。导致这种情况出现的两种常见的情形是：</p><ul><li>要发送的数据已经经过压缩, 再次进行压缩不会导致被传输的数据量更小, 一些图像格式的文件会存在这种情况;</li><li>服务器超载, 无法承受压缩需求导致的计算开销, 通常, 如果服务器使用超过80%的计算能力, 微软建议不要压缩;</li></ul></li><li><p>只要 identity(表示不需要进行任何编码)没有被明确禁止使用, 即, 没有通过 <code>identity;q=0</code>或是<code>*;q=0</code>指令明确设置 identity 的权重值，<strong>则服务器禁止返回表示客户端错误的 <code>406 Not Acceptable</code> 响应</strong>。</p><ul><li>也就是只有你通过设置identity的权重为0, 服务器才可以返回表示客户端错误的<code>406 Not Acceptable</code></li></ul></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Encoding" target="_blank" rel="external">MDN参考</a></p></li></ol><h3 id="对比-实体首部字段Content-encoding"><a href="#对比-实体首部字段Content-encoding" class="headerlink" title="对比 实体首部字段Content-encoding"></a>对比 <strong>实体首部字段<code>Content-encoding</code></strong></h3><p><strong>内容编码</strong></p><ol><li>实体首部字段’Content-encoding’会告诉客户端, 服务器对实体的主体部分选用的内容编码方式, </li><li>内容编码方式是指在不丢失实体信息的前提下所进行的压缩, 参考 <code>请求首部字段Accept-encoding</code> 所建议给服务器的编码方式:<ul><li>gzip</li><li>compress</li><li>deflate</li><li>identity</li></ul></li></ol><h3 id="对比-请求首部字段Accept-charset"><a href="#对比-请求首部字段Accept-charset" class="headerlink" title="对比 请求首部字段Accept-charset"></a>对比 <strong>请求首部字段<code>Accept-charset</code></strong></h3><ol><li>请求首部字段’Accept-charset’会告诉服务器, 用户代理(浏览器)所支持的<code>字符集</code>和<code>字符集的相对优先顺序</code>。<ul><li>可以一次性指定多种字符集;</li><li>也可以使用权重q值来表示相对优先级;</li></ul></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>请求首部字段<code>Accept-encoding</code> 和 实体首部字段<code>Content-encoding</code>来决定压缩方式;</li><li>通用首部字段<code>Transfer-Encoding</code>用来决定响应实体是否分块;</li><li>请求首部字段<code>Accept-charset</code>是客户端高速服务端自己能支持的编码方式;</li></ol><h2 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h2><h2 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h2><h2 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《HTTP权威指南》<br>《图解HTTP协议》<br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/HTTP</a><br><a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">https://tools.ietf.org/html/rfc2616</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通用首部字段 general-header&lt;/p&gt;
&lt;h2 id=&quot;Cache-Control&quot;&gt;&lt;a href=&quot;#Cache-Control&quot; class=&quot;headerlink&quot; title=&quot;Cache-Control&quot;&gt;&lt;/a&gt;Cache-Control&lt;/h2&gt;
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP - 请求Method</title>
    <link href="http://blog.renyimin.com/2017/11/30/2017-11-30-HTTP-03-Method/"/>
    <id>http://blog.renyimin.com/2017/11/30/2017-11-30-HTTP-03-Method/</id>
    <published>2017-11-30T03:25:12.000Z</published>
    <updated>2018-02-08T02:05:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见Method简要分类"><a href="#常见Method简要分类" class="headerlink" title="常见Method简要分类"></a>常见Method简要分类</h2><ol><li><p>HTTP/1.1 中实现的 method</p><ul><li><p>见<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">RFC2616</a><br><img src="/img/http/method-01.png" width="500"></p></li><li><p>可以看到有: <code>OPTIONS</code>, <code>GET</code>, <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>, <code>CONNECT</code></p></li></ul></li><li><p>RFC2616中提到: PATCH，LINK，UNLINK方法被定义，但并不常见, 在<a href="https://tools.ietf.org/html/rfc2068" target="_blank" rel="external">RFC 2068</a>中实现;</p></li><li><p>《图解http协议》中LINK,UNLINK已经被http1.1废弃;</p></li><li><p>规范中虽然是上面那样定义的, 但具体还要看不同应用各自是如何去实现的, 有些应用会完整实现, 有些还会扩展, 有些可能会实现一部分</p><ul><li><p>参考symfony中的 <a href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpFoundation/Request.php" target="_blank" rel="external">symfony/src/Symfony/Component/HttpFoundation/Request.php</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> METHOD_HEAD = <span class="string">'HEAD'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_GET = <span class="string">'GET'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_POST = <span class="string">'POST'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_PUT = <span class="string">'PUT'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_PATCH = <span class="string">'PATCH'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_DELETE = <span class="string">'DELETE'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_PURGE = <span class="string">'PURGE'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_OPTIONS = <span class="string">'OPTIONS'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_TRACE = <span class="string">'TRACE'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_CONNECT = <span class="string">'CONNECT'</span>;</div></pre></td></tr></table></figure></li><li><p>而像postman这种工具, 实现的就比较多:<br><img src="/img/http/postman-http-method.png" width="400/"></p></li></ul></li></ol><h2 id="PUT-对比POST"><a href="#PUT-对比POST" class="headerlink" title="PUT(对比POST)"></a>PUT(对比POST)</h2><ol><li><p><code>PUT</code>: 对已有资源进行更新操作, 所以是 update 操作;</p></li><li><p>一个简单例子: 假设一个博客系统提供一个Web API(<a href="http://superblogging/blogs/post/{blog-name}" target="_blank" rel="external">http://superblogging/blogs/post/{blog-name}</a>), 可以使用PUT或者POST进行请求, HTTP的body部分就是博文内容，这是一个很简单的REST API例子。</p></li><li><p><strong>put和post有什么区别呢</strong>?</p><ul><li>在HTTP中, PUT被定义为 <a href="https://tools.ietf.org/html/rfc2616#section-9.1.2" target="_blank" rel="external"><code>idempotent(幂等性)</code></a>) 的方法，POST则不是，<strong>这是一个很重要的区别</strong></li><li>我们应该用PUT还是POST？<br><strong>取决于这个REST服务的行为是否是idempotent(幂等)的</strong>, 假如发送两个请求, 希望服务器端是产生两个博客帖子，那就说明这个服务不是idempotent的, 因为多次使用产生了副作用了, 那就应该使用POST方法。<br><strong>但如果是希望后一个请求把第一个请求覆盖掉(这不正是修改么), 那这个服务就是idempotent的。</strong></li><li>虽然POST和PUT差别不大, 用错了也没关系, 但是你的服务一放到internet上，如果不遵从HTTP协议的规范，就可能给自己带来麻烦</li></ul></li></ol><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><ol><li><p><code>POST</code>: 上面已经提过了, 所以<strong>POST是非幂等的</strong>;</p></li><li><p>POST和PUT都可以上传文件或者创建新信息, 但主要看你的REST服务行为是否是幂等的</p></li><li><p>再比如, 在我们的支付系统中，一个api的功能是创建收款金额二维码，它和金额相关，每个用户可以有多个二维码，如果连续调用则会创建新的二维码，这个时候就用POST<br>但如果用户的账户二维码只和用户关联，而且是一一对应的关系，此时这个api就可以用PUT，因为每次调用它，都将刷新用户账户二维码</p></li></ol><h2 id="PATCH-对比PUT"><a href="#PATCH-对比PUT" class="headerlink" title="PATCH(对比PUT)"></a>PATCH(对比PUT)</h2><ol><li><p>对已有资源的操作:用于资源的部分内容的更新, 例如更新某一个字段。具体比如说只更新用户信息的电话号码字段。<br> 而<code>PUT</code>则用于更新某个资源较完整的内容, 比如说用户要重填完整表单更新所有信息, 后台处理更新时可能只是保留内部记录ID不变。</p></li><li><p>当资源不存在时: PATCH 可能会去创建一个新的资源, 这个意义上像是 saveOrUpdate 操作。</p></li><li><p>参考:</p><ul><li><a href="https://segmentfault.com/q/1010000005685904/" target="_blank" rel="external">https://segmentfault.com/q/1010000005685904/</a></li><li><a href="https://unmi.cc/restful-http-patch-method/" target="_blank" rel="external">https://unmi.cc/restful-http-patch-method/</a></li><li><a href="http://restcookbook.com/HTTP%20Methods/patch/" target="_blank" rel="external">http://restcookbook.com/HTTP%20Methods/patch/</a></li><li><a href="https://tools.ietf.org/html/rfc5789" target="_blank" rel="external">https://tools.ietf.org/html/rfc5789</a></li></ul></li></ol><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD和 <code>GET</code> 本质是一样的, 区别在于如果使用HEAD, 响应体将不会被返回，而仅仅返回HTTP头信息。<br>有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景: 欲判断某个资源是否存在, 我们通常使用GET, <strong>但这里用HEAD则意义更加明确</strong>。</p><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>比较简单, 直接获取资源;</p><h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><ol><li>这个方法很有趣, 但极少使用。它用于获取当前URL所支持的方法。若请求成功, 则它会在HTTP头中包含一个名为 <code>Allow</code> 的头, 值是服务器所支持的方法, 如 GET, POST。<br> 另外, 之前[介绍跨域]时(稍后奉上,近期正在重新修正), <code>CORS方案 -- (not-so-simple request)</code>中的”预检”请求用的请求方法就是 <code>OPTIONS</code></li></ol><h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><p>要求用隧道协议连接代理, 如使用SSL</p><h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><p>书中说比较少用</p><blockquote><p>TRACE_Method是HTTP（超文本传输）协议定义的一种协议调试方法，该方法会使服务器原样返回任意客户端请求的任何内容。<br>TRACE和TRACK是用来调试web服务器连接的HTTP方式。支持该方式的服务器存在跨站脚本漏洞，通常在描述各种浏览器缺陷的时候，把”Cross-Site-Tracing”简称为XST。攻击者可以利用此漏洞欺骗合法用户并得到他们的私人信息。（这个命令好怕怕，无知好吓人啊）<br>如何关闭Apache的TRACE请求<br>虚拟主机用户可以在.htaccess文件中添加如下代码过滤TRACE请求:<br>RewriteEngine on<br>RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)<br>RewriteRule .* - [F]<br>服务器用户在httpd.conf尾部添加如下指令后重启apache即可:<br>TraceEnable off </p></blockquote><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p><a href="https://tools.ietf.org/html/rfc2616#section-9.7" target="_blank" rel="external">参考</a></p><h2 id="PURGE"><a href="#PURGE" class="headerlink" title="PURGE"></a>PURGE</h2><p>非规范中定义的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常见Method简要分类&quot;&gt;&lt;a href=&quot;#常见Method简要分类&quot; class=&quot;headerlink&quot; title=&quot;常见Method简要分类&quot;&gt;&lt;/a&gt;常见Method简要分类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;HTTP/1.1 中实现的 method&lt;
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>08.</title>
    <link href="http://blog.renyimin.com/2017/09/22/2017-09-22-composer-08/"/>
    <id>http://blog.renyimin.com/2017/09/22/2017-09-22-composer-08/</id>
    <published>2017-09-22T13:20:17.000Z</published>
    <updated>2018-02-03T07:34:43.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Composer" scheme="http://blog.renyimin.com/categories/Composer/"/>
    
    
      <category term="Composer" scheme="http://blog.renyimin.com/tags/Composer/"/>
    
  </entry>
  
</feed>
