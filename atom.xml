<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2018-02-06T14:30:24.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&lt;HTTP权威指南&gt;学习--第17章 内容协商与转码 (300)</title>
    <link href="http://blog.renyimin.com/2017/12/06/http/2017-12-06-HTTP-06-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E4%B8%8E%E8%BD%AC%E7%A0%81%20/"/>
    <id>http://blog.renyimin.com/2017/12/06/http/2017-12-06-HTTP-06-内容协商与转码 /</id>
    <published>2017-12-06T10:50:27.000Z</published>
    <updated>2018-02-06T14:30:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p><strong>一个URL常常需要代表若干不同的资源</strong>: 例如那种需要以多种语言提供其内容的网站站点。<br> 如果某个站点有 ‘说法语的’ 和 ‘说英语的’ 两种用户, 它可能想用这两种语言提供网站站点信息;<br> 理想情况下，服务器应当向英语用户发送英文版，向法语用户发送法文版; 而用户只要访问网站主页就可以得到相应语言的内容。</p></li><li><p>HTTP提供了 <code>内容协商</code> 方法，允许客户端和服务器作这样的决定。<br> 通过这些方法，单一的URL就可以代表不同的资源(比如，同一个网站页面的法语版和英语版)，这些不同的版本称为<code>变体</code>。</p></li><li><p>除了根据 <code>内容协商</code> 来决定URL代表的是那种版本的资源。另外, 对于有些特定的URL来说, 服务器还可以根据一些<strong>其他原则</strong>来决定发送什么内容给客户端最合适。在有些场合下, 服务器甚至可以自动生成定制的页面。比如，服务器可以为手持设备把HTML页面转换成WML页面，这类动态内容变换被称为<strong>转码</strong>。这些变换动作是HTTP客户端和服务器之间进行内容协商的结果。</p></li></ol><h2 id="内容协商技术"><a href="#内容协商技术" class="headerlink" title="内容协商技术"></a>内容协商技术</h2><ol><li><p>共有3种不同的方法可以决定服务器上哪个页面最适合客户端: <code>让客户端来选择</code>, <code>服务器自动判定</code>, 或 <code>让中间代理来选</code>。这3种技术分别称为<code>客户端驱动的协商</code>、<code>服务器驱动的协商</code> 以及 <code>透明协商</code></p></li><li><p>内容协商技术摘要如下:<br><img src="/img/http/内容协商.png" width="600"></p></li></ol><h3 id="客户端驱动-300"><a href="#客户端驱动-300" class="headerlink" title="客户端驱动 (300)"></a>客户端驱动 (300)</h3><p>1.对于服务器来说，收到客户端请求时只是发回响应，在其中列出可用的页面，让客户端决定要看哪个，这是最容易的事情。</p><ul><li>很显然，这是服务器最容易实现的方式，而且客户端很可能选择到最佳的版本(只要列表中有让客户端选择的足够信息)。</li><li>不利之处是<strong>每个页面都需要两次请求</strong>: <strong>第一次获取列表</strong>，<strong>第二次获取选择的副本</strong>。<br>这种技术速度很慢且过程枯燥乏味，让用户厌烦。</li></ul><p>2.从实现原理上来说，服务器实际上有两种方法为客户端提供选项:</p><ul><li>一是发送回一个HTML文档，里面有到该页面的各种版本的链接和每个版本的描述信息;</li><li>另一种方法是发送回HTTP/1.1响应时，使用 <code>300 Multiple Choices</code> 响应代码。客户端浏览器收到这种响应时，在前一种情况下(发回html文档的情况)，会显示一个带有链接的页面; 在后一种情况下，可能会弹出对话窗口，让用户做选择。不管怎么样，决定是由客户端的浏览器用户作出的</li></ul><p>3.除了增加时延并且对每个页面都要进行繁琐的多次请求之外, 这种方法<strong>还有一个缺点</strong>: 它需要多个URL, 公共页面要一个, 其他每种特殊页面也都要一个。</p><h3 id="服务器驱动"><a href="#服务器驱动" class="headerlink" title="服务器驱动"></a>服务器驱动</h3><p>1.之前已经知道了客户端驱动的协商存在的若干缺点。大部分缺点都涉及客户端和服务器之间通信量的增长, 这些通信量用来决定什么页面才是对请求的最佳响应。</p><p>2.而减少额外通信量的一种方法是<strong>让服务器来决定发送哪个页面回去</strong>，但为了做到这一点，<strong>客户端必须发送有关客户偏好的足够信息</strong>，以便服务器能够作出准确的决策。服务器通过 <code>客户端请求的首部集</code> 来获得这方面的信息(客户偏好)!! 有以下两种机制可供HTTP服务器评估发送什么响应给客户端比较合适：</p><ul><li>检査 客户端请求中的<code>内容协商首部集</code>: 服务器察看客户端发送的 <code>Accept内容协商首部集</code>, 设法用相应的响应首部与之匹配;</li><li>根据其他(非内容协商)首部进行变通, 例如，服务器可以根据客户端发送的 <code>User-Agent</code> 首部来发送响应</li></ul><h4 id="客户端内容协商首部集"><a href="#客户端内容协商首部集" class="headerlink" title="客户端内容协商首部集"></a>客户端内容协商首部集</h4><p>1.客户端可以用下面列出的HTTP首部集发送用户的偏好信息</p><blockquote><p>Accept : 告知服务器发送何种媒体类型<br>Accept-Language : 告知服务器发送何种语言<br>Accept-Charset : 告知服务器发送何种字符集<br>Accept-Encoding : 告知服务器采用何种编码</p></blockquote><p>2.<strong>实体首部集</strong> 和 <strong>内容协商首部集</strong></p><ul><li><strong>注意</strong>: 内容协商首部集与实体首部非常类似(比如 <code>Accept-Encoding</code> 和 <code>Content-Encoding</code>)。不过, 这两种首部的用途截然不同:</li><li><p><code>实体首部集</code>,像运输标签,它们描述了把报文从服务器传输给客户端的过程中必须的各种报文主体属性; 如下列出的实体首部集来匹配客户端的<code>Accept内容协商首部集</code></p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Accet首部            实体首部</div><div class="line">Accept    　　　　　　Content-Type</div><div class="line">Accept-Language     Content-Language</div><div class="line">Accept-Charset      Content-Type</div><div class="line">Accept-Encoding     Content-Encoding</div></pre></td></tr></table></figure><p>  （由于HTTP是无状态的协议，表示服务器不会在不同的请求之间追踪客户端的偏好，所以客户端必须在每个请求中都发送其偏好信息）</p></li><li><p>而<code>内容协商首部集</code>是由客户端发送给服务器用来告知其偏好信息的, 以便服务器可以从文档的不同版本中选择出最符合客户端偏好的那个来提供服务;</p></li></ul><p>3.如果两个客户端都发送了 <code>Accept-Language</code> 首部来描述它们感兴趣的语言信息, 服务器就能够决定发送www.joes-hardware.com的何种版本给哪个客户端了。<strong>让服务器选择发送回去的文档</strong>，减少了往返通信的时延，这种时延是<code>客户端驱动模型中</code>无法避免的。</p><p>4.然而, 假设某个客户端偏好西班牙文，那服务器应当回送哪个版本的页面呢？英语还是法语？<br>服务器只有两种选择：猜测 或 回退到客户端驱动模型,问客户端选择哪个。假如这个西班牙人碰巧懂一点英语，他可能会选择英文页面，这不是最理想的，但它能解决问题。<br>在这种情况下，这个西班牙人需要有办法传达更多与其偏好有关的信息，也就是他的确对英语略知一二，在没有西班牙语的时候，英语也行。</p><p>5.幸运的是，HTTP提供了一种机制，可以让与这个西班牙人情况类似的客户端更详细地描述其偏好。这种机制就是<strong>质量值(简称q值)</strong></p><h4 id="内容协商首部中的质量值"><a href="#内容协商首部中的质量值" class="headerlink" title="内容协商首部中的质量值"></a>内容协商首部中的质量值</h4><p>1.HTTP协议中定义了质量值，允许客户端为每种偏好类别列出多种选项，并为每种偏好选项关联一个优先次序。</p><ul><li>例如，客户端可以发送下列形式的<code>Accept-Language</code>首部：<code>Accept-Language: en; q=0.5, fr; q=0.0 , nl; q=1.0, tr; q=0.0</code><br>  其中q值的范围从0.0-1.0(0.0是优先级最低的，而1.0是优先级最高的)。<br>  上面列出的那个首部，说明该客户端最愿意接收荷兰语(缩写为nl)文档，但英语(缩写为en)文档也行; 无论如何，这个客户端都不愿意收到法语(缩写为fr)或土耳 其语(缩写为tr)的版本;</li></ul><p>2.<strong>注意</strong>: 偏好的排列顺序并不重要，只有与偏好相关的<code>q值</code>才是重要的;</p><h4 id="客户端其它请求首部集"><a href="#客户端其它请求首部集" class="headerlink" title="客户端其它请求首部集"></a>客户端其它请求首部集</h4><p>1.服务器也可以根据客户端其他请求首部集来匹配响应, 比如 <code>User-Agent</code> 首部。例如, 服务器知道老版本的浏览器不支持JavaScript语言，这样就可以向其发送不含有JavaScript的页面版本。</p><p>2.在这种情况下，没有q值机制可供査找”最近似”的匹配。服务器或者去找完全匹配，或者简单地有什么就给什么，这取决于服务器的实现。</p><p>3.由于缓存需要尽力提供所缓存文档中正确的”最佳”版本，HTTP协议定义了服务器在响应中发送的 <code>Vary</code> 首部。这个首部告知<strong>缓存</strong>,<strong>客户端</strong>,和<strong>所有下游的代理</strong>, 服务器根据哪些首部来决定发送响应的最佳版本。</p><h3 id="透明协商-vary首部"><a href="#透明协商-vary首部" class="headerlink" title="透明协商(vary首部)"></a>透明协商(vary首部)</h3><p>1.了支持<strong>透明内容协商</strong>，服务器必须有能力告知代理，服务器需要检査哪些请求首部，以便对客户端的请求进行最佳匹配。但是HTTP/1.1规范中没有定义任何透明协商机制, 不过却定义了 <code>Vary</code> 首部。服务器在响应中发送了Vary首部，以告知中间节点需要使用哪些请求首部进行内容协商<br>2.代理缓存可以为通过单个URL访问的文档保存不同的副本, <strong>如果服务器把它们的决策过程传给代理,这些代理就能代表服务器与客户端进行协商</strong>。<br>（缓存同时也是进行内容转码的好地方，因为部署在缓存里的通用转码器能对任意服务器，而不仅仅是一台服务器传来的内容进行转码）</p><p>3.对内容进行缓存的时候是假设内容以后还可以重用。然而，为了确保对客户端请求回送的是正确的已缓存响应, 缓存必须应用服务器在回送响应时所用到的大部分决策逻辑;</p><p>4.之前我们已经了解了客户端发送的<code>Accept内容协商首部集</code>; 也了解到, 为了给每条请求选择最佳的响应, 服务器使用了哪些与这些首部集匹配的相应<code>实体首部集</code>。其实, 代理缓存也必须使用相同的首部集来决定回送哪个已缓存的响应。</p><p>5.<strong>下图展示了涉及缓存的正确及错误的操作序列</strong>。</p><ul><li>缓存把第一个请求转发给服务器，并存储其响应。</li><li>对于第二个请求，缓存根据URL査找到了匹配的文档。但是，这份文档是法语版的，而请求者想要的是西班牙语版的。如果缓存只是把文档的法语版本发给请求者的话，它就犯了错误;</li><li>像上面2中提到的, 代理缓存也必须要根据客户端发送来的<code>内容协商首部</code>来给客户端返回正确的响应<br>  <img src="/img/http/cache-beiyong-error.png" width="550"></li></ul><h4 id="Vary首部"><a href="#Vary首部" class="headerlink" title="Vary首部"></a>Vary首部</h4><p>1.下面是浏览器和服务器发送的一些典型的请求及响应首部:<br>    <img src="/img/http/vary-01.png" width="490"></p><p>2.然而, 如果服务器的决策不是依据<code>Accept</code>首部集，而是比如<code>User-Agent</code>首部的话，情况会如何？<br>例如, 服务器可能知道老版本的浏览器不支持JavaScript语言, 因此可能会回送不包含JavaScript的页面版本。<br>如果服务器是根据其他首部来决定发送哪个页面的话, <strong>和Accept首部集一样, 缓存也必须知道这些首部是什么, 这样才能在选择回送的页面时做出同样的逻辑判断</strong>。</p><p>3.HTTP的 <code>Vary</code> 响应首部中列出了所有客户端请求首部, 服务器可用这些首部来选择文档或产生定制的内容(在常规的内容协商首部集之外的内容)。例如, 若所提供的文档取决于<code>User-Agent</code>首部, <code>Vary首部</code>就必须包含<code>User-Agent</code>;</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>当新的请求到达时, 代理缓存会根据<code>内容协商首部集</code>来寻找最佳匹配。但在把文档提供给客户端之前, <strong>它还必须检査服务器有没有在已缓存响应中发送Vary首部</strong>。</li><li>如果有Vary首部, 那么新请求中那些首部的值必须与旧的已缓存的响应的请求首部相同。(也就是说,代理缓存也会保存旧的请求的请求首部和响应首部, 下面一句话更加肯定这一点)</li><li>因为服务器可能会根据客户端请求的首部来改变响应, 为了实现透明协商, 代理缓存就必须为每个已缓存变体保存<strong>客户端请求首部</strong>和<strong>相应的服务器响应首部</strong>)<br> <img src="/img/http/vary-02.png" width="650"></li><li>如果某服务器的Vary首部看起来像 <code>Vary: User-Agent, Cookie</code> 这样，大量不同的User-Agent和Cookie值将会产生非常多的变体, 而代理缓存必须为每个变体保存其相应的文档版本。当缓存执行査找时，首先会对内容协商首部集进行内容匹配，然后比较请求的变体与缓存的变体。如果无法匹配，缓存就从原始服务器获取文档</li></ol><h2 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h2><ol><li><p>我们已经讨论了一个机制, 该机制可以让客户端和服务器从某个URL的一系列文档中挑选出最适合客户端的文档。但是, 实现这些机制的前提是，存在一些满足客户端需求的文档—不管是完全满足还是在一定程度上满足;</p></li><li><p>然而, 如果服务器没有能满足客户端需求的文档会怎么样呢？服务器可以给出一个错误响应。但理论上，服务器可以把现存的文档转换成某种客户端可用的文档, 这种选项称为<strong>转码</strong>;</p></li><li><p>下面列出了一些假设的转码</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">转换之前 　　　　　　　　　　　　转换之后</div><div class="line">HTML文档    　　　　　　　　　　WML文档</div><div class="line">高分辨率图像    　　　　　　　　低分辨率图像</div><div class="line">彩色图像    　　　　　　　　　　黑白图像</div><div class="line">有多个框架的复杂页面    　　　　没有很多框架或图像的简单文本页面</div><div class="line">有Java小应用程序的HTML页面    没有Java小应用程序的HTML页面</div><div class="line">有广告的页面    　　　　　　　　去除广告的页面</div></pre></td></tr></table></figure></li><li><p>有3种类别的转码: <strong>格式转换</strong>、<strong>信息综合</strong>以及<strong>内容注入</strong></p></li></ol><h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><ol><li><p>格式转换是指将数据从一种格式转换成另一种格式, 使之可以被客户端査看。通过HTML到WML的转换, 无线设备就可以访问通常供桌面客户端査看的文档了。通过慢速连接访问Web页面的客户端并不需要接收高分辨率图像, 如果通过格式转换降低图像分辨率和颜色来减小图像文件大小的话, 这类客户端就能更容易地査看图像比较丰富的页面了。</p></li><li><p>格式转换可以由如下<code>内容协商首部集</code>来驱动, 但也能由 <code>User-Agent</code> 首部来驱动。注意: <code>内容转换或转码</code> 与 <code>内容编码</code> 或 <code>传输编码</code> 是不同的, 后两者一般用于更高效或安全地传输内容, 而前两者则可使访问设备能够査看内容;</p><pre><code class="php">Accet首部            实体首部Accept    　　　　　　Content-TypeAccept-Language     Content-LanguageAccept-Charset      Content-TypeAccept-Encoding     Content-Encoding</code></pre></li></ol><h3 id="信息综合"><a href="#信息综合" class="headerlink" title="信息综合"></a>信息综合</h3><ol><li><p>从文档中提取关键的信息片段称为信息综合(information synthesis), 这是一种有用的转码操作。这种操作的例子包括根据小节标题生成文档的大纲，或者从页面中删除广告和商标</p></li><li><p>根据内容中的关键字对页面分类是更精细的技术, 有助于总结文档的精髓。这种技术常用于Web页面分类系统中，比如门户网站的Web页面目录</p></li></ol><h3 id="内容注入"><a href="#内容注入" class="headerlink" title="内容注入"></a>内容注入</h3><p>参见P423</p><h3 id="转码与静态预生成的对比"><a href="#转码与静态预生成的对比" class="headerlink" title="转码与静态预生成的对比"></a>转码与静态预生成的对比</h3><ol><li><p>转码的替代做法是在Web服务器上建立Web页面的不同副本, 例如一个是HTML, 一个是WML, 一个图像分辨率高，一个图像分辨率低；一个有多媒体内容，一个没有。</p></li><li><p>但是，这种方法不是很切合实际，原因很多：</p><ul><li>某个页面中的任何小改动都会牵扯很多页面，需要很多空间来存储各页面的不同版本，而且使页面编目和Web服务器编程(以提供正确的版本)变得更加困难。</li><li>有些转码操作，比如广告插入(尤其是定向广告插入)，就不能静态实现, 因为插入什么广告和请求页面的用户有关</li></ul></li><li><p>对单一的根页面进行即时转换，是比静态的预生成更容易的解决方案。<br> 但这样会在提供内容时增加时延。不过有时候其中一些计算可以由第三方进行，这样就减少了Web服务器上的计算负荷——比如可以由代理或缓存中的外部Agent完成转换</p></li><li><p>下图显示了在代理缓存中进行的转码<br> <img src="/img/http/zhuanma-01.png" width="430"></p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><http权威指南></http权威指南>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;一个URL常常需要代表若干不同的资源&lt;/strong&gt;: 例如那种需要以多种语言提供其内容的网站站点。&lt;b
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP -- 实体和编码 (400, 411, 206)</title>
    <link href="http://blog.renyimin.com/2017/12/04/http/2017-12-04-HTTP-04-Entity-Header-Fields%20/"/>
    <id>http://blog.renyimin.com/2017/12/04/http/2017-12-04-HTTP-04-Entity-Header-Fields /</id>
    <published>2017-12-04T04:50:27.000Z</published>
    <updated>2018-02-07T11:35:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>主要讲解一些实体首部字段的相关知识</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1.要知道, 每天都有数以万计的各种媒体对象经由HTTP传送, 如图像, 文本, 影片以及软件程序等。只要你能叫出名字, HTTP就可以传送。<br>2.更重要的是: HTTP还会确保它的报文被正确传送, 识别, 提取以及适当处理</p><p>3.具体来说, <strong>HTTP要确保它所承载的”货物”满足以下条件</strong>:</p><ul><li><strong>符合用户的需要</strong>(基于<code>Accept</code>系列的内容协商首部)</li><li><strong>在网络上可以快速有效地传输</strong>(通过<code>范围请求</code>, <code>差异编码</code>以及<code>其他数据压缩方法</code>)</li><li><strong>完整到达, 未被篡改</strong>(通过传输编码首部和<code>Content-MD5</code>校验和首部)</li><li><strong>可以被正确识别</strong>(比如:通过<code>Content-Type</code>首部说明媒体格式, <code>Content-Language</code>首部说明语言), 以便浏览器和其他客户端能正确处理内容。</li><li><strong>可以被正确地解包</strong>(比如:通过<code>Content-Length</code>首部和<code>Content-Encoding</code>首部)。</li><li><strong>是最新的</strong>(通过实体验证码和缓存过期控制, 这一点第7章 缓存相关知识点已经介绍过)</li></ul><p>可以看到, HTTP要保证它所承载的货物完好的话, 会用到各种首部字段;</p><h2 id="报文实体"><a href="#报文实体" class="headerlink" title="报文实体"></a>报文实体</h2><p>1.HTTP响应报文中的报文实体由 <code>实体首部</code> 和 <code>实体主体</code> 组成; </p><ul><li>实体首部和实体主体之间以一个空白的CRLF行分隔;</li><li>实体主体中是原始数据, 所以需要 <code>实体首部</code> 来描述数据的意义;(例如 <code>Content-Type实体首部</code> 告诉我们数据的媒体格式…)。</li></ul><p>2.如下一个简单的HTTP响应报文:<br>    <img src="/img/http/15-01.png" width="350"></p><p>3.上面报文中:</p><ul><li>实体首部<code>Content-Type:text/plain</code>指出这是一个纯文本文档</li><li><code>Content-Length</code>首部指出它只有18个字节</li><li>一行空白(CRLF)把首部字段 和 主体的开始部分分隔开来</li></ul><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><ul><li>HTTP/1.1几个基本实体首部字段如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Content-Type : 实体中所承载对象的类型</div><div class="line">Content-Length 所传送实体主体的长度或大小</div><div class="line">Content-Encoding 对象数据所做的任意变换(比如,压缩)</div><div class="line">Content-Location 一个备用位置, 请求时可通过它获得对象</div><div class="line">Content-Range 如果这是部分实体, 这个首部说明它是整体的哪个部分</div><div class="line">Content-MD5 实体主体内容的校验和</div><div class="line">Last-Modified 所传输内容在服务器上创建或最后修改的日期时间</div><div class="line">Expires 实体数据将要失效的日期时间（为了兼容HTTP/1.0, 1.1中可以使用Cache-Control:max-age=..）</div><div class="line">Allow 该资源所允许的各种请求方法, 例如：GET和HEAD</div></pre></td></tr></table></figure></li></ul><h3 id="实体主体"><a href="#实体主体" class="headerlink" title="实体主体"></a>实体主体</h3><p>1.实体主体就是原始数据, 所以需要<code>实体首部</code>告诉我们如何去解释数据(content-type是图像还是文本,content-encoding是已被压缩或者重编码)<br>2.实体首部字段最后一以一个空白的CRLF行结束, 随后就是实体主体的原始内容, 不管内容是什么, 文本或二进制,文档或图像,压缩的或未压缩的, 英语,法语或日语,都紧随这个CRLF之后。</p><h2 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h2><p>1.<code>实体首部 Content-Length</code> 指示出报文主中实体主体的字节大小。</p><p>2.<strong>注意</strong>: 如果对文本文件进行了gzip压缩的话, Content-Length首部就是压缩后的大小, 而不是原始大小(后面在介绍<a href="http://localhost:4000/2017/12/04/2017-12-04-HTTP-04-Entity-Header-Fields%20/#%E5%86%85%E5%AE%B9%E7%BC%96%E7%A0%81%E8%BF%87%E7%A8%8B" target="_blank" rel="external">内容编码过程</a>的时候还会提及)。<br>    某些HTTP应用程序在这方面搞错了, 发送的是数据编码之前的大小, 这会导致严重的错误, 尤其是用在持久连接上。</p><p>3.除非使用了<code>分块编码</code>, 否则 <code>Content-Length</code> 实体首部就是带有实体主体的报文必须使用的; </p><ul><li>当然, 短连接自然也用不上content-length, 它依靠关闭连接就可以知道实体的大小</li><li><strong>使用Content-Length首部是为了能够检测出服务器崩溃而导致的<code>报文截尾</code>;</strong></li><li><strong>并对共享持久连接的多个报文进行正确分段</strong>。</li></ul><h3 id="检测截尾"><a href="#检测截尾" class="headerlink" title="检测截尾"></a>检测截尾</h3><p>1.HTTP早期版本采用<code>关闭连接</code>的办法来划定报文的结束; 但是, 没有 Content-Length 的话, 客户端无法区分到底是报文结束而导致正常的连接关闭, 还是在报文传输中由于服务器崩溃而导致的连接关闭; <strong>所以客户端需要 Content-Length 实体首部, 来监测报文截尾</strong></p><p>2.<code>报文截尾的问题</code> 对<strong>缓存服务器</strong>来说尤其严重, 如果缓存服务器收到被截尾的报文却没有识别出截尾的话, 它可能会存储不完整的内容并多次使用它来提供服务。<br>    <strong>缓存代理服务器通常不会为没有显示 Content-Length 首部的HTTP主体做缓存</strong>, 以此来减小缓存截尾报文的风险。</p><h3 id="Content-Length与持久连接"><a href="#Content-Length与持久连接" class="headerlink" title="Content-Length与持久连接"></a>Content-Length与持久连接</h3><p>1.<strong>Content-Length首部对于持久链接是必不可少的</strong>: 如果响应通过持久连接传送, 就可能有另一条HTTP响应紧随其后。客户端通过Content-Length首部就可以知道报文在何处结束,下一条报文从何处开始。因为连接是持久的, 客户端无法依赖连接关闭来判断报文的结束。<strong>所以需要有Content-Length来说明实体大小</strong></p><p>2.有一种情况, <strong>使用持久连接可以没有Content-Length首部</strong>，即<code>采用分块编码(chunked encoding)时</code>。</p><ul><li>在分块编码的情况下, 数据是分为一系列的块来发送的, <strong>每块都有大小说明</strong>。</li><li>哪怕服务器在生成首部的时候不知道整个实体的大小(通常是因为实体是动态生成的), 仍然可以使用分块编码传输若干已知大小的块。 </li></ul><h3 id="确定实体长度的规则"><a href="#确定实体长度的规则" class="headerlink" title="确定实体长度的规则"></a>确定实体长度的规则</h3><ul><li>Content-Length如果存在并且有效的话，则必须和消息内容的传输长度完全一致;</li><li>如果存在Transfer-Encoding(重点是chunked), 则在header中不能有Content-Length，有也会被忽视;</li><li>如果采用短连接，则直接可以通过<code>服务器关闭连接</code>来确定消息的传输长度。（这个很容易懂）<br>  在Http 1.0及之前版本中，content-length字段可有可无。因为这之前都不支持长连接.</li><li>在http1.1及之后版本, 如果是keep alive，<strong>则content-length和chunk必然是二选一</strong><br>  若是非keep alive，则和http1.0一样。content-length可有可无.</li></ul><p>为了和使用HTTP/1.0的应用程序兼容，任何带有实体主体的HTTP/1.1请求都必须带有正确的Content-Length首部字段(除非已经知道服务器兼容HTTP/1.1)<br>HTTP/1.1规范中建议对于带有主体但没有Content-Length首部的请求，服务器如果无法确定报文的长度，就应当发送 <code>400 Bad Request响应</code> 或 <code>411 Length Required</code> 响应，后一种情况表明服务器要求收到正确的Content-Length首部;</p><h2 id="实体摘要"><a href="#实体摘要" class="headerlink" title="实体摘要"></a>实体摘要</h2><h3 id="Content-MD5-数据的校验和"><a href="#Content-MD5-数据的校验和" class="headerlink" title="Content-MD5 数据的校验和"></a>Content-MD5 数据的校验和</h3><ol><li><p>尽管HTTP通常都是在像TCP/IP这样的可靠传输协议之上实现的, 但仍有很多因素会导致报文的一部分在传输过程中被修改;比如有不兼容的转码代理, 或者中间代理有误等等;</p></li><li><p>为检测实体主体的数据是否被不经意地修改, 发送方可以在生成初始的主体时, <strong>生成一个数据的 <code>校验和</code></strong>, 这样接收方就可以通过检査这个<code>校验和</code>来捕获所有意外的实体修改了;</p></li><li><p>服务器使用<code>Content-MD5</code>首部, 来发送对实体主体运行MD5算法的结果。</p><ul><li>只有产生响应的原始服务器可以计算并发送Content-MD5首部, <strong>中间代理和缓存不应当修改或添加这个首部</strong>, 否则就会与验证端到端完整性的这个最终目的相冲突。</li><li><code>Content-MD5</code>实体首部是在对内容做了所有需要的<code>内容编码</code>(content-encoding)之后, 还没有做任何<code>传输编码</code>(transfer-encoding)之前计算出来的。<br>  为了验证报文的完整性, 客户端必须先进行传输编码的解码, 然后计算所得到的未进行传输编码的实体主体的MD5;<br>  如果一份文档使用gzip算法进行压缩, 然后用分块编码发送, 那么就对整个经gzip压缩的主体进行MD5计算</li></ul></li><li><p>一般不常用到Content-MD5首部</p></li><li><p>作为对HTTP的扩展, 在IETF的草案中提出了其他一些摘要算法。这些扩展建议增加新的 <code>Want-Digest</code> 首部, 它允许客户端说明期望响应中使用的摘要类型，并使用质量值来建议多种摘要算法并说明优先顺序;</p></li></ol><h2 id="媒体类型和字符集简介"><a href="#媒体类型和字符集简介" class="headerlink" title="媒体类型和字符集简介"></a>媒体类型和字符集简介</h2><p><strong>Content-Type</strong></p><ol><li><p><code>Content-Type</code>实体首部字段说明了实体主体的MIME类型。MIME类型是标椎化的名字, 用于说明作为运载实体的基本媒体类型(比如:HTML文件, Microsoft Word文档或是MPEG视频等)。客户端应用程序使用MIME类型来解释和处理其内容。</p></li><li><p><code>Content-Type</code> 的值就是标椎化的MIME类型, 都在互联网号码分配机构IANA中注册。MIME类型由一个主媒体类型(比如:text,image或audio等)后面跟一条斜线一级一个子类型组成, 子类型用于进一步描述媒体类型。</p><ul><li>后面会详细讨论<a href="">MIME类型</a></li></ul></li><li><p><strong>要注意</strong>: <code>Content-Type</code> 实体首部, 说明的是原始实体主体的媒体类型, 例如, 经过内容编码的实体, <code>Content-Type</code> 首部说明的仍然是编码之前的实体主体的类型。</p></li><li><p>文本的字符编码</p><ul><li><code>Content-Type</code>首部还支持可选的参数来进一步说明内容的类型。charset(字符集)参数就是个例子, 它说明把实体中的比特转换为文本文件中的字符的方法:<code>Content-type:text/html;charset=iso-8859-4</code></li><li>后面会详细讨论<a href="">字符集</a></li></ul></li></ol><h2 id="内容编码-Content-Encoding"><a href="#内容编码-Content-Encoding" class="headerlink" title="内容编码 - Content-Encoding"></a>内容编码 - Content-Encoding</h2><p>HTTP应用程序有时在发送之前需要对内容进行编码。例如会把很大的HTML文档发送给通过慢速连接连上来的客户端之前, 服务器可能会对它进行<strong>压缩</strong>。</p><ul><li>这样有助于减少传输实体的时间。</li><li>服务器还可以把内容搅乱或加密,以此来防止未经授权的第三方看到文档的内容。</li><li>这种类型的编码是在发送方(可能是服务器也可能是代理缓存,下篇文章会看到 “缓存同时也是进行内容转码的好地方” 这句话)应用到内容之上的,当内容经过内容编码之后, 编好码的数据就放在实体主体中,像往常一样发送给接收方。 <h3 id="内容编码过程"><a href="#内容编码过程" class="headerlink" title="内容编码过程"></a>内容编码过程</h3></li></ul><ol><li>网站服务器生成原始响应报文, 其中有原始的 <code>Content-Type</code> 和 <code>Content-Length</code>首部;</li><li><p>内容编码服务器(也可能就是原始的服务器或下行的代理)创建编码后的报文。(编码后的报文Content-Type仍然和编码前相同, 但是Content-Length可能不同,比如主体被压缩了)。</p></li><li><p><strong>注意</strong>:</p><ul><li>Content-Type实体首部还需要出现在报文中, 因为它说明了实体的原始格式, 一旦实体被编码, 要显示的时候 ， 可能还是需要该信息才行的。、</li><li>Content-Length是编码之后的主体长度</li></ul></li><li><p>接收程序得到编码后的报文, 进行解码, 或得原始报文。    </p></li><li>可以参考下图:<br> <img src="/img/http/Content-Encoding-01.png" width="500"></li></ol><h3 id="内容编码类型"><a href="#内容编码类型" class="headerlink" title="内容编码类型"></a>内容编码类型</h3><h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a><code>Content-Encoding</code></h4><ol><li>HTTP定义了一些标准的内容编码类型, 并允许用扩展的形式添加更多的编码。由互联网号码分配机构(IANA)对各种编码进行标准化, 它给每个内容编码算法分配了唯一的代号。</li><li><code>Content-Encoding</code> 实体响应首部就用这些标准化的代号来说明编码时使用的算法;</li><li><p>编码算法(Content-Encoding值)如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gzip　　表明实体采用GNU zip编码</div><div class="line">compress 表明实体采用Unix的文件压缩程序</div><div class="line">deflate　　表明实体是用zlib的格式压缩的</div><div class="line">identity　　表明没有对实体进行编码。当没有Content-Encoding header时， 就默认为这种情况</div></pre></td></tr></table></figure><p> gzip, compress, 以及deflate编码都是无损压缩算法，用于减少传输报文的大小，不会导致信息损失。 其中gzip通常效率最高， 使用最为广泛。</p></li></ol><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a><code>Accept-Encoding</code></h4><ol><li>为了避免服务器使用客户端不支持的编码方式, 客户端就把自己支持的内容编码方式列表放在请求的 <code>Accept-Encoding</code> 首部里面发出去。</li><li>如果HTTP请求中没有包含 <code>Accept-Encoding</code> 首部, 服务器可以假设客户端能够接受任何编码方式(等价于发送<code>Accept-Encoding:*</code>)</li><li>如下展示了HTTP事务中对 <code>Accept-Encoding</code> 请求首部的使用<br> <img src="/img/http/accept-encoding-01.png" width="500"></li><li><code>Accept-Encoding</code> 字段包含用逗号分隔的的支持编码的列表, 下面是一些例子 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Accept-Encoding: compress,gzip</div><div class="line">Accept-Encoding: </div><div class="line">Accept-Encoding: *</div><div class="line">Accept-Encoding: compress;q=0.5, gzip;q=1.0</div><div class="line">Accept-Encoding: gzip;q=1.0, identity;q=0.5, *;q=0</div></pre></td></tr></table></figure></li></ol><h2 id="传输编码与分块编码"><a href="#传输编码与分块编码" class="headerlink" title="传输编码与分块编码"></a>传输编码与分块编码</h2><p><a href="http://localhost:4000/2017/11/30/2017-11-30-HTTP-04-General-Header-Fields/#Transfer-Encoding" target="_blank" rel="external">已经在通用首部字段中进行过介绍了</a><br>更多参考P375</p><h2 id="范围请求-断点续传"><a href="#范围请求-断点续传" class="headerlink" title="范围请求 - 断点续传"></a>范围请求 - 断点续传</h2><h3 id="accept-ranges-content-range-range"><a href="#accept-ranges-content-range-range" class="headerlink" title="accept-ranges, content-range, range"></a>accept-ranges, content-range, range</h3><ol><li><p>HTTP允许客户端只请求文档的一部分或者说某个范围。假设你正通过慢速的调制解调器连接下载最新的热门软件, 已经下了四分之三, 忽然因为一个网络故障, 连接中断了。你已经为等待下载完成耽误了很久, 而现在被迫要全部重头再来, 那多倒霉。</p></li><li><p>有了范围请求, HTTP客户端可以通过请求<strong>曾获取失败的实体</strong>的一个范围(或者说一部分), 来恢复下载该实体。当然这有一个前提，那就是从客户端上一次请求该实体到这次发出范围请求的时段内，该对象在服务器中没有改变过</p></li><li><p>例如:</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET /bigfile.html HTTP/<span class="number">1.1</span></div><div class="line">Host: www.joes-hardware.com </div><div class="line">Range: bytes=<span class="number">4000</span>-</div><div class="line">User-Agent: Mozilla/<span class="number">4.61</span> [en] (WinNT; I)</div></pre></td></tr></table></figure><p> 在本例中, 客户端请求的是文档开头4000字节之后的部分(不必给出结尾字节数, 因为请求方可能还不知道文档的大小)。（在客户端收到了开头的4000字节之后就失败的情况下, 可以使用这种形式的范围请求）</p></li><li><p>还可以用<code>Rang请求首部字段</code>来<strong>请求多个范围</strong>(这些范围可以按任意顺序给出, 也可以相互重叠)。</p><ul><li>例如,假设客户端同时连接到多个服务器, 为了加速下载文档<strong>而从不同的服务器下载同一个文档的不同部分</strong>。</li><li>对于客户端在一个请求内请求多个不同范围的情况, 返回的响应也是单个实体, 不过它会有一个<strong>多部分主体</strong>及<strong>Content-Type:multipart/byteranges首部</strong>。</li></ul></li><li><p>并不是所有服务器都接受范围请求，但很多服务器可以。</p><ul><li><p><strong>服务器可以通过在响应中包含响应首部字段<code>Accept-Ranges</code></strong>, 向客户端说明可以接受的范围请求。这个首部的值是计算范围的单位，通常是以字节计算的。例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> <span class="number">0</span>K</div><div class="line">Date: Fri, <span class="number">05</span> Nov <span class="number">2016</span> <span class="number">22</span>:<span class="number">35</span>:<span class="number">15</span> GMT</div><div class="line">Server: Apache/<span class="number">1.2</span><span class="number">.4</span></div><div class="line">Accept-Ranges: bytes</div></pre></td></tr></table></figure></li><li><p>服务器响应中的 <code>响应首部字段 accept-ranges</code>告诉客户端可以使用范围请求</p></li><li>对应的 客户端请求的 <code>请求首部字段range</code> 可以告知服务器此次请求的范围 (可以是多个范围)<br>接收到客户端请求中包含<code>range首部字段</code>的服务器, 会在处理请求之后返回状态码为 <code>206 Partial Content</code>的响应;<br>无法处理该范围请求时,则会返回状态码 200 ok响应及全部资源。</li><li>服务器响应中的 <code>Content-Range实体首部字段</code> 能告诉客户端作为响应返回的实体的哪个部分符合范围请求。<br>字段值以字节为单位(和服务器之前发回的accept-ranges首部字段说明的单位一样,都是字节)<br>还会告知当前发送的部分及整个实体大小；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Content-Range: bytes 5001-10000/1000</div></pre></td></tr></table></figure></li></ul></li><li><p>下图展示了范围请求的一系列HTTP事务的例子<br> <img src="/img/http/content-range_accept_ranges.png" width="500"></p></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>Range首部在流行的<code>点对点(Peer-to-Peer，P2P)</code>文件共享客户端软件中得到广泛应用, 它们从不同的对等实体同时下载多媒体文件的不同部分。</li><li>注意, 范围请求也属于一类实例操控, 因为它们是在客户端和服务器之间针对特定的对象实例来交换信息的。也就是说, 客户端的范围请求仅当客户端和服务器拥有文档的<strong>同一个版本</strong>时才有意义。**</li></ol><h2 id="扩展-–-差异编码"><a href="#扩展-–-差异编码" class="headerlink" title="扩展 – 差异编码"></a>扩展 – 差异编码</h2><ol><li><p>我们曾把网站页面的<strong>不同版本看作页面的不同实例</strong>。如果客户端有一个页面的已过期副本, 就要请求页面的最新实例。如果服务器有该页面更新的实例, 就要把它发给客户端, <strong>哪怕页面上只有一小部分发生了改变,也要把完整的新页面实例发给客户端</strong></p></li><li><p>若改变的地方比较少, 与其发送完整的新页面给客户端, <strong>客户端更愿意服务器只发送页面发生改变的部分</strong>, 这样就可以更快地得到最新的页面。</p></li><li><p><code>差异编码</code>是HTTP协议的一个扩展, 它通过交换对象改变的部分而不是完整的对象来优化传输性能。<br> 差异编码和范围请求一样, 也是<code>一类实例操控</code>, 因为它依赖客户端和服务器之间针对特定的对象实例来交换信息。</p></li></ol><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><ol><li><p>下图清楚地展示了差异编码的结构:包括请求、生成、接收和装配文档的全过程。<br> <img src="/img/http/A-IM--226.png" width="550"></p></li><li><p>客户端必须告诉服务器:</p><ul><li>它有页面的哪个版本</li><li>它愿意接受页面最新版的差异(<code>A-IM:diffe</code>)</li><li>它懂得哪些将差异应用于现有版本的算法</li></ul></li><li><p>服务器必须:</p><ul><li>检査它是否有这个页面的客户端现有版本</li><li>计算客户端现有版本与最新版之间的差异(有若干算法可以计算两个对象之间的差异), 然后服务器必须计算差异, 发送给客户端, 告知客户端所发送的是差异(<code>IM:diffe</code>), 并说明最新版页面的新标识(ETag), 因为客户端将差异应用于其老版本之后就会得到这个版本</li></ul></li><li><p>客户端在<code>If-None-Match</code>首部中使用的是它所持有页面版本的唯一标识, 这个标识是服务器之前响应客户端时在ETag首部中发送的。</p><ul><li>客户端是在对服务器说:”如果你那里页面的最新版本标识和这个ETag不同, 就把这个页面的最新版本发给我”。</li><li>如果只有<code>If-None-Match</code>首部，服务器将会把该页面的最新版本完整地发给客户端。(假设最新版和客户端持有的版本不同)</li></ul></li><li><p>不过, 如果客户端想告诉服务器它<strong>愿意接受该页面的差异</strong>, 那发送<code>A-IM</code>首部就可以了。</p><ul><li><code>A-IM</code>是<code>Accept-Instance-Manipulation(接受实例操控)</code>的缩写。</li><li>形象比喻的话, 客户端相当于这样说:”哦对了, 我能接受某些形式的实例操控, 如果你会其中一种的话, 就不用发送完整的文档给我了”。</li><li>在<code>A-IM</code>首部中, 客户端会说明<strong>它知道哪些算法可以把差异应用于老版本而得到最新版本</strong>, 服务端发送回下面这些内容:<br>  一个特殊的响应代码 —— <code>226 IM Used</code>, 告知客户端它正在发送的是所请求对象的实例操控, 而不是那个完整的对象自身;<br>  一个<code>IM(Instance-Manipulation的缩写)</code>首部, 说明用于计算差异的算法;<br>  新的 <code>ETag</code> 首部<br>  <code>Delta-Base</code> 首部, 说明用于计算差异的基线文档的ETag(理论上, 它应该和客户端之前请求里的if-None-Match首部中的ETag相同)</li></ul></li><li>下表总结了差异编码使用的首部<br> <img src="/img/http/A-IM_IM_Delta-Base.png" width="600"></li></ol><h3 id="实例操控-差异生成器-差异应用器"><a href="#实例操控-差异生成器-差异应用器" class="headerlink" title="实例操控,差异生成器,差异应用器"></a>实例操控,差异生成器,差异应用器</h3><ol><li>客户端可以使用<code>A-IM</code>首部说明可以接受的一些实例操控的类型。(比如有<code>diffe</code>)</li><li><p>而服务器在<code>IM</code>首部中说明使用的是何种实例操控。(比如是<code>diffe</code>)</p></li><li><p>不过到底哪些实例操控类型是可接受的呢？它们又是做什么的呢？下表中列出了一些在IANA注册的实例操控类型<br> <img src="/img/http/IANA.png" width="600"></p></li><li><p>更多差异编码相关的 <code>实例操控类型</code>, 可以查看P384</p></li><li><p>差异编码可以减少传输次数，但实现起来可能比较麻烦。</p></li></ol><ul><li>设想一下页面改动频繁，而且有很多不同的人都在访问的情形。支持差异编码的服务器必须保存页面随时间变化的所有不同版本，这样才能指出最新版本与所请求的客户端持有的任意版本之间的差异</li><li>如果文档变化频繁，而且有很多客户端都在请求文档，那它们就会获得文档的不同实例。随后当它们再向服务器发起请求时，它们将请求它们所持有的版本与最新版本之间的差异。为了能够只向它们发送变化的部分，服务器必须保存所有客户端曾经持有过的版本</li><li>要降低提交文档时的延迟时间，服务器必须增加磁盘空间来保存文档的各种旧的实例。实现差异编码所需的额外磁盘空间可能很快就会将减少传输量获得的好处抵消掉</li></ul><blockquote><p><http权威指南>学习–第15章</http权威指南></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;主要讲解一些实体首部字段的相关知识&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;1.要知道, 每天都有数以万计的各种媒体对象经由HTTP
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP -- cookie机制 (401)</title>
    <link href="http://blog.renyimin.com/2017/12/02/http/2017-12-02-HTTP-06-cookie/"/>
    <id>http://blog.renyimin.com/2017/12/02/http/2017-12-02-HTTP-06-cookie/</id>
    <published>2017-12-02T02:27:36.000Z</published>
    <updated>2018-02-28T08:56:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>HTTP最初是一个 <strong>匿名</strong>, <strong>无状态</strong> 的请求/响应协议; 服务器处理来自客户端的请求, 然后向客户端回送一条响应。Web服务器几乎没有什么信息可以用来判断是哪个用户发送的消息, 也无法记录来访用户的请求序列。</p></li><li><p>对于现代的Web站点我们, 我们知道, Web服务器可能会同时与成千上万个不同的客户端进行对话, 这些服务器通常都要记录下它们与谁交谈, 而不会认为所有的请求都来自匿名的客户端。因为现代的Web站点希望能够提供个性化的接触, 它希望对连接另一端的用户有更多的了解, 并且能在用户浏览页面时对其进行跟踪。</p></li><li><p>比如, Amazon.com可以通过以下几种方式实现站点的个性化:</p><ul><li>个性化问候 (专门为用户生成的欢迎词和页面内容, 使购物体验更加个性化)</li><li><strong>有的放矢的推荐</strong> (通过了解客户的兴趣, 推荐一些他们认为客户可能会感兴趣的商品。还可以在临近客户生日或其他一些重要日子的时候提供生日特定的商品)</li><li>管理信息的存档 (站点可以将用户的如地址,信用卡信息保存在一个数据库中, 只要他们识别出用户, 就可以使用该用户存档的管理信息, 而不是用户在购物时一次次地填写繁琐的地址和信用卡信息)</li><li>记录会话 (HTTP事务是无状态的, 每条请求/响应都是独立进行的。而很多Web站点希望能在用户与站点交互的过程中, 比如使用在线购物车的时候, 构建增量状态。要做到这一功能, <strong>Web站点就需要有一种方式来区分来自不同用户的HTTP事务</strong>)</li></ul></li><li><p>简而言之就是: HTTP无状态协议, 希望识别每个来自不同用户的HTTP事务; </p></li></ol><h2 id="HTTP识别用户的几种技巧"><a href="#HTTP识别用户的几种技巧" class="headerlink" title="HTTP识别用户的几种技巧"></a>HTTP识别用户的几种技巧</h2><ol><li>承载用户身份信息的HTTP首部</li><li>客户端IP地址跟踪, 通过用户的IP按地址对其进行识别</li><li>用户登录, 用认证方式来识别用户</li><li>胖URL, 一种在URL中嵌入识别信息的技术</li><li>cookie, 一种功能强大且高效的持久身份识别技术</li></ol><h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><ol><li><p>下面给出了7种最常见的用来承载用户相关信息的HTTP首部, 此处先讨论前3个, 后面4个首部用于更高级的识别技术</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Form请求首部字段, 用户的Email地址</div><div class="line">User-Agent请求首部字段, 用户的浏览器软件</div><div class="line">Refer请求首部字段, 用户是从这个页面上依照连接跳转过来的</div><div class="line">Authorization请求首部字段, 用户名和密码(稍后讨论)</div></pre></td></tr></table></figure></li><li><p><code>Form请求首部字段</code>: 包含了用户的Email地址, 每个用户都有不同的Email地址, 所以在理想情况下, 可以将这个地址作为可行的源端来识别用户。</p><ul><li>但是由于担心那些不讲道德的服务器会搜索这些E-mail地址, 用于垃圾邮件的发送, 所以<strong>很少有浏览器会发送Form首部</strong>;</li><li>实际上Form首部是由自动化机器人或蜘蛛发送的, 这样在出现问题时, 网管还有个地方可以发送愤怒的投诉邮件??</li></ul></li><li><p><code>User-Agent请求首部字段</code>：可以将用户所用的浏览器的相关信息告知服务器, 包括程序的名称和版本, 通常还包含操作系统的相关信息。</p><ul><li>要实现定制内容与特定的浏览器及其属性间的良好互操作时, 这个首部是非常有用的, 但<strong>它并没有为识别特定的用户提供太多有意义的帮助</strong>。</li></ul></li><li><p><code>Referer请求首部字段</code>: 提供了用户来源页面的URL</p><ul><li>Referer首部自身并不能完全标识用户, 但它确实说明了用户之前访问过哪个页面。</li><li>通过它可以更好地理解用户的浏览器行为, 以及用户的兴趣所在, 比如, 如果你是从一个篮球网站抵达某个Web服务器的,这个Web服务器可能会推断你是个篮球迷。</li></ul></li><li><p>总之, <code>Form</code>，<code>User-Agent</code>, <code>Referer</code> 这几个请求首部字段都<strong>不足以实现可靠的识别特定用户</strong>。</p></li></ol><h3 id="客户端IP地址"><a href="#客户端IP地址" class="headerlink" title="客户端IP地址"></a>客户端IP地址</h3><ol><li>通常HTTP首部并不提供客户端的IP地址, 但Web服务器可以通过其他方法找到另一端的IP地址。</li><li>但是, 使用客户端IP地址来识别用户存在很多缺点, 限制了将其作为用户识别技术的效能:<ul><li>客户端IP地址描述的是所用的机器，而不是用户。如果多个用户共享同一台计算机，就无法对其进行区分了；</li><li>很多因特网服务提供商都会在用户登录时为其动态分配IP地址。用户每次登录时，都会得到一个不同的地址，因此Web服务器不能假设IP地址可以在各登录会话之间标识用户；</li><li>为了提高安全性，并对稀缺的地址资源进行管理，很多用户都是通过网络地址转换(Network Address Translation, NAT)防火墙来浏览网络内容的。这些NAT设备隐藏了防火墙后面那些实际客户端的IP地址，将实际的客户端IP地址转换成了一个共享的防火墙IP地址和不同的端口号；</li><li>HTTP代理和网关通常会打开一些新的、到原始服务器的TCP连接。<strong>Web服务器看到的将是代理服务器的IP地址，而不是客户端的</strong>。有些代理为了绕过这个问题会添加特殊的<code>Client-IP</code>或<code>X-Forwarded-For</code>扩展首部来保存原始的IP地址，但并不是所有的代理都支持这种行为</li></ul></li></ol><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><ol><li>Web服务器无需被动地根据用户的IP地址来猜测他的身份，它可以要求用户通过用户名和密码进行认证登录来显式地询问用户是谁。</li><li><p>为了使Web站点的登录更加简便，HTTP中包含了一种内建机制，可以用 <code>www-Authenticate响应首部</code> 和 <code>Authorization请求首部</code> 向Web站点传送用户的相关信息。<br> 一旦登录，浏览器就可以不断地在每条发往这个站点的请求中发送这个登录信息了。这样，就总是有登录信息可用了</p></li><li><p>如果服务器希望在为用户提供对站点的访问之前，先行登录，可以向浏览器回送一条HTTP响应代码 <code>401 Login Required</code>。<br> 然后，浏览器会显示一个登录对话框，并用<code>Authorization首部</code>在下一条对服务器的请求中提供这些信息</p></li><li><p>如下图<br> <img src="/img/http/authorization-01.png" width="600/"></p><ul><li>在图a中，浏览器对站点www.joes-hardware.com发起了一条请求；</li><li>站点并不知道这个用户的身份，因此在图b中，服务器会返回 <code>401 Login Required HTTP响应码</code>，并添加 <code>www-Authentication响应首部</code>，要求用户登录。<br>这样浏览器就会弹出一个登录对话框；<br>只要用户输入了用户名和密码(对其身份进行完整性检査)，浏览器就会继续原来的请求。这次它会添加一个 <code>Authorization请求首部</code>，说明用户名和密码。对用户名和密码进行加密，防止那些有意无意的网络观察者看到；</li><li>现在，服务器已经知道用户的身份了，今后的请求要使用用户名和密码时，浏览器会自动将存储下来的值发送出去，甚至在站点没有要求发送的时候也经常会向其发送。浏览器在每次请求中都向服务器发送Authorization首部作为一种身份的标识，这样，只要登录一次，就可以在整个会话期间维持用户的身份了</li><li>但是，登录多个Web站点是很繁琐的。从一个站点浏览到另一个站点的时候，需要在每个站点上登录。更糟的是，很可能要为不同的站点记住不同的用户名和密码。访问很多站点，喜欢的用户名可能已经被其他人用过了，而且有些站点为用户名和密码的长度和组成设置了不同的规则</li></ul></li></ol><h2 id="胖URL"><a href="#胖URL" class="headerlink" title="胖URL"></a>胖URL</h2><ol><li><p>有些Web站点会<strong>为每个用户生成特定版本的URL来追踪用户的身份</strong>。通常, 会对真正的URL进行扩展, 在URL路径开始或结束的地方添加一些状态信息。<br> 用户浏览站点时, Web服务器会动态生成一些超链, 继续维护URL中的状态信息.</p></li><li><p>改动后包含了用户状态信息的URL被称为<code>胖URL(fat URL)</code>。下面是Amazon.com使用的一些胖URL实例, 每个URL后面都附加了一个用户特有的标识码, 在这个例子中就是002-1145265-8016838，这个标识码有助于在用户浏览商店内容时对其进行跟踪</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;/exec/obidos/tg/browse/-/229220/ref=gr_gifts/002-1145265-8016838&quot;&gt;All Gifts&lt;/a&gt;&lt;br&gt;</div><div class="line">&lt;a href=&quot;/exec/obidos/wishlist/ref=gr_pll_/002-1145265-8016838&quot;&gt;Wish List&lt;/a&gt;&lt;br&gt;</div></pre></td></tr></table></figure></li><li><p>可以通过胖URL将Web服务器上若干个独立的HTTP事务捆绑成一个”会话”或”访问”。<br> 用户首次访问这个Web站点时，会生成一个唯一的ID，用服务器可以识别的方式将这个ID添加到URL中去，然后服务器就会将客户端重新导向这个胖URL。<br> 不论什么时候，只要服务器收到了对胖URL的请求，就可以去査找与那个用户ID相关的所有增量状态(购物车、简介等)，然后重写所有的输出超链，使其成为胖URL，以维护用户的ID</p></li><li><p>可以在用户浏览站点时，用胖URL对其进行识别。但这种技术存在几个<strong>很严重的问题</strong>：</p><ul><li>丑陋的URL – 浏览器中显示的胖URL会给新用户带来困扰；</li><li>无法共享URL – 胖URL中包含了与特定用户和会话有关的状态信息。如果将这个URL发送给其他人，可能就在无意中将个人信息都共享出去了；</li><li>破坏缓存 – 为每个URL生成用户特有的版本就意味着不再有可供公共访问的URL需要缓存了；</li><li>额外的服务器负荷 – 服务器需要重写HTML页面使URL变胖；</li><li>逃逸口 – 用户跳转到其他站点或者请求一个特定的URL时，就很容易在无意中”逃离”胖URL会话, 只有当用户严格地追随预先修改过的链接时，胖URL才能工作。如果用户逃离此链接，就会丢失他的进展(可能是一个已经装满了东西的购物车)信息，得重新开始；</li><li>在会话间是非持久的，除非用户收藏了特定的胖URL，否则用户退出登录时，所有的信息都会丢失</li></ul></li></ol><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ol><li>cookie是当前识别用户，实现持久会话的最好方式。</li><li>cookie最初是由网景公司开发的, 但现在所有主要的浏览器都支持它。</li><li>cookie非常重要，而且它定义了一些新的HTTP首部。</li><li>cookie的存在也影响了缓存，大多数缓存和浏览器都不允许对任何cookie的内容进行缓存。</li></ol><h3 id="cookie的类型"><a href="#cookie的类型" class="headerlink" title="cookie的类型"></a>cookie的类型</h3><ol><li><p>可以笼统地将cookie分为两类：<code>会话cookie</code> 和 <code>持久cookie</code>。</p><ul><li><code>会话cookie</code> 是一种临时cookie，它记录了用户访问站点时的设置和偏好，用户退出浏览器时，会话cookie就被删除了。</li><li><code>持久cookie</code> 的生存时间更长一些，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。</li></ul></li><li><p>通常会用 <code>持久cookie</code> 维护某个用户会周期性访问的站点的配置文件或登录名。</p></li><li><p><code>会话cookie</code> 和 <code>持久cookie</code> 之间唯一的区别就是它们的过期时间。如果设置了 <code>Discard</code> 参数，或者没有设置 <code>Expires</code> 或 <code>Max-Age</code> 参数来说明扩展的过期时间，这个cookie就是一个会话cookie</p></li></ol><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ol><li><p>用户首次访问Web站点时, Web服务器对用户一无所知。Web服务器希望这个用户会再次回来，所以想给这个用户”拍上”一个独有的cookie, 这样以后它就可以识别出这个用户了。</p></li><li><p>cookie中包含了一个由 <code>名字=值(name=value)</code> 这样的信息构成的任意列表, 并通过 <code>Set-Cookie</code> 或 <code>Set-Cookie2</code> HTTP响应(扩展)首部将其贴到用户身上去</p></li><li><p>cookie中可以包含任意信息, 但它们通常都只包含一个服务器为了进行跟踪而产生的独特的识别码。比如, 服务器会将一个表示id=”34294”的cookie贴到用户上去。<br> 服务器可以用这个数字来查找服务器为其访问者积累的数据库信息(购物历史、地址信息等)</p></li><li><p>但是, cookie<strong>并不仅限于ID号</strong>, 很多Web服务器都会将信息直接保存在cookie中, 比如: <code>Cookie： name &quot;Brian Totty&quot;; phone=&quot;555-1212&quot;</code></p></li><li><p>浏览器会记住从服务器返回的 <code>Set-Cookie</code> 或 <code>Set-Cookie2</code> 首部中的cookie内容，并将cookie集存储在浏览器的cookie数据库中。将来用户返回同一站点时，浏览器会挑中那个服务器贴到用户上的那些cookie，并在一个cookie请求首部中将其传回去。</p></li></ol><h3 id="cookie罐-客户端的状态"><a href="#cookie罐-客户端的状态" class="headerlink" title="cookie罐: 客户端的状态"></a>cookie罐: 客户端的状态</h3><ol><li><p>cookie的基本思想就是让浏览器积累一组服务器特有的信息，每次访问服务器时都将这些信息提供给它。因为浏览器要负责存储cookie信息，所以此系统被称为<strong>客户端侧状态(client-side state)</strong>。</p></li><li><p>不同的浏览器会以不同的方式来存储cookie。（更多参考P218）</p></li></ol><h3 id="不同的站点使用不同的cookie"><a href="#不同的站点使用不同的cookie" class="headerlink" title="不同的站点使用不同的cookie"></a>不同的站点使用不同的cookie</h3><ol><li><p>浏览器内部的 <code>cookie罐</code> 中可以有成百上千个cookie，但<strong>浏览器不会将每个cookie都发送给所有的站点</strong>。实际上，它们通常只向每个站点发送2-3个cookie, 原因如下：</p><ul><li>对所有这些cookie字节进行传输会严重降低性能。浏览器实际传输的cookie字节数要比实际的内容字节数多; </li><li>cookie中包含的是各服务器特有的名值对，所以对大部分站点来说，大多数cookie都是自己无法识别的无用数据;</li><li><strong>将所有的cookie发送给所有站点会引发潜在的隐私问题，那些不信任的站点也会获得只想发给其他站点的信息</strong>;</li></ul></li><li><p>总之，**浏览器只会向服务器发送由同一服务器产生的那些cookie。如：joes-hardware.com产生的cookie会被发送给joes-hardware.com, 不会发送给bobs-books.com 或 marys-movies.com</p></li><li><p>很多Web站点都会与第三方厂商达成协议，由其来管理广告。<br> 这些广告被做得像Web站点的一个组成部分，而且它们确实发送了持久cookie。<br> 用户访问另一个由同一广告公司提供服务的站点时，由于域是匹配的，浏览器就会再次回送早先设置的持久cookie。<br> 营销公司可以将此技术与Referer首部结合，暗地里构建一个用户档案和浏览习惯的详尽数据集。<br> 现代的浏览器都允许用户对隐私特性进行设置，以限制第三方cookie的使用</p></li></ol><h3 id="cookie的域属性"><a href="#cookie的域属性" class="headerlink" title="cookie的域属性"></a>cookie的域属性</h3><ol><li><p>产生cookie的服务器可以向 <code>Set-Cookie响应首部</code> 添加一个 <code>Domain属性</code> 来控制哪些站点可以看到那个cookie。</p></li><li><p>比如，下面的HTTP响应首部就是在告诉浏览器将 cookie user= “maryl7” 发送给域为 “.airtravelbargains.com” 的所有站点：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Set-cookie: user=&quot;maryl7&quot;; domain=&quot;airtravelbargains.com&quot;</div><div class="line">如果用户访问的是www.airtravelbargains.com </div><div class="line">或者 specials.airtravelbargains.com</div><div class="line">或任意以.airtravelbargains.com结尾的站点，</div><div class="line"></div><div class="line">下列Cookie首部都会被发布出去：</div><div class="line">Cookie: user=&quot;maryl7&quot;</div></pre></td></tr></table></figure></li></ol><h2 id="cookie路径属性"><a href="#cookie路径属性" class="headerlink" title="cookie路径属性"></a>cookie路径属性</h2><ol><li><p>cookie规范甚至允许用户将cookie与部分Web站点关联起来, 可以通过 <code>Path属性</code> 来实现这一功能, 在这个属性列出的URL路径前缀下所有cookie都是有效的</p></li><li><p>例如, 某个Web服务器可能是由两个组织共享的，每个组织都有独立的cookie, 站点www.airtravelbargains.com可能会将部分Web站点用于汽车租赁<br> 比如，<a href="http://www.airtravelbargains.com`/autos/`" target="_blank" rel="external">http://www.airtravelbargains.com`/autos/`</a> – 用一个独立的cookie来记录用户喜欢的汽车尺寸, 可能会生成一个如下所示的特殊汽车租赁cookie:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Set-cookie: pref=compact; domain=&quot;airtravelbargains.com&quot;; path=/autos/</div><div class="line"></div><div class="line">如果用户访问http://www.airtravelbargains.com/specials.html，就只会获得这个cookie：</div><div class="line">Cookie: user=&quot;maryl7&quot; (结合前面域属性的例子)</div><div class="line"></div><div class="line">但如果访问http://www.airtravelbargains.com/autos/cheapo/index.html，就会获得这两个cookie:</div><div class="line">Cookie: user=&quot;maryl7&quot;</div><div class="line">Cookie: pref=compact</div></pre></td></tr></table></figure></li><li><p>因此，cookie就是由服务器贴到客户端上，由客户端维护的状态片段，只会回送给那些合适的站点。下面我们来更仔细地看看cookie的技术和标准。</p></li></ol><h2 id="cookie的成分"><a href="#cookie的成分" class="headerlink" title="cookie的成分"></a>cookie的成分</h2><p>现在使用的cookie规范有两个不同的版本: <code>cookies版本0</code>(有时被称为Netscape cookies) 和 <code>cookies版本1</code>(RFC 2965)。cookies版本1 是对cookies版本0的扩展，应用不如后者广泛。</p><h3 id="Cookies版本0"><a href="#Cookies版本0" class="headerlink" title="Cookies版本0"></a>Cookies版本0</h3><p>参考P284</p><h3 id="Cookies版本1"><a href="#Cookies版本1" class="headerlink" title="Cookies版本1"></a>Cookies版本1</h3><p>参考P285</p><h4 id="版本1的cookie2请求首部和版本协商"><a href="#版本1的cookie2请求首部和版本协商" class="headerlink" title="版本1的cookie2请求首部和版本协商"></a>版本1的cookie2请求首部和版本协商</h4><h2 id="cookie与缓存"><a href="#cookie与缓存" class="headerlink" title="cookie与缓存"></a>cookie与缓存</h2><h2 id="cookie安全性和隐私"><a href="#cookie安全性和隐私" class="headerlink" title="cookie安全性和隐私"></a>cookie安全性和隐私</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;HTTP最初是一个 &lt;strong&gt;匿名&lt;/strong&gt;, &lt;strong&gt;无状态&lt;/strong&gt; 的请求/响应协议;
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP -- 缓存 (200, 304)</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-05-cache/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-05-cache/</id>
    <published>2017-11-30T06:27:36.000Z</published>
    <updated>2018-02-08T02:10:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web缓存简介"><a href="#Web缓存简介" class="headerlink" title="Web缓存简介"></a>Web缓存简介</h2><ol><li>Web缓存是指可以自动保存常见文档副本的HTTP设备。当Web请求抵达缓存设备时, 如果缓存设备本地有”已缓存的”副本, 就可以从本地设备而不是原始服务器中提取这个文档。</li><li><p>使用缓存的优点:</p><ul><li><p>减少了冗余的数据传输, 节省了你的网络费用</p><blockquote><p>有很多客户端访问一个流行的原始服务器页面时, 服务器会多次传输同一份文档, 每次传送给一个客户端。<br>这样就会导致一些相同的字节在网络中一遍遍地传输, 这些冗余的数据传输会耗尽昂贵的网络带宽, 降低传输速度, 加重Web服务器的负载。<br>有了缓存, 就可以保留第一条服务器响应的副本, 后继请求就可以由缓存的副本来应对了, 这样可以减少那些流入/流出原始服务器而被浪费掉了的重复流量。</p></blockquote></li><li><p>缓解了网络本身的瓶颈问题, 不需要更多的带宽就能够更快地加载页面</p><blockquote><p>很多网络为本地网络客户端提供的带宽比为远程度服务器提供的带宽要宽。(这个大家应该有深有体会, 局域网内传输是很快的!!!)<br>如果客户端能够从一个快速局域网的缓存中得到一份副本, 那么缓存就可以提高性能—尤其是要传输比较大的文件时。</p></blockquote></li><li><p>降低了对原始服务器的要求, 服务器可以更快地响应, 避免过载的出现</p><blockquote><p>瞬间拥塞: 突发事件(爆发性新闻, 抢购等)使很多人几乎同时去访问一个Web文档时, 就会出现瞬间拥塞, 由此造成的过多流量峰值可能会使网络和Web服务器产生灾难性的崩溃。<br>而缓存在应对瞬间拥塞时就显得非常重要。</p></blockquote></li><li><p>降低了<strong>距离时延</strong>, 因为从较远的地方加载页面会更慢一些<br>即使带宽不是问题, 距离也可能成为问题。<strong>每台网络路由器都会增加因特网流量的时延</strong>。即使客户端和服务器之间没有太多的路由器, <strong>光速自身也会造成显著的时延</strong>。</p><blockquote><p>比如波士顿到旧金山的直线距离大约为2700英里, 在最好的情况下, 以光速传输(186000英里/秒)的信号可以在大约15毫秒从波士顿传送到旧金山, 并在30毫秒内完成一个往返。<br>假设某个Web页面包含了20个小图片, 都在旧金山的一台服务器上, 如果波士顿的一个客户端打开了4条到服务器的并行连接, 而且保持着连接的活跃状态, 光速自身就要消耗大约1/4秒(240毫秒)的下载时间。如果服务器位于(距离旧金山6700英里)的东京, 时延就会变成600毫秒。<br>中等复杂的web页面会带来几秒钟的光速时延。<br>况且实际应用中, 信号的传输速度会比光速低一些, 因此距离时延会更加严重。</p></blockquote><p>而将缓存放在附近的机房里可以将文件传输距离从数千英里缩短为数十米。</p></li></ul></li></ol><h2 id="‘缓存命中’、’未命中’-的概念"><a href="#‘缓存命中’、’未命中’-的概念" class="headerlink" title="‘缓存命中’、’未命中’ 的概念"></a>‘缓存命中’、’未命中’ 的概念</h2><ol><li><p>如果一些请求到达缓存设备时, 缓存设备可以用本地已有的副本为这些请求提供服务, 就被称为<strong>缓存命中</strong>。</p></li><li><p>如果一些请求到达缓存设备时, 缓存设备本地没有副本提供给这些请求, 而将请求转发给原始服务器, 这就被称为<strong>缓存未命中</strong>。</p></li><li><p>后面还有 <strong>再验证命中</strong> 和 <strong>再验证未命中</strong> 的概念;</p></li></ol><h2 id="引出文档过期-和-服务器再验证"><a href="#引出文档过期-和-服务器再验证" class="headerlink" title="引出文档过期 和 服务器再验证"></a>引出文档过期 和 服务器再验证</h2><ol><li><p><strong>已缓存的数据要与服务器数据保持一致</strong>:<br> 缓存设备本地的副本 并不是时刻都与原始服务器上的文档一样, 毕竟服务器中的这些文档会随着时间发生变化(比如有些报告可能每个月都会变化, 而在线报纸每天都会变化, 财经数据可能每过几秒就会发生变化)。<br> 所以, 如果缓存提供的总是老的数据, 就会变得毫无用处。</p></li><li><p>HTTP通过一些简单的机制, 可以做到: 在不要求服务器记住有哪些缓存设备拥有其文档副本的情况下, 保持已缓存数据与服务器数据之间的充分一致。<br> HTTP将这些简单的机制称为 <strong>文档过期(document expiration)</strong>(也就是缓存副本的过期时间) 和 <strong>服务器再验证(server revalidation)</strong>。</p></li></ol><h2 id="缓存副本的过期时间"><a href="#缓存副本的过期时间" class="headerlink" title="缓存副本的过期时间"></a>缓存副本的过期时间</h2><ol><li><p>原始服务器通过 老式的HTTP/1.0+的实体首部字段<code>Expires</code> 或 新式的HTTP/1.1的通用首部字段<code>Cache-Control:max-age</code> 可以向每个文档附加一个<strong>过期日期</strong>。</p><ul><li><code>Expires</code> 和 <code>Cache-Control:max-age</code> 所做的事情本质上是一直的, 但由于 <code>Cache-Control</code> 首部使用的是相对时间而不是绝对时间, 所以我们更倾向与使用比较新的 <code>Cache-Control</code> 首部。</li><li><code>Expires</code> 绝对日期依赖于计算机时钟的正确设置</li><li>如下图:<br><img src="/img/http/expire-max-age.png" width="550/"></li></ul></li><li><p><strong>在缓存文档过期之前, 缓存设备可以随意使用这些副本, 而且无需与服务器做任何联系!!</strong> 当然, 除非</p><ul><li>客户端请求中包含 “阻止提供缓存” 的首部 <code>Cache-Control:no-store</code>;</li><li><p>或者客户端请求中包含”只有经过验证才能返回缓存副本”的首部<code>Cache-Control:no-cache</code><em>*</em>), </p><p>但是一旦已缓存文档过期, 缓存设备就必须与服务器进行核对(<strong><em>当然, 除非你设置了<code>Cache-Control:only-if-cached</code>要求只使用缓存</em></strong>), 询问文档是否被修改过, 如果被修改过, 就要获取一份新鲜(带有新的过期日期)的副本。</p></li></ul></li><li><p><strong>注意</strong>: </p><ul><li>不推荐使用Expires首部, 它指定的是实际的过期日期而不是秒数。HTTP设计者后来认为, 由于很多服务器的时钟都不同步, 或者不正确, 所以最好还是用剩余秒数, 而不是绝对时间来表示过期时间。</li><li>有些服务器还会回送一个<code>Expires:0</code>响应头,视图将文档置于永远过期的状态, <strong>但这种语法是非法的</strong>, 可能给某个软件带来问题, 应该试着支持这种结构的输入, 但是不应该产生这种结构的输出。</li><li>而 <code>Cache-Control</code> 的 <code>max-age</code> 则可以设置 <code>Cache-Control: max-age=0</code></li></ul></li><li><p>另外, 注意 <code>no-cache</code> 和 <code>must-revalidate</code> 的区别</p><ul><li>no-cache: 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验。</li><li>must-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。(这应该是缓存系统的默认行为, 但must-revalidate指令使得这个要求是明确的<a href="https://stackoverflow.com/questions/2932890/http-cache-control-max-age-must-revalidate" target="_blank" rel="external">参考</a>)</li><li><a href="https://segmentfault.com/a/1190000007317481" target="_blank" rel="external">可参考</a></li></ul></li></ol><h2 id="副本过期算法测试"><a href="#副本过期算法测试" class="headerlink" title="副本过期算法测试"></a>副本过期算法测试</h2><ol><li>FireFox测试过期时间算法( Date + Expire/max-age - Age) <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 主要测试浏览器确实是根据 expirationTime = responseTime(Date头) + freshnessLifetime(max-age/Exprie值) - currentAge(Age头)</span></div><div class="line"><span class="comment"> * 来计算失效时间的</span></div><div class="line"><span class="comment"> * chrome好像不太正常(会交替显示 123 和 456789)</span></div><div class="line"><span class="comment"> * firefox 进行回车测试, 结果发现完全正常</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>($_SERVER[<span class="string">'HTTP_IF_MODIFIED_SINCE'</span>])) &#123;</div><div class="line">    header(<span class="string">"HTTP/1.1 200"</span>);</div><div class="line">    header(<span class="string">'Cache-Control: max-age=30'</span>); <span class="comment">// 放到下一行就不生效了(响应头还特么还有顺序?)</span></div><div class="line">    header(<span class="string">'Age:10'</span>);</div><div class="line">    <span class="comment">// 发现浏览器确实拿着这个日期去判断有没有过期</span></div><div class="line">    header(<span class="string">'Date:'</span>. date(<span class="string">'D, d M Y H:i:s'</span>, time()<span class="number">-10</span>).<span class="string">' GMT'</span>);</div><div class="line">    header(<span class="string">'Last-Modified:'</span>. date(<span class="string">'D, d M Y H:i:s'</span>, time()<span class="number">-20000</span>).<span class="string">' GMT'</span>);</div><div class="line">    <span class="keyword">echo</span> <span class="number">123</span>;</div><div class="line">    <span class="keyword">exit</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//算法: expirationTime = responseTime(Date头) + freshnessLifetime(max-age/Exprie值) - currentAge(Age头)</span></div><div class="line"><span class="comment">// 此处浏览器判断 date + 30 - 10 , 由于date是当前时间, 所以差不多有20秒的过期时间</span></div><div class="line"><span class="comment">// 如果是Age:0的话, date + 30 -0, 由于date是当前时间, 所以差不多有30秒的过期时间</span></div><div class="line"><span class="comment">// 如果是Date-10, Age:0的话, date-10 + 30 -10, 所以差不多有10秒的过期时间 (不太好抓, 不过肯定是10秒过期)</span></div><div class="line"></div><div class="line"><span class="comment">//发现只有超时之后, 才会显示出下面的信息   (firefox准确无误地实现,在未过期之前, 是不会带If-Modified-Since头去请求的)</span></div><div class="line"><span class="keyword">echo</span> <span class="number">456789</span>;<span class="keyword">die</span>;</div></pre></td></tr></table></figure></li></ol><h2 id="缓存副本过期后的”再验证”"><a href="#缓存副本过期后的”再验证”" class="headerlink" title="缓存副本过期后的”再验证”"></a>缓存副本过期后的”再验证”</h2><ol><li><p>原始服务器上的内容可能会发生变化, 缓存要不时地对其进行检测, 看看自己保存的副本是否仍是服务器上最新的副本。这种”新鲜度检测”就被称为HTTP再验证(revalidation)。</p></li><li><p>虽然缓存可以在任意时刻, 以任意的频率从对副本进行再验证, 但是由于缓存中通常会包含数百万的文档, 而且网络带宽是很珍贵的, 所以大部分缓存<strong>只有在客户端发起请求</strong>,并且<strong>副本旧的足以需要再次检测的时候</strong>, 才会对副本进行再验证。</p></li><li><p><strong>副本旧的足以需要再次检测的时候?</strong> 也就是缓存副本的过期时间已到!!</p></li><li><p>但是仅仅是已缓存文档过期了, 还不能说明该过期文档和原始服务器上的文档有实际的区别, 这只是意味着<strong>到时间进行再验证了</strong>！</p></li></ol><h3 id="再验证命中-缓慢命中"><a href="#再验证命中-缓慢命中" class="headerlink" title="再验证命中(缓慢命中)"></a>再验证命中(缓慢命中)</h3><ol><li><p>缓存对副本进行再验证时, 会向原始服务器发送一个小的再验证请求。如果发现内容没有变化, 服务器会以一个小的 <code>304 Not Modified</code> 进行响应。<br> 只要缓存知道副本仍然有效, 就会再次将副本标识为暂时新鲜的, 并将副本提供给客户端, 这被称为<strong>再验证命中(revalidate hit)</strong> 或 <strong>缓慢命中(slow hit)</strong>。<br> <img src="/img/http/revalidate-hit-01.png" width="300/"></p></li><li><p><strong>当然, 这种方式确实还是需要与原始服务器进行核对, 所以会比单纯的缓存命中要慢, 但是它并没有从服务器中获取对象数据, 所以要比缓存未命中要快一些。</strong></p></li></ol><h3 id="再验证未命中"><a href="#再验证未命中" class="headerlink" title="再验证未命中"></a>再验证未命中</h3><ol><li><p>缓存对副本进行再验证时, 会向原始服务器发送一个小的再验证请求。如果缓存发现服务器对象与已缓存副本不同, 则服务器会向客户端发送一条普通的, 带有完整内容的 <code>HTTP 200 OK</code> 响应;<br> <img src="/img/http/revalidate-not-hit-01.png" width="300/"></p></li><li><p><strong>当然, 这种方式确实不仅需要与原始服务器进行核对, 而且会从服务器中获取对象数据, 所以理论上貌似要比缓存未命中要慢一些, 但其实差不多</strong></p></li></ol><h3 id="再验证-–-服务器对象被删除"><a href="#再验证-–-服务器对象被删除" class="headerlink" title="再验证 – 服务器对象被删除"></a>再验证 – 服务器对象被删除</h3><p>如果再验证发现服务器对象已经被删除, 服务器就回送一个 <code>404 Not Found</code> 响应, 缓存也会将其副本删除。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>成功的再验证 比 缓存未命中 要快</strong><br><strong>失败的再验证 几乎和 缓存未命中 速度一样</strong></p><h3 id="再验证依靠-–-条件方法"><a href="#再验证依靠-–-条件方法" class="headerlink" title="再验证依靠 – 条件方法"></a>再验证依靠 – 条件方法</h3><ol><li><p>为了有效地进行再验证, HTTP定义了一些特殊的请求, <strong>不用从服务器上获取整个对象, 就可以快速检测出内容是否是最新的</strong>。</p></li><li><p>HTTP的<code>条件方法</code>可以高效地实现再验证。<br> HTTP允许缓存向原始服务器发送一个 “条件GET”, 请求只有在服务器文档与缓存中现有的副本不同时, web服务器才会回送对象主体;<br> 通过这种方式, 将新鲜度检测和对象获取结合成了单个条件GET。<br> 向GET请求报文中添加一些特殊的<code>条件首部</code>, 就可以发起<code>条件GET</code>。</p></li><li><p>HTTP定义了5个条件请求首部, 对 <code>缓存再验证</code> 来说有用的2个首部是 <code>If-Mofified-Since</code> 和 <code>If-None-Match</code>, 所有的条件首部都以前缀<code>If-</code>开头。<br> <img src="/img/http/revalidate-01.png" width="500/"></p></li></ol><h3 id="If-Modified-Since-Date-再验证"><a href="#If-Modified-Since-Date-再验证" class="headerlink" title="If-Modified-Since:Date 再验证"></a>If-Modified-Since:Date 再验证</h3><ol><li><p>最常见的缓存再验证首部是 <code>请求首部字段 If-Modified-Since</code>, <code>If-Modified-Since</code>再验证请求通常被称为IMS请求。</p><ul><li>如果自If-Modified-Since指定日期之后, 文档被修改了, <code>If-Modified-Since</code> 条件就为真, 通常GET就会成功执行, <strong>携带新首部的新文档</strong>会被返回给缓存, 新首部除了其他信息之外, 还包含了一个新的过期日期;</li><li>如果自If-Modified-Since指定日期之后, 文档没被修改, <code>If-Modified-Since</code> 条件就为假, 会向客户端<strong>返回一个小的 304 Not Modified响应报文</strong>, 为了提高有效性, <strong>不会返回文档主体</strong>。<br>这些首部是放在响应中返回的, 但是只会返回哪些需要在源端更新的首部, 比如, Content-Type首部通常不会被修改, 所以通常不需要发送。一般会发送一个新的过期日期。</li></ul></li><li><p>请求首部字段<code>If-Modified-Since</code> 和 实体首部字段<code>Last-Modified</code> 配合工作。</p><ul><li>原始服务器会将最后的修改日期附加到所提供的文档上去, 当缓存要对已缓存文档进行再验证时, 就会包含一个<code>If-Modified-Since</code>首部, 其中携带有最后修改已缓存副本的日期: <code>If-Modified-Since:&lt;cached last-modified date&gt;</code></li><li>如果在此期间原始服务器文档被修改了, 最后的修改日期就会不同了, 这样<code>If-Modified-Since</code>条件就为真, 原始服务器就会回送新的文档；</li><li>否则, 服务器会注意到缓存的最后修改日期与服务器文档当前的最后修改日期相符合, 则会返回一个 <code>304 Not Modified</code> 响应。</li></ul></li><li><p>小结: 如果在验证发现原始服务器内容未发生变化, If-Modified-Since在验证会返回304响应, 如果发生了变化, 就返回带有新主体的200响应。</p></li></ol><h3 id="If-None-Match-实体标签再验证"><a href="#If-None-Match-实体标签再验证" class="headerlink" title="If-None-Match 实体标签再验证"></a>If-None-Match 实体标签再验证</h3><h4 id="实体标签"><a href="#实体标签" class="headerlink" title="实体标签"></a>实体标签</h4><ol><li><p>有些情况下使用最后修改日期进行再验证是不够的:</p><ul><li>有些文档可能会被周期性地重写, 但实际包含的数据常常却是一样的。<strong>尽管内容没有发生变化, 但是修改日期会发生变化</strong>。</li><li>有些文档可能内容被修改了, 但是<strong>所做的修改并不重要</strong>, 不需要让世界范围内的缓存都重装数据(比如对拼写或注释的修改)。<br>  <strong>涉及到弱验证器</strong></li><li>有些服务器无法准确地判定其页面的最后修改日期。</li><li>有些服务器提供的文档会在亚秒间隙发生变化(比如,实时监视器), 对这些服务器来说, <strong>以秒为粒度的修改日期可能就不够用了</strong>。</li></ul></li><li><p>为了解决上述问题, HTTP有一个被称为 <code>实体标签(ETag)</code> 的 <code>版本标识符</code>, 这个实体标签是附加到文档上的任意标签, 标签可能可能包含了文档序列号或版本名, 或是文档内容的校验及其他指纹信息。<br> 当对文档进行修改时, 可以修改文档的实体标签来说明这个新的版本。这样, 如果实体标签被修改了, 缓存就可以用 <code>If-None-Match</code> 条件首部来GET文档的新副本了。</p></li><li><p>假设缓存中有一个文档已经过(Expires:, Cache-Control:max-age)期, 或者其他配置导致需要再次验证, 如果缓存中有一个实体标签为v2.6, 则它会与原始服务器进行再验证:</p><ul><li>如果服务器上的实体标签已经发生了变化(可能变成了v3.0, 和v2.6不再匹配), 服务器则会在一个 <code>200 OK</code> 响应中返回新的内容以及新的Etag标签 ;</li><li>如果标签仍然与原始服务器标签匹配, 则会返回一条304 Not Modified响应;</li></ul></li></ol><h4 id="弱验证器"><a href="#弱验证器" class="headerlink" title="弱验证器"></a>弱验证器</h4><ol><li><p>只要原始服务器内容发生变化, 则实体标签就会变化, 正常情况下, 强验证器就会对比失败, 导致服务器会在一个 <code>200 OK</code> 响应中返回新的内容以及新的Etag标签;</p></li><li><p>有时, 服务器希望对文档进行一些不重要的修改, 并且不需要使所有已缓存副本都失效<br>HTTP1.1支持的”弱验证器”, 就允许对一些内容做修改, 此时服务器会用前缀 <code>W/</code> 来标识弱验证器。</p></li><li><p>不管相关的实体值以何种方式发生了变化, 强实体标签都要发生变化, 而相关实体在语义上发生了比较重要的变化时, 弱实体标签页应该发生变化。</p></li></ol><h3 id="实体标签-和-最近修改日期"><a href="#实体标签-和-最近修改日期" class="headerlink" title="实体标签 和 最近修改日期"></a>实体标签 和 最近修改日期</h3><blockquote><p>如果服务器回送了一个实体标签, HTTP/1.1客户端就必须使用实体标签验证器。<br>如果服务器只回送了一个Last-Modified值, 客户端就可以使用 If-Modified-Since 验证。<br>如果实体标签和最后修改日期都提供了, 客户端就应该使用这两种再验证方案, 这样HTTP1.0和HTTP1.1换成你都可以正确响应了。</p></blockquote><p>除非HTTP/1.1原始服务器无法生成实体标签验证器, 否则就应该发送一个出去, 如果使用弱实体标签有优势的话, 发送的可能就是个弱实体标签, 而不是强实体标签。而且最好同时发送一个最近修改值。<br>如果HTTP/1.1缓存或服务器受到的请求既带有 If-Modified-Since, 又带有实体标签条件首部, <strong>那么只有这两个条件都满足时, 才能返回 <code>304 Not Modified</code> 响应</strong>(也就是两个都做验证)。</p><h2 id="缓存状态码-200-和-304"><a href="#缓存状态码-200-和-304" class="headerlink" title="缓存状态码 200 和 304"></a>缓存状态码 200 和 304</h2><p>参考P176: HTTP没有为用户提供一种手段来区分响应是缓存命中的, 还是访问原始服务器得到的。<strong>在这两种情况下, 响应状态码都是200OK</strong>, 说明响应有主体部分。</p><ul><li>你从public公共缓存中可能直接得到未过期的资源, 此时会返回 200 ok;</li><li>你也可能到公共缓存后发现要再验证, 此时发现文本已变更, 服务器也会返回 200 ok;</li></ul><ol><li><p>缓存命中(这里指的是公共的代理缓存命中) 返回 <code>200 ok</code></p><ul><li>客户端第一次访问资源, 浏览器和服务器之间有代理服务器, 这样的话, 由于这个代理服务器是个公共代理, 所以里面可能已经有了服务器响应的资源副本, 所以代理服务器会直接响应 资源副本和200 ok给客户端;<br><img src="/img/http/cdn-public-proxy-200.png" width="600/"></li></ul></li><li><p>访问原始服务器, 返回 <code>200 ok</code></p><ul><li>浏览器和服务器之间没有代理服务器, 这样的话, 客户端第一次请求资源, 则服务器直接 响应 200 ok 和 资源对象 给客户端;</li><li>客户端多次访问资源, 浏览器和服务器之间有代理服务器, 但是由于种种原因, 缓存需要再验证, 并且结果发现<strong>再验证未命中</strong>, 则服务器会响应资源对象和200 ok给代理缓存, 然后代理再响应”服务器响应的资源和200 ok副本”给客户端;</li></ul></li><li><p>浏览器直接取的自己的本地缓存, 返回 <code>200 ok (from disk/memory cache)</code><br> 此处由于浏览器之前缓存了 代理缓存服务器cdn 上的缓存副本, <strong>所以浏览器缓存的副本和上面cdn代理缓存的副本一样</strong>(age缓存时间都没变), 只不过会标注”已缓存”来表示没有响应主体部分<br> <img src="/img/http/cdn-private-200.png" width="600/"></p></li><li><p><code>304 Not Modified</code> 是缓存和服务器多确认了一次缓存有效性检测后, 发现<strong>缓存再验证命中</strong>, 但是用的还是缓存。</p></li><li><p>小结: <code>304 Not Modified</code> 比 <code>再验证未命中返回200 OK</code> 快, 但是比 <code>private缓存命中返回 200 ok from disk/memory cache</code> 慢;</p></li><li><p>参考 http权威指南176页</p></li></ol><h2 id="公有和私有缓存"><a href="#公有和私有缓存" class="headerlink" title="公有和私有缓存"></a>公有和私有缓存</h2><ol><li><p>通用首部字段(general header fields)<code>Cache-Control</code>有两个缓存响应指令: <code>public</code> 和 <code>private</code> </p></li><li><p>缓存可以是<code>单个用户专用的</code>, 也可以是<code>数千名用户共享的</code> ;</p></li></ol><ul><li>专用缓存被称为<code>私有缓存(private cache)</code>, 私有缓存是个人的缓存, 包含了单个用户最常用的页面 ;</li><li>共享缓存被称为<code>公有缓存(public cache)</code>, 公有缓存包含了某个用户团体常用页面 ;</li></ul><h3 id="私有缓存"><a href="#私有缓存" class="headerlink" title="私有缓存"></a>私有缓存</h3><p>私有缓存不需要很大的动力或存储空间, 这样就可以将其做的很小, 很便宜。<br>Web浏览器中就有内建的私有缓存—大多数浏览器都会将常用文档缓存在你个人电脑的磁盘和内存中, 并且允许用户去配置缓存的大小和各种设置;</p><h3 id="公有缓存"><a href="#公有缓存" class="headerlink" title="公有缓存"></a>公有缓存</h3><ol><li>公有缓存是特殊的共享代理服务器, 被称为缓存代理服务器(caching proxy server), 或者更常见地被称为代理缓存(proxy cache)。</li><li>代理缓存会从自己本地缓存中给用户提供缓存资源, 或者代表用户与服务器进行联系。公有缓存会接受来自多个用户的访问, 所以通过它可以更好地减少冗余流量。</li><li>如下图: </li></ol><ul><li>每个客户端都会重复地访问一个(还不在私有缓存中的)新的”热门”文档。每个私有缓存都要获取同一份文档, 这样它就会多次穿过网络。</li><li>而使用共享的公有缓存时, 对于这个流行的对象, 缓存只要取一次就行了, 它会用共享的副本为所有的请求服务, 以降低网络流量。<br><img src="/img/http/private-public-cache-01.png" width="416/"></li></ul><h2 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h2><ol><li><p>客户端可以用 <code>Cache-Control</code> 请求首部来 <strong>强化</strong> 或 <strong>放松</strong> 对过期时间的限制。</p><ul><li>有些应用程序对文档的新鲜度要求很高, 对于这些应用程序, 客户端可以用 Cache-Control 首部使过期时间更严格;</li><li>另一方面, 为了提高性能, 可靠性或开支的一种折中方式, 客户端可能会放松新鲜度要求;</li></ul></li><li><p>如下对 <code>Cache-Control</code> 的请求指令进行了小结:<br><img src="/img/http/cache-control-01.png" width="600/"><br><a href="https://stackoverflow.com/questions/33818854/what-is-difference-between-max-age-and-max-stale-in-cache-control-mechanism" target="_blank" rel="external">HTTP Cache-Control: max-age和max-stale=s的区别</a></p></li><li><p><code>Pagma:no-cache</code> 和 <code>Cache-Control:no-cache</code> 一样, 不过是为了兼容HTTP/1.0;</p></li></ol><p>参考:<br>HTTP权威指南 – 第七章 缓存<br>《图解HTTP协议》<br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/HTTP</a><br><a href="https://tools.ietf.org/html/rfc2616#section-4.5" target="_blank" rel="external">RFC 2616</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="external">MDN Web docs</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web缓存简介&quot;&gt;&lt;a href=&quot;#Web缓存简介&quot; class=&quot;headerlink&quot; title=&quot;Web缓存简介&quot;&gt;&lt;/a&gt;Web缓存简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Web缓存是指可以自动保存常见文档副本的HTTP设备。当Web请求抵达缓存设备时, 如果
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP - General Header Fields</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-04-General-Header-Fields/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-04-General-Header-Fields/</id>
    <published>2017-11-30T03:50:02.000Z</published>
    <updated>2018-02-08T02:10:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>通用首部字段 general-header</p><h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><ol><li><p><code>Cache-Control</code> 的指令是可选的,可以有多个, 多个指令之间通过 <code>,</code> 分隔;</p></li><li><p>缓存指令是单向的, 即请求中存在一个指令并不意味着响应中将存在同一个指令;</p></li><li><p>可以按请求和响应分为:</p><ul><li><p>缓存请求指令<br><img src="/img/http/cache-control-request.png" width="600/"></p></li><li><p>缓存响应指令<br><img src="/img/http/cache-control-response.png" width="600/"></p></li></ul></li><li><p>更多参考<a href="/2017/11/30/2017-11-30-HTTP-05-cache/">HTTP - 缓存</a></p></li><li><p><code>immutable</code><br>属于缓存控制的一个扩展属性, <a href="http://www.jdon.com/performance/cache-control-immutable.html" target="_blank" rel="external">http://www.jdon.com/performance/cache-control-immutable.html</a></p><blockquote><p>当一个支持immutable的客户端浏览器看到这个属性时, 它应该知道, 如果没有超过过期时间，那么服务器端该页面内容将不会改变, 这样浏览器就不应该再发送有条件的重新验证请求(比如通过If-None-Match 或 If-Modified-Since等条件再向服务器端发出更新检查);<br>也就是说, 通常过去我们使用304回复客户端该页面内容没有变化，但是如果用户按浏览器的刷新或F5键，浏览器会再次向服务器端发出该页面内容请求，服务器端如果确认该页面没有变化，那么发回304给客户端，不再发送该页面的实体内容，虽然这样节省了来回流量，但是如果大型网站的很多用户为了得到及时信息，经常会刷新浏览器，这就造成了大量刷新请求，向服务器端求证该页面是否改变，这会影响网站的带宽，也增加服务器端验证压力。<br><strong>而新的选项immutable可以杜绝这种现象</strong>。<br>immutable可以节省HTTP请求,缩短请求时间,这是因为服务器不必再处理304响应了。</p></blockquote></li></ol><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><ol><li>简单来说就是HTTP报文的创建日期, 它会参与到缓存控制的 过期时间运算中;</li><li>公式: <code>expirationTime = responseTime(Date头) + freshnessLifetime(max-age/Exprie值) - currentAge(Age头)</code></li><li>而响应首部字段中额 <code>Age</code> 头字段, 是告诉客户端, 源服务器在多久之前创建了响应, 字段的单位为秒;<br> 如果创建该响应的服务器是缓存服务器, Age值是指缓存后的响应再次发起认证到认证完成的时间值, 代理创建响应时必须加上首部字段Age。</li></ol><h2 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h2><ol><li>Pragma是HTTP1.1之前版本的历史遗留字段, 仅作为与HTTP1.0做向后兼容;</li><li>也属于和缓存相关的通用首部字段, 但只用在客户端发送的请求当中, 客户端会要求所有的中间服务器不返回缓存的资源(参考Cache-Control:no-cache), 但是并不专用于缓存, 最常用的是<code>Pragma:no-cache</code>;</li></ol><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><ol><li>该首部字段具备两个作用: <code>控制不再转发给代理的首部字段</code> 和 <code>管理持久连接</code>;</li><li>更多参考<a href="/2017-04-21-HTTP-Connection-Keep-Alive/">HTTP - 并行连接, 持久连接</a></li><li>未完待续…</li></ol><h2 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h2><ol><li><p>使用首部字段Via, 是为了追踪客户端与服务器之间的请求和响应报文的传输路径;<br>报文在经过代理或者网关时, 会先在首部字段Via中附加该服务器的信息, 然后再进行转发。</p><blockquote><p>Via首部是为了追踪传输路径, 所以也经常会和TRACE方法一起使用, 比如代理服务器受到由TRACE方法发送过来的请求(其中Max-Forward:0)时, 代理服务器就不能再转发该请求了,<br>这种情况下, 代理服务器会将自身的信息附加到Via首部后, 返回该请求的响应。</p></blockquote></li><li><p>Via通用首部字段不仅用于报文的转发, 还可避免请求回环的发生, 所以必须在经过代理时附加该首部字段;<br> <img src="/img/http/via-01.png" width="300"></p></li><li><p>未完待续…</p></li></ol><h2 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h2><p><strong>传输编码</strong></p><ol><li>该通用首部字段规定了传输报文主体时采用的编码方式;</li><li>HTTP/1.1的传输编码方式仅对分块传输编码有效, 即只能设置为 <code>Transfer-Encoding:chunked</code>;</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding" target="_blank" rel="external">MDN参考</a>;</li><li><code>Content-Encoding</code> 和 <code>Transfer-Encoding</code> 二者经常会结合来用, 其实就是针对 Transfer-Encoding 的分块再进行 Content-Encoding压缩;</li></ol><h3 id="对比-请求首部字段Accept-encoding"><a href="#对比-请求首部字段Accept-encoding" class="headerlink" title="对比 请求首部字段Accept-encoding"></a>对比 <strong>请求首部字段Accept-encoding</strong></h3><p><strong>期望内容编码</strong></p><ol><li><p>请求首部字段Accept-encoding是将客户端用户代理(浏览器)所<strong>支持的内容编码方式</strong>(通常是某种压缩算法) 及 <strong>内容编码方式的优先级顺序</strong>, 通知给服务器;</p><ul><li>通过内容协商, 服务端会选择一个客户端支持的方式, 使用并在 响应报文的实体首部字段 <code>Content-Encoding</code> 中通知客户端服务器选择了哪种内容编码方式;</li><li>另外, 可以一次性指定多种内容编码! </li><li>也可以使用权重q值来表示相对优先级;</li></ul></li><li><p>正常情况下, 主要采用以下4种编码方式:</p><ul><li>gzip</li><li>compress</li><li>deflate</li><li>identity: 不执行压缩或不会变化的默认编码格式;</li></ul></li><li><p>即使客户端和服务器都支持某些相同的压缩算法，但如果<code>Accept-encoding:identity</code>, 表示客户端告诉服务器对响应主体不要进行压缩。导致这种情况出现的两种常见的情形是：</p><ul><li>要发送的数据已经经过压缩, 再次进行压缩不会导致被传输的数据量更小, 一些图像格式的文件会存在这种情况;</li><li>服务器超载, 无法承受压缩需求导致的计算开销, 通常, 如果服务器使用超过80%的计算能力, 微软建议不要压缩;</li></ul></li><li><p>只要 identity(表示不需要进行任何编码)没有被明确禁止使用, 即, 没有通过 <code>identity;q=0</code>或是<code>*;q=0</code>指令明确设置 identity 的权重值，<strong>则服务器禁止返回表示客户端错误的 <code>406 Not Acceptable</code> 响应</strong>。</p><ul><li>也就是只有你通过设置identity的权重为0, 服务器才可以返回表示客户端错误的<code>406 Not Acceptable</code></li></ul></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Encoding" target="_blank" rel="external">MDN参考</a></p></li></ol><h3 id="对比-实体首部字段Content-encoding"><a href="#对比-实体首部字段Content-encoding" class="headerlink" title="对比 实体首部字段Content-encoding"></a>对比 <strong>实体首部字段<code>Content-encoding</code></strong></h3><p><strong>内容编码</strong></p><ol><li>实体首部字段’Content-encoding’会告诉客户端, 服务器对实体的主体部分选用的内容编码方式, </li><li>内容编码方式是指在不丢失实体信息的前提下所进行的压缩, 参考 <code>请求首部字段Accept-encoding</code> 所建议给服务器的编码方式:<ul><li>gzip</li><li>compress</li><li>deflate</li><li>identity</li></ul></li></ol><h3 id="对比-请求首部字段Accept-charset"><a href="#对比-请求首部字段Accept-charset" class="headerlink" title="对比 请求首部字段Accept-charset"></a>对比 <strong>请求首部字段<code>Accept-charset</code></strong></h3><ol><li>请求首部字段’Accept-charset’会告诉服务器, 用户代理(浏览器)所支持的<code>字符集</code>和<code>字符集的相对优先顺序</code>。<ul><li>可以一次性指定多种字符集;</li><li>也可以使用权重q值来表示相对优先级;</li></ul></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>请求首部字段<code>Accept-encoding</code> 和 实体首部字段<code>Content-encoding</code>来决定压缩方式;</li><li>通用首部字段<code>Transfer-Encoding</code>用来决定响应实体是否分块;</li><li>请求首部字段<code>Accept-charset</code>是客户端高速服务端自己能支持的编码方式;</li></ol><h2 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h2><h2 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h2><h2 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《HTTP权威指南》<br>《图解HTTP协议》<br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/HTTP</a><br><a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">https://tools.ietf.org/html/rfc2616</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通用首部字段 general-header&lt;/p&gt;
&lt;h2 id=&quot;Cache-Control&quot;&gt;&lt;a href=&quot;#Cache-Control&quot; class=&quot;headerlink&quot; title=&quot;Cache-Control&quot;&gt;&lt;/a&gt;Cache-Control&lt;/h2&gt;
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP - 请求Method</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-03-Method/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-03-Method/</id>
    <published>2017-11-30T03:25:12.000Z</published>
    <updated>2018-02-08T02:05:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见Method简要分类"><a href="#常见Method简要分类" class="headerlink" title="常见Method简要分类"></a>常见Method简要分类</h2><ol><li><p>HTTP/1.1 中实现的 method</p><ul><li><p>见<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">RFC2616</a><br><img src="/img/http/method-01.png" width="500"></p></li><li><p>可以看到有: <code>OPTIONS</code>, <code>GET</code>, <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>, <code>CONNECT</code></p></li></ul></li><li><p>RFC2616中提到: PATCH，LINK，UNLINK方法被定义，但并不常见, 在<a href="https://tools.ietf.org/html/rfc2068" target="_blank" rel="external">RFC 2068</a>中实现;</p></li><li><p>《图解http协议》中LINK,UNLINK已经被http1.1废弃;</p></li><li><p>规范中虽然是上面那样定义的, 但具体还要看不同应用各自是如何去实现的, 有些应用会完整实现, 有些还会扩展, 有些可能会实现一部分</p><ul><li><p>参考symfony中的 <a href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpFoundation/Request.php" target="_blank" rel="external">symfony/src/Symfony/Component/HttpFoundation/Request.php</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> METHOD_HEAD = <span class="string">'HEAD'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_GET = <span class="string">'GET'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_POST = <span class="string">'POST'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_PUT = <span class="string">'PUT'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_PATCH = <span class="string">'PATCH'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_DELETE = <span class="string">'DELETE'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_PURGE = <span class="string">'PURGE'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_OPTIONS = <span class="string">'OPTIONS'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_TRACE = <span class="string">'TRACE'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_CONNECT = <span class="string">'CONNECT'</span>;</div></pre></td></tr></table></figure></li><li><p>而像postman这种工具, 实现的就比较多:<br><img src="/img/http/postman-http-method.png" width="400/"></p></li></ul></li></ol><h2 id="PUT-对比POST"><a href="#PUT-对比POST" class="headerlink" title="PUT(对比POST)"></a>PUT(对比POST)</h2><ol><li><p><code>PUT</code>: 对已有资源进行更新操作, 所以是 update 操作;</p></li><li><p>一个简单例子: 假设一个博客系统提供一个Web API(<a href="http://superblogging/blogs/post/{blog-name}" target="_blank" rel="external">http://superblogging/blogs/post/{blog-name}</a>), 可以使用PUT或者POST进行请求, HTTP的body部分就是博文内容，这是一个很简单的REST API例子。</p></li><li><p><strong>put和post有什么区别呢</strong>?</p><ul><li>在HTTP中, PUT被定义为 <a href="https://tools.ietf.org/html/rfc2616#section-9.1.2" target="_blank" rel="external"><code>idempotent(幂等性)</code></a>) 的方法，POST则不是，<strong>这是一个很重要的区别</strong></li><li>我们应该用PUT还是POST？<br><strong>取决于这个REST服务的行为是否是idempotent(幂等)的</strong>, 假如发送两个请求, 希望服务器端是产生两个博客帖子，那就说明这个服务不是idempotent的, 因为多次使用产生了副作用了, 那就应该使用POST方法。<br><strong>但如果是希望后一个请求把第一个请求覆盖掉(这不正是修改么), 那这个服务就是idempotent的。</strong></li><li>虽然POST和PUT差别不大, 用错了也没关系, 但是你的服务一放到internet上，如果不遵从HTTP协议的规范，就可能给自己带来麻烦</li></ul></li></ol><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><ol><li><p><code>POST</code>: 上面已经提过了, 所以<strong>POST是非幂等的</strong>;</p></li><li><p>POST和PUT都可以上传文件或者创建新信息, 但主要看你的REST服务行为是否是幂等的</p></li><li><p>再比如, 在我们的支付系统中，一个api的功能是创建收款金额二维码，它和金额相关，每个用户可以有多个二维码，如果连续调用则会创建新的二维码，这个时候就用POST<br>但如果用户的账户二维码只和用户关联，而且是一一对应的关系，此时这个api就可以用PUT，因为每次调用它，都将刷新用户账户二维码</p></li></ol><h2 id="PATCH-对比PUT"><a href="#PATCH-对比PUT" class="headerlink" title="PATCH(对比PUT)"></a>PATCH(对比PUT)</h2><ol><li><p>对已有资源的操作:用于资源的部分内容的更新, 例如更新某一个字段。具体比如说只更新用户信息的电话号码字段。<br> 而<code>PUT</code>则用于更新某个资源较完整的内容, 比如说用户要重填完整表单更新所有信息, 后台处理更新时可能只是保留内部记录ID不变。</p></li><li><p>当资源不存在时: PATCH 可能会去创建一个新的资源, 这个意义上像是 saveOrUpdate 操作。</p></li><li><p>参考:</p><ul><li><a href="https://segmentfault.com/q/1010000005685904/" target="_blank" rel="external">https://segmentfault.com/q/1010000005685904/</a></li><li><a href="https://unmi.cc/restful-http-patch-method/" target="_blank" rel="external">https://unmi.cc/restful-http-patch-method/</a></li><li><a href="http://restcookbook.com/HTTP%20Methods/patch/" target="_blank" rel="external">http://restcookbook.com/HTTP%20Methods/patch/</a></li><li><a href="https://tools.ietf.org/html/rfc5789" target="_blank" rel="external">https://tools.ietf.org/html/rfc5789</a></li></ul></li></ol><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD和 <code>GET</code> 本质是一样的, 区别在于如果使用HEAD, 响应体将不会被返回，而仅仅返回HTTP头信息。<br>有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景: 欲判断某个资源是否存在, 我们通常使用GET, <strong>但这里用HEAD则意义更加明确</strong>。</p><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>比较简单, 直接获取资源;</p><h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><ol><li>这个方法很有趣, 但极少使用。它用于获取当前URL所支持的方法。若请求成功, 则它会在HTTP头中包含一个名为 <code>Allow</code> 的头, 值是服务器所支持的方法, 如 GET, POST。<br> 另外, 之前[介绍跨域]时(稍后奉上,近期正在重新修正), <code>CORS方案 -- (not-so-simple request)</code>中的”预检”请求用的请求方法就是 <code>OPTIONS</code></li></ol><h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><p>要求用隧道协议连接代理, 如使用SSL</p><h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><p>书中说比较少用</p><blockquote><p>TRACE_Method是HTTP（超文本传输）协议定义的一种协议调试方法，该方法会使服务器原样返回任意客户端请求的任何内容。<br>TRACE和TRACK是用来调试web服务器连接的HTTP方式。支持该方式的服务器存在跨站脚本漏洞，通常在描述各种浏览器缺陷的时候，把”Cross-Site-Tracing”简称为XST。攻击者可以利用此漏洞欺骗合法用户并得到他们的私人信息。（这个命令好怕怕，无知好吓人啊）<br>如何关闭Apache的TRACE请求<br>虚拟主机用户可以在.htaccess文件中添加如下代码过滤TRACE请求:<br>RewriteEngine on<br>RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)<br>RewriteRule .* - [F]<br>服务器用户在httpd.conf尾部添加如下指令后重启apache即可:<br>TraceEnable off </p></blockquote><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p><a href="https://tools.ietf.org/html/rfc2616#section-9.7" target="_blank" rel="external">参考</a></p><h2 id="PURGE"><a href="#PURGE" class="headerlink" title="PURGE"></a>PURGE</h2><p>非规范中定义的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常见Method简要分类&quot;&gt;&lt;a href=&quot;#常见Method简要分类&quot; class=&quot;headerlink&quot; title=&quot;常见Method简要分类&quot;&gt;&lt;/a&gt;常见Method简要分类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;HTTP/1.1 中实现的 method&lt;
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>15.实战compose编排集成环境</title>
    <link href="http://blog.renyimin.com/2017/10/21/docker/2017-10-21-15-docker/"/>
    <id>http://blog.renyimin.com/2017/10/21/docker/2017-10-21-15-docker/</id>
    <published>2017-10-21T03:50:08.000Z</published>
    <updated>2018-03-05T03:19:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker-Composer编排<code>nginx+phpfpm+mysql+redis+mongo</code>集成环境<br>Github仓库地址:<a href="https://github.com/rymuscle/docker-composer-lnmp" target="_blank" rel="external">https://github.com/rymuscle/docker-composer-lnmp</a></p><h2 id="定义项目目录结构"><a href="#定义项目目录结构" class="headerlink" title="定义项目目录结构"></a>定义项目目录结构</h2><ol><li><p>为了在项目启动后, 能方便地对各项服务服务进行配置, 观察日志, 持久化数据, 并且保证容器不过于臃肿; 我们在项目中的各服务在启动时, 我们就需要将诸如: 服务的<code>配置文件</code>, <code>日志文件</code>, 数据库服务的<code>数据文件目录</code>, Nginx服务的<code>项目目录</code>等从容器的存储层用挂载数据卷的方式持久化出来;</p></li><li><p>要对各服务进行数据挂载, 因此在使用Docker-Composer编排环境项目前, 要先定义好项目的目录结构, 本人目前的目录结构如下 (基本已做到见名知意):</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">├── docker-compose.yml</div><div class="line">├── mongo</div><div class="line">│   ├── Dockerfile</div><div class="line">│   └── data</div><div class="line">├── mysql</div><div class="line">│   ├── Dockerfile</div><div class="line">│   ├── conf</div><div class="line">│   ├── data</div><div class="line">│   ├── env_config.env</div><div class="line">│   └── log</div><div class="line">├── nginx</div><div class="line">│   ├── Dockerfile</div><div class="line">│   ├── conf</div><div class="line">│   └── log</div><div class="line">├── php</div><div class="line">│   ├── php56</div><div class="line">│   │   ├── Dockerfile</div><div class="line">│   │   ├── conf</div><div class="line">│   │   └── log</div><div class="line">│   └── php72</div><div class="line">│       ├── Dockerfile</div><div class="line">│       ├── conf</div><div class="line">│       └── log</div><div class="line">├── redis</div><div class="line">│   ├── Dockerfile</div><div class="line">│   ├── conf</div><div class="line">│   ├── data</div><div class="line">│   └── log</div><div class="line">└── site</div></pre></td></tr></table></figure></li><li><p>目录结构说明</p></li></ol><ul><li>每个服务下面都放置了一份属于容器自己的<code>Dockerfile</code>文件, 方便对容器进行单独定制 (比如php可能需要安装一些扩展, 就可以放在自己的Dockerfile中进行)</li><li>因为挂载会使用 本机文件/目录 覆盖 容器中的目录/文件, 所以<strong>各服务的配置文件需要提前准备好</strong>, 然后挂载到容器服务的对应目录下(可以直接对应文件,也可以对应目录),<ul><li>各容器的配置文件, 日志等的路径, 可以到<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>上参考具体容器的详情</li><li>拿到各容器的中的的配置文件路径后, 需要使用先启动容器, 然后使用 <code>docker cp</code> 将配置文件/目录拷贝到本地</li></ul></li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在挂载项目根目录<code>site</code>时需要注意, 由于nginx和php-fpm为各自独立的服务(分布式部署方式), 所以</p><ul><li>本机<code>site</code>目录挂载到nginx容器中的项目目录 和 本机<code>site</code>目录挂载到php-fpm容器中的项目目录应该一样, 比如都是 <code>./site:/www</code></li><li>在nginx配置时稍加注意, php-fpm才可以正确找到项目路径</li></ul><h2 id="准备各容器镜像"><a href="#准备各容器镜像" class="headerlink" title="准备各容器镜像"></a>准备各容器镜像</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">renyimindembp:php56 renyimin$ docker pull nginx:1.12.2</div><div class="line">renyimindembp:php56 renyimin$ docker pull mongo:3.2</div><div class="line">renyimindembp:php56 renyimin$ docker pull redis:3.2</div><div class="line">renyimindembp:php56 renyimin$ docker pull mysql:5.6</div><div class="line">renyimindembp:php56 renyimin$ docker pull php:5.6-fpm</div><div class="line">renyimindembp:php56 renyimin$ docker pull php:7.2-fpm</div><div class="line">renyimindembp:php56 renyimin$ docker images</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">mysql                                                 5.6                 0248eeb807c7        4 days ago          256MB</div><div class="line">nginx                                                 1.12.2              a810e4ccb26c        2 weeks ago         108MB</div><div class="line">php                                                   5.6-fpm             aaf299648ff3        2 weeks ago         367MB</div><div class="line">php                                                   7.2-fpm             60245f64ed12        2 weeks ago         367MB</div><div class="line">redis                                                 3.2                 3859b0a6622a        2 weeks ago         99.7MB</div><div class="line">mongo                                                 3.2                 56d7fa068c3d        2 weeks ago         300MB</div></pre></td></tr></table></figure></code></pre><h2 id="从容器中获取配置文件"><a href="#从容器中获取配置文件" class="headerlink" title="从容器中获取配置文件"></a>从容器中获取配置文件</h2><h3 id="启动上面所有容器"><a href="#启动上面所有容器" class="headerlink" title="启动上面所有容器"></a>启动上面所有容器</h3><p>容器的启动方式最好也参考一下<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>上相关资料 (比如mysql在启动时就需要<code>-e</code>设置环境变量来提供root用户密码)</p><ol><li><p>nginx 容器启动: <code>$ docker run -d --name nginx nginx:1.12.2</code></p></li><li><p>mysql 容器启动: <code>$ docker run --name mysql -e MYSQL_ROOT_PASSWORD=renyimin -d mysql:5.6</code></p></li><li><p>php:fpm5.6容器的启动: <code>docker run -d --name php-5.6-fpm php:5.6-fpm</code> 即可启动</p></li><li><p>php:fpm7.2容器的启动: <code>docker run -d --name php-7.2-fpm php:7.2-fpm</code> 即可启动</p></li><li><p>mongo容器的启动: <code>docker run -d --name mg mongo:3.2</code></p></li><li><p>redis容器的启动: <code>docker run -d --name redis redis:3.2</code></p></li><li><p>结果如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">renyimindembp:php56 renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                                NAMES</div><div class="line">145a629c84be        nginx:1.12.2        &quot;nginx -g &apos;daemon ...&quot;   3 seconds ago        Up 2 seconds        80/tcp                               nginx</div><div class="line">72390d1e2aa1        mysql:5.6           &quot;docker-entrypoint...&quot;   56 seconds ago       Up 56 seconds       3306/tcp                             mysql</div><div class="line">6b5019214fc1        mongo:3.2           &quot;docker-entrypoint...&quot;   About a minute ago   Up About a minute   27017/tcp                            mg</div><div class="line">7524ffe44739        redis:3.2           &quot;docker-entrypoint...&quot;   About a minute ago   Up About a minute   6379/tcp                             redis</div><div class="line">8716df7a08fb        php:7.2-fpm         &quot;docker-php-entryp...&quot;   About an hour ago    Up 27 minutes       9000/tcp                             php-7.2-fpm</div><div class="line">2d2d5bb12a68        php:5.6-fpm         &quot;docker-php-entryp...&quot;   About an hour ago    Up About an hour    9000/tcp                             php-5.6-fpm</div></pre></td></tr></table></figure></li></ol><h3 id="docker-cp-获取配置文件"><a href="#docker-cp-获取配置文件" class="headerlink" title="docker cp 获取配置文件"></a><code>docker cp</code> 获取配置文件</h3><p>各容器的配置文件, 日志等的路径, 可以到<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>上参考具体容器的详情<br>最后需要手动调整一下目录结构即可</p><ol><li><p>nginx</p><ul><li>拷贝nginx默认配置文件到设定的 nginx/conf 目录 :<br><code>docker cp 8d572e88f735:/etc/nginx/ /Users/renyimin/Desktop/docker-compose/nginx/conf/</code></li></ul></li><li><p>mysql</p><ul><li>拷贝mysql默认数据库文件到设定的 mysql/data 目录<br><code>docker cp 72390d1e2aa1:/var/lib/mysql /Users/renyimin/Desktop/docker-compose/mysql/data</code></li><li>拷贝mysql默认配置文件到设定的 mysql/conf 目录<br><code>docker cp 72390d1e2aa1:/etc/mysql/ /Users/renyimin/Desktop/docker-compose/mysql/conf/</code></li></ul></li><li><p>php56</p><ul><li>拷贝php56默认配置文件到设定的 php56/conf 目录<br><code>docker cp 2d2d5bb12a68:/usr/local/etc/php/ /Users/renyimin/Desktop/docker-compose/php/php56/conf/</code><br><code>docker cp 2d2d5bb12a68:/usr/local/etc/php-fpm.d/ /Users/renyimin/Desktop/docker-compose/php/php56/conf/</code></li></ul></li><li><p>php72</p><ul><li>拷贝php72默认配置文件到设定的 php72/conf 目录<br><code>docker cp 8716df7a08fb:/usr/local/etc/php/ /Users/renyimin/Desktop/docker-compose/php/php72/conf/</code><br><code>docker cp 8716df7a08fb:/usr/local/etc/php-fpm.d/ /Users/renyimin/Desktop/docker-compose/php/php72/conf/</code></li></ul></li><li><p>mongo</p><ul><li>拷贝mongo默认数据库文件到设定的 mongo/data 目录 (mongo容器的/data有configdb和db两个目录)<br><code>docker cp 6b5019214fc1:/data/ /Users/renyimin/Desktop/docker-compose/mongo/</code></li></ul></li><li><p>redis</p><ul><li>拷贝redis默认数据库文件到设定的 redis/data 目录<br><code>docker cp 7524ffe44739:/data /Users/renyimin/Desktop/docker-compose/redis/data</code></li><li>拷贝redis默认配置文件到设定的 redis/conf 目录<br><code>docker cp 7524ffe44739:/usr/local/etc/redis/ /Users/renyimin/Desktop/docker-compose/redis/conf/</code></li></ul></li></ol><h2 id="整理各个服务的Dockerfile"><a href="#整理各个服务的Dockerfile" class="headerlink" title="整理各个服务的Dockerfile"></a>整理各个服务的Dockerfile</h2><ol><li>首先, 每个服务的 <code>FROM</code> 和 <code>MAINTAINER</code> 需要写在Dockerfile的开头;</li><li>这里主要定制了php-fpm的 <code>Dockerfile</code>, 安装哪些扩展主要是参考<ul><li><a href="https://hub.docker.com/_/php/" target="_blank" rel="external">Docker Hub</a>上php容器的介绍</li><li><a href="https://github.com/twang2218/docker-lnmp" target="_blank" rel="external">https://github.com/twang2218/docker-lnmp</a></li><li><a href="https://www.awaimai.com/2120.html#53_docker-composeyml" target="_blank" rel="external">歪麦博客</a></li></ul></li><li>最后在Dockerfile中完成对扩展的安装 <ul><li>如何安装扩展可以参考<a href="https://hub.docker.com/_/php/" target="_blank" rel="external">Docker Hub</a> 和 <a href="https://my.oschina.net/antsky/blog/1591418" target="_blank" rel="external">这里</a></li><li><strong>注意如何清理?</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 貌似源码安装的软件需要如下进行清理:</div><div class="line">RUN docker-php-source extract \</div><div class="line">    # 此处开始执行你需要的操作 \</div><div class="line">    &amp;&amp; docker-php-source delete</div></pre></td></tr></table></figure></li></ul></li></ol><ol><li>如果稍后需要安装其他扩展, 在Dockerfile文件中定制即可, 然后 <code>docker-compose up -d --build php(docker-composer.yml中设定的服务名)</code> 重新构建即可 </li></ol><h2 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写docker-compose.yml</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line"></div><div class="line">services:</div><div class="line">  nginx:</div><div class="line">    build:</div><div class="line">      context: ./nginx/</div><div class="line">      dockerfile: Dockerfile</div><div class="line">      #args:</div><div class="line">    ports:</div><div class="line">      - &quot;8090:80&quot;</div><div class="line">    volumes:</div><div class="line">      - ./site/:/www:rw</div><div class="line">      - ./nginx/conf/conf.d:/etc/nginx/conf.d/:ro</div><div class="line">      - ./nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro</div><div class="line">      - ./nginx/log/:/var/log/nginx/:rw</div><div class="line">    depends_on:</div><div class="line">      - php</div><div class="line">    networks:</div><div class="line">      - frontend</div><div class="line">  php:</div><div class="line">    build: ./php/php72/</div><div class="line">    expose:</div><div class="line">      - &quot;9000&quot;</div><div class="line">    volumes:</div><div class="line">      - ./site/:/www:rw</div><div class="line">      - ./php/php72/conf/php/:/usr/local/etc/php/</div><div class="line">      - ./php/php72/conf/php-fpm.d/:/usr/local/etc/php-fpm.d/:rw</div><div class="line">      - ./php/php72/log/php-fpm/:/var/log/:rw</div><div class="line">    depends_on:</div><div class="line">      - mysql</div><div class="line">      - redis</div><div class="line">      - mongo</div><div class="line">    networks:</div><div class="line">      - frontend</div><div class="line">      - backend</div><div class="line"></div><div class="line">  mysql:</div><div class="line">    build: ./mysql/</div><div class="line">    ports:</div><div class="line">      - &quot;3307:3306&quot;</div><div class="line">    volumes:</div><div class="line">      - ./mysql/conf/:/etc/mysql/:rw</div><div class="line">      - ./mysql/data/:/var/lib/mysql/:rw</div><div class="line">      - ./mysql/log/:/var/log/mysql/:rw</div><div class="line">    env_file: ./mysql/env_config.env</div><div class="line">    environment:</div><div class="line">      TZ: &apos;Asia/Shanghai&apos;</div><div class="line">      MYSQL_ROOT_PASSWORD: &quot;renyimin&quot;</div><div class="line">    networks:</div><div class="line">      - backend</div><div class="line"></div><div class="line">  mongo:</div><div class="line">      build: ./mongo/</div><div class="line">      ports:</div><div class="line">        - 27018:27017</div><div class="line">      volumes:</div><div class="line">        - ./mongo/data:/data:rw</div><div class="line">        - ./mongo/data:/var/log/mongodb/:rw</div><div class="line"></div><div class="line">  redis:</div><div class="line">    build: ./redis/</div><div class="line">    volumes:</div><div class="line">      - ./redis/conf/:/usr/local/etc/redis</div><div class="line">      - ./redis/data/:/data:rw</div><div class="line">      - ./redis/log/:/var/log/</div><div class="line">    ports:</div><div class="line">      - &quot;6380:6379&quot;</div><div class="line"></div><div class="line">networks:</div><div class="line">    frontend:</div><div class="line">    backend:</div></pre></td></tr></table></figure></code></pre><h2 id="编排"><a href="#编排" class="headerlink" title="编排"></a>编排</h2><p>编排构建过程可能会有点慢(视网络快慢, 因为需要安装一些php扩展)</p><h2 id="小细节问题"><a href="#小细节问题" class="headerlink" title="小细节问题"></a>小细节问题</h2><ol><li><p>如果修改docker-compose.yml文件中某个容器的配置, 需要如何单独重新构建这个容器?</p><ul><li><code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> , 如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 当docker-compose.yml中nginx服务的相关配置没有改动时</div><div class="line">renyimindembp:docker-compose renyimin$ docker-compose up --no-deps -d nginx</div><div class="line">dockercompose_nginx_1 is up-to-date</div><div class="line"># 当docker-compose.yml中nginx服务的相关配置被改动后</div><div class="line">renyimindembp:docker-compose renyimin$ docker-compose up --no-deps -d nginx</div><div class="line">Recreating dockercompose_nginx_1 ... done</div><div class="line">renyimindembp:docker-compose renyimin$</div></pre></td></tr></table></figure></li></ul></li><li><p>如果修改了某个容器的配置文件, 如何单独重启这个容器? </p><ul><li>注意, 此时<code>docker-compose up --no-deps -d nginx</code>重新构建会发现docker-compose.yml中nginx服务的相关配置并没有改动, 所以不会生效</li><li>此时应该重启这个容器: <code>docker-compose restart nginx</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindembp:docker-compose renyimin$ docker-compose restart nginx</div><div class="line">Restarting dockercompose_nginx_1 ... done</div><div class="line">renyimindembp:docker-compose renyimin$</div></pre></td></tr></table></figure></li></ul></li></ol><ol><li>每次 <code>docker-compose up</code> 会重新构建所有容器<ul><li>但是只构建<code>docker-compose.yml</code>中配置发生变化的容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">renyimindembp:docker-compose renyimin$ docker-compose up -d</div><div class="line">dockercompose_mongo_1 is up-to-date</div><div class="line">dockercompose_redis_1 is up-to-date</div><div class="line">dockercompose_mysql_1 is up-to-date</div><div class="line">dockercompose_php_1 is up-to-date</div><div class="line">dockercompose_nginx_1 is up-to-date</div><div class="line">renyimindembp:docker-compose renyimin$</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="pecl扩展安装问题"><a href="#pecl扩展安装问题" class="headerlink" title="pecl扩展安装问题"></a>pecl扩展安装问题</h2><p>代理问题:  参考<a href="https://www.awaimai.com/2120.html讨论" target="_blank" rel="external">https://www.awaimai.com/2120.html讨论</a><br>未完待续~~ (安装mongo, redis, memcached 扩展)</p><p>参考:<a href="https://yeasy.gitbooks.io/docker_practice/content/compose/commands.html#up" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/compose/commands.html#up</a><br>参考:<a href="https://github.com/twang2218/docker-lnmp" target="_blank" rel="external">https://github.com/twang2218/docker-lnmp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker-Composer编排&lt;code&gt;nginx+phpfpm+mysql+redis+mongo&lt;/code&gt;集成环境&lt;br&gt;Github仓库地址:&lt;a href=&quot;https://github.com/rymuscle/docker-composer-lnmp&quot;
      
    
    </summary>
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/categories/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/tags/Docker%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>14.Compose模板文件</title>
    <link href="http://blog.renyimin.com/2017/10/19/docker/2017-10-19-14-docker/"/>
    <id>http://blog.renyimin.com/2017/10/19/docker/2017-10-19-14-docker/</id>
    <published>2017-10-19T10:50:08.000Z</published>
    <updated>2018-03-05T03:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://yeasy.gitbooks.io/docker_practice/content/compose/compose_file.html" target="_blank" rel="external">docker-compose.yml</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/content/compose/compose_file.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;docker-compose.yml&lt;/
      
    
    </summary>
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/categories/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/tags/Docker%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>13.Compose命令学习</title>
    <link href="http://blog.renyimin.com/2017/10/19/docker/2017-10-19-13-docker/"/>
    <id>http://blog.renyimin.com/2017/10/19/docker/2017-10-19-13-docker/</id>
    <published>2017-10-19T06:27:53.000Z</published>
    <updated>2018-03-05T03:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Compose命令说明"><a href="#Compose命令说明" class="headerlink" title="Compose命令说明"></a>Compose命令说明</h2><ol><li><p>命令作用的对象: 对于<code>Compose</code>来说, 大部分命令所作用的对象既可以是<code>项目本身</code>, 也可以指定为<code>项目中的服务或者容器</code>。如果没有特别的说明, 命令针对的对象将是项目, 这意味着项目中所有的服务都会受到命令影响。</p></li><li><p>命令格式: </p><ul><li>docker-compose 命令的基本的使用格式是: <code>docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</code></li><li>执行<code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</li></ul></li><li><p>命令选项:</p><ul><li><p><code>-f, --file FILE</code> 指定使用的Compose模板文件,默认为docker-compose.yml, 可以多次指定。</p></li><li><p><code>-p, --project-name NAME</code> 指定项目名称,<strong>默认将使用所在目录名称作为项目名</strong>。</p></li><li><p><code>--x-networking</code> 使用Docker的可拔插网络后端特性</p></li><li><p><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 bridge</p></li><li><p><code>--verbose</code> 输出更多调试信息。</p></li><li><p><code>-v, --version</code> 打印版本并退出。</p></li></ul></li></ol><h2 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h2><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>打印compose的版本信息 <code>docker-compose version</code></p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><p>列出Compose模板文件中包含的镜像 <code>docker-compose images</code></p><h3 id="build"><a href="#build" class="headerlink" title="build ??"></a>build ??</h3><ol><li>构建(重新构建)项目中的服务容器, 格式为 <code>docker-compose build [options] [SERVICE...]</code><ul><li>服务容器一旦构建后, 将会带上一个标记名, 例如对于<code>web项目</code>中的一个<code>db容器</code>, 可能叫web_db</li><li>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务</li></ul></li><li>选项包括：<ul><li><code>--force-rm</code> 删除构建过程中的临时容器</li><li><code>--no-cache</code> 构建镜像过程中不使用 cache(这将加长构建过程)</li><li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li></ul></li></ol><h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><ol><li><p>该命令十分强大, 它将尝试自动完成包括构建镜像, (重新)创建服务, 启动服务, 并关联服务相关容器的一系列操作。</p><ul><li>链接的服务都将会被自动启动, 除非已经处于运行状态; (可以说，大部分时候都可以直接通过该命令来启动一个项目。)</li><li>格式为 docker-compose up [options] [SERVICE…]。</li></ul></li><li><p>默认情况, <code>docker-compose up</code> 启动的容器都在前台, 控制台将会同时打印所有容器的输出信息, 可以很方便进行调试。当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p></li><li><p>如果使用 <code>docker-compose up -d</code>, 将会在后台启动并运行所有的容器, 一般推荐生产环境下使用该选项。</p></li><li><p>默认情况, 如果服务容器已经存在, <code>docker-compose up</code>将会尝试停止容器, 然后重新创建(保持使用 <code>volumes-from</code> 挂载的卷), 以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。<br> 如果用户不希望容器被停止并重新创建, 可以使用 <code>docker-compose up --no-recreate</code>。<br> 这样将只会启动处于停止状态的容器, 而忽略已经运行的服务;</p></li><li><p>如果用户只想重新部署某个服务, 可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务, 启动新服务, 并不会影响到其所依赖的服务。</p></li></ol><h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>打印某个容器端口所映射的公共端口, 格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code></p><ul><li><code>--protocol=proto</code> 指定端口协议, tcp(默认值)或者 udp</li><li><code>--index=index</code> 如果同一服务存在多个容器, 指定命令对象容器的序号(默认为 1)</li></ul><h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>在指定服务上执行一个命令, 格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code></p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>进入指定的容器</p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>通过发送SIGKILL信号来强制停止服务容器, 格式为 <code>docker-compose kill [options] [SERVICE...]</code><br>支持通过 -s 参数来指定发送的信号, 例如, 通过<code>$ docker-compose kill -s SIGINT</code>指令发送SIGINT信号</p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>查看各个服务容器内运行的进程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Compose命令说明&quot;&gt;&lt;a href=&quot;#Compose命令说明&quot; class=&quot;headerlink&quot; title=&quot;Compose命令说明&quot;&gt;&lt;/a&gt;Compose命令说明&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;命令作用的对象: 对于&lt;code&gt;Compose&lt;
      
    
    </summary>
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/categories/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/tags/Docker%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>12.Docker三剑客 之 Compose</title>
    <link href="http://blog.renyimin.com/2017/10/19/docker/2017-10-19-12-docker/"/>
    <id>http://blog.renyimin.com/2017/10/19/docker/2017-10-19-12-docker/</id>
    <published>2017-10-19T03:07:53.000Z</published>
    <updated>2018-03-05T03:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Compose简介"><a href="#Compose简介" class="headerlink" title="Compose简介"></a>Compose简介</h2><ol><li><p><a href="https://github.com/docker/compose" target="_blank" rel="external">Compose 项目</a>是Docker官方的开源项目, 负责快速在集群中部署分布式应用。</p></li><li><p>Compose定位是「定义和运行多个Docker容器的应用(Defining and running multi-container Docker applications)」。</p></li><li><p>通过之前的学习，已经知道使用一个Dockerfile模板文件, 可以让用户很方便的定义一个单独的应用容器。然而, 在日常工作中, 经常会碰到需要多个容器相互配合来完成某项任务的情况。<br> 例如要实现一个Web项目, 除了 <code>Web服务容器</code> 本身, 往往还需要再加上后端的 <code>数据库服务容器</code>，甚至还包括 <code>负载均衡容器</code> 等。</p></li><li><p>Compose 恰好满足了这样的需求, 它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件(YAML格式)来定义 <strong>一组相关联的应用容器</strong> 为一个<strong>项目(project)</strong>。</p></li><li><p>Compose 中有两个重要的概念:</p><ul><li>服务(service): 一个应用容器，实际上可以包括若干运行相同镜像的容器实例。 </li><li>项目(project): 由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li></ul></li><li><p>Compose的默认管理对象是<strong>项目</strong>, 通过子命令对项目中的一组容器进行便捷地生命周期管理。<br>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。   </p></li></ol><h2 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h2><ol><li>Compose 目前支持 Linux、macOS、Windows 10 三大平台。</li><li>Compose 可以通过 Python 的包管理工具 <code>pip</code> 进行安装，也可以直接下载编译好的二进制文件使用，甚至直接运行在 Docker 容器中。</li><li><p>PIP 安装</p><ul><li>这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。</li><li>执行安装命令: <code>pip install -U docker-compose</code></li></ul></li><li><p>安装成功后，可以查看 docker-compose 命令的用法: <code>$ docker-compose -h</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Compose简介&quot;&gt;&lt;a href=&quot;#Compose简介&quot; class=&quot;headerlink&quot; title=&quot;Compose简介&quot;&gt;&lt;/a&gt;Compose简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/docke
      
    
    </summary>
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/categories/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/tags/Docker%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>11.高级网络配置</title>
    <link href="http://blog.renyimin.com/2017/10/19/docker/2017-10-19-11-docker/"/>
    <id>http://blog.renyimin.com/2017/10/19/docker/2017-10-19-11-docker/</id>
    <published>2017-10-19T02:20:31.000Z</published>
    <updated>2018-03-05T03:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker虚拟网络原理"><a href="#Docker虚拟网络原理" class="headerlink" title="Docker虚拟网络原理"></a>Docker虚拟网络原理</h2><ol><li><p>当Docker启动时, 会自动在主机上创建一个<code>docker0虚拟网桥</code>, 实际上是 Linux 的一个 bridge, 可以理解为一个软件交换机。它会在 挂载到它上面的哪些网口 之间转发信息。</p></li><li><p>同时, Docker随机分配一个本地未占用的私有网段中的一个地址给<code>docker0</code>接口, 比如典型的172.17.42.1,掩码为255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段(172.17.0.0/16)的地址。</p></li><li><p>当创建一个Docker容器的时候,同时会创建了一对<code>veth pair</code>接口(当数据包发送到一个接口时, 另外一个接口也可以收到相同的数据包)</p><ul><li>这对接口一端在容器内,即 <code>eth0</code>; </li><li>另一端在本地并被挂载到<code>docker0</code>网桥, 名称以 veth 开头(例如 vethAQI2QT);</li></ul></li><li><p>通过这种方式, 主机可以跟容器通信, 容器之间也可以相互通信, Docker就创建了在主机和所有容器之间一个虚拟共享网络。<br><img src="/img/docker/network.png" width="350/"></p></li></ol><p>接下来的部分将介绍在一些场景中, Docker 所有的网络定制配置, 以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认的网络配置。</p><p>未完待续….</p><p>参考: <a href="https://yeasy.gitbooks.io/docker_practice/content/advanced_network/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/advanced_network/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker虚拟网络原理&quot;&gt;&lt;a href=&quot;#Docker虚拟网络原理&quot; class=&quot;headerlink&quot; title=&quot;Docker虚拟网络原理&quot;&gt;&lt;/a&gt;Docker虚拟网络原理&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当Docker启动时, 会自动在主机上创建
      
    
    </summary>
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/categories/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/tags/Docker%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>10.Docker中的网络功能</title>
    <link href="http://blog.renyimin.com/2017/10/17/docker/2017-10-17-10-docker/"/>
    <id>http://blog.renyimin.com/2017/10/17/docker/2017-10-17-10-docker/</id>
    <published>2017-10-17T10:15:23.000Z</published>
    <updated>2018-03-05T03:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><ol><li><p>容器中可以运行一些网络应用, 要让外部也可以访问这些应用, 可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 8090:80 --name testVip --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div></pre></td></tr></table></figure></li><li><p>使用 <code>docker ps</code> 可以看到本地主机的 8090 被映射到了容器的 80 端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                       NAMES</div><div class="line">27863a3a8f70        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   39 minutes ago      Up 39 minutes       3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   testVip</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure><p>此时访问本机的 8090 端口即可访问容器内 web 应用提供的界面。</p></li></ol><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><ol><li><p>使用 <code>docker port 容器名</code>  来查看当前映射的端口配置, 也可以查看到绑定的地址</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                       NAMES</div><div class="line">27863a3a8f70        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   45 minutes ago      Up 45 minutes       3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   testVip</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker port testVip</div><div class="line">80/tcp -&gt; 0.0.0.0:8090</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></li><li><p>注意:</p><ul><li><code>-p</code> 可以多次使用来绑定多个端口</li><li>容器有自己的内部网络和 ip 地址(使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置)</li></ul></li></ol><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>容器的连接(linking)系统是除了端口映射外, 另一种跟容器中应用交互的方式。该系统会在源和接收容器之间创建一个隧道, 接收容器可以看到源容器指定的信息。<br>相对于端口映射, 这种方式主要用来做内部链接, 不暴露链接接口给外部</p><h3 id="自定义容器命名"><a href="#自定义容器命名" class="headerlink" title="自定义容器命名"></a><strong>自定义容器命名</strong></h3><ol><li>连接系统依据<strong>容器的名称</strong>来执行。因此，首先需要自定义一个好记的容器命名。虽然当创建容器的时候, 系统默认会分配一个名字。</li><li>自定义命名容器有2个好处:<ul><li>自定义的命名，比较好记，比如一个web应用容器我们可以给它起名叫web</li><li>当要连接其他容器时候，可以作为一个有用的参考点，比如连接web容器到db容器</li></ul></li><li>使用 <code>--name</code> 标记可以为容器自定义命名(使用 docker ps 来验证设定的命名)<ul><li>注意:<strong>容器的名称是唯一的</strong>。如果已经命名了一个叫 web 的容器，当你要再次使用 web 这个 名称的时候，需要先用 docker rm 来删除之前创建的同名容器。<h3 id="–rm"><a href="#–rm" class="headerlink" title="–rm"></a>–rm</h3>在执行 <code>docker run</code> 的时候如果添加 <code>--rm</code> 标记，则容器在终止后会立刻删除。注意, <code>--rm</code> 和 <code>-d</code> 参数不能同时使用。</li></ul></li></ol><h2 id="容器互联-1"><a href="#容器互联-1" class="headerlink" title="容器互联"></a>容器互联</h2><p>使用 <code>--link name:alias</code> 参数可以让容器之间安全的进行交互, 其中 <code>name</code> 是要链接的容器的名称, <code>alias</code> 是这个连接的别名;</p><ol><li><p>下面先创建一个新的数据库容器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 3307:3306 --name db --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div><div class="line">fd29cafa699da868a57f559630c6fb7f5dcf30705f884c9fa7feb4a373bba37c</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></li><li><p>然后创建一个新的 web 容器，并将它连接到 db 容器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 8090:80 --name web --link db:db --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div><div class="line">0e20f11d0f57fedb9d5fee96c8d9d56b67a7c62ded101fd92abf12bba04d09e4</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></li><li><p>使用 <code>docker ps</code> 来查看容器的连接</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                                       NAMES</div><div class="line">0e20f11d0f57        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   About a minute ago   Up About a minute   3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   web</div><div class="line">fd29cafa699d        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   About a minute ago   Up About a minute   80/tcp, 15672/tcp, 0.0.0.0:3307-&gt;3306/tcp   db</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure><p> (理论上可以看到自定义命名的容器 db 和 web, db 容器的 names 列有 db 也有 web/db。这表示 web 容器链接到 db 容器，web 容器将被允许访问 db 容器的信息。)<br> 但实际上貌似没有在names列看到有web/db</p></li><li><p>Docker 在两个互联的容器之间创建了一个安全隧道，而且不用映射它们的端口到宿主主机 上。在启动 db 容器的时候可以不用使用 -p 和 -P 标记，从而避免了暴露数据库端口到外部网络上。</p></li><li><p>Docker 通过 2 种方式为容器公开连接信息:</p><ul><li>环境变量</li><li>更新 /etc/hosts 文件</li></ul></li><li><p>使用 <code>env</code> 命令来查看 web 容器的环境变量</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run --rm --name web2 --link db:db vipservice env</div></pre></td></tr></table></figure><p> 更多参考书上…</p></li><li><p>除了环境变量, Docker 还添加 host 信息到父容器的 <code>/etc/hosts</code> 的文件。下面是父容器 web 的 <code>hosts</code> 文件</p><ul><li><p>这里有 2 个 hosts，第一个是 web 容器，web 容器用 id 作为他的主机名，第二个是 db 容器 的 ip 和主机名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                       NAMES</div><div class="line">297c83c40bc4        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   9 minutes ago       Up 8 minutes        3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   web</div><div class="line">46985aa1ab7b        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   9 minutes ago       Up 9 minutes        80/tcp, 15672/tcp, 0.0.0.0:3307-&gt;3306/tcp   db</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker exec -it web /bin/sh</div><div class="line">sh-4.2# cat /etc/hosts</div><div class="line">127.0.0.1localhost</div><div class="line">::1localhost ip6-localhost ip6-loopback</div><div class="line">fe00::0ip6-localnet</div><div class="line">ff00::0ip6-mcastprefix</div><div class="line">ff02::1ip6-allnodes</div><div class="line">ff02::2ip6-allrouters</div><div class="line">172.17.0.2db 46985aa1ab7b</div><div class="line">172.17.0.3297c83c40bc4</div><div class="line">sh-4.2#</div></pre></td></tr></table></figure></li><li><p>可以在 web 容器中安装 ping 命令来测试跟db容器的连通, 用 ping 来测试db容器，它会解析成 172.17.0.2 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sh-4.2# ping db</div><div class="line">PING db (172.17.0.2) 56(84) bytes of data.</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=1 ttl=64 time=0.243 ms</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=2 ttl=64 time=0.330 ms</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=3 ttl=64 time=0.136 ms</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=4 ttl=64 time=0.129 ms</div></pre></td></tr></table></figure></li><li><p>用户可以链接多个父容器到子容器，比如可以链接多个 web 到 db 容器上。</p></li></ul></li></ol><p>参考: <a href="https://yeasy.gitbooks.io/docker_practice/content/network/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/network/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;外部访问容器&quot;&gt;&lt;a href=&quot;#外部访问容器&quot; class=&quot;headerlink&quot; title=&quot;外部访问容器&quot;&gt;&lt;/a&gt;外部访问容器&lt;/h2&gt;&lt;h3 id=&quot;端口映射&quot;&gt;&lt;a href=&quot;#端口映射&quot; class=&quot;headerlink&quot; title=&quot;端
      
    
    </summary>
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/categories/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/tags/Docker%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>09.Docker数据管理</title>
    <link href="http://blog.renyimin.com/2017/10/17/docker/2017-10-17-09-docker/"/>
    <id>http://blog.renyimin.com/2017/10/17/docker/2017-10-17-09-docker/</id>
    <published>2017-10-17T06:40:23.000Z</published>
    <updated>2018-03-05T03:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>容器中管理数据主要有两种方式：<code>数据卷(Volumes)</code> 和 <code>挂载主机目录(Bind mounts)</code></p><h2 id="数据卷-Volumes"><a href="#数据卷-Volumes" class="headerlink" title="数据卷(Volumes)"></a>数据卷(Volumes)</h2><ol><li>数据卷 是一个可供<strong>一个或多个</strong>容器使用的特殊目录, 它绕过UFS, 可以提供很多有用的特性:<ul><li>数据卷 可以在容器之间共享和重用</li><li>对 数据卷 的修改会立马生效</li><li>对 数据卷 的更新，不会影响镜像</li><li>数据卷 默认会一直存在，即使容器被删除</li></ul></li><li>注意: 数据卷 的使用, 类似于 Linux 下对目录或文件进行 <code>mount</code>，镜像中的被指定为挂载点的目录中的文件会隐藏掉, 能显示看的是挂载的数据卷。</li></ol><h2 id="数据卷操作"><a href="#数据卷操作" class="headerlink" title="数据卷操作"></a>数据卷操作</h2><p>(在主机里使用)</p><ol><li>创建一个数据卷: <code>docker volume create my-vol</code> (其实还有一种方式就是在docker run的时候直接指定一个数据卷名, 就会自动帮你创建数据卷)</li><li>查看所有数据卷: <code>docker volume ls</code></li><li>查看指定数据卷的信息: <code>docker volume inspect my-vol</code><br> 查看容器的数据卷挂载信息: <code>docker inspect 容器名</code></li><li><p>删除数据卷 <code>$ docker volume rm my-vol</code></p><ul><li>数据卷 是被设计用来<strong>持久化</strong>数据的, 它的生命周期独立于容器, Docker不会在容器被删除后自动删除数据卷, 并且<strong>也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷</strong>。</li><li>如果需要在删除容器的同时移除数据卷, 可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令, <strong>这个命令貌似只是移除该容器和数据卷之间的关系</strong>, 除非这个数据卷没有任何容器引用了, 才可以使用下面介绍的命令来删除掉。</li></ul></li><li><p><strong>无主的数据卷</strong>可能会占据很多空间，要清理请使用命令 <code>$ docker volume prune</code></p><ul><li>可以看到清除时会提醒你 <code>WARNING! This will remove all volumes not used by at least one container</code></li><li>清除的是没有被<strong>至少一个</strong>容器使用的数据卷!</li></ul></li></ol><h2 id="创建并启动容器时-挂载数据卷"><a href="#创建并启动容器时-挂载数据卷" class="headerlink" title="创建并启动容器时,挂载数据卷"></a>创建并启动容器时,挂载数据卷</h2><ol><li>在使用 <code>docker run</code> 命令的时候, 还可以使用 <code>--mount</code> 参数来将<code>数据卷</code>挂载到容器里, 另外, 在一次 <code>docker run</code> 中可以挂载多个数据卷。</li><li><p>下面创建一个名为 <code>my-first-vol</code> 的数据卷</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">localhost:~ renyimin$ docker volume create my-first-vol</div><div class="line">my-first-vol</div><div class="line">localhost:~ renyimin$ </div><div class="line">localhost:~ renyimin$ docker volume inspect my-first-vol</div><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;CreatedAt&quot;: &quot;2017-04-26T13:43:16Z&quot;,</div><div class="line">        &quot;Driver&quot;: &quot;local&quot;,</div><div class="line">        &quot;Labels&quot;: &#123;&#125;,</div><div class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-first-vol/_data&quot;,</div><div class="line">        &quot;Name&quot;: &quot;my-first-vol&quot;,</div><div class="line">        &quot;Options&quot;: &#123;&#125;,</div><div class="line">        &quot;Scope&quot;: &quot;local&quot;</div><div class="line">    &#125;</div><div class="line">]</div><div class="line">localhost:~ renyimin$</div></pre></td></tr></table></figure></li><li><p>创建并运行一个名为 <code>web</code> 的容器, 同时加载上面的<code>数据卷</code>到容器内的 <code>/test-vol</code> 目录</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">localhost:~ renyimin$ docker run -d -p 5000:5000 --name myFirstRegistry --mount source=my-first1-vol,target=/test-vol registry</div><div class="line">45e2da7a8ee3c51ae682ff78d02c9779531a79fe2f7a58739023cd19ab48b09d</div><div class="line">localhost:~ renyimin$ docker exec -it myFirstRegistry /bin/sh</div><div class="line">/ # ls</div><div class="line">bin            entrypoint.sh  home           linuxrc        mnt            root           sbin           sys            tmp            var</div><div class="line">dev            etc            lib            media          proc           run            srv            test-vol       usr</div><div class="line">/ #</div></pre></td></tr></table></figure><ul><li>容器中会自动创建虚拟机中的挂载目录;</li><li>另外, 之前我们创建的数据卷是 <code>my-first-vol</code>, 此次运行容器时, 加载的数据卷<strong>却是</strong> <code>my-first1-vol</code>,<br>后面通过查看容器在<code>&quot;Mounts&quot;</code>key下面的数据卷信息, 会发现在启动容器时如果指定的数据卷不存在, 则会自动创建;<br>通过<code>docker volume ls</code>也可以看到现在有<code>my-first-vol</code> 和 <code>my-first1-vol</code> 这两个我们创建的数据卷;</li></ul></li><li><p>可以在主机里使用以下命令查看 <code>myFirstRegistry</code> 容器的信息, 数据卷信息在 <code>&quot;Mounts&quot;</code> Key 下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ docker inspect myFirstRegistry</div><div class="line">&quot;Mounts&quot;: [</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;volume&quot;,</div><div class="line">        &quot;Name&quot;: &quot;my-first1-vol&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-first1-vol/_data&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/test-vol&quot;,</div><div class="line">        &quot;Driver&quot;: &quot;local&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;z&quot;,</div><div class="line">        &quot;RW&quot;: true,</div><div class="line">        &quot;Propagation&quot;: &quot;&quot;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;volume&quot;,</div><div class="line">        &quot;Name&quot;: &quot;4fde6460059e4f0f07bc1c91ed852da7884b872dffc66bc4e237a260c7248250&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/4fde6460059e4f0f07bc1c91ed852da7884b872dffc66bc4e237a260c7248250/_data&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/var/lib/registry&quot;,</div><div class="line">        &quot;Driver&quot;: &quot;local&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;&quot;,</div><div class="line">        &quot;RW&quot;: true,</div><div class="line">        &quot;Propagation&quot;: &quot;&quot;</div><div class="line">    &#125;</div><div class="line">],</div></pre></td></tr></table></figure></li></ol><h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><ol><li><p>挂载一个主机目录作为数据卷: 使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 8090:80 --name testVip --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha vipservice</div><div class="line">2dea428aa379aaf415e5eff38b76f43d64e77b6b34d25bb5e353354ba897cee6</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker exec -it 2dea428aa379aaf415e5eff38b76f43d64e77b6b34d25bb5e353354ba897cee6 /bin/sh</div><div class="line">sh-4.2# cd /</div><div class="line">sh-4.2# ls</div><div class="line">anaconda-post.log  bindata  dev  etchaha  home  lib  lib64lost+found  media  mntopt  proc  root  run  run.sh  sbin  srv  sys  tmp  usrvar</div><div class="line">sh-4.2# cd haha</div><div class="line">sh-4.2# ls</div><div class="line">myfirstregistry  registry.tar</div><div class="line">sh-4.2#</div></pre></td></tr></table></figure></li><li><p>上面的命令会加载主机的 <code>/Users/renyimin/Desktop/testVip</code> 目录到容器的 <code>/haha</code> 目录, 这个功能在进行测试的时候十分方便, 比如, 你可以放置一些程序到本地目录中,来查看容器是否正常工作。<strong>本地目录的路径必须是绝对路径</strong>, 以前使用 <code>-v</code> 参数时, 如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在, Docker 会报错。</p></li><li><p>查看容器的挂载信息, 发现和数据卷相比, <code>Type</code>信息是<code>bind</code>而不是<code>volume</code>, 并且没有数据卷的<code>name</code>信息, <code>docker volume ls</code> 也不会看到有新的数据卷被创建, 所以…可以认为只是一次简单的目录绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker inspect testVip</div><div class="line">&quot;Mounts&quot;: [</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;bind&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/Users/renyimin/Desktop/testVip&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/haha&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;&quot;,</div><div class="line">        &quot;RW&quot;: true,</div><div class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure></li><li><p>选择 <code>-v</code> 还是 <code>--mount</code> 参数?</p><ul><li>Docker 新用户应该选择 <code>--mount</code> 参数，经验丰富的 Docker 使用者对 <code>-v</code> 或者 <code>--volume</code> 已经很熟悉了，但是推荐使用 <code>--mount</code> 参数;</li><li>可以理解为, <strong><code>--mount</code> 参数应该可以挂载数据卷, 也可以代替-v来进行目录关联</strong>。</li></ul></li><li><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <strong>只读</strong></p><ul><li><p>加了 readonly 之后，就挂载为 只读 了。如果你在容器内 /haha 目录新建文件，会显示如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 8090:80 --name testVip --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div><div class="line">27863a3a8f70fa4bddb9c97fabfee2db7f35d5615d4b90ad0be13717dc23d092</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker exec -it 27863a3a8f70fa4bddb9c97fabfee2db7f35d5615d4b90ad0be13717dc23d092 /bin/sh</div><div class="line">sh-4.2# </div><div class="line">sh-4.2# cd /</div><div class="line">sh-4.2# ls</div><div class="line">anaconda-post.log  bindata  dev  etchaha  home  lib  lib64lost+found  media  mntopt  proc  root  run  run.sh  sbin  srv  sys  tmp  usrvar</div><div class="line">sh-4.2# cd haha</div><div class="line">sh-4.2# ls</div><div class="line">myfirstregistry  registry.tar</div><div class="line">// 可以看到报错了</div><div class="line">sh-4.2# touch a.txt</div><div class="line">touch: cannot touch &apos;a.txt&apos;: Read-only file system</div><div class="line">sh-4.2#</div></pre></td></tr></table></figure></li><li><p>查看数据卷的具体信息 <code>$ docker inspect testVip</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&quot;Mounts&quot;: [</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;bind&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/Users/renyimin/Desktop/testVip&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/haha&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;&quot;,</div><div class="line">        &quot;RW&quot;: false,</div><div class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</div><div class="line">    &#125;</div><div class="line">],</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="数据卷挂载的问题"><a href="#数据卷挂载的问题" class="headerlink" title="数据卷挂载的问题"></a>数据卷挂载的问题</h2><p>上面提到的数据卷, 对很多容器都非常有用, 比如 </p><ul><li>mysql容器中存储数据文件的 <code>/var/lib/mysql</code> 目录你就需要挂载数据卷;</li><li>mysql, php-fpm, nginx等容器中, 关于服务配置的目录你也需要挂载到数据卷, 这些配置你可能需要进行改动;</li></ul><p>但是挂载数据卷有个问题, 一旦挂载之后, 容器中的目录就是空的, 原本服务的配置文件就被清空了, 也就导致有些容器在挂载数据卷之后, 无法正常启动;</p><h2 id="docker-cp-命令"><a href="#docker-cp-命令" class="headerlink" title="docker cp 命令"></a>docker cp 命令</h2><ol><li><p>可以将本地目录/文件拷贝到容器, 也可以将容器中的目录/文件拷贝到本地; 格式: </p><ul><li><code>docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</code></li><li><code>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</code></li></ul></li><li><p>所以为了避免挂载导致容器无法正常启动, 挂载的可以这样来:</p><ul><li>先确定你需要挂载的容器中目录的位置(比如: nginx容器中的配置文件在<code>/etc/nginx/conf.d/default.conf</code> )</li><li>使用 <code>docker cp</code> 命令, 将需要映射的目录从容器复制到本地; (比如:  <code>docker cp nginx_test:/etc/nginx/ ./conf/</code>)</li><li>然后再将本地default.conf文件挂载到nginx容器的/etc/nginx/conf.d/default.conf</li></ul></li></ol><p>参考: <a href="https://yeasy.gitbooks.io/docker_practice/content/data_management/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/data_management/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;容器中管理数据主要有两种方式：&lt;code&gt;数据卷(Volumes)&lt;/code&gt; 和 &lt;code&gt;挂载主机目录(Bind mounts)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据卷-Volumes&quot;&gt;&lt;a href=&quot;#数据卷-Volumes&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/categories/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/tags/Docker%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>08.容器--基本操作</title>
    <link href="http://blog.renyimin.com/2017/10/17/docker/2017-10-17-08-docker/"/>
    <id>http://blog.renyimin.com/2017/10/17/docker/2017-10-17-08-docker/</id>
    <published>2017-10-17T04:01:08.000Z</published>
    <updated>2018-03-05T03:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>1.镜像(Image)和容器(Container)的关系, 就像是面向对象程序设计中的 类 和 实例 的关系一样, 镜像是静态的定义, 容器是镜像运行时的实体。容器可以被 <code>创建</code>、<code>启动</code>、<code>停止</code>、<code>删除</code>、<code>暂停</code>等。</p><p>2.容器的实质是<strong>进程</strong>，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。</p><ul><li>因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。</li><li>容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会把容器和虚拟机搞混。</li></ul><p>3.前面讲过镜像使用的是<strong>分层存储</strong>，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。<br><code>容器存储层</code>的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，<strong>任何保存于容器存储层的信息都会随容器的删除而丢失</strong>。</p><p>4.按照 Docker 最佳实践的要求, 容器不应该向其存储层内写入任何数据，<strong>容器存储层要保持无状态化</strong></p><ul><li>所有的文件写入操作，都应该使用<code>数据卷(Volume)</code>、或者<code>绑定宿主目录</code>，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</li><li>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</li></ul><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a><strong>容器操作</strong></h2><p>启动容器有两种方式：<strong>一种是基于镜像新建一个容器并启动</strong>, <strong>另外一个是将在终止状态(stopped)的容器启动</strong></p><h3 id="创建并启动"><a href="#创建并启动" class="headerlink" title="创建并启动"></a>创建并启动</h3><p>1.因为 Docker 的容器<strong>实在太轻量级了</strong>, 很多时候用户都是<strong>随时删除和新创建容器</strong>。 </p><p>2.新建并启动一个容器, 所需要的命令主要为 <code>docker run</code>, 例如: <code>$ docker run -d -p 5000:5000 --name myFirstRegistry registry</code>, 是根据名为registry的镜像创建并运行一个名为myFirstRegistry容器;</p><p>3.当利用 <code>docker run</code> 来创建容器时, Docker 在后台运行的标准操作包括:</p><ul><li>检查本地是否存在指定的镜像, 不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统, 并在只读的镜像层外面挂载一层可读写层 </li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 </li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p>4.<strong>容器被启动后, 设置的挂载目录, 端口映射都会随着此容器, 容器stop后, 再次start, 这些设置都还在;</strong></p><h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker start [containerID or NAME]</code> 命令, 直接将一个已经终止的容器启动运行。 </p><h3 id="守护态运行容器"><a href="#守护态运行容器" class="headerlink" title="守护态运行容器"></a>守护态运行容器</h3><p>其实更多时候, 我们需要让容器在后台运行, 而不是直接运行容器并展示出结果, 此时只用在运行时加上 <code>-d 参数</code>即可; (在容器的第一种启动方式中已经介绍过了)</p><h3 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h3><p>可以通过 <code>docker ps</code> 命令来查看正在运行的容器信息</p><p>可以通过 <code>docker ps -a</code> 命令来查看 正在运行的和终止的 容器信息</p><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>可以使用 <code>docker stop [containerID or NAME]</code> 来终止一个运行中的容器</p><h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><p>可以使用 <code>docker restart [containerID or NAME]</code> 来重启一个运行中的容器</p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>1.可以使用 <code>docker rm 容器ID/容器NAME</code> 来删除一个<strong>处于终止状态</strong>的容器。 </p><p>2.如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>可参考<a href="https://yeasy.gitbooks.io/docker_practice/content/container/attach_exec.html" target="_blank" rel="external">书中介绍</a></p><p>本人通常使用 <code>docker exec -it [containerID or NAME] /bin/sh</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;容器&quot;&gt;&lt;a href=&quot;#容器&quot; class=&quot;headerlink&quot; title=&quot;容器&quot;&gt;&lt;/a&gt;容器&lt;/h2&gt;&lt;p&gt;1.镜像(Image)和容器(Container)的关系, 就像是面向对象程序设计中的 类 和 实例 的关系一样, 镜像是静态的定义, 容器
      
    
    </summary>
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/categories/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/tags/Docker%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>07.Docker Registry 仓库</title>
    <link href="http://blog.renyimin.com/2017/10/17/docker/2017-10-17-07-docker/"/>
    <id>http://blog.renyimin.com/2017/10/17/docker/2017-10-17-07-docker/</id>
    <published>2017-10-17T03:30:08.000Z</published>
    <updated>2018-03-05T03:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公开-Docker-Registry"><a href="#公开-Docker-Registry" class="headerlink" title="公开 Docker Registry"></a>公开 Docker Registry</h2><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务</p><ul><li>一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</li><li>最常使用的Registry公开服务是官方的 <code>Docker Hub</code>, 这也是默认的 Registry，并拥有大量的高质量的官方镜像。</li></ul><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务(Registry Mirror)，这些镜像服务被称为<strong>加速器</strong>。</p><p>但是, 有时候使用 Docker Hub 或其他公共仓库可能不方便(比如, 有时候我们的服务器无法访问互联网 或者 你不希望将自己的镜像放到公网当中)，则可以创建一个 <code>本地仓库供</code> 私人使用。</p><h2 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h2><p>1.除了使用公开服务外, 用户还可以在本地搭建私有Docker Registry, <a href="https://docs.docker.com/registry/" target="_blank" rel="external"><code>docker-registry</code></a>是官方提供的工具, 可以用于构建私有的镜像仓库。</p><p>2.安装运行 <code>docker-registry</code></p><ul><li><p>你可以通过获取官方<code>registry</code>镜像来在本地运行一个自己的私有镜像仓库 (如 <code>$ docker run -d -p 5000:5000 --restart=always --name registry registry</code>, 将使用官方的registry镜像来启动一个私有仓库)</p></li><li><p>默认情况下, 仓库中的镜像会被创建在容器的 <code>/var/lib/registry</code> 目录下, 你可以通过 <code>-v</code> 参数来将镜像文件存放到本地的指定路径中。</p></li><li><p>另外, 可以将私有仓库的配置文件指定到本地的路径下 (如 ~/Desktop/registry-config/ 下 )</p></li></ul><p>3.我们大可不必这么麻烦, 只是简单运行一个私有仓库服务 <code>$ docker run -d -p 5000:5000 --restart=always --name registry registry</code></p><h3 id="查看私有仓库中镜像"><a href="#查看私有仓库中镜像" class="headerlink" title="查看私有仓库中镜像"></a>查看私有仓库中镜像</h3><p>1.用 <code>curl</code> 查看仓库中的镜像, 可以看到你的私有仓库暂时还是空的</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl 127.0.0.1:5000/v2/_catalog</div><div class="line">&#123;&quot;repositories&quot;:[]&#125;</div><div class="line">$</div></pre></td></tr></table></figure></code></pre><p>2.还可以在浏览器中直接查看私有仓库中的镜像(并且内网其他机器也可以通过内网地址来访问你所搭建的私有仓库的镜像):<br><img src="/img/docker/private_registry_01.png" width="200/"><br><img src="/img/docker/private_registry_02.png" width="200/"></p><h3 id="上传镜像到私有仓库中"><a href="#上传镜像到私有仓库中" class="headerlink" title="上传镜像到私有仓库中"></a>上传镜像到私有仓库中</h3><p>1.之前我们已经通过获取官方 <code>registry镜像</code> 来创建好了自己的私有仓库, 接下来就可以使用 <code>docker tag</code> 来标记一个镜像, 然后推送它到仓库。</p><p>2.先查看一下本地已有的镜像 <code>docker image ls</code> :</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div></pre></td></tr></table></figure></code></pre><p>3.使用 <code>docker tag</code> 将 <code>registry:lates</code> 这个镜像标记为一个新的本地镜像 <code>127.0.0.1:5000/registry:latest</code> ; </p><ul><li><p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker tag registry:latest 127.0.0.1:5000/registry:latest</div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div></pre></td></tr></table></figure></li><li><p>这样, 假设你的小组成员需要尝试在本地搭建自己的私有仓库的话，就不用去公共镜像仓库去下载了, 只用在内网就可以方便地下载registry镜像</p></li></ul><p>4.使用 docker push 上传标记的镜像</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker push 127.0.0.1:5000/registry:latest</div><div class="line">The push refers to a repository [127.0.0.1:5000/registry]</div><div class="line">9113493eaae1: Pushed </div><div class="line">621c2399d41a: Pushed </div><div class="line">59e80739ed3f: Pushed </div><div class="line">febf19f93653: Pushed </div><div class="line">e53f74215d12: Pushed </div><div class="line">latest: digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c size: 1364</div></pre></td></tr></table></figure></code></pre><p>5.然后查看仓库中的镜像，可以看到镜像已经被成功上传了</p><ul><li><p>curl 查看</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl 127.0.0.1:5000/v2/_catalog</div><div class="line">&#123;&quot;repositories&quot;:[&quot;registry&quot;]&#125;</div></pre></td></tr></table></figure></li><li><p>浏览器查看<br><img src="/img/docker/private_registry_03.png" width="200/"><br><img src="/img/docker/private_registry_04.png" width="200/"></p></li></ul><h3 id="上传私有仓库问题"><a href="#上传私有仓库问题" class="headerlink" title="上传私有仓库问题"></a>上传私有仓库问题</h3><p>1.如果上传的时候, 打包的镜像使用的是本机的内网地址, 最后在上传的时候, 你会发现<strong>如下报错信息</strong>:</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker push 192.168.1.3:5000/registry:latest</div><div class="line">The push refers to a repository [192.168.1.3:5000/registry]</div><div class="line">Get https://192.168.1.3:5000/v2/: http: server gave HTTP response to HTTPS client</div><div class="line">renyimindembp:vipvip renyimin$</div></pre></td></tr></table></figure></code></pre><p>2.此时, 你需要将内网地址配置到本机docker的 <code>insecure registries</code> 中, 如下:<br><img src="/img/docker/insecure_registries_01.png" width="300"></p><p>3.之后, 无论本机还是在同一内网中的其他机器也都可以推送镜像到仓库中了(之前打包好的两个镜像, 都可以成功推送到私有仓库中):</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ docker push 192.168.1.3:5000/registry</div><div class="line">The push refers to a repository [192.168.1.3:5000/registry]</div><div class="line">9113493eaae1: Pushed </div><div class="line">621c2399d41a: Pushed </div><div class="line">59e80739ed3f: Pushed </div><div class="line">febf19f93653: Pushed </div><div class="line">e53f74215d12: Pushed </div><div class="line">latest: digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c size: 1364</div><div class="line">   </div><div class="line">$ docker push 127.0.0.1:5000/registry</div><div class="line">The push refers to a repository [127.0.0.1:5000/registry]</div><div class="line">9113493eaae1: Layer already exists </div><div class="line">621c2399d41a: Layer already exists </div><div class="line">59e80739ed3f: Layer already exists </div><div class="line">febf19f93653: Layer already exists </div><div class="line">e53f74215d12: Layer already exists </div><div class="line">latest: digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c size: 1364</div></pre></td></tr></table></figure></code></pre><h3 id="从私有仓库中下载镜像"><a href="#从私有仓库中下载镜像" class="headerlink" title="从私有仓库中下载镜像"></a>从私有仓库中下载镜像</h3><p>1.先删除已有镜像</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">192.168.1.3:5000/registry                             latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line"></div><div class="line">$ docker image rm 127.0.0.1:5000/registry:latest 192.168.1.3:5000/registry:latest</div><div class="line">Untagged: 127.0.0.1:5000/registry:latest</div><div class="line">Untagged: 127.0.0.1:5000/registry@sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line">Untagged: 192.168.1.3:5000/registry:latest</div><div class="line">Untagged: 192.168.1.3:5000/registry@sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line"></div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">renyimindembp:vipvip renyimin$</div></pre></td></tr></table></figure></code></pre><p>2.再尝试从私有仓库中下载这个镜像 (两个地址都可以下载, 也是因为之前配置了 <code>Insecure registries</code>, 这里最后才可以使用内网地址来下载)</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">$ docker pull 127.0.0.1:5000/registry:latest</div><div class="line">latest: Pulling from registry</div><div class="line">Digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line">Status: Downloaded newer image for 127.0.0.1:5000/registry:latest</div><div class="line"></div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line"></div><div class="line">$ docker pull 192.168.1.3:5000/registry:latest</div><div class="line">latest: Pulling from registry</div><div class="line">Digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line">Status: Downloaded newer image for 192.168.1.3:5000/registry:latest</div><div class="line"></div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">192.168.1.3:5000/registry                             latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div></pre></td></tr></table></figure></code></pre><h2 id="几个简单问题"><a href="#几个简单问题" class="headerlink" title="几个简单问题"></a>几个简单问题</h2><p>1.<a href="https://docs.docker.com/registry/spec/api/#deleting-an-image" target="_blank" rel="external">删除<code>仓库</code>镜像</a><br>    自己的docker仓库中存放的镜像, 时间长了难免存在一些废弃的镜像在里面, 如果不删除就造成空间的浪费。<br>2.容器启动之后, 如果忘记挂载某个目录, 能否再进行挂载?<br>其实没有必要, 直接停止删除, 重开一个即可！</p><p><del>~~未完待续</del>~~    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;公开-Docker-Registry&quot;&gt;&lt;a href=&quot;#公开-Docker-Registry&quot; class=&quot;headerlink&quot; title=&quot;公开 Docker Registry&quot;&gt;&lt;/a&gt;公开 Docker Registry&lt;/h2&gt;&lt;p&gt;Docker
      
    
    </summary>
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/categories/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/tags/Docker%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>06.其他方法定制 -- (镜像/容器 的 导入导出)</title>
    <link href="http://blog.renyimin.com/2017/10/14/docker/2017-10-14-06-docker/"/>
    <id>http://blog.renyimin.com/2017/10/14/docker/2017-10-14-06-docker/</id>
    <published>2017-10-14T12:15:28.000Z</published>
    <updated>2018-03-05T03:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="镜像-save-load"><a href="#镜像-save-load" class="headerlink" title="镜像 (save/load)"></a>镜像 (save/load)</h2><p>1.<code>docker save nginx:v1 &gt; alpine-latest.tar.gz</code>：将指定<strong>镜像</strong>导出为 <code>镜像存储文件</code>;</p><p>2.再使用 <code>docker load -i alpine-latest.tar.gz</code> 命令将 <code>镜像存储文件</code> 导入到本地镜像库;</p><h2 id="容器-export-import"><a href="#容器-export-import" class="headerlink" title="容器(export/import)"></a>容器(export/import)</h2><p>1.<code>docker export container_id &gt; my_container.tar</code>：将一个<strong>容器</strong>导出为 <code>容器快照文件</code>;<br>2.再使用 <code>docker import my_container.tar imageName:tag</code> 命令将 <code>容器快照文件</code> 导入为一个新的镜像到本地镜像库;<br>3.测试, 将nginx_v1容器导出, 并在本地重新生成nginx:v3镜像, 然后运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 运行中的nginx_v1容器</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</div><div class="line">d5d17a25cc35        nginx:v1            &quot;nginx -g &apos;daemon ...&quot;   2 hours ago         Up 11 minutes       0.0.0.0:8089-&gt;80/tcp     nginx_v1</div><div class="line">0e7070854958        registry            &quot;/entrypoint.sh /e...&quot;   26 hours ago        Up About an hour    0.0.0.0:5000-&gt;5000/tcp   registry</div><div class="line">//导出容器为 容器快照文件</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker export nginx_v1 &gt; nginx_v1.tar</div><div class="line">//将 nginx_v1的容器快照文件, 重新导入为一个新的本地镜像 nginx:v3</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker import nginx_v1.tar nginx:v3</div><div class="line">sha256:985fba7fd176d79685322d184bc79b81ca4365619bc0a773672e5c87cfc701cd</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker images</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">nginx                                                 v3                  985fba7fd176        10 seconds ago      107MB</div><div class="line">nginx                                                 v1                  8b748aee8b23        2 hours ago         109MB</div><div class="line">nginx                                                 latest              e548f1a579cf        8 days ago          109MB</div><div class="line">// 运行新镜像, 发现报错</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker run -d --name nginx_v3 nginx:v3</div><div class="line">docker: Error response from daemon: No command specified.</div><div class="line">See &apos;docker run --help&apos;.</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$</div></pre></td></tr></table></figure></p><p>4.解决方案, 通过<code>docker import 导入容器快照文件</code>生成的镜像, 在初次创建并启动(run)时, 需要提供快照文件所对应的容器的<code>COMMAND</code>字段, 可以通过<code>docker ps</code>查看, 如果命令太长, 则需要使用 <code>docker inspect 容器名</code> 查看 <code>cmd</code> 字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker run -d --name nginx_v3 nginx:v3 nginx &apos;-g&apos; &apos;daemon off;&apos;</div><div class="line">0fb30bafe266248bbb58e31d9dcab7479f4a59494fcc636f7f7dfd2df498066d</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</div><div class="line">0fb30bafe266        nginx:v3            &quot;nginx -g &apos;daemon ...&quot;   2 seconds ago       Up 1 second                                  nginx_v3</div><div class="line">d5d17a25cc35        nginx:v1            &quot;nginx -g &apos;daemon ...&quot;   2 hours ago         Up 19 minutes       0.0.0.0:8089-&gt;80/tcp     nginx_v1</div><div class="line">0e7070854958        registry            &quot;/entrypoint.sh /e...&quot;   26 hours ago        Up About an hour    0.0.0.0:5000-&gt;5000/tcp   registry</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$</div></pre></td></tr></table></figure></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1.可以使用 <code>docker load</code> 来导入<code>镜像存储文件</code>到本地镜像库。<br>2.也可以使用 <code>docker import</code> 来导入一个<code>容器快照文件</code>到本地镜像库。<br>3.这两者的区别在于:</p><ul><li><code>镜像存储文件</code>将保存完整记录, 体积也要大</li><li>而<code>容器快照文件</code>将丢弃所有的历史记录和元数据信息(即仅保存容器当时的快照状态)</li><li>此外，从容器快照文件导入时可以<strong>重新指定标签</strong>等元数据信息</li></ul><ol><li>另外, 使用<code>docker save</code>保存的<code>镜像存储文件</code>, 不能使用 <code>docker import</code> 来导入成镜像, 这样导入的镜像无法运行起来</li></ol><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>在初次为公司内部准备镜像时, 可以启动一个基础镜像, 然后在容器中做好软件安装, 完成各种配置工作之后:</p><ul><li>可以手动commit成功新的 <code>镜像:tag</code>, 然后将镜像push到私有仓库供给大家下载使用;</li><li>可以简单将容器直接export成容器快照文件, 然后import为新的 <code>镜像:tag</code>, 然后push到私有仓库供给大家下载使用; </li><li>或者通过Dockerfile定制脚本及<code>docker build</code>来构建新的 <code>镜像:tag</code>, 然后push到私有仓库供给大家下载使用; </li></ul><p><strong>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡, 这里的消亡是指容器被删除, 而不是stop容器, stop容器后, 容器中发生的改变不会被忽略, 除非容器被删除掉</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>如果只是做集成环境的镜像, 比如lnmp全部在一个镜像中运行, 自己觉着可以:</p><ul><li>使用一个基础镜像运行起容器, 然后自己安装各种环境, 最后可以直接 <code>export</code> 导出容器为快照文件, 然后分发给组员;(如果需要再次修改环境信息, 直接修改好, 然后导出新的容器快找文件给组员即可)</li><li>可以在容器中构建好各环境之后, <code>commit</code> 手动构建好镜像, 然后将镜像 <code>push</code> 到仓库中, 供组员使用 (变动频次较高的时候不方便, 因为这样会导致容器变得越来越臃肿); </li><li>可以使用<code>Dockerfile</code>对镜像进行定制(如果镜像比较基础, 可能编写的比较多), 然后将镜像 <code>push</code> 到仓库中, 供组员使用</li></ul></li><li><p>如果做多容器部署, 需要使用到docker-compose….<br>未完待续~~</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://yeasy.gitbooks.io/docker_practice/content/image/other.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/image/other.html</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/content/container/import_export.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/container/import_export.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;镜像-save-load&quot;&gt;&lt;a href=&quot;#镜像-save-load&quot; class=&quot;headerlink&quot; title=&quot;镜像 (save/load)&quot;&gt;&lt;/a&gt;镜像 (save/load)&lt;/h2&gt;&lt;p&gt;1.&lt;code&gt;docker save nginx:
      
    
    </summary>
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/categories/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/tags/Docker%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>05.镜像 - Dockerfile常见指令详解</title>
    <link href="http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/"/>
    <id>http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/</id>
    <published>2017-10-13T02:25:07.000Z</published>
    <updated>2018-03-05T03:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h2><ol><li>所谓定制镜像, <strong>是以一个镜像为基础, 在其上进行定制</strong>。<code>FROM</code> 就用来指定基础镜像, 因此一个 Dockerfile 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</li><li>格式: <code>FROM 镜像名[:标签]</code></li></ol><h2 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h2><ol><li>指定镜像的作者和联系方式信息(执行<code>docker inspect image</code> 输出中有相应的字段记录该信息)</li><li>格式:<code>MAINTAINER author &quot;e-mail&quot;</code> 指定作者名和E-mail</li></ol><h2 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h2><ol><li><p><code>RUN</code>指令是用来执行<code>命令行命令</code>的。(由于命令行的强大能力, RUN指令在定制镜像时是最常用的指令之一)</p></li><li><p>其格式有两种：</p><ul><li>shell 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样, 如: <code>RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code></li><li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code> , 这更像是函数调用中的格式, 如: <code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code>。</li></ul></li><li><p>虽然RUN就像Shell脚本一样可以执行命但是我们也不能像Shell脚本一样把每个命令对应一个RUN, 因为每一个RUN的行为, 就像手工建立commit镜像的过程一样:新建立一层，在其上执行这些命令, 执行结束后, commit 这一层的修改, 构成新的镜像。</p><ul><li><p>像下面的这种写法，创建了 7 层镜像, 这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。<strong>结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。这是很多初学 Docker 的人常犯的一个错误</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN apt-get update</div><div class="line">RUN apt-get install -y gcc libc6-dev make</div><div class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</div><div class="line">RUN mkdir -p /usr/src/redis</div><div class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</div><div class="line">RUN make -C /usr/src/redis</div><div class="line">RUN make -C /usr/src/redis install</div></pre></td></tr></table></figure></li><li><p>上面的 Dockerfile 正确的写法应该是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN buildDeps=&apos;gcc libc6-dev make&apos; \</div><div class="line">    &amp;&amp; apt-get update \</div><div class="line">    &amp;&amp; apt-get install -y $buildDeps \</div><div class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \</div><div class="line">    &amp;&amp; mkdir -p /usr/src/redis \</div><div class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</div><div class="line">    &amp;&amp; make -C /usr/src/redis \</div><div class="line">    &amp;&amp; make -C /usr/src/redis install \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</div><div class="line">    &amp;&amp; rm redis.tar.gz \</div><div class="line">    &amp;&amp; rm -r /usr/src/redis \</div><div class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</div></pre></td></tr></table></figure><blockquote><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层, 这只是一层的事情。<br><strong>在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建</strong>。<br>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，因为<strong>镜像是多层存储，每一层的东西并不会在下一层被删除</strong>，会一直跟随着镜像。<br>因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p></blockquote></li></ul></li></ol><h2 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h2><ol><li>这个指令很简单,就是设置环境变量而已,无论是后面的其它指令,如RUN,还是运行时的应用,都可以直接使用这里定义的环境变量。</li><li><code>ENV</code>设置环境变量格式有两种:<ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul></li><li>下面例子中演示了”设置环境变量”, “如何换行”, 以及对”含有空格的值用双引号括起来”的办法, 这和Shell下的行为是一致的 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ENV VERSION=1.0 DEBUG=on \</div><div class="line">NAME=&quot;Happy Feet&quot;</div></pre></td></tr></table></figure></li></ol><h2 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h2><ol><li><p>构建参数和ENV的效果一样, 都是设置环境变量。所不同的是,<code>ARG</code>所设置的环境变量,在将来容器运行时是<strong>不会存在</strong>这些环境变量的;但是不要因此就使用ARG保存密码之类的信息, 因为 <code>docker history</code> 还是可以看到所有值的;</p></li><li><p>Dockerfile 中的ARG指令是定义参数名称及其默认值, 该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖</p></li><li><p>格式: <code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p></li></ol><h2 id="WORKDIR-切换工作目录"><a href="#WORKDIR-切换工作目录" class="headerlink" title="WORKDIR 切换工作目录"></a>WORKDIR 切换工作目录</h2><ol><li>使用 <code>WORKDIR</code> 指令可以来指定接下来之后各层的工作目录, <strong>如该目录不存在, WORKDIR 会帮你建立目录</strong>。</li><li>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code></li><li><p>之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写, 这种错误的理解还可能会导致出现下面这样的错误:</p><ul><li><p>如果将下面这个 Dockerfile 进行构建镜像运行后, 会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 hello </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RUN cd /app #第一层 `RUN cd /app` 的执行仅仅是当前进程的工作目录变更, 一个内存上的变化而已, 其结果不会造成任何文件变更。</div><div class="line">RUN echo &quot;hello&quot; &gt; world.txt #而到第二层的时候, 启动的是一个全新的容器, 跟第一层的容器更完全没关系, 自然不可能继承前一层构建过程中的内存变化</div></pre></td></tr></table></figure></li><li><p>原因其实很简单, 在Shell中, 上面连续的两行是同一个进程执行环境, 而在 Dockerfile 中, 这两行 RUN 命令的执行环境根本不同, 是两个完全不同的容器。(这就是对 Dokerfile 构建分层存储的概念不了解所导致的错误)</p></li><li>之前说过每一个RUN都是启动一个容器、执行命令、然后提交存储层文件变更</li></ul></li></ol><h2 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h2><ol><li><p><code>USER</code> 指令和 WORKDIR 相似, <strong>都是改变环境状态并影响以后的层</strong> (<code>WORKDIR</code>是改变工作目录, 而<code>USER</code>则是改变之后层执行RUN,CMD以及ENTRYPOINT这类命令时的身份)。</p></li><li><p>格式: <code>USER &lt;用户名&gt;</code></p></li><li><p>注意: USER只是帮助你切换到指定用户而已, <strong>这个用户必须是事先建立好的, 否则无法切换</strong>。</p></li><li><p>如果以root执行的脚本, 在执行期间希望改变身份, 比如希望以某个已经建立好的用户来运行某个服务进程, 不要使用 <code>su</code> 或者 <code>sudo</code>, 这些都需要比较麻烦的配置, 而且在TTY缺失的环境下经常出错。</p><ul><li>建议使用 <code>gosu</code> ，可以从其<a href="https://github.com/tianon/gosu" target="_blank" rel="external">项目网站</a>看到进一步的信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</div><div class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</div><div class="line"># 下载 gosu</div><div class="line">RUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot; \</div><div class="line">    &amp;&amp; chmod +x /usr/local/bin/gosu \</div><div class="line">    &amp;&amp; gosu nobody true</div><div class="line"># 设置 CMD，并以另外的用户执行</div><div class="line">CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ]</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h2><ol><li><p>容器运行时应该尽量保持<code>容器存储层</code>不发生写操作, 对于像数据库这类需要保存动态数据的应用, 其数据库文件应该保存于<code>卷(volume)</code>中。</p></li><li><p>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在Dockerfile中, 可以事先指定某些目录挂载为匿名卷, 这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p></li><li><p>格式为: <code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></p></li><li><p><code>VOLUME /data</code> : 容器中的 “/data” 目录就会在运行时自动挂载为匿名卷, 任何向 /data 中写入的信息都不会记录进容器存储层。<br>当然，运行时可以覆盖这个挂载设置。比如:<code>docker run -d -v mydata:/data xxxx</code> 在这行命令中, 就使用了 mydata 这个命名卷挂载到了 /data 这个位置, 替代了 Dockerfile 中定义的匿名卷的挂载配置。</p></li></ol><h2 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h2><ol><li><p><code>EXPOSE</code>指令是声明运行时为容器提供的映射端口, 这<strong>只是一个声明, 并不会自动在宿主进行端口映射</strong>。</p></li><li><p>格式为:<code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p></li><li><p>在 Dockerfile 中写入这样的声明有两个好处</p><ul><li>一个是帮助镜像使用者理解这个镜像服务的守护端口, 以方便配置映射;</li><li>另一个用处则是在运行时使用随机端口映射时, 也就是 <code>docker run -P</code> 时, 会自动随机映射 <code>EXPOSE</code> 的端口。</li></ul></li><li><p>要将 <code>EXPOSE</code> 和 在运行时使用<code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来</p><ul><li><code>-p</code> 是映射宿主端口和容器端口, 换句话说, 就是将容器的对应端口服务公开给外界访问;</li><li>而 <code>EXPOSE</code> 仅仅是声明, 容器打算使用什么端口而已, <strong>并不会自动在宿主进行端口映射</strong>;</li></ul></li></ol><h2 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h2><ol><li><p><code>CMD</code> 指令的格式和 RUN 相似，也是两种格式:</p><ul><li>shell 格式: <code>CMD &lt;命令&gt;</code></li><li>exec 格式: <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li></ul></li><li><p>但是如果指定了 <code>ENTRYPOINT</code> 指令，用 CMD 指定的就是具体的参数 <code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。</p></li><li><p>Docker不是虚拟机, 容器就是进程, 那么在启动容器的时候, CMD 指令就是用于指定默认的容器主进程的启动命令的。</p><ul><li><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令<br>比如ubuntu镜像默认的CMD是<code>/bin/bash</code>, 如果我们直接 <code>docker run -it ubuntu</code> 的话, 会直接进入 bash ;<br>我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>, 这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了, 输出了系统版本信息。 </p></li><li><p>在指令格式上, 一般推荐使用 <code>exec</code> 格式, 这类格式在解析时会被解析为JSON数组，因此一定要使用双引号, 而不要使用单引号。</p></li><li><p>如果使用 shell 格式的话，实际的命令会被包装为<code>sh -c</code>的参数的形式进行执行。比如 <code>CMD echo $HOME</code> 在实际执行中，会将其变更为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code><br>这就是为什么我们可以使用环境变量的原因, 因为这些环境变量会被shell进行解析处理。</p></li></ul></li><li><p>Docker不是虚拟机, 容器中的应用都应该以前台执行, 而不是像虚拟机、物理机里面那样, 用 <code>upstart/systemd</code> 去启动后台服务, <strong>容器内没有后台服务的概念</strong>。</p><ul><li><p>一些初学者将 CMD 写为 <code>CMD service nginx start</code>, 然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。<br>这就是因为没有搞明白前台、后台的概念, 没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p></li><li><p>对于容器而言, 其启动程序就是容器应用进程, 容器就是为了主进程而存在的，主进程退出, 容器就失去了存在的意义, 从而退出, 其它辅助进程不是它需要关心的东西。<br>而使用 <code>service nginx start</code> 命令，则是希望upstart来以后台守护进程形式启动nginx服务, <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>, 因此主进程实际上是sh, 那么当 <code>service nginx start</code> 命令结束后, sh也就结束了, sh 作为主进程退出了, 自然就会令容器退出。</p></li><li><p>正确的做法是直接执行nginx可执行文件，并且要求以前台形式运行。比如: <code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code></p></li></ul></li></ol><h2 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h2><ol><li><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样, 都是在指定容器启动程序及参数。 </p><ul><li>ENTRYPOINT 在运行时也可以被替代, 不过比CMD要略显繁琐, 需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定;</li><li>当指定了 ENTRYPOINT 后, <strong>CMD 的含义就发生了改变</strong>, 不再是直接的运行其命令, 而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令, 换句话说实际执行时, 将变为:<code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code></li></ul></li><li><p><code>ENTRYPOINT</code> 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。</p></li><li><p>有了<code>CMD</code>后, 为什么还要有<code>ENTRYPOINT</code>? 这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处? <a href="https://yeasy.gitbooks.io/docker_practice/content/image/dockerfile/entrypoint.html" target="_blank" rel="external">参考书中</a></p><ul><li>场景一：让镜像变成像命令一样使用</li><li>场景二：应用运行前的准备工作</li></ul></li></ol><h2 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h2><ol><li><p>和RUN指令一样, 也有两种格式:</p><ul><li><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li></ul></li><li><p>COPY 指令将从 <code>构建上下文目录</code> 中 <code>&lt;源路径&gt;</code>目录/ 复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如:<code>COPY package.json /usr/src/app/</code></p><ul><li>&lt;源路径&gt; 可以是多个, 甚至可以是通配符</li><li>&lt;目标路径&gt; 可以是容器内的绝对路径, 也可以是相对于工作目录的相对路径(工作目录可以用 <code>WORKDIR</code> 指令来指定)。</li><li>目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</li></ul></li><li><p>此外, 还需要注意一点, 使用 COPY 指令, 源文件的各种元数据都会保留。比如读、写、执 行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p></li></ol><h2 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h2><ol><li><p><code>ADD</code> 指令 和 <code>COPY</code> 的格式和性质基本一致, 但是在 COPY 基础上增加了一些功能:</p><ul><li><p>比如 &lt;源路径&gt; 可以是一个 URL , 这种情况下, Docker 引擎会试图去下载这个链接的文件放 到 &lt;目标路径&gt; 去, 下载后的文件权限自动设置为 600 , 如果这并不是想要的权限, 则需要增加额外的一层 RUN 进行权限调整<br>另外, 如果下载的是个压缩包, 需要解压缩, 也一样, 还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令, 然后使用 wget 或 者 curl 工具下载, 处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并 不实用，而且不推荐使用。</p></li><li><p>如果 &lt;源路径&gt; 为一个tar压缩文件的话,压缩格式为 gzip , bzip2 以及 xz 的情况下, ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去<br>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。</p></li></ul></li><li><p>在 Docker 官方的最佳实践文档中要求，尽可能的使用 COPY ，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。<strong>最适合使用ADD 的场合，就是所提及的需要自动解压缩的场合</strong>。</p></li><li><p>另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD 。</p></li></ol><h2 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h2><h2 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h2><ol><li><p>格式：<code>ONBUILD &lt;其它指令&gt;</code></p></li><li><p><code>ONBUILD</code> 是一个特殊的指令, 它后面跟的是其它指令, 比如 RUN, COPY 等, 而这些指令, 在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像, 去构建下一级镜像的时候才会被执行。</p></li><li><p>Dockerfile 中的其它指令都是为了定制当前镜像而准备的, 唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p></li><li><p>假设我们要制作Node.js所写的应用的镜像, 我们都知道Node.js使用npm进行包管理, 所有依赖、配置、启动信息等会放到package.json文件里。</p><ul><li>在拿到程序代码后, 需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。</li><li><p>然后就可以通过 <code>npm start</code> 来启动应用, 因此, 一般来说会这样写 Dockerfile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FROM node:slim</div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">COPY ./package.json /app</div><div class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ]</div><div class="line">COPY . /app/</div><div class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</div></pre></td></tr></table></figure></li><li><p>把这个 Dockerfile 放到 Node.js 项目的根目录, 构建好镜像后, 就可以直接拿来启动容器运行。</p></li></ul></li><li><p>但是如果我们还有第二个 Node.js 项目也差不多呢？好吧, 那就再把这个Dockerfile复制到第二个项目里。那如果有第三个项目呢?再复制么?文件的副本越多,版本控制就越困难,让我们继续看这样的场景维护的问题。</p><ul><li>如果第一个Node.js项目在开发过程中, 发现这个Dockerfile里存在问题,比如敲错字了、或者需要安装额外的包, 然后开发人员修复了这个 Dockerfile, 再次构建, 问题解决。</li><li>第一个项目没问题了,但是第二个项目呢?虽然最初 Dockerfile 是复制、粘贴自第一个项目的,但是并不会因为第一个项目修复了 Dockerfile, 而第二个项目的 Dockerfile 就会被自动修复。</li></ul></li><li><p>那么我们可不可以做一个基础镜像, 然后各个项目使用这个基础镜像呢? 这样基础镜像更新, 各个项目不用同步Dockerfile的变化, 重新构建后就继承了基础镜像的更新?</p><ul><li><p>其实是可以的, 那么上面的这个 Dockerfile 就会变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FROM node:slim</div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</div></pre></td></tr></table></figure></li><li><p>这里我们把项目相关的构建指令拿出来, 放到子项目里去。假设这个基础镜像的名字为my-node的话, 各个项目内的自己的 Dockerfile 就变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FROM my-node</div><div class="line">COPY ./package.json /app</div><div class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ]</div><div class="line">COPY . /app/</div></pre></td></tr></table></figure><p>基础镜像变化后, 各个项目都用这个 Dockerfile 重新构建镜像, 会继承基础镜像的更新。</p></li></ul></li><li><p>此时问题只解决了一半, 如果这个Dockerfile里面有些东西需要调整, 比如 npm install 都需要加一些参数, 那怎么办?</p><ul><li>这一行 RUN 是不可能放入基础镜像的, 因为涉及到了当前项目的 ./package.json, 难道又要一个个修改么?</li><li>所以说, 这样制作基础镜像, 只解决了原来的 Dockerfile 的前4条指令的变化问题, 而后面三条指令的变化则完全没办法处理。</li></ul></li><li><p><code>ONBUILD</code> 可以解决这个问题, 用ONBUILD重新写一下基础镜像的 Dockerfile:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FROM node:slim</div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">ONBUILD COPY ./package.json /app</div><div class="line">ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]</div><div class="line">ONBUILD COPY . /app/</div><div class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</div></pre></td></tr></table></figure></li></ol><p>这次我们回到原始的 Dockerfile，但是这次将项目相关的指令加上 ONBUILD，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 Dockerfile 就变成了简单地：<code>FROM my-node</code>, 只有这么一行。<br>当在各个项目目录中, 用这个只有一行的 Dockerfile 构建镜像时, 之前基础镜像的那三行 ONBUILD 就会开始执行, 成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>, 生成应用镜像。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FROM-指定基础镜像&quot;&gt;&lt;a href=&quot;#FROM-指定基础镜像&quot; class=&quot;headerlink&quot; title=&quot;FROM 指定基础镜像&quot;&gt;&lt;/a&gt;FROM 指定基础镜像&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;所谓定制镜像, &lt;strong&gt;是以一个镜像为基础, 在
      
    
    </summary>
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/categories/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/tags/Docker%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>04.定制镜像 - Dockerfile脚本</title>
    <link href="http://blog.renyimin.com/2017/10/12/docker/2017-10-12-04-docker/"/>
    <id>http://blog.renyimin.com/2017/10/12/docker/2017-10-12-04-docker/</id>
    <published>2017-10-12T15:05:07.000Z</published>
    <updated>2018-03-05T03:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Dockerfile定制镜像"><a href="#使用Dockerfile定制镜像" class="headerlink" title="使用Dockerfile定制镜像"></a>使用Dockerfile定制镜像</h2><ol><li><p>通过之前<code>docker commit</code>的学习了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 <code>Dockerfile</code>。</p></li><li><p>Dockerfile是一个文本文件，其内包含了一条条的指令, <strong>每一条指令构建一层</strong>，因此每一条指令的内容，就是描述该层应当如何构建。</p></li><li><p>在使用Dockerfile脚本定制镜像时, 有很多指令可以使用;</p></li></ol><h2 id="Dockerfile指令详解"><a href="#Dockerfile指令详解" class="headerlink" title="Dockerfile指令详解"></a>Dockerfile指令详解</h2><p>参考下一篇博文<a href="/2017/10/13/2017-10-13-05-docker/">05.Dockerfile指令详解</a></p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>1.还以之前定制 nginx 镜像为例，下面使用Dockerfile来定制</p><ul><li><p>在一个空白目录中，建立一个文本文件，并命名为 Dockerfile, 其内容为如下:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FROM nginx</div><div class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</div></pre></td></tr></table></figure></li><li><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code></p></li></ul><p>2.在 Dockerfile 文件所在目录执行</p><ul><li><p>从命令的输出结果如下</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:image_build renyimin$ docker build -t nginx:v5 .</div><div class="line">Sending build context to Docker daemon  2.048kB</div><div class="line">Step 1/2 : FROM nginx</div><div class="line"> ---&gt; e548f1a579cf</div><div class="line">Step 2/2 : RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</div><div class="line"> ---&gt; Running in 5dc1025063e7</div><div class="line"> ---&gt; 65c15ffa7c7c</div><div class="line">Removing intermediate container 5dc1025063e7</div><div class="line">Successfully built 65c15ffa7c7c</div><div class="line">Successfully tagged nginx:v5</div><div class="line">renyimindeMacBook-Pro:image_build renyimin$</div></pre></td></tr></table></figure></li><li><p>可以看到镜像的构建过程: 在Step2中, RUN指令重新启动了一个容器 <code>5dc1025063e7</code>，执行了所要求的命令，并最后提交了新的层 <code>65c15ffa7c7c</code>, 随后删除了所用到的容器<code>5dc1025063e7</code></p></li></ul><p>3.这里我们使用了 <code>docker build</code> 命令进行镜像构建, 其格式为: <code>docker build [选项] &lt;上下文路径/URL/-&gt;</code></p><ul><li>在这里我们指定了最终镜像的名称 <code>-t nginx:v5</code>，构建成功后, <code>docker images</code> 就会看到这个新镜像  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:image_build renyimin$ docker images</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">nginx                                                 v5                  65c15ffa7c7c        5 minutes ago       109MB</div></pre></td></tr></table></figure></li></ul><p>4.启动这个新镜像: <code>docker run -d -p 8098:80 --name nginx_v5 nginx:v5</code></p><ul><li><p>执行过程</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:image_build renyimin$ docker run -d -p 8098:80 --name nginx_v5 nginx:v5</div><div class="line">247dfedcf52c3cbfd652302a8f2226274661cea77200092b54044d37e0a2ae25</div><div class="line">renyimindeMacBook-Pro:image_build renyimin$ </div><div class="line">renyimindeMacBook-Pro:image_build renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</div><div class="line">247dfedcf52c        nginx:v5            &quot;nginx -g &apos;daemon ...&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8098-&gt;80/tcp     nginx_v5</div><div class="line">d762abfc1ab6        nginx:latest        &quot;nginx -g &apos;daemon ...&quot;   8 minutes ago       Up 8 minutes        0.0.0.0:8090-&gt;80/tcp     nginx_l</div><div class="line">0e7070854958        registry            &quot;/entrypoint.sh /e...&quot;   2 days ago          Up 39 hours         0.0.0.0:5000-&gt;5000/tcp   registry</div><div class="line">renyimindeMacBook-Pro:image_build renyimin$</div></pre></td></tr></table></figure></li><li><p>对比定制前后<br><img src="/img/docker/dockerfile_test_01.png" width="400/"></p></li></ul><h3 id="镜像构建上下文-Context"><a href="#镜像构建上下文-Context" class="headerlink" title="镜像构建上下文(Context)"></a>镜像构建上下文(Context)</h3><p>上面在构建镜像时, 如果注意, 会看到 <code>docker build</code> 命令最后有一个 <code>.</code>, 表示当前目录, 而 <code>Dockerfile</code> 就在当前目录, 因此不少初学者以为这个路径是在指定Dockerfile所在的路径, 但这么理解其实是不准确的。<br>这是在指定<code>上下文路径</code>, 那么什么是上下文呢?</p><ol><li><p>首先我们要理解 <code>docker build</code> 的工作原理</p><ul><li><p>Docker 在运行时分为<code>Docker引擎</code>(也就是服务端守护进程)和<code>客户端工具</code>;</p></li><li><p>Docker 的引擎提供了一组REST API, 被称为Docker Remote API, 而如docker命令这样的客户端工具, 则是通过这组 API 与 Docker 引擎交互, 从而完成各种功能, 因此, 虽然表面上我们好像是在本机执行各种docker功能, 但实际上, 一切都是使用的远程调用形式在服务端(Docker 引擎)完成。<br>也因为这种C/S设计, 让我们操作远程服务器的 Docker 引擎变得轻而易举。</p></li></ul></li><li><p>当我们进行镜像构建的时候, 并非所有定制都会通过RUN指令完成, <strong>经常会需要将一些主机本地文件复制进镜像</strong>, 比如通过<code>COPY</code>、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像, 其实并非在本地构建, 而是在服务端, 也就是Docker引擎中构建的。那么在这种客户端/服务端的架构中, 如何才能让服务端获得本地文件呢?</p></li><li><p>这就引入了上下文的概念, 当构建的时候, 用户会指定构建镜像上下文的路径, <code>docker build</code> 命令得知这个路径后, 会将路径下的所有内容打包, 然后上传给Docker引擎。这样 Docker 引擎收到这个上下文包后, 展开就会获得构建镜像所需的一切文件。</p></li><li><p>如果在 Dockerfile 中 <code>COPY ./package.json</code> 这么写:</p><ul><li>这并不是要复制你执行 <code>docker build</code> 命令时, 所在的目录下的 package.json, 也不是复制 Dockerfile 所在目录下的 package.json, 而是复制上下文(context)目录下的 package.json</li><li><strong>COPY 这类指令中的源文件的路径都是相对上下文路径的</strong></li></ul></li><li><p>理解构建上下文对于镜像构建是很重要的, 避免犯一些不应该的错误, 比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后, 于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建, 结果发现 <code>docker build</code> 执行后, 在发送一个几十GB的东西, 极为缓慢而且很容易构建失败(因为这种做法是在让 docker build 打包整个硬盘, 这显然是使用错误)。</p></li><li><p>一般来说, 应该将 <code>Dockerfile</code> 置于一个空目录下, 或者项目根目录下。</p><ul><li>如果该目录下没有所需文件, 那么应该把所需文件复制一份过来。</li><li>如果目录下有些东西确实不希望构建时传给 Docker 引擎, 那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>, 该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</li></ul></li><li><p>那么为什么会有人误以为 <code>.</code> 是指定 Dockerfile 所在目录呢?</p><ul><li>这是因为在默认情况下, 如果不额外指定 Dockerfile 的话, 会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。</li><li>这只是默认行为, 实际上Dockerfile的文件名并不要求必须为Dockerfile, 而且并不要求 必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为Dockerfile。</li></ul></li></ol><p>参考 : <a href="https://yeasy.gitbooks.io/docker_practice/content/image/commit.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/image/commit.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用Dockerfile定制镜像&quot;&gt;&lt;a href=&quot;#使用Dockerfile定制镜像&quot; class=&quot;headerlink&quot; title=&quot;使用Dockerfile定制镜像&quot;&gt;&lt;/a&gt;使用Dockerfile定制镜像&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通过之前&lt;
      
    
    </summary>
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/categories/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/tags/Docker%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>03.定制镜像 - docker commit手动定制</title>
    <link href="http://blog.renyimin.com/2017/10/12/docker/2017-10-12-03-docker/"/>
    <id>http://blog.renyimin.com/2017/10/12/docker/2017-10-12-03-docker/</id>
    <published>2017-10-12T13:50:07.000Z</published>
    <updated>2018-03-05T03:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>镜像是容器的基础, 每次执行 <code>docker run</code> 的时候都会指定哪个镜像作为容器运行的基础。<br>在之前的例子中, 我们所使用的都是来自于 Docker Hub 的镜像, 直接使用这些镜像是可以满足一定的需求, 而当这些镜像无法直接满足需求时, 我们就需要<strong>定制这些镜像</strong>。</p><h2 id="docker-commit-手动定制镜像"><a href="#docker-commit-手动定制镜像" class="headerlink" title="docker commit 手动定制镜像"></a><code>docker commit</code> 手动定制镜像</h2><p>1.当运行一个容器的后(如果不使用<code>数据卷</code>的话), 你所做的任何文件修改都会被记录于<code>容器存储层</code>里</p><ul><li>如果改动了容器的存储层, 我们可以通过 <code>docker diff</code> 命令看到具体的改动</li><li>但是如果改动的是数据卷挂载到容器对应目录下的内容, <code>docker diff</code> 看不到具体的改动</li></ul><p>2.注意: 容器存储层的生存周期和容器一样, 容器被删除后, 存储层中的内容也就会被删除掉, 而不会保留到镜像中。</p><p>3.Docker提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像</p><ul><li>换句话说，就是在原有镜像的基础上，<strong>再叠加上容器的存储层，并构成新的镜像</strong></li><li>以后我们运行这个新镜像的时候, 就会拥有原有容器最后的文件变化</li></ul><p>4.docker commit 的语法格式为: <code>docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</code>, 如下:</p><ul><li>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker commit --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; --message &quot;修改了默认网页&quot; webserver nginx:v2</div></pre></td></tr></table></figure></li></ul><h3 id="手动定制镜像-挂载数据卷问题"><a href="#手动定制镜像-挂载数据卷问题" class="headerlink" title="手动定制镜像~~挂载数据卷问题"></a>手动定制镜像~~挂载数据卷问题</h3><p>1.之前已经配置了docker中国加速镜像, 现在通过<code>git pull nginx</code>获取一个<a href="https://hub.docker.com/_/nginx/" target="_blank" rel="external">nginx基础镜像</a>;</p><p>2.直接运行这个nginx基础镜像为一个容器(由于该镜像非常基础,甚至没有像vi的工具,因此在启动时可以将nginx的项目根目录<code>/usr/share/nginx/html</code>映射出来, 以便于测试)</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 8088:80 --mount type=bind,source=/Users/renyimin/Desktop/nginx_test,target=/usr/share/nginx/html --name nginx_test nginx</div><div class="line">1c39a78311e579482a2334347f80ba479555097d869a1254a27c9ac581c13eed</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</div><div class="line">1c39a78311e5        nginx               &quot;nginx -g &apos;daemon ...&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8088-&gt;80/tcp   nginx_test</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></code></pre><p>3.通过 <code>localhost:8088</code> 会看到nginx的欢迎界面<br><img src="/img/docker/nginx_test_01.png" width="300/"></p><p>4.现在，假设需要更改欢迎界面文字(本应该使用 <code>docker exec -it nginx_test /bin/sh</code> 命令进入容器修改其内容, 但后来发现该进行非常基础,很多基础工具如vi都没有, 所以最终采用挂载主机目录方式启动, 然后在主机新增一个index.html文件)<br><img src="/img/docker/nginx_test_02.png" width="300/"></p><p>5.之后直接刷新浏览器的话，会发现内容被改变了<br><img src="/img/docker/nginx_test_03.png" width="300/"></p><p>6.现在修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动, 你会发现自己的改动并没有体现出来, 其实这主要是因为<strong>你将目录挂载出来了</strong>, 如果不是挂载出来,而是直接在容器中修改的话, 则会体现出来</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker diff nginx_test</div><div class="line">C /run</div><div class="line">A /run/nginx.pid</div><div class="line">C /var/cache/nginx</div><div class="line">A /var/cache/nginx/client_temp</div><div class="line">A /var/cache/nginx/fastcgi_temp</div><div class="line">A /var/cache/nginx/proxy_temp</div><div class="line">A /var/cache/nginx/scgi_temp</div><div class="line">A /var/cache/nginx/uwsgi_temp</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></code></pre><p>7.当运行一个容器的时候(如果不使用卷的话)，我们做的任何文件修改都会被记录于<strong>容器存储层里</strong>, 可以使用 <code>docker diff</code> 命令看到容器存储层中的变动, 但是如果使用了数据卷, 则挂载目录中的改动无法体现出来;</p><h3 id="手动定制镜像-实验"><a href="#手动定制镜像-实验" class="headerlink" title="手动定制镜像~~实验"></a>手动定制镜像~~实验</h3><p>1.既然数据卷中的内容无法使用<code>docker diff</code>来查看差异, 我们可以将index.html文件复制到容器的<code>/home</code>下, 然后使用 <code>docker diff</code> 命令就可以看到容器存储层中的改动</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker diff nginx_test</div><div class="line">C /home</div><div class="line">A /home/index.html</div><div class="line">C /run</div><div class="line">A /run/nginx.pid</div><div class="line">C /var/cache/nginx</div><div class="line">A /var/cache/nginx/client_temp</div><div class="line">A /var/cache/nginx/fastcgi_temp</div><div class="line">A /var/cache/nginx/proxy_temp</div><div class="line">A /var/cache/nginx/scgi_temp</div><div class="line">A /var/cache/nginx/uwsgi_temp</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></code></pre><p>2.<code>docker commit --author &#39;renyimin&#39; --message &quot;在/home下添加了一个index.html文件&quot; nginx_test nginx:v1</code></p><p>3.<code>docker images</code> 可以看到这个新定制的镜像</p><p>4.我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 nginx:v1 的历史记录，我们会发现新增了我们刚刚提交的这一层</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker history nginx:v1</div><div class="line">IMAGE               CREATED              CREATED BY                                      SIZE                COMMENT</div><div class="line">fe3e3a4c47b8        About a minute ago   nginx -g daemon off;                            1.4MB               在/home下添加了一个index.html文件</div><div class="line">e548f1a579cf        8 days ago           /bin/sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daem...   0B                  </div><div class="line">&lt;missing&gt;           8 days ago           /bin/sh -c #(nop)  STOPSIGNAL [SIGTERM]         0B                  </div><div class="line">&lt;missing&gt;           8 days ago           /bin/sh -c #(nop)  EXPOSE 80/tcp                0B                  </div><div class="line">.....</div><div class="line">.....</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$</div></pre></td></tr></table></figure></code></pre><p>5.新的镜像定制好后，就可以来运行这个镜像</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 8089:80 --name nginx_v1 nginx:v1</div><div class="line">d5d17a25cc35837c64f446a6623afa0a23b6c543593276979ebb7c5ced1e7e1d</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</div><div class="line">d5d17a25cc35        nginx:v1            &quot;nginx -g &apos;daemon ...&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8089-&gt;80/tcp   nginx_v1</div><div class="line">785d252f5c94        nginx               &quot;nginx -g &apos;daemon ...&quot;   4 minutes ago       Up 3 minutes        0.0.0.0:8088-&gt;80/tcp   nginx_test</div><div class="line">// 会发现使用新的镜像启动容器后, 容器中的/home目录下包含我们提交的index.html个文件, 当然, localhost:8089和localhost:8088不同, 8089访问的还是默认欢迎页</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker exec -it nginx_v1 /bin/sh</div><div class="line"># cd /home</div><div class="line"># ls</div><div class="line">index.html</div><div class="line">#</div></pre></td></tr></table></figure></code></pre><blockquote><p>至此，我们第一次完成了定制镜像，使用的是 <code>docker commit</code> 命令，<strong>手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉</strong>。</p></blockquote><h2 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用 docker commit"></a>慎用 docker commit</h2><p>使用 docker commit 命令虽然可以比较直观的帮助理解镜像分层存储的概念, <strong>但是实际环境中并不会这样使用</strong>。<br>1.首先，如果仔细观察之前的 <code>docker diff nginx_test</code> 的结果，你会发现除了真正想要的 /home/index.html 文件外，由于命令的执行，还有很多文件被改动或添加了。<br>这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。</p><p>2.此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是<strong>黑箱操作</strong>，生成的镜像也被称为<strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 docker diff 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p><p>3.而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 docker commit 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p><p>4.可以结合<a href="/2017/10/17/2017-10-17-07-docker/#构建镜像">07.镜像/容器 – 导入导出</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;镜像是容器的基础, 每次执行 &lt;code&gt;docker run&lt;/code&gt; 的时候都会指定哪个镜像作为容器运行的基础。&lt;br&gt;在之前的例子
      
    
    </summary>
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/categories/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/tags/Docker%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>02.镜像 - 基础</title>
    <link href="http://blog.renyimin.com/2017/10/12/docker/2017-10-12-02-docker/"/>
    <id>http://blog.renyimin.com/2017/10/12/docker/2017-10-12-02-docker/</id>
    <published>2017-10-12T11:40:07.000Z</published>
    <updated>2018-03-05T03:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>镜像(Image)和容器(Container)的关系，就像是面向对象程序设计中的类和实例一样, 镜像是静态的定义, 容器是镜像运行时的实体。<br>所以 Docker 运行容器前首先需要本地存在对应的镜像, 如果本地不存在该镜像, Docker 会从镜像仓库下载该镜像。</p><h2 id="镜像的获取"><a href="#镜像的获取" class="headerlink" title="镜像的获取"></a>镜像的获取</h2><p><a href="https://hub.docker.com/explore/" target="_blank" rel="external">Docker Hub</a>上有大量的高质量的镜像可以用, 如何获取这些镜像呢?</p><p>1.从Docker镜像仓库获取镜像的命令是 <code>docker pull</code>, 其命令格式为：<code>docker pull [选项] [Docker Registry地址[:端口号]/]仓库名[:标签]</code></p><ul><li>docker pull命令的具体选项可以通过 <code>docker pull --help</code> 命令看到</li><li>镜像名称的格式:<br><strong>Docker镜像仓库地址</strong>: 地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code> (默认地址是 Docker Hub 仓库地址)<br><strong>仓库名</strong>: 仓库名是<strong>两段式名称</strong>, 即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code> (对于 Docker Hub, 如果不给出用户名, 则默认为 library, 也就是官方镜像。)</li><li>比如 <code>$ docker pull ubuntu:16.04</code>: 由于没有给出Docker镜像仓库地址, 因此将会从Docker Hub获取镜像, 而镜像名称是 <code>ubuntu:16.04</code>(没有用户名), 因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>16.04</code> 的镜像;</li></ul><p>2.另外, 如果从 Docker Hub 下载镜像非常缓慢，可以 配置镜像加速器。</p><h2 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h2><p>1.国内从 Docker Hub 拉取镜像有时会遇到困难, 此时可以配置镜像加速器, Docker 官方和国内很多云服务商都提供了<strong>国内加速器服务</strong>, 例如:</p><ul><li><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror" target="_blank" rel="external">Docker 官方提供的中国 registry mirror</a></li><li><a href="https://cr.console.aliyun.com/?accounttraceid=d520cfad-1577-4905-91cd-09aa8b4964cd#/imageSearch" target="_blank" rel="external">阿里云加速器</a></li><li><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="external">DaoCloud 加速器</a></li></ul><p>2.此处以 Docker 官方加速器为例进行介绍(由于本人使用macOS系统,下面只列出macOS上如何配置镜像加速器, 其他系统请<a href="https://yeasy.gitbooks.io/docker_practice/content/install/mirror.html" target="_blank" rel="external">参考</a>)</p><ul><li>在任务栏点击<code>Docker for mac</code> 应用图标 -&gt; <code>Perferences</code>… -&gt; <code>Daemon</code> -&gt; <code>Registry mirrors</code></li><li>在列表中填写加速器地址即可, 修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像地址了</li></ul><p>3.如果在添加加速器地址后出现 <code>registry-mirrors no certs for egistry.docker-....</code><br><img src="/img/docker/jiasuqi-error-macOS.png" width="300">  </p><p>4.网上查找资料后, <a href="https://yq.aliyun.com/articles/29941" target="_blank" rel="external">有人说是证书问题</a>, 尝试修改https为http后正常<br><img src="/img/docker/jiasuqi-macOS.png" width="300"> </p><p>5.检查加速器是否生效</p><ul><li>配置加速器之后,如果拉取镜像仍然十分缓慢,请手动检查加速器配置是否生效,在命令行执行 <code>docker info</code></li><li>由于我配置的是docker hub提供的中国镜像站点, 所以如果从结果中看到了如下内容，说明配置成功(你看到的可能和我的不一样)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Registry Mirrors:</div><div class="line">http://registry.docker-cn.com/</div><div class="line">//如果添加了多个加速站点, 此处也会有多个</div></pre></td></tr></table></figure></li></ul><h2 id="镜像相关基础操作"><a href="#镜像相关基础操作" class="headerlink" title="镜像相关基础操作"></a>镜像相关基础操作</h2><h3 id="列出已存在镜像"><a href="#列出已存在镜像" class="headerlink" title="列出已存在镜像"></a>列出已存在镜像</h3><p>1.<code>docker images</code>：列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>;</p><p>2.虽然 <code>镜像ID</code> 是镜像的唯一标识, 但是一个镜像可以打包出多个不同标签的镜像 (所以有些镜像的ID一样, 但是tag会不一样);</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker images</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        7 weeks ago         33.3MB</div><div class="line">registry                                              latest              d1fd7d86a825        7 weeks ago         33.3MB</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></code></pre><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>如果要删除本地的镜像, 可以使用 <code>$ docker image rm [选项] &lt;镜像名1&gt; [&lt;镜像名2&gt; ...]</code> 命令; (因为镜像ID可能会一样, 所以删除镜像用的是镜像名)</p><h3 id="镜像更名"><a href="#镜像更名" class="headerlink" title="镜像更名"></a>镜像更名</h3><p>镜像更改名称也很简单, 直接 <code>$ docker tag 镜像名 新镜像名:标签</code></p><p>在 Docker 1.13+ 版本中推荐使用 <code>docker image</code> 来管理镜像。 (比如 <code>docker image ls</code> 会列出所有镜像);</p><h2 id="理解分层存储"><a href="#理解分层存储" class="headerlink" title="理解分层存储"></a>理解分层存储</h2><p>1.严格来说，镜像并非是像一个ISO那样的打包文件, 镜像只是一个虚拟的概念, 其实际体现并非由一个文件组成, 而是由一组文件系统组成, 或者说, 由<code>多层文件系统</code>联合组成。</p><p>2.镜像是多层存储，每一层是在前一层的基础上进行的修改; 而容器同样也是多层存储，是在以镜像为基础层，<strong>在其基础上加一层作为容器运行时的存储层</strong>。</p><p>3.镜像构建时, 会一层层构建, 前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p><p>4.<strong>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡, 这里的消亡是指容器被删除, 而不是stop容器, stop容器后, 容器中发生的改变不会被忽略, 除非容器被删除掉</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;镜像(Image)和容器(Container)的关系，就像是面向对象程序设计中的类和实例一样, 镜像是静态的定义, 容器是镜像运行时的实体。
      
    
    </summary>
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/categories/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker学习" scheme="http://blog.renyimin.com/tags/Docker%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
