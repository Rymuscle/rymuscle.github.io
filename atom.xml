<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2019-09-03T03:52:53.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>String常用操作 (StringUtils)</title>
    <link href="http://blog.renyimin.com/2019/05/27/SpringFramework5/2019-05-27-15/"/>
    <id>http://blog.renyimin.com/2019/05/27/SpringFramework5/2019-05-27-15/</id>
    <published>2019-05-27T11:20:11.000Z</published>
    <updated>2019-09-03T03:52:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>StringUtils类中的方法其实真的还是很多, 可能平时我们用的比较多的还是一些普通的方法, 其实类似文件路径, 文件名等相关操作, 以前还会专门引入common-io的FilenameUtils等额外的工具类, 原来在StringUtils中都有, 而且根据其设计的这些方法, 我们也能大概的猜出一些方法在Spring中哪些地方可能有用；最后, 其中有些方法, 还是非常常见的面试题, 比如替换字符串, 查询子串个数等, 有兴趣也可以看看Spring的具体实现。</p></blockquote><h1 id="org-apache-commons-lang3-StringUtils"><a href="#org-apache-commons-lang3-StringUtils" class="headerlink" title="org.apache.commons.lang3.StringUtils"></a>org.apache.commons.lang3.StringUtils</h1><p>参考<br><a href="https://www.jianshu.com/p/da7d986cf19e" target="_blank" rel="noopener">https://www.jianshu.com/p/da7d986cf19e</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;StringUtils类中的方法其实真的还是很多, 可能平时我们用的比较多的还是一些普通的方法, 其实类似文件路径, 文件名等相关操作, 以前还会专门引入common-io的FilenameUtils等额外的工具类, 原来在StringUtils中
      
    
    </summary>
    
      <category term="Spring" scheme="http://blog.renyimin.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://blog.renyimin.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.renyimin.com/2019/05/27/SpringFramework5/2019-05-27-17/"/>
    <id>http://blog.renyimin.com/2019/05/27/SpringFramework5/2019-05-27-17/</id>
    <published>2019-05-27T10:23:39.000Z</published>
    <updated>2019-09-03T06:22:12.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Spring" scheme="http://blog.renyimin.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://blog.renyimin.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.renyimin.com/2019/05/27/SpringFramework5/2019-05-27-16/"/>
    <id>http://blog.renyimin.com/2019/05/27/SpringFramework5/2019-05-27-16/</id>
    <published>2019-05-27T10:23:39.000Z</published>
    <updated>2019-09-03T06:18:25.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Spring" scheme="http://blog.renyimin.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://blog.renyimin.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 事务控制</title>
    <link href="http://blog.renyimin.com/2019/05/25/SpringFramework5/2019-05-25-11/"/>
    <id>http://blog.renyimin.com/2019/05/25/SpringFramework5/2019-05-25-11/</id>
    <published>2019-05-25T07:20:11.000Z</published>
    <updated>2019-08-12T09:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注解AOP的问题"><a href="#注解AOP的问题" class="headerlink" title="注解AOP的问题"></a>注解AOP的问题</h1><p>AOP 的 后置通知 和  最终通知 在注解配置时, 其执行顺序是有问题, 会导致事务出现问题, 先释放了事务, 然后再提交或者回滚, 是有问题的; 可以自己写环绕通知来解决</p><h1 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h1><ol><li>Spring为我们提供了一组事务控制的API (即在 <code>spring-tx</code> 包中)</li><li></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注解AOP的问题&quot;&gt;&lt;a href=&quot;#注解AOP的问题&quot; class=&quot;headerlink&quot; title=&quot;注解AOP的问题&quot;&gt;&lt;/a&gt;注解AOP的问题&lt;/h1&gt;&lt;p&gt;AOP 的 后置通知 和  最终通知 在注解配置时, 其执行顺序是有问题, 会导致事务出现问
      
    
    </summary>
    
      <category term="Spring" scheme="http://blog.renyimin.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://blog.renyimin.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JdbcTemplate</title>
    <link href="http://blog.renyimin.com/2019/05/19/SpringFramework5/2019-05-19-10/"/>
    <id>http://blog.renyimin.com/2019/05/19/SpringFramework5/2019-05-19-10/</id>
    <published>2019-05-19T12:19:36.000Z</published>
    <updated>2019-08-12T09:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li><p><code>JdbcTemplate</code> 是 spring 框架中提供的一个对象, 是对原始 Jdbc API 对象的简单封装</p></li><li><p>Spring 框架为我们提供了很多 操作模板类</p><ul><li>操作关系型数据的: <code>JdbcTemplate</code>、<code>HibernateTemplate</code> </li><li>操作 nosql 数据库的: <code>RedisTemplate</code></li><li>操作消息队列的: <code>JmsTemplate</code></li></ul></li><li><p>在导包的时候，除了要导入这个 <code>spring-jdbc-5.1.4.RELEASE.jar</code> 包外, 还需要导入一个 <code>spring-tx-5.1.4.RELEASE.jar</code> (它是和事务相关的)<br><img src="/img/SpringFramework/jdbc-template-xml.png"></p></li><li><p>下图仅供参考<br><img src="/img/SpringFramework/spring-jdbc-00.png"></p></li></ol><h1 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h1><ol><li><p>JdbcTemplate 最基本的使用<br><img src="/img/SpringFramework/spring-jdbctemplate-01.png"></p></li><li><p>基于 ioc, JdbcTemplate 最基本的使用<br><img src="/img/SpringFramework/spring-jdbctemplate-02.png"></p></li><li><p>JdbcTemplate 基本的 crud 操作<br><img src="/img/SpringFramework/spring-jdbctemplate-03.png"></p></li><li><p>JdbcTemplate 在Dao中的使用<br><img src="/img/SpringFramework/spring-jdbctemplate-04.png"></p></li><li><p>JdbcDaoSupport 使用, 解决各个 Dao 中的重复代码<br><img src="/img/SpringFramework/spring-jdbctemplate-05.png"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;JdbcTemplate&lt;/code&gt; 是 spring 框架中提供的一个对象, 是对原始 Jdbc API 
      
    
    </summary>
    
      <category term="Spring" scheme="http://blog.renyimin.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://blog.renyimin.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>AOP (Aspect Oriented Programming) 面向切面编程</title>
    <link href="http://blog.renyimin.com/2019/05/18/SpringFramework5/2019-05-18-09/"/>
    <id>http://blog.renyimin.com/2019/05/18/SpringFramework5/2019-05-18-09/</id>
    <published>2019-05-18T09:57:29.000Z</published>
    <updated>2019-08-30T03:49:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li><p>AOP 是使用 动态代理的方式 实现的 (在程序运行期间, 不用去修改源码即可对原有方法进行增强, 满足 <code>开闭原则</code> )</p></li><li><p>Spring中的AOP 是通过配置来实现上一篇中的动态代理功能的 (Spring同样提供了 基于xml配置 和 基于注解 两种方式来实现AOP)</p></li><li><p>Spring的AOP可以手动选择动态代理是 基于接口的 还是 基于子类的</p></li><li><p>术语</p></li></ol><ul><li><code>Join point</code> 连接点: 在Spring中指的就是 委托类中的所有方法</li><li><code>Point cut</code> 切入点: 代理类在 invoke 中还可以决定对 委托类 的哪些方法进行增强, 被增强的连接点就是切入点 (切入点一定是连接点, 连接点不一定是切入点) </li><li><code>Advice</code> 通知: 即拦截到连接点时要做的事情, 通知的类型分为 <code>前置通知</code>, <code>后置通知</code>, <code>异常通知</code> (在 catch 块中的), <code>最终通知</code> (在 finally 块中的), <code>环绕通知</code></li><li>…</li></ul><h1 id="基于XML的AOP"><a href="#基于XML的AOP" class="headerlink" title="基于XML的AOP"></a>基于XML的AOP</h1><p>项目准备<br><img src="/img/SpringFramework/bean-xml-aop-01.png"></p><p>Demo<br><img src="/img/SpringFramework/aop-xml-01.png"></p><p>切入点表达式写法<br><img src="/img/SpringFramework/aop-xml-pointcut-expression.png"><br>（后置通知和异常通知只会执行一个, 最终通知无论有没有异常都会执行）</p><h1 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h1><p>除了通过配置的方式来实现对方法的增强, 还可以使用Spring为我们提供的 <strong>环绕通知</strong><br><img src="/img/SpringFramework/aop-round.png"></p><h1 id="基于注解的AOP"><a href="#基于注解的AOP" class="headerlink" title="基于注解的AOP"></a>基于注解的AOP</h1><p>下面仍包含了少量的xml配置<br><img src="/img/SpringFramework/aop-annotation.png"></p><h2 id="基于注解AOP的问题"><a href="#基于注解AOP的问题" class="headerlink" title="基于注解AOP的问题"></a>基于注解AOP的问题</h2><p>发现通过注解的方式使用AOP时, 后置通知的顺序有问题, 跑到了最终通知的后面</p><h2 id="基于注解环绕通知"><a href="#基于注解环绕通知" class="headerlink" title="基于注解环绕通知"></a>基于注解环绕通知</h2><p>此时可以通过 环绕通知 解决上述问题<br><img src="/img/SpringFramework/aop-annotation-round.png"></p><h2 id="纯注解AOP"><a href="#纯注解AOP" class="headerlink" title="纯注解AOP"></a>纯注解AOP</h2><p><img src="/img/SpringFramework/aop-annotation-000.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;AOP 是使用 动态代理的方式 实现的 (在程序运行期间, 不用去修改源码即可对原有方法进行增强, 满足 &lt;code&gt;开闭
      
    
    </summary>
    
      <category term="Spring" scheme="http://blog.renyimin.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://blog.renyimin.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>静态代理, 动态代理</title>
    <link href="http://blog.renyimin.com/2019/05/18/SpringFramework5/2019-05-18-08/"/>
    <id>http://blog.renyimin.com/2019/05/18/SpringFramework5/2019-05-18-08/</id>
    <published>2019-05-18T09:36:13.000Z</published>
    <updated>2019-08-30T03:44:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理 Proxy"></a>代理 Proxy</h1><ol><li><p>Proxy代理模式 是一种 结构型 设计模式, 是一种常用的设计模式, 主要解决的问题是: 在直接访问对象时所带来的问题</p></li><li><p>其目的就是为某个对象提供一个代理, 以控制对该对象的访问, 代理类负责为委托类 预处理消息、过滤消息并转发消息、以及进行 被委托类执行后的 后续处理</p></li><li><p>为了保持行为的一致性, 代理类 和 委托类 通常会实现相同的接口, 所以在访问者看来两者没有丝毫的区别; 通过代理类这中间一层, 能有效控制对委托类对象的直接访问, 也可以很好地隐藏和保护委托类对象, 同时也为实施不同控制策略预留了空间, 从而在设计上获得了更大的灵活性</p></li><li><p>更通俗的说, 当两个类需要通信时, 引入第三方代理类, 将两个类的关系解耦, 让我们只了解代理类即可, 而且代理的出现还可以让我们完成与另一个类之间的关系的统一管理, 但是切记, <strong>代理类和委托类要实现相同的接口</strong>, 因为代理真正调用的还是委托类的方法</p></li><li><p>按照代理的创建时期, 代理类可以分为两种:</p><ul><li>静态: 由程序员创建代理类或特定工具自动生成源代码再对其编译, 在程序运行前代理类的.class文件就已经存在了</li><li>动态: 在程序运行时运用反射机制动态创建而成</li></ul></li><li><p>下面分别用静态代理与动态代理演示一个示例: 添加打印日志的功能, 即每个方法调用之前和调用之后写入日志</p></li></ol><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><p><img src="/img/javase/static-proxy.png"></p><h2 id="静态代理优点"><a href="#静态代理优点" class="headerlink" title="静态代理优点"></a>静态代理优点</h2><p>通过 代理 使 客户端 不需要知道实现类是什么, 怎么做的, 而客户端只需知道代理即可(解耦合), 对于如上的客户端代码, <code>newUserManagerImpl()</code> 可以应用 工厂 或 IOC 将它隐藏, 如上只是举个例子而已</p><h2 id="静态代理缺点"><a href="#静态代理缺点" class="headerlink" title="静态代理缺点"></a>静态代理缺点</h2><ul><li>代理类 和 委托类 实现了相同的接口, 代理类 和 委托类 也都会实现相同的方法, 这样就出现了大量的代码重复, 如果接口增加一个方法, 除了所有实现类需要实现这个方法外, 所有代理类也需要实现此方法, 增加了代码维护的复杂度</li><li>代理对象只服务于一种类型的对象, 如果要服务多类型的对象, 势必要为每一种对象都进行代理, 静态代理在程序规模稍大时就无法胜任了<br>如上的代码是只为UserManager类的访问提供了代理, 但是如果还要为其他类如Department类提供代理的话, 就需要我们再次添加代理Department的代理类</li></ul><p><strong>即静态代理类只能为特定的接口(Service)服务, 如想要为多个接口服务则需要建立很多个代理类</strong></p><h2 id="静态代理小结"><a href="#静态代理小结" class="headerlink" title="静态代理小结"></a>静态代理小结</h2><p>代理可以对实现类进行统一的管理, 如在调用具体实现类之前, 需要打印日志等信息, 这样我们只需要添加一个代理类, 在代理类中添加打印日志的功能, 然后调用实现类, 这样就避免了修改具体实现类, <strong>满足开闭原则</strong>;</p><p>但是如果想让不同类型的其他实现类都添加打印日志的功能的话, 就需要添加多个代理类, 并且代理类中各个方法都需要添加打印日志功能(如上的代理方法中删除, 修改, 以及查询都需要添加上打印日志的功能)</p><h1 id="动态代理-基于接口"><a href="#动态代理-基于接口" class="headerlink" title="动态代理 (基于接口)"></a>动态代理 (基于接口)</h1><p>根据如上的介绍, 你会发现每个代理类只能为一个接口服务, 这样程序开发中必然会产生许多的代理类, 所以我们需要的是 通过一个代理类完成全部的代理功能, 那么我们就需要用动态代理</p><p>在上面的示例中, 一个代理只能代理一种类型, 而且是在<strong>编译期</strong>就已经确定被代理的对象, 而动态代理是在<strong>运行时</strong> 通过反射机制实现动态代理, 并且能够代理各种类型的对象</p><p>在Java中要想实现 动态代理 机制, 需要 <code>java.lang.reflect.InvocationHandler</code>接口 和 <code>java.lang.reflect.Proxy</code>类 的支持</p><p><img src="/img/javase/dynamic-proxy.png"></p><p>可以看到, 我们可以通过 <code>LogHandler</code> 代理不同类型的对象, 如果我们把对外的接口都通过动态代理来实现, 那么所有的函数调用最终都会经过 <code>invoke</code>函数 的转发, 因此我们就可以在这里做一些自己想做的操作, 比如日志系统、事务、拦截器、权限控制等, <strong>这也就是AOP(面向切面编程)的基本原理</strong></p><p>小结: 动态代理与静态代理相比较, 最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（<code>InvocationHandler.invoke</code>）这样, 在接口方法数量比较多的时候, 我们可以进行灵活处理, 而不需要像静态代理那样每一个方法进行中转;<br>而且动态代理的应用使我们的类职责更加单一, 复用性更强</p><h1 id="动态代理-基于子类"><a href="#动态代理-基于子类" class="headerlink" title="动态代理(基于子类)"></a>动态代理(基于子类)</h1><p>基于接口的动态代理, 委托类必须实现接口 (上面已经演示过了), 下面看基于子类的动态代理</p><ol><li><p>提供者：第三方<code>cglib</code>库</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>涉及的类：<code>Enhancer</code></p><ul><li>使用 <code>Enhancer</code> 类中的 <code>create</code> 方法创建代理对象</li><li>创建代理对象的要求: 被代理类不能是最终类(不能被 <code>final</code> 修饰)</li></ul></li><li><p>Demo<br><img src="/img/javase/sub-dynamic-proxy.png"></p></li><li><p>Demo<br><img src="/img/javase/sub-dynamic-proxy-01.png"></p></li></ol><h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p><a href="https://blog.csdn.net/hejingyuan6/article/details/36203505" target="_blank" rel="noopener">https://blog.csdn.net/hejingyuan6/article/details/36203505</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代理-Proxy&quot;&gt;&lt;a href=&quot;#代理-Proxy&quot; class=&quot;headerlink&quot; title=&quot;代理 Proxy&quot;&gt;&lt;/a&gt;代理 Proxy&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Proxy代理模式 是一种 结构型 设计模式, 是一种常用的设计模式, 主
      
    
    </summary>
    
      <category term="Spring" scheme="http://blog.renyimin.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://blog.renyimin.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 整合 Junit</title>
    <link href="http://blog.renyimin.com/2019/05/14/SpringFramework5/2019-05-14-07/"/>
    <id>http://blog.renyimin.com/2019/05/14/SpringFramework5/2019-05-14-07/</id>
    <published>2019-05-14T08:47:31.000Z</published>
    <updated>2019-08-30T03:32:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Junit进行之前的测试"><a href="#使用Junit进行之前的测试" class="headerlink" title="使用Junit进行之前的测试"></a>使用Junit进行之前的测试</h1><p>如下, 直接加上对junit的依赖即可<br><img src="/img/SpringFramework/ioc-junit.png"></p><h1 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h1><ol><li><p>在测试类中, 每个测试方法都会有以下代码:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); </span><br><span class="line">ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);</span><br></pre></td></tr></table></figure></li><li><p>针对上述问题, 我们需要的是程序能<strong>自动帮我们创建容器</strong></p></li></ol><ul><li>而 junit 是无法实现的, 它甚至无法知晓我们是否使用了 spring 框架, 更不用说帮我们创建 spring 容器了</li><li>不过, junit 给我们暴露了一个注解, 可以让我们替换掉它的运行器, 这时, 我们需要依靠 spring 框架, 因为它提供了一个运行器, 可以读取配置文件(或注解)来创建容器, 我们只需要告诉它配置文件在哪就行了</li></ul><h1 id="Spring-整合-Junit"><a href="#Spring-整合-Junit" class="headerlink" title="Spring 整合 Junit"></a>Spring 整合 Junit</h1><p>1.使用 <code>@RunWith</code> 注解替换原有运行器</p><p>2.使用 <code>@ContextConfiguration</code> 注解 指定 spring 配置文件的位置<br><code>locations</code>属性: 用于指定xml配置文件的位置(如果是类路径下, 需要用 <code>classpath:</code> 表明)<br><code>classes</code>属性: 用于指定注解的类 (当不使用 xml 配置时, 需要用此属性指定注解类的位置)</p><p>3.使用 <code>@Autowired</code> 给测试类中的变量注入数据</p><p>demo<br><img src="/img/SpringFramework/Spring-Junit-01.png"></p><h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p><a href="https://blog.csdn.net/hejingyuan6/article/details/36203505" target="_blank" rel="noopener">https://blog.csdn.net/hejingyuan6/article/details/36203505</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用Junit进行之前的测试&quot;&gt;&lt;a href=&quot;#使用Junit进行之前的测试&quot; class=&quot;headerlink&quot; title=&quot;使用Junit进行之前的测试&quot;&gt;&lt;/a&gt;使用Junit进行之前的测试&lt;/h1&gt;&lt;p&gt;如下, 直接加上对junit的依赖即可&lt;br
      
    
    </summary>
    
      <category term="Spring" scheme="http://blog.renyimin.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://blog.renyimin.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>基于注解的IOC配置</title>
    <link href="http://blog.renyimin.com/2019/05/12/SpringFramework5/2019-05-12-05/"/>
    <id>http://blog.renyimin.com/2019/05/12/SpringFramework5/2019-05-12-05/</id>
    <published>2019-05-12T11:36:11.000Z</published>
    <updated>2019-08-30T02:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring2.0 开始引入基于注解的配置方式, 即 Bean的定义信息可以通过在 Bean的实现类上 标注注解来实现</p><p>注解配置和 xml 配置要实现的功能都是一样的, 都是要降低程序间的耦合, 只是配置的形式不一样, 关于实际的开发中到底使用 xml 还是注解, 每家公司有着不同的使用习惯 (基于注解的配置需要 aop jar 包)</p><p>创建 spring 的 xml 配置文件并开启对注解的支持 (基于注解整合时, 导入约束时需要多导入 context 名称空间下的约束)<br><img src="/img/SpringFramework/bean-xml-04.png"></p><p>下面开始介绍 Spring IOC 的常用注解</p><h1 id="用于创建Bean的注解"><a href="#用于创建Bean的注解" class="headerlink" title="用于创建Bean的注解"></a>用于创建Bean的注解</h1><p>作用和之前学的使用xml实现ioc时, 配置一个 <code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring.study.service.impl.AccountServiceImpl&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;</code> 是类似的</p><h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a><code>@Component</code></h2><p>该注解用于把当前类对象存入Spring容器中<br>属性 <code>value</code>: 指定 bean 的 id (如果不指定 value 属性, 默认 bean 的 id 是当前类的类名, 首字母小写)</p><p><strong>tips</strong>: 要知道, 只在类上加了 <code>@Component</code> 并不能完成 “将类对象存入Spring容器<br>因为我们目前仍然是通过 <code>new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</code> 来创建容器的, 因此 <code>bean.xml</code> 需要知道你在哪些地方使用了 <code>@Component</code><br>所以会用到新的xml标签 <code>&lt;context:component-scan base-package=&quot;要扫描的包&quot;&gt;&lt;/context:component-scan&gt;</code>, 用来指定将要扫描的注解的位置</p><p><img src="/img/SpringFramework/ioc-innotation-xml.png"></p><h2 id="另外几个注解"><a href="#另外几个注解" class="headerlink" title="另外几个注解"></a>另外几个注解</h2><p><code>@Controller</code>、 <code>@Service</code>、 <code>@Repository</code>, 他们三个注解都是针对 <code>@Component</code> 的衍生注解, 作用及属性都一样, 只不过是提供了更加明确的语义化</p><ul><li><code>@Controller</code>: 一般用于表现层的注解</li><li><code>@Service</code>: 一般用于业务层的注解</li><li><code>@Repository</code>: 一般用于持久层的注解</li></ul><p><img src="/img/SpringFramework/ioc-innotation-xml-01.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>相比 使用xml配置来创建bean, xml + annotation 的方式只用在xml中配置很少的内容, 然后对于需要被Spring容器管理的对象, 在其类上加上以上注解即可（<strong>但此时仍然需要在xml中进行配置, 为了说明你使用注解的地方</strong>） </p><h1 id="用于-注入依赖bean-的注解"><a href="#用于-注入依赖bean-的注解" class="headerlink" title="用于 注入依赖bean 的注解"></a>用于 注入依赖bean 的注解</h1><p>作用和之前学的使用xml实现 ioc 时, 在 <code>&lt;bean&gt;</code> 下通过 <code>&lt;property name=&quot;&quot; value=&quot;&quot;&gt;&lt;/property&gt;</code> 或 <code>&lt;property name=&quot;&quot; ref=&quot;&quot;&gt;&lt;/property&gt;</code> 是类似的</p><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a><code>@Autowired</code></h2><p>其作用是<strong>自动按照类型注入</strong>, 只要容器中有唯一的一个bean对象的类型 和 <code>@Autowired</code> 所修饰的要注入的变量的类型一致, 就可以注入成功; </p><p>该注解可以修饰 成员变量、方法 ……</p><p><img src="/img/SpringFramework/ioc-innotation-xml-Autowired.png"></p><p><img src="/img/SpringFramework/ioc-innotation-xml-Autowired-01.png"></p><p>如果容器中没有任何对象的类型与当前变量类型匹配, 则注入失败会报错</p><p>如果容器中有多个对象(的类型与当前变量类型匹配时, 会继续使用当前变量名称作为 bean的id进行匹配, 如果id都不匹配则报错)<br><img src="/img/SpringFramework/ioc-innotation-xml-Autowired-02.png"></p><p><img src="/img/SpringFramework/ioc-innotation-xml-Autowired-03.png"></p><p><strong>tip</strong>: 值得注意的是, 在 <code>AccountServiceImpl</code> 中注入 <code>AccountDaoImpl</code> 时, 并没有使用之前xml配置ioc时的三种方式 (并没有 <code>setter</code>), 这是肿么回事儿?<br><code>@Autowired</code> 方式是通过万能而无节操的反射设置属性值的…. （有空可以看看源码）</p><h2 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a><code>@Qualifier</code></h2><p>相比于 <code>@Autowired</code>, <code>@Qualifier</code> 会同时按照 类型 和 bean的id 进行匹配<br>属性 <code>value</code> : 用于指定注入bean的id</p><p><code>@Qualifier</code> 略微闹心, 在修饰类成员变量时, 不能单独使用, 还得使用 <code>@Autowired</code></p><p><strong>tips</strong>: 它在给类成员注入时不能单独使用, 但是在给方法参数注入时可以单独使用 (如: <code>public QueryRunner createQueryRunner(@Qualifier(&quot;ds2&quot;) DataSource dataSource){</code>, 指明当Spring容器中有多个类型都为 DataSource 的bean对象时, 此处取name为ds2的)</p><p><img src="/img/SpringFramework/ioc-innotation-xml-Qualifier-01.png"></p><h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a><code>@Resource</code></h2><p>相比之前两种, <code>@Resource</code> 可以直接按照bean的id进行注入, 并且可以单独使用</p><p>但是它的属性是 <code>name</code>, 用来指明bean的id</p><h1 id="基本类型-的注入"><a href="#基本类型-的注入" class="headerlink" title="基本类型 的注入"></a>基本类型 的注入</h1><ol><li>以上注解都只能注入其他bean类型的数据, 而 基本类型 和 String类型 无法使用上述注解实现</li><li>另外, <strong>集合类型的注入只能使用 xml 配置的方式进行注入</strong></li></ol><h2 id="Value"><a href="#Value" class="headerlink" title="@Value"></a><code>@Value</code></h2><p>其作用用于注入 基本类型 和 String类型 的数据</p><p>属性value用于指定数据的值, 同时它还可以使用 Spring 中的 SpEL表达式 (el表达式的写法 <code>${表达式}</code>)</p><p><img src="/img/springboot/@Value-bean-property-01.png"></p><h1 id="用于改变作用范围的注解"><a href="#用于改变作用范围的注解" class="headerlink" title="用于改变作用范围的注解"></a>用于改变作用范围的注解</h1><h2 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a><code>@Scope</code></h2><p>作用 和 之前学的使用xml实现ioc时, 在 <code>&lt;bean&gt;</code> 中使用 <code>scope</code> 属性是类似的</p><p>属性<code>value</code>: 用于指定范围, 取值为 (singleton: 默认值, 单例的、prototype: 多例的  、…)</p><p>可以用在类上(当类使用了创建bean的注解时,可以一起用), 也可以用在返回bean对象的方法上(当方法上使用了 <code>@Bean</code> 将bean交给Spring容器进行管理时, 可以一起使用)</p><h1 id="用于生命周期的注解"><a href="#用于生命周期的注解" class="headerlink" title="用于生命周期的注解"></a>用于生命周期的注解</h1><p>作用和之前学的使用xml实现ioc时, 在 <code>&lt;bean&gt;</code> 中使用 <code>init-method</code>、<code>destroy-method</code> 属性是类似的<br>用于方法上, 指定方法为 初始化方法 或者 销毁方法 (<strong>如果是多例对象的话, 调用销毁方法没效, 因为多例的销毁是JVM进行的</strong>)</p><h2 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a><code>@PostConstruct</code></h2><p>指定初始化方法</p><h2 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a><code>@PreDestroy</code></h2><p>指定销毁方法</p><h1 id="xml-注解-的IOC"><a href="#xml-注解-的IOC" class="headerlink" title="xml + 注解 的IOC"></a><code>xml + 注解</code> 的IOC</h1><p>到目前为止我们仍未脱离 xml配置: 对于上面的示例中的操作, 相比 使用xml配置来 创建bean 或者 依赖注入, xml+annotation 的方式只用在xml中配置很少的内容（为了说明你使用注解的地方）, 然后对于需要被Spring容器管理的对象, 在其类上加上以上注解即可</p><h1 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h1><ol><li>注解配置Ioc的问题： <strong>试想一下, 一旦当我们所依赖的对象是其他 jar 包中的类时, 我们是无法使用 注解 方法完成bean的创建 和 注入 的, 因为我们无法在别人jar包的代码中加注解</strong></li><li>如何将 xml配置 直接取消, 完全使用纯注解进行 IOC 配置呢 ?</li></ol><h1 id="纯注解配置IOC"><a href="#纯注解配置IOC" class="headerlink" title="纯注解配置IOC"></a>纯注解配置IOC</h1><p><img src="/img/SpringFramework/ioc-annotation.png"></p><h1 id="Spring的几个新注解"><a href="#Spring的几个新注解" class="headerlink" title="Spring的几个新注解"></a>Spring的几个新注解</h1><p>在纯注解配置IOC时, 如果要对配置类进行拆分, 比如 公共配置类, 和多个专项配置类, 如果拆开的话, 由于主配置类文件中的扫描路径不包含 config路径, 所以会报错, 可以如下:<br><img src="/img/SpringFramework/ioc-annotation-01.png"><br>或者<br><img src="/img/SpringFramework/ioc-annotation-02.png"></p><p>如果不希望每个配置类都配置 <code>@Configuration</code>, 并且在主配置类中还要修改 <code>@ComponentScan</code> 设置多个路径<br>或者也不希望在 <code>AnnotationConfigApplicationContext</code> 中传递多个配置类<br>该怎么办?</p><h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a><code>@Import</code></h2><p>用于导入其他配置类; 属性value, 用于指定其他配置类的字节码</p><p><img src="/img/SpringFramework/ioc-annotation-03.png"></p><h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a><code>@PropertySource</code></h2><p>用于指定 properties 文件的路径, 属性value用来指定文件的路径 （value中的关键字<code>classpath:</code>表示类路径下）<br>当使用 <code>@Configuration</code> 修饰的配置类, 并通过在其中的方法上使用 <code>@Bean</code> 来将bean对象交给Spring容器管理时, 比如在操作数据库时, 由于需要设置一些datasource的数据参数, 这些参数就写死到了 方法中</p><p>此时就需要使用 <code>@PropertySource</code> 并且配合 <code>@Value</code>来将这些基本类型进行注入</p><p><img src="/img/SpringFramework/ioc-annotation-04.png"></p><h1 id="关于-Spring-注解和-XML-的选择问题"><a href="#关于-Spring-注解和-XML-的选择问题" class="headerlink" title="关于 Spring 注解和 XML 的选择问题"></a>关于 Spring 注解和 XML 的选择问题</h1><ol><li><p>注解的优势: 配置简单, 维护方便 (我们找到类, 就相当于找到了对应的配置)</p></li><li><p>XML 的优势: 修改时, 不用改源码。不涉及重新编译和部署 </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring2.0 开始引入基于注解的配置方式, 即 Bean的定义信息可以通过在 Bean的实现类上 标注注解来实现&lt;/p&gt;
&lt;p&gt;注解配置和 xml 配置要实现的功能都是一样的, 都是要降低程序间的耦合, 只是配置的形式不一样, 关于实际的开发中到底使用 xml 还是注
      
    
    </summary>
    
      <category term="Spring" scheme="http://blog.renyimin.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://blog.renyimin.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>基于 XML 的 IOC 配置</title>
    <link href="http://blog.renyimin.com/2019/05/12/SpringFramework5/2019-05-12-04/"/>
    <id>http://blog.renyimin.com/2019/05/12/SpringFramework5/2019-05-12-04/</id>
    <published>2019-05-12T07:07:48.000Z</published>
    <updated>2019-08-29T04:01:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识-Spring-的配置文件"><a href="#认识-Spring-的配置文件" class="headerlink" title="认识 Spring 的配置文件"></a>认识 Spring 的配置文件</h1><ol><li><p><strong>Spring的配置文件 其实就是Spring容器对Bean进行生产以及关系注入的图纸, 它是Spring的基础, 如果没有配置文件的话, 则 Spring 的容器将无从谈起</strong><br>Spring 的配置文件 是用于指导 Spring 工厂进行 Bean 的生产、依赖关系注入及 Bean 实例分发的”图纸”, 我们必须学会并灵活应用这份”图纸”, 准确地表达自己的”生产意图”, 它是一个或多个标准的XML文档 (<code>ApplicationContext.xml</code> 是Spring的默认配置文件, 当容器启动时找不到其他的配置文件时, 则会尝试加载这个默认的配置文件)</p></li><li><p>Spring启动时会读取 配置文件 中提供的Bean的配置信息, 并在Spring容器中生成一份相应的Bean的配置注册表, 然后根据这张注册表来实例化Bean, 装配好Bean之间的依赖关系, 为上层应用提供准备就绪的运行环境</p></li><li><p><strong>bean的配置信息就是Bean的元数据信息, 由以下五个方面来组成</strong>:<br> Bean的一些属性信息: 比如 数据源的连接数, 用户名和密码等等<br> Bean的依赖关系: Spring根据依赖关系配置完成Bean之间的装配<br> Bean的行为配置: 比如, 生命周期范围以及生命周期各个过程的回调函数等<br> Bean的创建方式定义: 主要说明是通过构造器还是工厂方法来构造Bean</p></li><li><p>有时, 一个项目中可能存在多个配置文件, 那么Spring项目加载多个配置文件的方法如下:<br> 在配置文件中使用 <code>import</code> 来导入所需的配置文件<br> 将多个配置文件构造为一个数组, 然后传递给 <code>ApplicationContext</code><br> 这两种方式都是通过调用 <code>BeanDefinitionReader</code> 来读取定义文件的, 在内部实现上没有任何的区别</p></li><li><p>在大型的Spring项目当中, 所有的bean配置在一个配置文件当中很不容易管理且也不利于团队的开发; 因此, 通常在开发过程当中, 我们会按照 功能模块和开发人员 来将配置文件分成多个, 这样会有利与模块的划分, 接下来我们需要使用 <code>import</code> 属性来引入多个配置文件到项目当中</p></li></ol><h1 id="xml-配置-ioc"><a href="#xml-配置-ioc" class="headerlink" title="xml 配置 ioc"></a>xml 配置 ioc</h1><p>在项目根目录下创建任意名称的 xml 文件 (此处为 bean.xml):</p><p>给配置文件导入约束 (查看文档/spring-framework-5.1.4.RELEASE/docs/spring-framework-reference/core.html)<br><img src="/img/SpringFramework/bean-xml-01.png"><br>如下就做好了准备工作<br><img src="/img/SpringFramework/bean-xml-03.png"></p><h2 id="配置-lt-bean-gt-标签"><a href="#配置-lt-bean-gt-标签" class="headerlink" title="配置 &lt;bean&gt; 标签"></a>配置 <code>&lt;bean&gt;</code> 标签</h2><ol><li><p>其作用就是配置对象以让 spring 进行创建, 默认情况下它调用的是类中的无参构造函数, <strong>如果没有无参构造函数则不能创建成功</strong><br><img src="/img/SpringFramework/bean-xml-construct-no-param.png"></p></li><li><p>属性: </p></li></ol><ul><li>id: 给对象在容器中提供一个唯一标识, 用于获取对象</li><li>class: 指定类的全类名, 用于反射创建对象 (默认情况下调用无参构造函数)</li><li><p><strong>scope: 指定对象的作用范围</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">singleton: 默认值, 单例的</span><br><span class="line">prototype: 多例的</span><br><span class="line">request: WEB项目中, Spring创建一个Bean的对象, 将对象存入到request域中</span><br><span class="line">session: WEB项目中, Spring创建一个Bean的对象, 将对象存入到session域中</span><br><span class="line">global session: 作用于集群环境的会话范围, 当不是集群环境时, 则作用于session</span><br></pre></td></tr></table></figure></li><li><p>init-method: 指定类中的初始化方法名称</p></li><li>destroy-method: 指定类中销毁方法名称</li></ul><h2 id="bean-的作用范围和生命周期"><a href="#bean-的作用范围和生命周期" class="headerlink" title="bean 的作用范围和生命周期"></a>bean 的作用范围和生命周期</h2><p>单例对象: <code>scope=&quot;singleton&quot;</code> </p><ol><li>一个应用只有一个对象的实例, 它的作用范围就是整个应用</li><li>生命周期:</li></ol><ul><li>对象出生: 当容器创建时(配置文件被加载时), 对象立刻就被创建了</li><li>对象活着: 只要容器在, 对象一直活着</li><li>对象死亡: 容器销毁时, 对象就被销毁了</li><li>小结: 单例对象的生命周期和容器相同</li></ul><p>多例对象: <code>scope=&quot;prototype&quot;</code></p><ol><li>每次访问对象时, 都会重新创建对象实例</li><li>生命周期: </li></ol><ul><li>对象出生: 当获取对象时, 才会创建新的对象实例</li><li>对象活着: 只要对象在使用中, 就一直活着</li><li>对象死亡: 当对象长时间不用时, 且没有别的对象使用时, 会被 java 的垃圾回收器回收了</li></ul><h2 id="ApplicationContext-接口的实现类"><a href="#ApplicationContext-接口的实现类" class="headerlink" title="ApplicationContext 接口的实现类"></a><code>ApplicationContext</code> 接口的实现类</h2><ol><li><code>ClassPathXmlApplicationContext</code>: 可以加载类路径下的配置文件, 否则无法加载 （实际开发中, 相比第二种而言, 这种比较常用）</li><li><code>FileSystemXmlApplicationContext</code>: 可以加载磁盘任意路径下的配置文件 (必须有访问权限)</li><li><p><code>AnnotationConfigApplicationContext</code>: 用于读取注解创建容器</p></li><li><p><code>BeanFactory</code> 和 <code>ApplicationContext</code></p></li></ol><ul><li><p><code>BeanFactory</code> 才是 Spring 容器中的顶层接口, <code>ApplicationContext</code> 是它的子接口<br><img src="/img/SpringFramework/ApplicationContext-01.png"><br><img src="/img/SpringFramework/ApplicationContext-02.png"><br>下面还可以查看其实现类<br><img src="/img/SpringFramework/ApplicationContext-03.png"></p></li><li><p>两者创建对象的时间点不一样<br><code>BeanFactory</code>: 创建对象采取的是延迟加载, 什么时候get, 什么时候创建对象 （所以 多例 貌似比较适用）<br><code>ApplicationContext</code>: 只要一读取配置文件, 默认情况下就会创建对象 （所以 单例 貌似比较适用） 实际开发中更多适用 <code>ApplicationContext</code> </p></li></ul><h2 id="创建-Bean-的三种配置方式"><a href="#创建-Bean-的三种配置方式" class="headerlink" title="创建 Bean 的三种配置方式"></a>创建 Bean 的三种配置方式</h2><h3 id="使用默认无参构造函数"><a href="#使用默认无参构造函数" class="headerlink" title="使用默认无参构造函数"></a>使用默认无参构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--在默认情况下: 它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数, 将会创建失败--&gt;</span><br><span class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.spring.study.service.impl.AccountServiceImpl&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="使用静态工厂的方法创建对象"><a href="#使用静态工厂的方法创建对象" class="headerlink" title="使用静态工厂的方法创建对象"></a>使用静态工厂的方法创建对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 模拟一个静态工厂, 创建业务层实现类</span><br><span class="line">*/</span><br><span class="line">public class StaticFactory &#123;</span><br><span class="line">    public static IAccountService createAccountService()&#123; </span><br><span class="line">        return new AccountServiceImpl();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 此种方式是: 使用 StaticFactory 类中的静态方法 createAccountService 创建对象, 并存入 spring 容器</span><br><span class="line">id 属性: 指定 bean 的 id, 用于从容器中获取 </span><br><span class="line">class 属性: 指定静态工厂的全限定类名 </span><br><span class="line">factory-method 属性: 指定生产对象的静态方法</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.spring.study.factory.InstanceFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="使用实例工厂的方法创建对象"><a href="#使用实例工厂的方法创建对象" class="headerlink" title="使用实例工厂的方法创建对象"></a>使用实例工厂的方法创建对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 模拟一个实例工厂, 创建业务层实现类</span><br><span class="line">* 此工厂创建对象, 必须现有工厂实例对象, 再调用方法 </span><br><span class="line">*/</span><br><span class="line">public class InstanceFactory &#123;</span><br><span class="line">public IAccountService createAccountService()&#123;</span><br><span class="line">    return new AccountServiceImpl(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 此种方式是:</span><br><span class="line">先把工厂的创建交给 spring 来管理</span><br><span class="line">然后在使用工厂的 bean 来调用里面的方法 </span><br><span class="line">factory-bean 属性: 用于指定实例工厂 bean 的 id</span><br><span class="line">factory-method 属性: 用于指定实例工厂中创建对象的方法</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=&quot;instancFactory&quot; class=&quot;com.spring.study.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;accountService&quot; factory-bean=&quot;instancFactory&quot; factory-method=&quot;createAccountService&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="Ioc-注入-Bean-的三种方式"><a href="#Ioc-注入-Bean-的三种方式" class="headerlink" title="Ioc (注入 Bean) 的三种方式"></a>Ioc (注入 Bean) 的三种方式</h2><h3 id="构造函数注入-constructor-arg"><a href="#构造函数注入-constructor-arg" class="headerlink" title="构造函数注入 (constructor-arg)"></a>构造函数注入 (<code>constructor-arg</code>)</h3><p>顾名思义, 就是使用类中的构造函数, 给成员变量赋值 (<strong>注意</strong>: 赋值的操作不是我们自己做的, 还是通过配置的方式, 让 spring 框架来为我们注入)<br><img src="/img/SpringFramework/ioc-constructor.png"></p><h3 id="set-方法注入-property"><a href="#set-方法注入-property" class="headerlink" title="set 方法注入 (property)"></a>set 方法注入 (<code>property</code>)</h3><p><img src="/img/SpringFramework/ioc-setter.png"></p><h3 id="p-名称空间注入数据-p"><a href="#p-名称空间注入数据-p" class="headerlink" title="p 名称空间注入数据 (p:)"></a>p 名称空间注入数据 (<code>p:</code>)</h3><p>使用 p名称空间 注入数据(本质还是调用 set 方法, 即 类的属性需要有对应的setter)<br>参考文档 /spring-framework-5.1.4.RELEASE/docs/spring-framework-reference/core.html 在xml中导入 <code>P命名空间</code><br><img src="/img/SpringFramework/spring-p-namespace.png"><br>测试<br><img src="/img/SpringFramework/ioc-p-namespace-01.png"></p><h2 id="如何注入集合属性"><a href="#如何注入集合属性" class="headerlink" title="如何注入集合属性?"></a>如何注入集合属性?</h2><p><img src="/img/SpringFramework/ioc-collection.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;认识-Spring-的配置文件&quot;&gt;&lt;a href=&quot;#认识-Spring-的配置文件&quot; class=&quot;headerlink&quot; title=&quot;认识 Spring 的配置文件&quot;&gt;&lt;/a&gt;认识 Spring 的配置文件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;S
      
    
    </summary>
    
      <category term="Spring" scheme="http://blog.renyimin.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://blog.renyimin.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>最基础的 Spring 项目</title>
    <link href="http://blog.renyimin.com/2019/05/12/SpringFramework5/2019-05-12-03/"/>
    <id>http://blog.renyimin.com/2019/05/12/SpringFramework5/2019-05-12-03/</id>
    <published>2019-05-12T06:35:09.000Z</published>
    <updated>2019-08-29T03:38:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手动创建"><a href="#手动创建" class="headerlink" title="手动创建"></a>手动创建</h1><p>1.创建普通Java项目<br><img src="/img/SpringFramework/create-spring-object-1-01.png"></p><p>2.在项目目录下创建 libs 目录 ( 右击 项目目录 —&gt; “Add as library”)</p><p>3.导入所需的 Spring 包</p><ul><li>核心容器四个包<br>spring-beans-5.1.4.RELEASE.jar<br>spring-context-5.1.4.RELEASE.jar<br>spring-core-5.1.4.RELEASE.jar<br>spring-expression-5.1.4.RELEASE.jar</li><li>核心容器依赖的日志包<br>commons-logging-1.2.jar ( commons-logging 相当于一个日志接口, log4j相当于该接口的实现, 如果不添加log4j包也可以, 因为commons-logging也有一个简单的实现会自动使用)<br>log4j-1.2.17.jar</li><li>测试类包<br>spring-test-5.1.4.RELEASE.jar<br>junit-4.12.jar(高于4.10版本还需要hamcrest-core.jar + hamcrest-library.jar)</li><li>测试类用到了AOP必须导入aop包<br>spring-aop-4.1.3.RELEASE.jar</li></ul><p>4.这样一个Spring项目所需要的最基础的环境就搭建完成了<br><img src="/img/SpringFramework/create-spring-object-1-02.png"></p><p>当然, 现在一般不像上面那样创建项目, 而是选择 Maven 等构件工具来创建项目</p><h1 id="Maven创建-推荐"><a href="#Maven创建-推荐" class="headerlink" title="Maven创建 (推荐)"></a>Maven创建 (推荐)</h1><p>1.创建maven空项目</p><p>2.导入所需的 Spring 包<br>Spring框架提供了很多服务, 但这些服务并不是默认为应用打开的, 应用可以按需指明使用的服务<br><img src="/img/SpringFramework/spring-lightweight-01.png"></p><p>和手动创建时一样, 不过此处是在maven项目的 pom 文件中指定对应的包坐标</p><p>3.<strong>注意</strong>: 创建Spring基础项目的话, 其实只用导入 <a href="https://mvnrepository.com/artifact/org.springframework/spring-context/5.1.4.RELEASE" target="_blank" rel="noopener">spring-context</a> 即可自动拉取创建基本Spring项目所需的jar包<br>(apo:是基于注解配置IOC所要依赖的jar, spring不知道你将来会使用xml还是注解配置IOC, 所以会将aop包也导入)<br>可以查看 <code>spring-context</code> 的依赖 (我们的项目依赖了 <code>spring-context</code>, 而<code>spring-context</code>依赖的包如下)<br><img src="/img/SpringFramework/spring-context-dependency-structure.png"></p><p>参考:<br><a href="https://www.cnblogs.com/mibloom/p/9871652.html" target="_blank" rel="noopener">https://www.cnblogs.com/mibloom/p/9871652.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;手动创建&quot;&gt;&lt;a href=&quot;#手动创建&quot; class=&quot;headerlink&quot; title=&quot;手动创建&quot;&gt;&lt;/a&gt;手动创建&lt;/h1&gt;&lt;p&gt;1.创建普通Java项目&lt;br&gt;&lt;img src=&quot;/img/SpringFramework/create-spring-o
      
    
    </summary>
    
      <category term="Spring" scheme="http://blog.renyimin.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://blog.renyimin.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 核心 之 DI、IOC</title>
    <link href="http://blog.renyimin.com/2019/05/11/SpringFramework5/2019-05-11-02/"/>
    <id>http://blog.renyimin.com/2019/05/11/SpringFramework5/2019-05-11-02/</id>
    <published>2019-05-11T03:15:31.000Z</published>
    <updated>2019-08-29T03:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li><p>控制反转(Inversion of Control, IOC) 不是什么技术, 而是一种设计思想<br>传统的创建对象的方法是直接通过 new 关键字, 而 Spring 则是通过 IOC 容器来创建对象, 也就是说我们将创建对象的控制权交给了 IOC 容器, 控制权发生了转移<br><strong>而 IOC 让程序员不再关注怎么去创建对象, 而是关注与对象创建之后的操作, 把对象的创建、初始化、销毁等工作交给Spring容器来做</strong>, 所有的类的创建、销毁都由 spring来控制, 也就是说控制对象生存周期的不再是引用它的对象, 而是spring, 对于某个具体的对象而言, 以前是它控制其他对象, 现在是所有对象都被spring控制, 所以这叫<strong>控制反转</strong></p></li><li><p>对于 Spring框架 来说, Ioc 就是由 Spring 来负责控制对象的生命周期和对象间的关系</p><blockquote><ul><li>在传统的程序开发中, 在一个对象中, 如果要使用另外的对象, 就必须得到它 (自己new一个, 或者从JNDI中查询一个), 使用完之后还要将对象销毁(比如Connection等), 这样会导致当前对象 和 其他的接口或类藕合起来</li><li>而对于IoC, 有点像通过婚介找女朋友, 在我和女朋友之间引入了一个第三者: 婚姻介绍所。婚介管理了很多男男女女的资料, 我可以向婚介提出一个列表, 告诉它我想找个什么样的女朋友, 比如长得像李嘉欣, 身材像林熙雷, 唱歌像周杰伦, 速度像卡洛斯, 技术像齐达内之类的, 然后婚介就会按照我们的要求, 提供一个mm, 我们只需要去和她谈恋爱、结婚就行了。简单明了, 如果婚介给我们的人选不符合要求, 我们就会抛出异常。整个过程不再由我自己控制, 而是有婚介这样一个类似容器的机构来控制。</li></ul></blockquote></li><li><p>Spring所倡导的开发方式就是如此, 所有的类都会在spring容器中登记, 告诉Spring你是谁, 你需要什么, 然后spring会在系统运行到适当的时候, 把你要的东西主动给你, 同时也把你交给其他需要你的东西</p></li><li><p>Ioc 和 DI 大致可以认为是一个意思, 不同的叫法 (使用 Spring容器进行 依赖注入 后, 控制权就发生了反转 😆!)</p></li><li><p>Ioc 的三种依赖注入方式后面会讲到</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;控制反转(Inversion of Control, IOC) 不是什么技术, 而是一种设计思想&lt;br&gt;传统的创建对象的方
      
    
    </summary>
    
      <category term="Spring" scheme="http://blog.renyimin.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://blog.renyimin.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Framework 5 入门</title>
    <link href="http://blog.renyimin.com/2019/05/11/SpringFramework5/2019-05-11-01/"/>
    <id>http://blog.renyimin.com/2019/05/11/SpringFramework5/2019-05-11-01/</id>
    <published>2019-05-11T03:12:31.000Z</published>
    <updated>2020-03-13T02:53:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="当谈到-“Spring”-时，通常在说什么"><a href="#当谈到-“Spring”-时，通常在说什么" class="headerlink" title="当谈到 “Spring” 时，通常在说什么?"></a><a href="https://docs.spring.io/spring/docs/5.1.14.RELEASE/spring-framework-reference/overview.html#overview-spring" target="_blank" rel="noopener">当谈到 “Spring” 时，通常在说什么?</a></h1><!--1. What We Mean by "Spring"The term "Spring" means different things in different contexts. It can be used to refer to the Spring Framework project itself, which is where it all started. Over time, other Spring projects have been built on top of the Spring Framework. Most often, when people say "Spring", they mean the entire family of projects. This reference documentation focuses on the foundation: the Spring Framework itself.The Spring Framework is divided into modules. Applications can choose which modules they need. At the heart are the modules of the core container, including a configuration model and a dependency injection mechanism. Beyond that, the Spring Framework provides foundational support for different application architectures, including messaging, transactional data and persistence, and web. It also includes the Servlet-based Spring MVC web framework and, in parallel, the Spring WebFlux reactive web framework.A note about modules: Spring’s framework jars allow for deployment to JDK 9’s module path ("Jigsaw"). For use in Jigsaw-enabled applications, the Spring Framework 5 jars come with "Automatic-Module-Name" manifest entries which define stable language-level module names ("spring.core", "spring.context" etc) independent from jar artifact names (the jars follow the same naming pattern with "-" instead of ".", e.g. "spring-core" and "spring-context"). Of course, Spring’s framework jars keep working fine on the classpath on both JDK 8 and 9+.--><p>术语 “Spring” 在不同的上下文中表示不同的事物。它可以用来指代 Spring Framework 项目本身(当然一切都是从这里开始的)。随着时间的流逝，其他Spring项目已经建立在Spring Framework之上。通常，当人们说“春天”时，它们表示整个项目系列 （即Spring生态）。</p><h1 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8+"></a>JDK8+</h1><p>从Spring Framework 5.1开始，Spring需要JDK 8+（Java SE 8+）</p><h1 id="Spring-生态的基础"><a href="#Spring-生态的基础" class="headerlink" title="Spring 生态的基础"></a>Spring 生态的基础</h1><p>Spring Framework 项目是整个Spring生态的基础，包含了Spring生态最核心的功能</p><p>为企业级开发提供了丰富的功能</p><ul><li>控制反转(IOC)</li><li>面向切面编程(AOP)</li><li>Web框架: Spring MVC？</li><li>众多辅助及工具类?</li><li>众多服务？</li><li>轻量级- 模块分离</li><li>单元测试？</li><li>……</li></ul><h1 id="仓库地址"><a href="#仓库地址" class="headerlink" title="仓库地址"></a><a href="https://repo.spring.io/release/org/springframework/spring/" target="_blank" rel="noopener">仓库地址</a></h1><p>下载并解压 spring-framework-5.1.4.RELEASE-dist.zip 后, 可以看到 Spring Framework 有 <code>docs</code>、<code>libs</code> 和 <code>schema</code> 文件夹<br><img src="/img/SpringFramework/download-01.png">  </p><p>其中libs文件夹下是所需要的jar包(从Spring 5 RELEASE版本开始, Spring 提供了21个模块, 可以看到每一模块都有三个jar包, 分别为类库、文档和源码, 所以总共会有63个jar包), 在项目中引用Spring Framework时, 应该按需引用所需的类库</p><p>下图是从 spring-framework-5.1.4.RELEASE 解压包下的 docs/spring-framework-reference/images 中拿到的<br><img src="/img/SpringFramework/spring-overview.png"><br>Spring 总共大约有 21 个模块, 而这些组件被分别整合在 <code>核心容器(Core Container)</code>、<code>AOP(Aspect Oriented Programming)</code>、<code>设备支持(Instrmentation)</code>、 <code>数据访问及集成(Data Access/Integeration)</code>、<code>Web</code>、<code>报文发送(Messaging)</code>、<code>Test</code> 7个模块集合中</p><!--## 核心容器是Spring框架的重要组成部分, 也可以说是Spring框架的基础。他在整个框架中的作用是负责管理对象的创建, 管理, 配置等等的操作, 由 `spring-core`、`spring-beans`、`spring-context` 和 `spring-expression`(Spring Expression Language, SpEL) 4 个模块组成 `spring-beans` 和 `spring-core` 模块是 Spring 框架的核心模块, 包含了控制反转(Inversion of Control, IOC) 和 依赖注入(Dependency Injection, DI)> `BeanFactory` 接口是 Spring 框架中的核心接口, 它是工厂模式的具体实现, BeanFactory 使用控制反转对 应用程序的配置和依赖性规范 与 实际的应用程序代码 进行了分离但 BeanFactory 容器实例化后并不会自动实例化 Bean, 只有当 Bean 被使用时 BeanFactory 容器才会对该 Bean 进行实例化与依赖关系的装配`spring-context` 模块构架于核心模块之上, 它扩展了 BeanFactory, 为它添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。此外该模块还提供了许多企业级支持, 如邮件访问、远程访问、任务调度等> `ApplicationContext` 是该模块的核心接口, 它是 BeanFactory 的超类, 与 BeanFactory 不同, ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配, 使之处于待用状态`spring-expression` 模块是统一表达式语言(EL)的扩展模块, 可以查询、管理运行中的对象, 同时也方便的可以调用对象方法、操作数组、集合等> 它的语法类似于传统 EL, 但提供了额外的功能, 最出色的要数函数调用和简单字符串的模板函数。这种语言的特性是基于 Spring 产品的需求而设计, 它可以非常方便地同 Spring IOC 进行交互## AOP由 `spring-aop`、`spring-aspects` 和 `spring-instrument` 3 个模块组成`spring-aop` 是 Spring 的另一个核心模块, 是 AOP 主要的实现模块。作为继 OOP 后, 对程序员影响最大的编程思想之一, AOP 极大地开拓了人们对于编程的思路在 Spring 中, 他是以 JVM的动态代理技术 为基础, 然后设计出了一系列的 AOP 横切实现, 比如 前置通知、返回通知、异常通知等, 同时, Pointcut 接口来匹配切入点, 可以使用现有的切入点来设计横切面, 也可以扩展相关方法根据需求进行切入## 设备支持`spring-instrument` 模块是基于 JAVA SE 中的 `java.lang.instrument` 进行设计的, 应该算是 AOP 的一个支援模块, 主要作用是在 JVM 启用时, 生成一个代理类, 程序员通过代理类在运行时修改类的字节, 从而改变一个类的功能, 实现 AOP 的功能该模块提供了为JVM添加代理的功能, 该模块包含 spring-instrument, spring-instrument-tomcat组件, 使用较少, 不必过分关注## 数据访问及集成由 `spring-jdbc`、`spring-tx`、`spring-orm`、`spring-jms` 和 `spring-oxm` 5 个模块组成`spring-jdbc` 模块是 Spring 提供的 JDBC 抽象框架的主要实现模块, 用于简化 Spring JDBC, 主要是提供 JDBC 模板方式、关系数据库对象化方式、SimpleJdbc 方式、事务管理来简化 JDBC 编程主要实现类是 `JdbcTemplate`、`SimpleJdbcTemplate` 以及 `NamedParameterJdbcTemplate``spring-tx` 模块是 Spring JDBC 事务控制实现模块。使用 Spring 框架, 它对事务做了很好的封装`spring-orm` 模块是 ORM 框架支持模块, 主要集成 Hibernate, Java Persistence API (JPA) 和Java Data Objects (JDO) 用于资源管理、数据访问对象(DAO)的实现和事务策略`spring-jms` 模块（Java Messaging Service）能够发送和接受信息, 自 Spring Framework 4.1 以后, 他还提供了对 spring-messaging 模块的支撑`spring-oxm` 模块主要提供一个抽象层以支撑 OXM (OXM 是 Object-to-XML-Mapping 的缩写, 它是一个 O/M-mapper, 将 java 对象映射成 XML 数据, 或者将 XML 数据映射成 java 对象), 例如: JAXB, Castor, XMLBeans, JiBX 和 XStream 等## Web由 `spring-web`、`spring-webmvc`、`spring-websocket` 和 `spring-webflux` 4 个模块组成`spring-web` 模块为 Spring 提供了最基础 Web 支持, 主要建立于核心容器之上, 通过 Servlet 或者 Listeners 来初始化 IOC 容器, 也包含一些与 Web 相关的支持`spring-webmvc` 模块众所周知是一个 Web-Servlet 模块, 实现了Spring MVC(model-view-Controller)的Web应用`spring-websocket` 模块主要是与 Web 前端的全双工通讯的协议`spring-webflux` 是一个新的非堵塞函数式 Reactive Web 框架, 可以用来建立异步的, 非阻塞, 事件驱动的服务, 并且扩展性非常好## 报文发送即 `spring-messaging` 模块, 是从 Spring4 开始新加入的一个模块, 主要职责是为 Spring 框架集成一些基础的报文传送应用## Test即 `spring-test` 模块, 主要为测试提供支持的, 毕竟在不需要发布(程序)到你的应用服务器或者连接到其他企业设施的情况下能够执行一些集成测试或者其他测试对于任何企业都是非常重要的--><h1 id="Spirng-各模块之间的依赖关系"><a href="#Spirng-各模块之间的依赖关系" class="headerlink" title="Spirng 各模块之间的依赖关系"></a>Spirng 各模块之间的依赖关系</h1><p>该图是 Spring5 的包结构, 可以从中清楚看出 Spring 各个模块之间的依赖关系<br><img src="/img/SpringFramework/spring-relation.png"> </p><p>另外, 因为 spring-core 依赖了 commons-logging, 而其他模块都依赖了 spring-core, 所以整个spring框架都依赖了commons-logging<br>日志框架有多种, 也不一定使用commons-logging, 如果有自己的日志实现如 log4j, 可以排除对 commons-logging 的依赖, 否则会编译报错</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;当谈到-“Spring”-时，通常在说什么&quot;&gt;&lt;a href=&quot;#当谈到-“Spring”-时，通常在说什么&quot; class=&quot;headerlink&quot; title=&quot;当谈到 “Spring” 时，通常在说什么?&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.
      
    
    </summary>
    
      <category term="Spring" scheme="http://blog.renyimin.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://blog.renyimin.com/tags/Spring/"/>
    
  </entry>
  
</feed>
