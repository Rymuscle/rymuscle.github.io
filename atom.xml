<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2018-05-02T08:07:37.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>01.</title>
    <link href="http://blog.renyimin.com/2018/04/28/oauth/2018-04-28-CAS/"/>
    <id>http://blog.renyimin.com/2018/04/28/oauth/2018-04-28-CAS/</id>
    <published>2018-04-28T13:10:12.000Z</published>
    <updated>2018-05-02T08:07:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Single-Sign-On"><a href="#Single-Sign-On" class="headerlink" title="Single Sign On"></a>Single Sign On</h2><p>单点登录(Single Sign On), 简称为<code>SSO</code>, 是目前比较流行的企业业务整合的解决方案之一;<br>SSO的定义是在多个应用系统中, 用户只需要登录一次就可以访问所有相互信任的应用系统;</p><h2 id="CAS简介"><a href="#CAS简介" class="headerlink" title="CAS简介"></a><a href="https://www.apereo.org/" target="_blank" rel="external">CAS</a>简介</h2><ol><li><a href="https://www.apereo.org/projects/cas" target="_blank" rel="external">CAS</a>由Yale耶鲁大学研发的一款开源的,企业级,SSO单点登录解决方案;</li><li><a href="https://github.com/apereo/cas" target="_blank" rel="external">CAS Github 源码下载</a>, 这里使用的是CAS5.1.9</li><li><a href="https://apereo.github.io/cas/5.1.x/" target="_blank" rel="external">CAS 文档</a><h3 id="CAS系统组件"><a href="#CAS系统组件" class="headerlink" title="CAS系统组件"></a>CAS系统组件</h3>CAS系统架构由 <code>CAS Server</code> 和 <code>CAS Client</code> 两个物理组件构成, 它们通过各种协议进行通信;<h3 id="CAS-Server"><a href="#CAS-Server" class="headerlink" title="CAS Server"></a>CAS Server</h3></li><li>CAS服务器是基于Spring框架构建的Java servlet, 其主要职责是验证用户, 并通过发布和验证票证来对 启用CAS的服务(通常称为CAS客户端)的访问权限 进行授权;<br>服务器在成功登录后, 会向用户授予 <code>票证(TGT)</code>时创建SSO会话;<br>根据用户的请求, 通过使用TGT作为标记的浏览器重定向向服务发出服务票据(ST);<br>ST随后通过反向信道通信在CAS服务器上进行验证。 CAS Protocol文档中详细描述了这些交互;</li></ol><h3 id="CAS-Client"><a href="#CAS-Client" class="headerlink" title="CAS Client"></a>CAS Client</h3><h2 id="CAS-Server搭建"><a href="#CAS-Server搭建" class="headerlink" title="CAS Server搭建"></a>CAS Server搭建</h2><ol><li><code>CAS</code> 可以分为两部分 <code>CAS Server</code> 和 <code>CAS Client</code></li></ol><ul><li><code>CAS Server</code> 用来负责用户的认证工作, 就像是把第一次登录用户的一个标识存在这里, 以便此用户在其他系统登录时验证其需不需要再次登录;</li><li><code>CAS Client</code> 就是我们自己的应用, 需要接入<code>CAS Server</code>端; 当用户访问我们的应用时, 首先需要重定向到CAS Server端进行验证, 要是原来登陆过, 就免去登录, 重定向到下游系统, 否则进行用户名密码登陆操作;</li></ul><ol><li>术语<br>Ticket Granting ticket (TGT): 可以认为是CAS Server根据用户账号和密码生成的一张票, 存在CAS Server端;<br>Ticket-granting cookie (TGC): 其实就是一个cookie, 存放用户身份信息, 由CAS Server发给CAS Client端;<br>Service ticket (ST): 由TGT生成的一次性票据, 用于验证, 只能用一次。相当于server发给client一张票, 然后client拿着这是个票再来找server验证, 看看是不是server签发的;<br>就像是我给了你一张我的照片, 然后你拿照片再来问我, 这个照片是不是你, 没错，就是这么无聊</li></ol><h3 id="TGT-Ticket-Grangting-Ticket"><a href="#TGT-Ticket-Grangting-Ticket" class="headerlink" title="TGT(Ticket Grangting Ticket)"></a>TGT(Ticket Grangting Ticket)</h3><ol><li><code>TGT</code>是<code>CAS</code>为用户签发的登录票据, 拥有了TGT, 用户就可以证明自己在CAS成功登录过;<ul><li>TGT封装了Cookie值以及此Cookie值对应的用户信息;</li><li>用户在CAS认证成功后, CAS生成cookie, 写入浏览器, 同时生成一个TGT对象, 放入自己的缓存;</li><li>TGT对象的ID就是cookie的值</li><li>当HTTP再次请求到来时, 如果传过来的有CAS生成的cookie, 则CAS以此cookie值为key查询缓存中有无TGT, 如果有的话, 则说明用户之前登录过, 如果没有, 则用户需要重新登录;</li></ul></li></ol><p>ST（Service Ticket）<br>ST是CAS为用户签发的访问某一service的票据。用户访问service时，service发现用户没有ST，则要求用户去CAS获取ST。用户向CAS发出获取ST的请求，如果用户的请求中包含cookie，则CAS会以此cookie值为key查询缓存中有无TGT，如果存在TGT，则用此TGT签发一个ST，返回给用户。<br>用户凭借ST去访问service，service拿ST去CAS验证，验证通过后，允许用户访问资源。</p><p>PGT（Proxy Granting Ticket）<br>Proxy Service的代理凭据。用户通过CAS成功登录某一Proxy Service后，CAS生成一个PGT对象，缓存在CAS本地，同时将PGT的值（一个UUID字符串）回传给Proxy Service，并保存在Proxy Service里。Proxy Service拿到PGT后，就可以为Target Service（back-end service）做代理，为其申请PT。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Single-Sign-On&quot;&gt;&lt;a href=&quot;#Single-Sign-On&quot; class=&quot;headerlink&quot; title=&quot;Single Sign On&quot;&gt;&lt;/a&gt;Single Sign On&lt;/h2&gt;&lt;p&gt;单点登录(Single Sign On), 
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>03. 一些注意点</title>
    <link href="http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-03/"/>
    <id>http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-03/</id>
    <published>2018-04-21T07:50:21.000Z</published>
    <updated>2018-04-21T11:21:42.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>类常量</p><ul><li>类常量是公共的</li><li>只能通过<code>类名</code>, 使用 <code>::</code> 静态访问类常量 (也可以使用实例化的对象通过<code>::</code>来访问类常量)</li><li>客户端代码不能对其进行改变</li><li>常量属性使用 <code>const</code> 关键字来声明, 不需要使用 <code>$</code> 符号</li><li>常量属性的值只能包含<strong>基本数据类型</strong>的值, 不能将一个对象指派给常量</li><li>当需要在类的所有实例中都能访问某个属性, 并且属性值无需改变时, 应该使用常量</li></ul></li><li><p>抽象类</p><ul><li>不能实例化抽象类</li><li>抽象类中应该至少包含一个抽象方法 (但也不是强制性的)</li><li>抽象方法使用<code>abstract</code>关键字声明, 不能有具体的内容</li><li>抽象方法不能有消息体<code>{}</code>, 并且需要以<code>;</code>结束</li><li>继承抽象方法的子类必须实现抽象类中的所有抽象方法</li><li>继承抽象方法的子类实现了抽象类中的所有抽象方法之后, 还应该注意: 新实现的这个方法的访问控制权限不能比抽象方法更严格;</li></ul></li><li><p>接口</p><ul><li>接口相对于抽象类, 可能更是彻底的, 一个纯粹的模板;    </li><li>接口只能定义功能, 而不包含实现的内容;</li><li>任何实现了接口的类都需要实现接口中所定义的所有方法, 否则该类必须声明为<code>abstract</code>;</li><li>接口中的所有方法都必须声明为 <code>public</code>(或者不声明权限, 默认就为public)</li><li>接口中的所有方法不能有消息体<code>{}</code>, 并且需要以<code>;</code>结束</li><li>一个类可以同时<strong>继承一个父类</strong>和<strong>实现任意个接口</strong>, <code>extends</code>子句应该在<code>inplements</code> 子句之前;</li><li>一个比较重要的概念是: <strong>实现接口的类接受了它继承的类以及实现的接口的类型</strong>; (对于面向对象来说, 依赖抽象而不依赖具体)</li></ul></li><li><p>final关键字</p></li><li><p>~~未完待续</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;类常量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类常量是公共的&lt;/li&gt;
&lt;li&gt;只能通过&lt;code&gt;类名&lt;/code&gt;, 使用 &lt;code&gt;::&lt;/code&gt; 静态访问类常量 (也可以使用实例化的对象通过&lt;code&gt;::&lt;/code&gt;来访问类常量)&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>02. 延迟静态绑定static关键字</title>
    <link href="http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-02/"/>
    <id>http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-02/</id>
    <published>2018-04-21T07:03:35.000Z</published>
    <updated>2018-04-21T10:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>延迟静态绑定是在PHP5.3引入的;</p></li><li><p><code>static</code>类似于<code>self</code>, 但它指的是调用 包含<code>static</code>的方法 的调用类, 而不是包含<code>static</code>的类;</p></li><li><p>一般 <code>static</code> 和 <code>self</code> 的使用语法有下面两种</p><ul><li><p><code>new static()</code> 与 <code>new self()</code> (用作实例化)</p></li><li><p><code>self::</code> 与 <code>static::</code> (静态方法调用)</p></li></ul></li><li><p>如何理解第2点中的意思</p><ul><li><p>如下, <code>Male</code>与<code>Female</code> 两个类分别继承自 <code>Human</code>, 并且继承了<code>createSelf()</code>方法, 结果却发现, <code>Male</code> 和 <code>Female</code> 调用<code>createSelf()</code>后, 创建的却是 <code>Human</code> 对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Human</div><div class="line">&#123;</div><div class="line">    public function createSelf()</div><div class="line">    &#123;</div><div class="line">        return new self();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Human</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Human</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">var_dump($boy-&gt;createSelf());</div><div class="line">$girl = new Female();</div><div class="line">var_dump($girl-&gt;createSelf());</div></pre></td></tr></table></figure></li><li><p>如果<code>Human</code>是个抽象类, 你甚至无法使用 <code>new self()</code><br><img src="/img/oop/php/static-self.png" width="350/"></p></li></ul></li><li><p>而使用了<code>new static()</code>效果就不一样了</p><ul><li>下面, <code>Male</code>与<code>Female</code> 两个类分别继承自 <code>Human</code>, 并且继承了<code>createSelf()</code>方法, 结果 <code>Male</code> 和 <code>Female</code> 调用<code>createSelf()</code>后, 创建的也都是各自的对象实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">abstract class Huma</div><div class="line">&#123;</div><div class="line">    public function createSelf()</div><div class="line">    &#123;</div><div class="line">        return new static();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Huma</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Huma</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">var_dump($boy-&gt;createSelf());</div><div class="line">$girl = new Female();</div><div class="line">var_dump($girl-&gt;createSelf());</div></pre></td></tr></table></figure></li></ul></li><li><p><code>static</code> 和 <code>self</code> 在调用静态方法时也是一样的</p><ul><li><p>如下结果, 两个类都是 <code>Hello!</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">abstract class Huma</div><div class="line">&#123;</div><div class="line">    public static function createSelf()</div><div class="line">    &#123;</div><div class="line">        self::say();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;Hello!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Male&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Female&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">$boy-&gt;createSelf();</div><div class="line">$girl = new Female();</div><div class="line">$girl-&gt;createSelf();</div></pre></td></tr></table></figure></li><li><p>如果想在父类的<code>公共静态方法</code>中, 调用子类自己重载的<code>静态方法</code>, 那就需要使用 <code>static::</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">abstract class Huma</div><div class="line">&#123;</div><div class="line">    public static function createSelf()</div><div class="line">    &#123;</div><div class="line">        static::say();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;Hello!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Male&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Female&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">$boy-&gt;createSelf(); // I am a Male</div><div class="line">$girl = new Female();</div><div class="line">$girl-&gt;createSelf();   // I am a Female</div></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;延迟静态绑定是在PHP5.3引入的;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;static&lt;/code&gt;类似于&lt;code&gt;self&lt;/code&gt;, 但它指的是调用 包含&lt;code&gt;static&lt;/code&gt;的方法 的调用类, 而不是包含&lt;code&gt;s
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>01. 普通非静态 与 静态</title>
    <link href="http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-01/"/>
    <id>http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-01/</id>
    <published>2018-04-21T06:16:26.000Z</published>
    <updated>2018-04-21T10:51:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对于-属性-来说"><a href="#对于-属性-来说" class="headerlink" title="对于 属性 来说"></a>对于 <code>属性</code> 来说</h2><h3 id="类内部的调用方式"><a href="#类内部的调用方式" class="headerlink" title="类内部的调用方式"></a>类内部的调用方式</h3><ol><li><code>静态属性</code>是<strong>类</strong>的属性</li><li><code>普通属性</code>是<strong>类具体实例化出的对象</strong>的属性</li><li>所以二者是完全不同的, <code>调用方式</code>也非常不同<ul><li>静态属性 <code>self::$静态属性名</code> 、<code>类名::$静态属性名</code></li><li>普通属性 <code>$this-&gt;普通属性名</code></li></ul></li></ol><h3 id="类外部的调用方式"><a href="#类外部的调用方式" class="headerlink" title="类外部的调用方式"></a>类外部的调用方式</h3><ol><li><code>静态属性</code>是<strong>类</strong>的属性</li><li><code>普通属性</code>是<strong>类具体实例化出的对象</strong>的属性</li><li>所以二者是完全不同的, <code>调用方式</code>也非常不同<ul><li>静态属性 <code>类名::$静态属性名</code></li><li>普通属性 <code>实例化对象-&gt;普通属性名</code></li></ul></li></ol><h2 id="对于-方法-来说"><a href="#对于-方法-来说" class="headerlink" title="对于 方法 来说"></a>对于 <code>方法</code> 来说</h2><p>对于方法, 无论 <code>普通</code>还是<code>静态</code>, 它们都是属于类的, 所以理论上, 它们的调用方式 <code>-&gt;/::</code> 是可以互换的, 但事实上, 还是应该严格区分, 否则可能会报 <code>Deprecated...</code>;</p><h3 id="类内部的调用方式-1"><a href="#类内部的调用方式-1" class="headerlink" title="类内部的调用方式"></a>类内部的调用方式</h3><ol><li><code>普通方法</code> 可以使用 <code>$this-&gt;普通方法名()</code> 来进行调用;<ul><li>也可以使用 <code>self::$普通方法名()</code></li></ul></li><li><p><code>静态方法</code> 可以使用 <code>self::$静态方法名()</code> / <code>类名::$静态方法名()</code> 来进行调用;</p><ul><li>也可以使用 <code>$this-&gt;$静态方法名()</code></li></ul></li><li><p><strong>即类内部 <code>普通方法</code> 和 <code>静态方法</code> 的调用方式可以互换</strong>;</p></li></ol><h2 id="类外部的调用方式-1"><a href="#类外部的调用方式-1" class="headerlink" title="类外部的调用方式"></a>类外部的调用方式</h2><ol><li><p><code>普通方法</code> 可以使用 <code>实例化对象-&gt;普通方法名()</code> 来进行调用;</p><ul><li><strong>注意</strong>: 使用 <code>类名::普通方法名()</code> / <code>实例化对象::普通方法名()</code> 都会报 <code>Deprecated:非静态方法不应该按照镜头盖方法的调用方式来使用</code></li></ul></li><li><p><code>静态方法</code> 可以使用 <code>类名::$静态方法名()</code> 来进行调用;</p><ul><li><strong>注意</strong>：静态方法也可以使用 <code>实例化对象-&gt;普通方法名()</code> 来进行调用; (<strong>静态属性不可以</strong>)</li></ul></li></ol><h2 id="静态-非静态方法中的调用权限"><a href="#静态-非静态方法中的调用权限" class="headerlink" title="静态/非静态方法中的调用权限"></a>静态/非静态方法中的调用权限</h2><ol><li>静态方法中只能使用 静态调用方式<code>::</code>来调用 <code>静态属性</code>, <code>静态方法</code>, <code>非静态方法</code>; 不能使用<code>::</code>调用<code>非静态属性</code>;</li><li>非静态普通方法中可以调用 <code>静态/非静态</code> 的 <code>属性/方法</code>;</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>静态属性/方法, 只能通过 <code>::</code> 来访问;</li><li>普通属性只能通过 <code>-&gt;</code> 来访问; </li><li>普通方法能通过 <code>-&gt;/::</code> 来访问; (类外部只能通过<code>-&gt;</code>) </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对于-属性-来说&quot;&gt;&lt;a href=&quot;#对于-属性-来说&quot; class=&quot;headerlink&quot; title=&quot;对于 属性 来说&quot;&gt;&lt;/a&gt;对于 &lt;code&gt;属性&lt;/code&gt; 来说&lt;/h2&gt;&lt;h3 id=&quot;类内部的调用方式&quot;&gt;&lt;a href=&quot;#类内部的调用方式
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://blog.renyimin.com/2018/04/08/2018-04-08-rsa-01/"/>
    <id>http://blog.renyimin.com/2018/04/08/2018-04-08-rsa-01/</id>
    <published>2018-04-08T02:41:16.000Z</published>
    <updated>2018-04-08T05:14:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>加密和解密使用同样的规则(“密钥”);</p><ul><li>这种加密模式有一个最大弱点: 甲方必须把加密规则告诉乙方, 否则乙方无法解密; 这样, <code>保存和传递密钥</code> 就成了最头疼的问题;</li></ul><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li><p>非对称加密算法模式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">乙方生成两把密钥(公钥和私钥): 公钥是公开的, 任何人都可以获得, 私钥则是保密的;</div><div class="line">甲方获取乙方的公钥, 然后用它对信息加密;</div><div class="line">乙方得到加密后的信息, 用私钥解密;</div></pre></td></tr></table></figure></li><li><p><strong>如果公钥加密的信息只有私钥解得开, 那么只要私钥不泄漏, 通信就是安全的</strong>;</p></li><li><p>所谓非对称加密，其实很简单，就是加密和解密需要两把钥匙: 一把公钥和一把私钥;</p><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3></li><li><p>1977年, 三位数学家Rivest、Shamir 和 Adleman 设计了一种算法, 可以实现<code>非对称加密</code>, 这种算法用他们三个人的名字命名, 叫做<code>RSA算法</code>。从那时直到现在, RSA算法一直是最广为使用的”非对称加密算法”。<br> 毫不夸张地说, 只要有计算机网络的地方, 就有RSA算法;</p></li><li><p>这种算法非常可靠, 密钥越长, 它就越难破解。根据已经披露的文献, 目前被破解的最长RSA密钥是768个二进制位, 也就是说, 长度超过768位的密钥, 还无法破解(至少没人公开宣布)。<br> 因此可以认为, <strong>1024位的RSA密钥基本安全, 2048位的密钥极其安全</strong>;</p></li></ol><h3 id="RSA算法的原理"><a href="#RSA算法的原理" class="headerlink" title="RSA算法的原理"></a>RSA算法的原理</h3><p>RSA算法并不难, 只需要一点数论知识就可以理解 (要用到的四个数学概念)</p><p>~~ 未完待续</p><ol><li>互质关系<br> 如果两个正整数, 除了1以外, 没有其他公因子，我们就称这两个数是<code>互质关系</code>(coprime), 比如, 15和32没有公因子, 所以它们是互质关系;<br> 这说明, 不是质数也可以构成互质关系。(质数(prime number)又称素数, 有无限个, 质数定义为在大于1的自然数中, 除了1和它本身以外不再有其他因数)     </li><li>关于互质关系, 不难得到以下结论:<ul><li>任意两个质数构成互质关系, 比如13和61;</li><li>一个数是质数, 另一个数只要不是前者的倍数, 两者就构成互质关系, 比如3和10;</li><li>如果两个数之中, 较大的那个数是质数, 则两者构成互质关系, 比如97和57;</li><li>1和任意一个自然数是都是互质关系，比如1和99;</li><li>p是大于1的整数, 则p和p-1构成互质关系, 比如57和56;</li><li>p是大于1的奇数, 则p和p-2构成互质关系, 比如17和15;</li></ul></li><li></li></ol><p><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对称加密算法&quot;&gt;&lt;a href=&quot;#对称加密算法&quot; class=&quot;headerlink&quot; title=&quot;对称加密算法&quot;&gt;&lt;/a&gt;对称加密算法&lt;/h2&gt;&lt;p&gt;加密和解密使用同样的规则(“密钥”);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这种加密模式有一个最大弱点: 甲方必须把加
      
    
    </summary>
    
      <category term="RSA" scheme="http://blog.renyimin.com/categories/RSA/"/>
    
    
      <category term="RSA" scheme="http://blog.renyimin.com/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>PHP7语法新特性</title>
    <link href="http://blog.renyimin.com/2018/04/04/PHP/2018-04-04-php7new-base/"/>
    <id>http://blog.renyimin.com/2018/04/04/PHP/2018-04-04-php7new-base/</id>
    <published>2018-04-04T01:32:02.000Z</published>
    <updated>2018-04-04T02:30:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="null合并运算符"><a href="#null合并运算符" class="headerlink" title="null合并运算符 ??"></a>null合并运算符 <code>??</code></h3><ol><li><p><code>??</code> : 如果变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数;</p></li><li><p>先回顾一下 <code>isset</code> 用法: 只有 <code>显示声明为null</code> 或者 <code>未声明</code> 的变量, isset的结果为false</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$a = 0;</div><div class="line">$b = 0.0;</div><div class="line">$c = &apos;&apos;;</div><div class="line">$d = &apos;0&apos;;</div><div class="line">$e = &apos;0.0&apos;;</div><div class="line">$f = &apos;null&apos;;</div><div class="line">$g = [];</div><div class="line">$h = [&apos;name&apos; =&gt; &apos;renyimin&apos;, &apos;age&apos; =&gt; null];</div><div class="line">$i = null;</div><div class="line">var_dump(isset($a));    // true</div><div class="line">var_dump(isset($b));    // true</div><div class="line">var_dump(isset($c));    // true</div><div class="line">var_dump(isset($d));    // true</div><div class="line">var_dump(isset($e));    // true</div><div class="line">var_dump(isset($f));    // true</div><div class="line">var_dump(isset($g));    // true</div><div class="line"></div><div class="line">var_dump(isset($h[&apos;age&apos;])); // false</div><div class="line">// 注意: array_key_exists 即使键的值为null, 结果也是true</div><div class="line">var_dump(array_key_exists(&apos;age&apos;, $h));  // true</div><div class="line"></div><div class="line">var_dump(isset($h[&apos;address&apos;])); // false</div><div class="line">// 注意: array_key_exists 即使键的值为null, 结果也是true, 除非键真的不存在</div><div class="line">var_dump(array_key_exists(&apos;address&apos;, $h));  // false</div><div class="line"></div><div class="line">var_dump(isset($h[&apos;address&apos;])); // false</div><div class="line">var_dump(isset($i));    // false</div><div class="line">var_dump(isset($j));    // false</div></pre></td></tr></table></figure></li><li><p><code>??</code> 示例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$a = 0;</div><div class="line">$c = $a ?? 10;  // 相当于 $c = isset($a) ? $a : 10;</div><div class="line">echo $c;</div></pre></td></tr></table></figure></li></ol><p>~~ 未完待续</p><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;null合并运算符&quot;&gt;&lt;a href=&quot;#null合并运算符&quot; class=&quot;headerlink&quot; title=&quot;null合并运算符 ??&quot;&gt;&lt;/a&gt;null合并运算符 &lt;code&gt;??&lt;/code&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;??&lt;/code
      
    
    </summary>
    
      <category term="PHP" scheme="http://blog.renyimin.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.renyimin.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>103. 分区管理</title>
    <link href="http://blog.renyimin.com/2018/03/28/mysql/2018-03-28-mysql-103/"/>
    <id>http://blog.renyimin.com/2018/03/28/mysql/2018-03-28-mysql-103/</id>
    <published>2018-03-28T02:41:26.000Z</published>
    <updated>2018-03-28T02:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h2><p>MySQL5.1 提供了许多修改分区表的方式, 添加、删除、重新定义、合并或拆分已经存在的分区是可能的, 所有这些操作都可以通过使用<code>ALTER TABLE</code>命令的分区扩展来实现; 当然, 也有获得分区表和分区信息的方式;</p><h3 id="drop删除分区及数据"><a href="#drop删除分区及数据" class="headerlink" title="drop删除分区及数据"></a>drop删除分区及数据</h3><ol><li><p><code>mysql&gt; alter table user drop partition p4;</code></p></li><li><p><strong>注意</strong>: </p><ul><li><p>只能对每个分区进行删除, 不能针对每个子分区进行删除操作, 删除分区后子分区连同数据一并被删除;</p></li><li><p>删除分区后, 数据也被删除了;</p></li><li><p><strong><code>drop partition</code>删除分区的语法, 只能用于 <code>range/list</code> 分区</strong> (如果用来删除hash分区或者key分区,则会报错)</p></li><li><p>如果要删除 <code>hash/key</code> 分区, 则直接使用下面remove来移除分区即可, 一般也不直接删除数据;</p></li></ul></li></ol><h3 id="remove移除分区"><a href="#remove移除分区" class="headerlink" title="remove移除分区"></a>remove移除分区</h3><ol><li><p>使用remove移除分区, 注意仅仅是移除分区, <strong>并不会删除数据</strong> (和drop PARTITION不一样, 后者会连同数据一起删除)</p></li><li><p><code>ALTER TABLE tablename REMOVE PARTITIONING;</code> 这样就可以将一个原本分区的数据表变成不分区的表</p><ul><li><p>移除分区前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">0B    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p><code>ALTER TABLE</code>user<code>REMOVE PARTITIONING;</code> 移除分区后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user.MYD</div><div class="line">4.0K    user.MYI</div><div class="line">12K    user.frm</div></pre></td></tr></table></figure></li></ul></li><li><p>注意: 该语法是可以适用于 <code>range/list/key/hash</code> 类型的分区的;</p></li></ol><h3 id="创建不同类型分区"><a href="#创建不同类型分区" class="headerlink" title="创建不同类型分区"></a>创建不同类型分区</h3><h3 id="分区创建索引-整表创建索引"><a href="#分区创建索引-整表创建索引" class="headerlink" title="分区创建索引(整表创建索引)"></a>分区创建索引(整表创建索引)</h3><h3 id="新增分区"><a href="#新增分区" class="headerlink" title="新增分区"></a>新增分区</h3><h3 id="新增不同类型分区"><a href="#新增不同类型分区" class="headerlink" title="新增不同类型分区"></a>新增不同类型分区</h3><h3 id="合并分区"><a href="#合并分区" class="headerlink" title="合并分区"></a>合并分区</h3><ol><li><p>原本分区结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">4.0K    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p>合并 p2, p3这两个分区 </p><ul><li>分区并无子分区<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE tb_sub_ev REORGANIZE PARTITION p2,p3 INTO (</div><div class="line">    PARTITION m_p2_p3 VALUES LESS THAN (2000)</div><div class="line">    ( SUBPARTITION n0,</div><div class="line">        SUBPARTITION n1</div><div class="line">    ) </div><div class="line">);</div></pre></td></tr></table></figure></li></ul></li></ol><h3 id="拆分分区"><a href="#拆分分区" class="headerlink" title="拆分分区"></a>拆分分区</h3><h3 id="重新分区"><a href="#重新分区" class="headerlink" title="重新分区"></a>重新分区</h3><h2 id="每日自动新增分区"><a href="#每日自动新增分区" class="headerlink" title="每日自动新增分区"></a>每日自动新增分区</h2><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分区管理&quot;&gt;&lt;a href=&quot;#分区管理&quot; class=&quot;headerlink&quot; title=&quot;分区管理&quot;&gt;&lt;/a&gt;分区管理&lt;/h2&gt;&lt;p&gt;MySQL5.1 提供了许多修改分区表的方式, 添加、删除、重新定义、合并或拆分已经存在的分区是可能的, 所有这些操作都可以
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>102. 分区键, 主键, 唯一索引关系</title>
    <link href="http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-102/"/>
    <id>http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-102/</id>
    <published>2018-03-27T07:46:51.000Z</published>
    <updated>2018-03-28T02:09:40.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>若表有 <code>primary key</code> 或 <code>unique key</code>, 在对表进行分区时, 需要注意: <code>分区键</code> 必须包含在primary key或unique key列内, 这是为了确保主键的效率, 否则同一主键区的数据一个在Ａ分区, 一个在Ｂ分区, 显然会比较麻烦;<br> 可以说: 在分区表上, 用于分区表达式里的每一个字段都必须是<code>唯一性索引</code>的<code>一部分</code>;</p></li><li><p>如何理解上面的概念?</p></li><li><p>如果表中既有<code>主键</code>, 也有<code>唯一索引</code>: 无论<code>单列键</code>还是<code>多列键</code>分区都会失败</p><ul><li><p>单列唯一索引键分区报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `user` (  </div><div class="line">    `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;,  </div><div class="line">    `name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">    `sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男，1为女&apos;,</div><div class="line">`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,</div><div class="line">    PRIMARY KEY (`id`),</div><div class="line">UNIQUE KEY `age_unique` (`age`)</div><div class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8</div><div class="line">PARTITION BY RANGE COLUMNS (`age`)</div><div class="line">(</div><div class="line">PARTITION p0 VALUES LESS THAN (3),  </div><div class="line">PARTITION p1 VALUES LESS THAN (6),</div><div class="line">PARTITION p2 VALUES LESS THAN (9),  </div><div class="line">PARTITION p3 VALUES LESS THAN (12),  </div><div class="line">PARTITION p4 VALUES LESS THAN (MAXVALUE)</div><div class="line">);</div><div class="line">// 1503 - A PRIMARY KEY must include all columns in the table&apos;s partitioning function, Time: 0.011000s</div></pre></td></tr></table></figure></li><li><p>单列主键分区报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>),</p><pre><code>UNIQUE KEY `age_unique` (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);<br>// 1503 - A UNIQUE INDEX must include all columns in the table’s partitioning function, Time: 0.008000s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 多列(主键和唯一索引键)分区报错</div></pre></td></tr></table></figure><p>// 两列做分区也是失败的, 如下会报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>),</p><pre><code>UNIQUE KEY `age_unique` (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>,<code>age</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3, 10),<br>  PARTITION p1 VALUES LESS THAN (6, 15),<br>  PARTITION p2 VALUES LESS THAN (9, 20),<br>  PARTITION p3 VALUES LESS THAN (12, 25),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);<br>// 1503 - A PRIMARY KEY must include all columns in the table’s partitioning function, Time: 0.012000s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">4. 表中只有`主键`: 分区键属于主键内的键即可 (多列分区, 需要将列与主键一起作为主键才行)</div><div class="line">    - 分区键属于主键内的键即可</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 如果想多列分区, 则需要将多余的列与主键一起作为主键</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>, <code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>,<code>age</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3, 10),<br>  PARTITION p1 VALUES LESS THAN (6, 15),<br>  PARTITION p2 VALUES LESS THAN (9, 20),<br>  PARTITION p3 VALUES LESS THAN (12, 25),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">5. 表中只有`唯一索引`: 分区键属于`唯一索引键`内的键即可 (多列分区, 需要将多个列一起作为唯一索引)</div><div class="line">    - 分区键属于`唯一索引键`内的键即可</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  UNIQUE KEY (<code>id</code>, <code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 多列分区报错(竟然是报主键错): 1503 - A PRIMARY KEY must include all columns in the table&apos;s partitioning function, Time: 0.012000s</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br><code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br><code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br><code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,<br>  <code>age</code> int(2) NOT NULL DEFAULT ‘0’ COMMENT ‘年龄’,<br>UNIQUE KEY id_u (<code>id</code>),<br>  UNIQUE KEY age_u (<code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>, <code>age</code>)<br>(<br>PARTITION p0 VALUES LESS THAN (3,10),<br>PARTITION p1 VALUES LESS THAN (6,15),<br>PARTITION p2 VALUES LESS THAN (9,20),<br>PARTITION p3 VALUES LESS THAN (12,25),<br>PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- **多个唯一索引: 无论单列分区还是多列分区, 都会报错**</div></pre></td></tr></table></figure><p>// 单列分区报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  UNIQUE KEY id_u (<code>id</code>),</p><pre><code>UNIQUE KEY age_u (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);<br>```</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li></ul></li></ol><ul><li>要进行分区, 表中不能同时存在<code>主键</code>和<code>唯一索引键</code>, 也不能存在多个唯一索引键;</li><li>分区的键必须包含在<code>主键</code>内 或者 包含在<code>唯一索引键</code>内;</li><li>本篇只是测试了<code>range</code>这种分区类型, 其实上面的限制对于<code>range/list/hash/key</code>类型的分区都适用;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;若表有 &lt;code&gt;primary key&lt;/code&gt; 或 &lt;code&gt;unique key&lt;/code&gt;, 在对表进行分区时, 需要注意: &lt;code&gt;分区键&lt;/code&gt; 必须包含在primary key或unique key列内, 这是为了确保主键
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>101. 分区,分表,分库</title>
    <link href="http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-101/"/>
    <id>http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-101/</id>
    <published>2018-03-27T03:37:12.000Z</published>
    <updated>2018-03-28T02:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>MySQL是从5.1开始支持分区功能的, 在MySQL中, 数据是以文件的形势存在磁盘上的, 默认放在 ‘/mysql/data/‘ 下(可以通过my.cnf中的datadir来指定)</p></li><li><p>MyISAM引擎中, 一张表主要对应着三个文件: </p><ul><li><code>.frm</code>(与表相关的元数据信息都存放在frm文件, 包括表结构的定义信息等)</li><li><code>.myd</code>(存放表数据)</li><li><code>.myi</code>(存表索引)</li></ul></li><li><p>InnoDB引擎中, 一张表也是对应着三个文件: </p><ul><li><code>.frm</code>(和MyISAM差不多)</li><li><code>.ibd</code>文件和<code>.ibdata</code>文件, 都是存放innodb数据的文件, 之所以用两种文件来存放innodb的数据, 是因为innodb的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据, 还是用独享表空间存放存储数据<br>独享表空间存储方式使用.ibd文件,并且每个表一个ibd文件;<br>共享表空间存储方式使用.ibdata文件，所有表共同使用一个ibdata文件<br>可在mysql的配置文件通过<code>innodb_file_per_table</code>进行配置</li></ul></li><li><p>如果一张表的数据量太大, <code>.ibd</code>, <code>.myd</code>, <code>.myi</code> 之类的文件就会变的很大, 查找数据就会变的很慢, 此时就可以利用mysql的分区功能, 在物理上将这一张表对应的三个文件, 分割成许多个小块, 这样之后, 如果查找一条数据时, 就不用全部查找了, 只要知道这条数据在哪一块, 然后在那一块找即可;<br> 如果表的数据太大, 可能一个磁盘放不下, 此时, 还可以把数据分配到不同的磁盘里面去;</p></li></ol><h2 id="查看当前MySQL版本是否支持分区"><a href="#查看当前MySQL版本是否支持分区" class="headerlink" title="查看当前MySQL版本是否支持分区"></a>查看当前MySQL版本是否支持分区</h2><ol><li><p>对于MySQL5.6以下版本, 如果查询结果显示Empty, 表示不支持分区:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show variables like &apos;%partition%&apos;;</div><div class="line">Empty set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>对于mysql5.6以及以上版本, 需要使用下面的查询命令:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show plugins;</div></pre></td></tr></table></figure><p> 上面的查询方法会显示所有插件, 如果有如下插件的话, 表示支持分区:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| partition                  | ACTIVE   | STORAGE ENGINE     | NULL    | GPL     |</div></pre></td></tr></table></figure></li></ol><h2 id="分区的2种方式"><a href="#分区的2种方式" class="headerlink" title="分区的2种方式"></a>分区的2种方式</h2><h3 id="横向分区"><a href="#横向分区" class="headerlink" title="横向分区"></a>横向分区</h3><p>横向分区: 比如, 有1000W条数据, 分成十份, 前10W条数据放到第一个分区, 第二个10W条数据放到第二个分区, 依此类推; </p><ul><li>也就是把表分成了十份(和使用<code>merge</code>来分表有点像, 取出一条数据的时候, 这条数据包含了表结构中的所有字段);</li><li>横向分区, 并没有改变表的结构;</li></ul><h3 id="纵向分区"><a href="#纵向分区" class="headerlink" title="纵向分区"></a>纵向分区</h3><p>纵向分区: 比如, 在设计用户表的时候, 开始的时候没有考虑好, 把用户的所有信息都放到了一张表里面去, 这样这个表里面就会有比较大的字段, 如个人简介..等, 而这些简介也许不会有好多人去看，所以等到有人要看的时候, 再去查找(分表的时候, 可以把这样的大字段与主表分开来);</p><h2 id="横向分区-1"><a href="#横向分区-1" class="headerlink" title="横向分区"></a>横向分区</h2><p>mysql提供的分区属于第一种 <code>横向分区</code>, 并且细分成很多种方式</p><h3 id="range分区"><a href="#range分区" class="headerlink" title="range分区"></a>range分区</h3><ol><li><p>按照<code>RANGE</code>分区的表是通过如下方式进行分区的, 分区表达式的值位于一个给定的连续区间内的那些行, 会被放到一个分区中</p><ul><li><p>创建表同时进行分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `user` (  </div><div class="line">`id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;,  </div><div class="line">`name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">`sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男，1为女&apos;,  </div><div class="line">PRIMARY KEY (`id`)  </div><div class="line">) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1  </div><div class="line">PARTITION BY RANGE (id) (  </div><div class="line">PARTITION p0 VALUES LESS THAN (3),  </div><div class="line">PARTITION p1 VALUES LESS THAN ( 6 ),</div><div class="line">PARTITION p2 VALUES LESS THAN (9),  </div><div class="line">PARTITION p3 VALUES LESS THAN (12),  </div><div class="line">PARTITION p4 VALUES LESS THAN MAXVALUE  </div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>查看分区效果 (到数据表文件的存放处 <code>$ cd /Library/Application\ Support/appsolute/MAMP\ PRO/db/mysql56/</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">0B    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">0B    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">0B    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">0B    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">0B    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p>插入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">INSERT INTO `test`.`user` (`name` ,`sex`)VALUES (&apos;tank&apos;, &apos;0&apos;)  </div><div class="line">,(&apos;zhang&apos;,1),(&apos;ying&apos;,1),(&apos;张&apos;,1),(&apos;映&apos;,0),(&apos;test1&apos;,1),(&apos;tank2&apos;,1)  </div><div class="line">,(&apos;tank1&apos;,1),(&apos;test2&apos;,1),(&apos;test3&apos;,1),(&apos;test4&apos;,1),(&apos;test5&apos;,1),(&apos;tank3&apos;,1)  </div><div class="line">,(&apos;tank4&apos;,1),(&apos;tank5&apos;,1),(&apos;tank6&apos;,1),(&apos;tank7&apos;,1),(&apos;tank8&apos;,1),(&apos;tank9&apos;,1)  </div><div class="line">,(&apos;tank10&apos;,1),(&apos;tank11&apos;,1),(&apos;tank12&apos;,1),(&apos;tank13&apos;,1),(&apos;tank21&apos;,1),(&apos;tank42&apos;,1);</div></pre></td></tr></table></figure></li><li><p>再次查看分区效果<br>如下可以看到, 文件大小都是4.0K, 从这儿我们可以看出<strong>MyISAM引擎下, 分区的最小区块是4K (InnoDB貌似是96k)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">4.0K    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li></ul></li><li><p>数据测试</p><ul><li><p>初始数据为25条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select count(id) as count from user;</div><div class="line">+-------+</div><div class="line">| count |</div><div class="line">+-------+</div><div class="line">|    25 |</div><div class="line">+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>删除第四个分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; alter table user drop partition p4; </div><div class="line">Query OK, 0 rows affected (0.15 sec)</div><div class="line">Records: 0  Duplicates: 0  Warnings: 0</div></pre></td></tr></table></figure></li><li><p>可以发现, 存放在第四个分区里面的14条数据丢失了, 剩下的3个分区只有11条数据  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select count(id) as count from user; </div><div class="line">+-------+</div><div class="line">| count |</div><div class="line">+-------+</div><div class="line">|    11 |</div><div class="line">+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>查看分区文件, 发现第四个分区确实被删除了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li></ul></li><li><p>小结: 可以发现, 在进行range分区后</p><ul><li>会生成一个 <code>.par</code>文件,用来存储分区信息;</li><li>MyISAM/InnoDB引擎, 原有的 <code>.frm</code> 表结构文件没有被分隔;</li><li>MyISAM引擎, 原有的 <code>.MYD</code>数据文件, <code>.MYI</code>索引文件都被分隔了;</li><li>InnoDB引擎, 原有的 <code>.idb</code>数据文件被分隔了;</li></ul></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li></ul></li></ol><h3 id="List分区"><a href="#List分区" class="headerlink" title="List分区"></a>List分区</h3><ol><li><p>RANGE分区是从属于一个连续区间值的集合, 而LIST分区是基于某列的值从属于一个值列表集中的一个值</p></li><li><p>如果不用主键, 如下list分区可以创建成功，一般情况下, 一张表肯定会有一个主键(所以如果需要用其他键来做分区, 参考下一篇博文<a href="2017/12/17/mysql/2017-12-17-mysql-102/">分区键, 主键, 唯一索引关系</a>)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `list_part` (  </div><div class="line">`id` int(11) NOT NULL COMMENT &apos;用户ID&apos;,  </div><div class="line">`province_id` int(2) NOT NULL DEFAULT 0 COMMENT &apos;省&apos;,  </div><div class="line">`name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">`sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男, 1为女&apos;</div><div class="line">) ENGINE=INNODB DEFAULT CHARSET=utf8</div><div class="line">PARTITION BY LIST (province_id) (  </div><div class="line">PARTITION p0 VALUES IN (1,2,3,4,5,6,7,8),  </div><div class="line">PARTITION p1 VALUES IN (9,10,11,12,16,21),  </div><div class="line">PARTITION p2 VALUES IN (13,14,15,19),  </div><div class="line">PARTITION p3 VALUES IN (17,18,20,22,23,24)</div><div class="line">);</div><div class="line"></div><div class="line">// 创建成功, 会看到分区效果 (InnoDB默认分区最小是96k)</div><div class="line">$ ls |grep list_part |xargs du -sh</div><div class="line">96K    list_part#P#p0.ibd</div><div class="line">96K    list_part#P#p1.ibd</div><div class="line">96K    list_part#P#p2.ibd</div><div class="line">96K    list_part#P#p3.ibd</div><div class="line">12K    list_part.frm</div><div class="line">4.0K    list_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="hash分区"><a href="#hash分区" class="headerlink" title="hash分区"></a>hash分区</h3><ol><li><p>HASH分区主要用来确保数据在预先确定数目的分区中平均分布, 你所要做的只是</p><ul><li>对将要被哈希的列值, 指定一个列值或表达式;</li><li>指定被分区的表将要被分割成的分区数量;</li><li>对HASH分区，使用的用户函数必须返回一个大于0的整数值;</li></ul></li><li><p>创建表同时进行hash分区</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `hash_part` (  </div><div class="line">`id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;评论ID&apos;,  </div><div class="line">`comment` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;评论&apos;,  </div><div class="line">`ip` varchar(25) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;来源IP&apos;,  </div><div class="line">PRIMARY KEY (`id`)  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1  </div><div class="line">PARTITION BY HASH(id)  </div><div class="line">PARTITIONS 3;</div></pre></td></tr></table></figure></li><li><p>查看分区效果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ls |grep hash_part |xargs du -sh</div><div class="line">96K    hash_part#P#p0.ibd</div><div class="line">96K    hash_part#P#p1.ibd</div><div class="line">96K    hash_part#P#p2.ibd</div><div class="line">12K    hash_part.frm</div><div class="line">4.0K    hash_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="key分区"><a href="#key分区" class="headerlink" title="key分区"></a>key分区</h3><ol><li><p>按照KEY进行分区, 类似于按照HASH分区</p><ul><li>HASH分区是使用用户定义的表达式</li><li>而KEY分区的哈希函数是由MySQL服务器提供</li></ul></li><li><p>创建表同时进行key分区</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `key_part` (  </div><div class="line">`news_id` int(11) NOT NULL  COMMENT &apos;新闻ID&apos;,  </div><div class="line">`content` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;新闻内容&apos;,  </div><div class="line">`u_id` varchar(25) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;来源IP&apos;,  </div><div class="line">`create_time` DATE NOT NULL DEFAULT &apos;0000-00-00 00:00:00&apos; COMMENT &apos;时间&apos;  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8  </div><div class="line">PARTITION BY LINEAR HASH(YEAR(create_time))  </div><div class="line">PARTITIONS 3;</div></pre></td></tr></table></figure></li><li><p>查看分区效果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ls |grep key_part |xargs du -sh</div><div class="line">96Kkey_part#P#p0.ibd</div><div class="line">96Kkey_part#P#p1.ibd</div><div class="line">96Kkey_part#P#p2.ibd</div><div class="line">12Kkey_part.frm</div><div class="line">4.0Kkey_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h3><ol><li><p>子分区是分区表中每个分区的再次分割, 对于已经通过<code>RANGE</code>或<code>LIST</code>分区了的表再进行子分区是可能的, 子分区既可以使用<code>HASH</code>分区, 也可以使用<code>KEY</code>分区; 这也被称为复合分区(composite partitioning)</p><ul><li>如果一个分区中创建了子分区, 其他分区也要有子分区</li><li>如果创建了子分区, 每个分区中的<strong>子分区数必须相同</strong></li><li>同一分区内的子分区, 名字不相同, 不同分区内的子分区名子可以相同(5.1.50不适用)</li></ul></li><li><p>创建表同时, 进行子分区操作</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `sub_part` (  </div><div class="line">`news_id` int(11) NOT NULL  COMMENT &apos;新闻ID&apos;,  </div><div class="line">`content` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;新闻内容&apos;,  </div><div class="line">`u_id`  int(11) NOT NULL DEFAULT 0 COMMENT &apos;来源IP&apos;,  </div><div class="line">`create_time` DATE NOT NULL DEFAULT &apos;0000-00-00 00:00:00&apos; COMMENT &apos;时间&apos;  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8  </div><div class="line">PARTITION BY RANGE(YEAR(create_time))  </div><div class="line">SUBPARTITION BY HASH(TO_DAYS(create_time))(  </div><div class="line">    PARTITION p0 VALUES LESS THAN (1990)(</div><div class="line">        SUBPARTITION s0,SUBPARTITION s1,SUBPARTITION s2</div><div class="line">    ),  </div><div class="line">    PARTITION p1 VALUES LESS THAN (2000)(</div><div class="line">        SUBPARTITION s3,SUBPARTITION s4,SUBPARTITION good</div><div class="line">    ),  </div><div class="line">    PARTITION p2 VALUES LESS THAN MAXVALUE(</div><div class="line">        SUBPARTITION tank0,SUBPARTITION tank1,SUBPARTITION tank3</div><div class="line">    )  </div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>查看分区后, 数据表文件结构</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ ls |grep sub_part |xargs du -sh</div><div class="line">96K    sub_part#P#p0#SP#s0.ibd</div><div class="line">96K    sub_part#P#p0#SP#s1.ibd</div><div class="line">96K    sub_part#P#p0#SP#s2.ibd</div><div class="line">96K    sub_part#P#p1#SP#good.ibd</div><div class="line">96K    sub_part#P#p1#SP#s3.ibd</div><div class="line">96K    sub_part#P#p1#SP#s4.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank0.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank1.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank3.ibd</div><div class="line">12K    sub_part.frm</div><div class="line">4.0K    sub_part.par</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;MySQL是从5.1开始支持分区功能的, 在MySQL中, 数据是以文件的形势存在磁盘上的, 默认放在 ‘/mysql/d
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Restful</title>
    <link href="http://blog.renyimin.com/2018/03/16/http/2018-03-06-restful/"/>
    <id>http://blog.renyimin.com/2018/03/16/http/2018-03-06-restful/</id>
    <published>2018-03-16T11:36:23.000Z</published>
    <updated>2018-05-09T06:31:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>REST本身并没有创造新的技术, 组件或服务, 主要指的是一组<strong>架构约束条件和原则</strong>, 隐藏在RESTful背后的理念就是<strong>使用Web的现有特征和能力, 更好地使用现有Web标准中的一些准则和约束</strong>; 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。</p><p>虽然REST本身受Web技术的影响很深, 但是理论上REST架构风格并不是绑定在HTTP上, 只不过目前HTTP是唯一与REST相关的实例;</p><p>所以通常描述的REST也是通过HTTP实现的REST;</p><h2 id="URI的设计"><a href="#URI的设计" class="headerlink" title="URI的设计"></a>URI的设计</h2><ol><li><p>URI的设计应该遵循可寻址性原则, 具有<strong>自描述性</strong>, 需要在形式上给人以直觉上的关联; 比如:</p><ul><li><p>用<code>_</code>或<code>-</code>来让URI可读性更好<br>例如国内比较出名的开源中国社区, 它上面的新闻地址就采用这种风格, 如 <a href="http://www.oschina.net/news/38119/oschina-translate-reward-plan" target="_blank" rel="external">http://www.oschina.net/news/38119/oschina-translate-reward-plan</a></p></li><li><p>使用<code>/</code>来表示资源的层级关系<br>例如 <a href="https://github.com/rymuscle/chat/issues" target="_blank" rel="external">https://github.com/rymuscle/chat/issues</a> 就表示了一个多级的资源, 指的是rymuscle用户的chat项目的issues列表</p></li><li><p>使用<code>?</code>用来过滤资源 (如果记录数量很多，服务器不可能都将它们返回给用户, 比如分页等筛选条件)<br>很多人只是把<code>?</code>简单的当做是参数的传递, 很容易造成URI过于复杂、难以理解; 其实可以把<code>?</code>用于对资源的过滤;<br>例如 <code>https://github.com/rymuscle/chat/pulls</code> 用来表示git项目的所有推入请求;<br>而 <code>/pulls?state=closed</code> 用来表示git项目中已经关闭的推入请求, 这种URL通常对应的是一些特定条件的查询结果或算法运算结果;</p></li><li><p><code>,</code>或<code>;</code>可以用来表示同级资源的关系</p></li></ul></li><li><p>URI里带上版本号, 如 <code>https://api.example.com/v1/</code> (Github就是这样做的)<br> 另一种做法是, 将版本号放在HTTP头信息中, 但不如放入URL方便和直观;</p></li><li><p><strong>URI中只应该描述清楚资源的名称</strong>, 而不应该包括资源的操作(因为统一资源接口要求使用标准的HTTP方法对资源进行操作, 方法都是有语义的, 所以已经明确描述了这次的操作含义)</p><ul><li>URI不应该再使用动作来描述, 如下就是一些不符合统一接口要求的URI (它们都在URI中对操作进行了描述):<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET /getUser/1</div><div class="line">POST /createUser</div><div class="line">PUT /updateUser/1</div><div class="line">DELETE /deleteUser/1</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2><p>接口应该使用标准的HTTP方法如GET，PUT和POST，并<strong>遵循这些方法的语义</strong>(通过明确的方法来描述操作), 可以参考博文 <a href="/2016/11/30/http/2016-11-30-HTTP-03/">HTTP各请求方法详解</a> 或者 <a href="http://www.runoob.com/w3cnote/restful-architecture.html" target="_blank" rel="external">Restful架构详解</a></p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>状态码应该使用HTTP标准状态码 可以参考博文 <a href="/2016/11/30/http/2016-11-30-HTTP-01/#状态码详解">HTTP协议预览</a></p><p>更多<a href="http://cizixs.com/2016/12/12/restful-api-design-guide" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;REST本身并没有创造新的技术, 组件或服务, 主要指的是一组&lt;strong&gt;架构约束条件和原则&lt;/strong&gt;, 隐藏在RESTful背
      
    
    </summary>
    
      <category term="Restful" scheme="http://blog.renyimin.com/categories/Restful/"/>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/Restful/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
      <category term="Restful" scheme="http://blog.renyimin.com/tags/Restful/"/>
    
  </entry>
  
  <entry>
    <title>yield 协程</title>
    <link href="http://blog.renyimin.com/2018/01/13/PHP/2018-01-13-yield/"/>
    <id>http://blog.renyimin.com/2018/01/13/PHP/2018-01-13-yield/</id>
    <published>2018-01-13T05:20:31.000Z</published>
    <updated>2018-04-04T09:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h2 id="迭代生成器"><a href="#迭代生成器" class="headerlink" title="迭代生成器"></a>迭代生成器</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li><p>(迭代)生成器也是一个函数, 返回的是一个<code>迭代器</code>, 而这个<code>迭代器</code>实现了<code>Iterator接口</code>, 所以叫<code>迭代生成器</code>;</p></li><li><p>和普通函数不同, 由于(迭代)生成器返回的是一个迭代器, 所以(迭代)生成器函数中的返回值可以依次返回, 而不是只返回一个单独的值; 或者换句话说, (迭代)生成器使你能更方便的实现了迭代器接口;</p></li><li><p>引用网上常见的示例</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">function xrange($start, $end, $step = 1) &#123;</div><div class="line">    for ($i = $start; $i &lt;= $end; $i += $step) &#123;</div><div class="line">        yield $i;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// var_dump(xrange(1, 1000000));   // object(Generator)[1]</div><div class="line">foreach (xrange(1, 1000000) as $num) &#123;</div><div class="line">    echo $num;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>上面这个 xrange() 函数提供了和PHP的内建函数range()一样的功能, 但是不同的是range()函数返回的是一个包含值从1到100万0的数组; <strong>而xrange()函数返回的是依次输出这些值的一个迭代器, 而不会真正以数组形式返回</strong>;</p><ul><li>这种方法的优点是显而易见的, 它可以让你在处理大数据集合的时候不用一次性的加载到内存中, 甚至你可以处理无限大的数据流;</li><li>当然, 也可以不通过生成器来实现这个功能, 而是可以通过继承Iterator接口实现, 但通过使用生成器实现起来会更方便, 不用再去实现iterator接口中的5个方法了;</li></ul></li></ol><h3 id="生成器内部"><a href="#生成器内部" class="headerlink" title="生成器内部"></a>生成器内部</h3><ol><li><p>要从<code>生成器</code>认识<code>协程</code>, 理解它内部是如何工作是非常重要的: 生成器是一种可中断的函数, 在它里面的<code>yield</code>构成了中断点;<br> 像上面的例子, 调用xrange(1,1000000)的时候, xrange()函数里代码其实并没有真正地运行, 它只是返回了一个迭代器;</p></li><li><p>调用迭代器的方法一次, 其中的代码运行一次, 例如:</p><ul><li>如果你调用生成器返回的迭代器的rewind方法 <code>$range-&gt;rewind()</code>, 那么xrange()里的代码就会运行到控制流第一次出现yield的地方, 而函数内传递给yield语句的返回值, 可以通过$range-&gt;current()获取;</li><li>为了继续执行生成器中yield后的代码, 你就需要调用迭代器的 <code>$range-&gt;next()</code> 方法, 这将再次启动生成器, 直到下一次yield语句出现; 因此, 连续调用next()和current()方法, 你就能从生成器里获得所有的值,直到再没有yield语句出现;</li><li>对xrange()来说, 这种情形出现在$i超过$end时, 在这种情况下, 控制流将到达函数的终点, 因此将不执行任何代码, 一旦这种情况发生, vaild()方法将返回假, 这时迭代结束;</li><li><p>示例1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">function gen() &#123;</div><div class="line">    var_dump(&apos;cat&apos;);</div><div class="line">    yield &apos;t&apos;;</div><div class="line">    var_dump(&apos;dog&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$gen = gen();</div><div class="line">$gen-&gt;rewind();   // 指针会走到第一个yield处, 所以会经过 cat</div><div class="line">var_dump($gen-&gt;current());  // 获取第一个yield处的值</div><div class="line">var_dump(&apos;----------&apos;);</div><div class="line">$gen-&gt;next();  // 会往下走, 走到下一个yield处, 所以会经过 dog</div><div class="line">var_dump($gen-&gt;current());  // 获取下一个yield处的值 (但是后面已经没有yield了, 所以为null)</div><div class="line"></div><div class="line">// 结果:</div><div class="line">string(3) &quot;cat&quot;</div><div class="line">string(1) &quot;t&quot;</div><div class="line">string(10) &quot;----------&quot;</div><div class="line">string(3) &quot;dog&quot;</div><div class="line">NULL</div></pre></td></tr></table></figure></li><li><p>示例2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">function gen() &#123;</div><div class="line">    var_dump(&apos;cat&apos;);</div><div class="line">    yield &apos;t&apos;;</div><div class="line">    var_dump(&apos;dog&apos;);</div><div class="line">    yield &apos;g&apos;;</div><div class="line">    var_dump(&apos;pig&apos;);</div><div class="line">    yield &apos;p&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$gen = gen();</div><div class="line">$gen-&gt;rewind();   // 指针会走到第一个yield处, 所以会经过 cat</div><div class="line">var_dump($gen-&gt;current());  // 获取第一个yield处的值</div><div class="line">var_dump(&apos;----------&apos;);</div><div class="line"></div><div class="line">$gen-&gt;next();  // 会往下走, 走到下一个yield处, 所以会经过 dog</div><div class="line">var_dump($gen-&gt;current());  // 获取下一个yield处的值 (但是后面已经没有yield了, 所以为null)</div><div class="line">var_dump(&apos;----------&apos;);</div><div class="line"></div><div class="line">$gen-&gt;next();  // 会往下走, 走到下一个yield处, 所以会经过 pig</div><div class="line">var_dump($gen-&gt;current());  // 获取下一个yield处的值 (p)</div><div class="line"></div><div class="line">var_dump(&apos;----------&apos;);</div><div class="line">$gen-&gt;next();  // 会往下走, 什么也没有</div><div class="line">var_dump($gen-&gt;current());  // 获取下一个yield处的值 (为null)</div><div class="line"></div><div class="line">// 结果</div><div class="line">string(3) &quot;cat&quot;</div><div class="line">string(1) &quot;t&quot;</div><div class="line">string(10) &quot;----------&quot;</div><div class="line">string(3) &quot;dog&quot;</div><div class="line">string(1) &quot;g&quot;</div><div class="line">string(10) &quot;----------&quot;</div><div class="line">string(3) &quot;pig&quot;</div><div class="line">string(1) &quot;p&quot;</div><div class="line">string(10) &quot;----------&quot;</div><div class="line">NULL</div></pre></td></tr></table></figure></li></ul></li><li><p>上面示例中使用(迭代)生成器时, <code>yield</code> 都只是简单地作为一个<code>语句</code>来使用, 这样只能实现 <strong>生成器到调用者的单向通信</strong>;</p></li></ol><p>迭代器在进行循环(迭代)前, 需要先进行<code>rewind</code>;</p><h3 id="简单理解-协程-Coroutine"><a href="#简单理解-协程-Coroutine" class="headerlink" title="简单理解 协程(Coroutine)"></a>简单理解 <code>协程(Coroutine)</code></h3><ol><li><p>协程的支持是在迭代生成器的基础上, 增加了<strong>调用者可以回送数据给生成器</strong>的功能(调用者发送数据给被调用的生成器函数), <strong>这就把生成器到调用者的单向通信</strong>转变为<strong>两者之间的双向通信</strong>;</p></li><li><p>调用者传递数据给生成器, 是通过迭代器的<code>send()</code>方法实现的; 下面就是一个简单的协程示例, 用来演示这种通信如何运行的</p><ul><li><p>下面例子可以看到在生成器内部, <code>yield</code> 不再是简单的语句, 而是一个可以接收调用者参数并进行赋值的<code>表达式</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">function gen() &#123;</div><div class="line">    var_dump(&apos;cat&apos;);</div><div class="line">    $ret1 = (yield &apos;yield1&apos;);</div><div class="line">    var_dump($ret1 . &apos;dog&apos;);</div><div class="line">    $ret2 = (yield &apos;yield2&apos;);</div><div class="line">    var_dump($ret2 . &apos;pig&apos;);</div><div class="line">&#125;</div><div class="line">$gen = gen();</div><div class="line">$gen-&gt;rewind();     // 指针会走到第一个 yield 处, 所以会经过 cat</div><div class="line">// cat</div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;current());</div><div class="line">// yield1</div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;send(&apos;lala&apos;));   // 如果第一次send之前没有rewind将指针指向第一个yield, 则send会: 自动先进行一次rewind</div><div class="line">                                // 2. 由于指针还在第一个yield处, 此时send传递参数还是传到第一个yield处 (yield &apos;yield1&apos;)</div><div class="line">                                // 3. 执行next 到下一个yield (会经过 $ret.dog )</div><div class="line">                                // 4. 返回next之后的yield值(yield &apos;yield2&apos; )</div><div class="line">// laladog</div><div class="line">// yield2</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;current());      // 到了第二个yield处, 由于没有传递至, 所以可以通过current直接获取 yield &apos;yield2&apos; 传给调用者的 &apos;yield2&apos;</div><div class="line">// yield2</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;send(&apos;haha&apos;));   // 由于指针没变, 还在第二个yield处, 传递了 haha 给生成器</div><div class="line">                                // 然后执行了next 继续往下走, 会经过 var_dump($ret . &apos;pig&apos;);</div><div class="line">                                // 返回next之后的yield值 (已经进行了next, 而之后没有yield了, 所以会返回null)</div><div class="line">// hahapig</div><div class="line">// null</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;current());      // 由于上面已经走了next, 而下面啥都没有了......</div><div class="line">// null</div></pre></td></tr></table></figure></li><li><p>第一次send会默认执行rewind</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">function gen() &#123;</div><div class="line">    var_dump(&apos;cat&apos;);</div><div class="line">    $ret1 = (yield &apos;yield1&apos;);</div><div class="line">    var_dump($ret1 . &apos;dog&apos;);</div><div class="line">    $ret2 = (yield &apos;yield2&apos;);</div><div class="line">    var_dump($ret2 . &apos;pig&apos;);</div><div class="line">&#125;</div><div class="line">$gen = gen();</div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;send(&apos;lala&apos;));   // 如果第一次send之前没有rewind将指针指向第一个yield, 则send会: 自动先进行一次rewind (所以也会经过 cat )</div><div class="line">                                // 2. 由于指针还在第一个yield处, 此时send传递参数还是传到第一个yield处 (yield &apos;yield1&apos;)</div><div class="line">                                // 3. 执行next 到下一个yield (会经过 $ret.dog )</div><div class="line">                                // 4. 返回next之后的yield值(yield &apos;yield2&apos; )</div><div class="line">// cat</div><div class="line">// laladog</div><div class="line">// yield2</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;current());      // 到了第二个yield处, 由于没有传递至, 所以可以通过current直接获取 yield &apos;yield2&apos; 传给调用者的 &apos;yield2&apos;</div><div class="line">// yield2</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;send(&apos;haha&apos;));   // 由于指针没变, 还在第二个yield处, 传递了 haha 给生成器</div><div class="line">                                // 然后执行了next 继续往下走, 会经过 var_dump($ret . &apos;pig&apos;);</div><div class="line">                                // 返回next之后的yield值 (已经进行了next, 而之后没有yield了, 所以会返回null)</div><div class="line">// hahapig</div><div class="line">// null</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;current());      // 由于上面已经走了next, 而下面啥都没有了......</div><div class="line">// null</div><div class="line"></div><div class="line">//function foo() &#123;</div><div class="line">//    $string = yield;</div><div class="line">//    echo $string;</div><div class="line">//    for ($i = 1; $i &lt;= 3; $i++) &#123;</div><div class="line">//        yield $i;</div><div class="line">//    &#125;</div><div class="line">//&#125;</div><div class="line">//</div><div class="line">//$generator = foo();</div><div class="line">//$generator-&gt;send(&apos;Hello world!&apos;);</div><div class="line">//foreach ($generator as $value) echo &quot;$value\n&quot;;</div></pre></td></tr></table></figure></li></ul></li><li><p>更多小例子 (<a href="http://php.net/manual/zh/generator.send.php" target="_blank" rel="external">可参考PHP手册</a>)</p><ul><li><p>可以迭代三次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">function printer() &#123;</div><div class="line">    $i = 3;</div><div class="line">    while ($i&gt;0) &#123;</div><div class="line">        echo 33;</div><div class="line">        $string = yield;</div><div class="line">        echo $string;</div><div class="line">        $i--;</div><div class="line">        echo $i;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$printer = printer();</div><div class="line">$printer-&gt;send(&apos;Hello world!&apos;);</div><div class="line">echo &quot;&lt;br/&gt;++++++++++&lt;br/&gt;&quot;;</div><div class="line">$printer-&gt;send(&apos;haha&apos;);</div><div class="line">echo &quot;&lt;br/&gt;++++++++++&lt;br/&gt;&quot;;</div><div class="line">$printer-&gt;send(&apos;heihei&apos;);</div></pre></td></tr></table></figure></li><li><p>可以一直迭代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">function printer() &#123;</div><div class="line">    while (true) &#123;</div><div class="line">        echo 33;</div><div class="line">        $string = yield;</div><div class="line">        echo $string;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$printer = printer();</div><div class="line">$printer-&gt;send(&apos;Hello world!&apos;);</div><div class="line">echo &quot;&lt;br/&gt;++++++++++&lt;br/&gt;&quot;;</div><div class="line">$printer-&gt;send(&apos;haha&apos;);</div><div class="line">echo &quot;&lt;br/&gt;++++++++++&lt;br/&gt;&quot;;</div><div class="line">$printer-&gt;send(&apos;heihei&apos;);</div><div class="line">echo &quot;&lt;br/&gt;++++++++++&lt;br/&gt;&quot;;</div><div class="line">$printer-&gt;send(&apos;heihei2&apos;);</div></pre></td></tr></table></figure></li></ul></li><li><p>个人感觉重点在于理解调用者发出<code>send()</code>后, <code>send()</code>的执行包括<code>next()</code>及<code>返回</code> (以及, 如果是初次执行send的话, 会隐式执行<code>rewind</code>); </p><ul><li>也可以参考<a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="external">鸟哥博客对send的说明</a><br><img src="/img/PHP/yield-send.png" width="400/"></li></ul></li></ol><h2 id="协程实现任务调度"><a href="#协程实现任务调度" class="headerlink" title="协程实现任务调度"></a>协程实现<code>任务调度</code></h2><ol><li><p>上面的例子比较简单, 可能无法体系会到协程的优点, 接下来可以尝试利用<code>协程</code>去实现<code>多任务调度</code></p><ul><li>要解决的问题是当你想并发地运行多任务(或者”程序”)时, 我们都知道CPU在一个时刻只能运行一个任务(不考虑多核的情况), 因此处理器需要在不同的任务之间进行切换, 而且总是让每个任务<code>运行一小会儿</code>;</li><li>多任务协作这个术语中的<code>协作</code>很好的说明了如何进行这种切换的: 它要求当前正在运行的任务<strong>自动</strong>把控制传回给调度器, 这样就可以运行其他任务了;<br>这与<code>抢占多任务</code>相反, 抢占多任务是这样的: 调度器可以中断运行了一段时间的任务, 不管它喜欢还是不喜欢;<br>协作多任务在Windows的早期版本(windows95)和Mac OS中有使用, 不过它们后来都切换到使用抢先多任务了, <strong>理由相当明确</strong>: 如果你依靠程序自动交出控制的话, <strong>那么一些恶意的程序将很容易占用整个CPU, 不与其他任务共享</strong>;</li></ul></li><li><p>现在你应当明白协程和任务调度之间的关系: </p><ul><li>yield指令提供了任务中断自身的一种方法, 然后把控制交回给任务调度器;</li><li><p>因此协程可以运行多个其他任务, 更进一步来说, <code>yield</code>可以用来在<code>任务</code>和<code>调度器</code>之间进行通信;</p><p>手册中这个例子有空可以稍稍微品味一下: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">function nums() &#123;</div><div class="line">    for ($i = 0; $i &lt; 5; ++$i) &#123;</div><div class="line">        //get a value from the caller</div><div class="line">        $cmd = (yield $i);</div><div class="line"></div><div class="line">        if($cmd == &apos;stop&apos;) return;//exit the function</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$gen = nums();</div><div class="line">foreach($gen as $v)</div><div class="line">&#123;</div><div class="line">    if($v == 3)//we are satisfied</div><div class="line">        $gen-&gt;send(&apos;stop&apos;);</div><div class="line"></div><div class="line">    echo &quot;&#123;$v&#125;\n&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li><li><p>多任务调度的实现</p><ul><li><p>两个使用协程函数的任务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function task1() &#123;</div><div class="line">    for ($i = 1; $i &lt;= 10; ++$i) &#123;</div><div class="line">        echo &quot;This is task 1 iteration $i.\n&quot;;</div><div class="line">        yield;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function task2() &#123;</div><div class="line">    for ($i = 1; $i &lt;= 5; ++$i) &#123;</div><div class="line">        echo &quot;This is task 2 iteration $i.\n&quot;;</div><div class="line">        yield;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Task任务类包装 任务协程函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">/**</div><div class="line"> * 如代码, 一个任务就是用任务ID标记的一个协程(函数).</div><div class="line"> * 使用setSendValue()方法, 你可以指定哪些值将被发送到下次的恢复(在之后你会了解到我们需要这个),</div><div class="line"> * run()函数确实没有做什么, 除了调用send()方法的协同程序</div><div class="line"> * 要理解为什么添加了一个 beforeFirstYieldflag变量</div><div class="line"> */</div><div class="line">class Task &#123;</div><div class="line">    protected $taskId;</div><div class="line">    protected $coroutine;</div><div class="line">    protected $sendValue = null;</div><div class="line">    protected $beforeFirstYield = true;</div><div class="line"></div><div class="line">    public function __construct($taskId, Generator $coroutine) &#123;</div><div class="line">        $this-&gt;taskId = $taskId;</div><div class="line">        $this-&gt;coroutine = $coroutine;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function getTaskId() &#123;</div><div class="line">        return $this-&gt;taskId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//    public function setSendValue($sendValue) &#123;</div><div class="line">//        $this-&gt;sendValue = $sendValue;</div><div class="line">//    &#125;</div><div class="line"></div><div class="line">    public function run() &#123;</div><div class="line">        // 由于send的特性, 会导致先next, 所以下面在设置了一个初始标志beforeFirstYield, 初始时, 先获取了current</div><div class="line">        if ($this-&gt;beforeFirstYield) &#123;</div><div class="line">            $this-&gt;beforeFirstYield = false;</div><div class="line">            return $this-&gt;coroutine-&gt;current();</div><div class="line">        &#125; else &#123;</div><div class="line">            // 注意: 执行send之后会返回next之后的yield值</div><div class="line">            $retval = $this-&gt;coroutine-&gt;send(&apos;目前还没用到双向通信&apos;);</div><div class="line">            return $retval;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function isFinished() &#123;</div><div class="line">        return !$this-&gt;coroutine-&gt;valid();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>实现Scheduler调度器类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Scheduler &#123;</div><div class="line">    protected $maxTaskId = 0;</div><div class="line">    protected $taskMap = []; // taskId =&gt; task</div><div class="line">    protected $taskQueue;</div><div class="line"></div><div class="line">    public function __construct() &#123;</div><div class="line">        $this-&gt;taskQueue = new SplQueue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function newTask(Generator $coroutine) &#123;</div><div class="line">        // 生成任务id</div><div class="line">        $tid = ++$this-&gt;maxTaskId;</div><div class="line">        // 将协程函数封包到Task类中 作为任务</div><div class="line">        $task = new Task($tid, $coroutine);</div><div class="line">        // 放入调度器的任务池中</div><div class="line">        $this-&gt;taskMap[$tid] = $task;</div><div class="line">        // 将任务放入调度器的队列中</div><div class="line">        $this-&gt;schedule($task);</div><div class="line">        return $tid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function schedule(Task $task) &#123;</div><div class="line">        $this-&gt;taskQueue-&gt;enqueue($task);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function run() &#123;</div><div class="line">        while (!$this-&gt;taskQueue-&gt;isEmpty()) &#123;</div><div class="line">            // 从调度器队列中弹出任务, 准备执行</div><div class="line">            $task = $this-&gt;taskQueue-&gt;dequeue();</div><div class="line">            // 执行任务</div><div class="line">            $task-&gt;run();</div><div class="line"></div><div class="line">            // 如果任务执行完毕, 则从调度器的任务池中清除任务</div><div class="line">            if ($task-&gt;isFinished()) &#123;</div><div class="line">                unset($this-&gt;taskMap[$task-&gt;getTaskId()]);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 否则, 再次将弹出的任务放入调度器的任务队列中</div><div class="line">                $this-&gt;schedule($task);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>测试 test.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">require_once &apos;Task.php&apos;;</div><div class="line">require_once &apos;Scheduler.php&apos;;</div><div class="line"></div><div class="line">function task1() &#123;</div><div class="line">    for ($i = 1; $i &lt;= 10; ++$i) &#123;</div><div class="line">        echo &quot;This is task 1 iteration $i.\n&quot;;</div><div class="line">        yield;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function task2() &#123;</div><div class="line">    for ($i = 1; $i &lt;= 5; ++$i) &#123;</div><div class="line">        echo &quot;This is task 2 iteration $i.\n&quot;;</div><div class="line">        yield;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$scheduler = new Scheduler;</div><div class="line">$scheduler-&gt;newTask(task1());</div><div class="line">$scheduler-&gt;newTask(task2());</div><div class="line">$scheduler-&gt;run();</div></pre></td></tr></table></figure></li></ul></li><li><p>当然, 上面是具有两个简单任务(没什么意义的任务)的调度器;</p></li></ol><h2 id="任务和调度器之间的通信"><a href="#任务和调度器之间的通信" class="headerlink" title="任务和调度器之间的通信"></a>任务和调度器之间的通信</h2><ol><li><p>上面可以看到, 调度器已经运行了, 那么我们来看下一个问题: <strong>任务和调度器之间的通信</strong>;</p></li><li><p>接下来将模拟 进程和操作系统进行会话时的方式 – <code>系统调用</code>, 来做任务和调度器之间的通信<br>我们需要<code>系统调用</code>的理由是操作系统与进程相比它处在不同的权限级别上, 因此为了执行特权级别的操作(如杀死另一个进程), 就不得不以某种方式把控制传回给内核, 这样内核就可以执行所说的操作了;<br> 再说一遍, 这种行为在内部是通过使用<code>中断指令</code>来实现的. 过去使用的是通用的int指令, 如今使用的是更特殊并且更快速的syscall/sysenter指令;</p></li><li><p>我们的任务调度系统将反映这种设计: 不是简单地把调度器传递给任务(这样就允许它做它想做的任何事), 我们将通过给yield表达式传递信息来与系统调用通信, 这儿yield即是中断, 也是传递信息给调度器(和从调度器传递出信息)的方法;</p></li><li><p>为了说明系统调用, 我们对可调用的系统调用做一个小小的封装:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure></li></ol><p>~~未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h2&gt;&lt;h2 id=&quot;迭代生成器&quot;&gt;&lt;a href=&quot;#迭代生成器&quot; class=&quot;headerlink&quot; title=&quot;迭代生成器&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="PHP" scheme="http://blog.renyimin.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.renyimin.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>08. 并行连接, 持久连接</title>
    <link href="http://blog.renyimin.com/2017/12/06/http/2017-12-06-HTTP-08/"/>
    <id>http://blog.renyimin.com/2017/12/06/http/2017-12-06-HTTP-08/</id>
    <published>2017-12-06T12:10:11.000Z</published>
    <updated>2018-05-09T06:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常被误解的Connection首部"><a href="#常被误解的Connection首部" class="headerlink" title="常被误解的Connection首部"></a>常被误解的<code>Connection</code>首部</h2><ol><li><p>HTTP允许在客户端和最终的源端服务器之间存在一串HTTP中间实体(代理, 高速缓存等)。可以从客户端开始, 逐跳地将HTTP报文经过这些中间设备, 转发到源端服务器上去(或者进行反向传递)。</p></li><li><p>HTTP的 <code>Connection</code> 首部字段中有一个由<code>,</code>分隔的连接标签列表;</p></li><li><p>Connection首部可以承载3种不同类型的标签, 因此非常令人费解:</p><ul><li>HTTP首部字段名, 列出了只与此链接有关的首部; </li><li>任意标签值, 用于描述此链接的非标准选项;</li><li>close, 说明操作完成之后需要关闭这条持久连接;</li></ul></li><li><p>如果连接标签中包含了一个HTTP首部字段的名称, 那么这个首部字段就包含了一些连接有关的信息, 不能将其转发出去, 在将报文转发出去之前, 必须删除Connection首部列出的所有首部字段。</p><ul><li>由于Connection首部可以防止无意中对本地首部的转发, 因此将逐跳字首部名放入Connection首部被称为”对首部的保护”。<br>(<strong>Connection首部是个逐跳首部, 只适用于单条传输链路, 不应该沿着传输链路向下传输</strong> (参考P101))<br><img src="/img/http/connection-not-field.png" width="550/"></li></ul></li></ol><h2 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h2><ol><li><p>在串行请求时, 浏览器可以先完整地请求原始的HTML页面, 然后请求第一个嵌入对象, 然后请求第二个嵌入对象等, 以这种简单的方式对每个嵌入式对象进行串行处理, 很明显这样处理很慢!!</p></li><li><p>HTTP允许客户端打开多条连接, 并行地执行多个HTTP事务, 如下图, 并行加载了四幅嵌入式图片, 每个事务都有自己的TCP连接:<br> <img src="/img/http/http-concurrence-request-01.png" width="550/"></p></li><li><p>并行连接可能会提高页面的加载速度</p><ul><li>包含嵌入对象的组合页面如果能通过并行连接克服单条连接的空载时间和带宽限制, 加载速度也会有所提高。时延可以重叠起来, 而且如果单条连接没有充分利用客户端的因特网带宽, 可以将为用带宽分配来装载其他对象。</li><li>如下图, 串行和并行的对比, 并行情况下, 先装载的是封闭的HTML页面, 然后并行处理其余3个事务, 每个事务都有自己的连接。(图片的装载是并行的, 连接的时延也是重叠的)<br><img src="/img/http/chuanxing-01.png" width="550/"><br><img src="/img/http/http-concurrence-request-02.png" width="550/"></li><li>由于软件开销的存在, 每个连接请求之间总会有一些小的时延, 但连接请求和传输时间<strong>基本上</strong>都是重叠起来的!</li></ul></li><li><p>并行连接不一定更快<br> <strong>即使并行连接的速度可能会更快, 但是并不一定总是更快</strong></p><blockquote><p>因为在客户端的网络带宽如果不足时, 大部分的时间可能都是用来传送数据的。在这种情况下, 一个连接到速度较快服务器上的HTTP事务就会很容易耗尽所有可用的Modem带宽。<br> 如果并行加载多个对象, 每个对象都会去竞争这有限的带宽, 每个对象都会以较慢的速度按比例加载, 这样带来的性能提升就很小, 甚至没什么提升。<br> 而且打开大量连接会消耗很多内存资源, 从而引发自身性能问题。<br> 复杂的Web有可能会有数十或数百个内嵌对象, 客户端可能可以打开数百个连接, 但Web服务器通常要同时处理很多其他用户的请求, 所以很少有Web服务器希望出现这样的情况。<br> 一百个用户同时发出申请, 每个用户打开100个连接, 服务器就要负责处理1W个连接, 这会造成服务器性能的严重下降。对高负荷的代理来说也同样如此。<br> 实际上, 浏览器确实使用了并行连接, 但它们会将并行连接的总数限制为一个较小的值(通常是四个)。服务器可以随意关闭来自特定客户端的超量连接。</p></blockquote></li><li><p><strong>并行连接可能让人”感觉”更快一些</strong><br>通过上面的介绍, 我们知道并行连接并不总是能使页面加载更快, 但即使实际上没有加快页面的传输速度, 并行连接通常也会让用户<code>觉得</code>页面加载的更快了,<br>因为多个组件对象同时出现屏幕上时, 用户能够看到加载的进展。如果整个屏幕上有很多动作在进行, 即使实际上整个页面的下载时间更长, 用户也会认为Web页面加载得更快一些。</p></li></ol><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><ol><li><p>HTTP/1.1(以及HTTP/1.0的各种增强版本)允许HTTP设备在事务处理结束之后将TCP连接保持在打开状态, 以便未来的HTTP请求能够重用现存的连接。在事务处理结束之后仍然保持在打开状态的TCP连接被称为<strong>持久连接</strong>。</p></li><li><p>非持久连接会在每个事务结束之后关闭, 持久连接会在不同事务之间保持打开状态, 直到客户端或服务器其决定将其关闭为止。</p></li><li><p>重用已对目标服务器打开的空闲持久连接, 就可以避开缓慢的连接建立阶段。而且已经打开的连接还可以避免慢启动的拥塞使用阶段, 以便更快速地进行数据的传输。</p></li><li><p>持久连接和并行连接</p><blockquote><p>之前已经了解过”并行连接可以提高复合页面的传输速度, 但并行连接也有一些缺点”;<br>而持久连接有一些比并行连接更好的地方,持久连接降低了时延和连接建立的开销, 将连接保持在已调谐状态, 而且减少了打开连接的潜在数量。<br>但是, 管理持久连接时要特别小心, 不然就会积累大量的空闲连接, 耗费本地以及远程客户端和服务器上的资源。</p></blockquote><p> 持久连接与并行连接配合使用可能是更高效的方式。现在, 很多Web应用程序都会打开少量的并行连接, 其中的每一个都是持久连接。</p></li><li><p>持久连接有两种类型: 比较老的 <code>HTTP/1.0+&quot;keep-alive&quot;</code> 连接, 以及现代的 <code>HTTP/1.1 &quot;persistent&quot;</code> 连接。</p></li></ol><h2 id="HTTP-1-0-keep-alive连接"><a href="#HTTP-1-0-keep-alive连接" class="headerlink" title="HTTP/1.0+keep-alive连接"></a>HTTP/1.0+keep-alive连接</h2><ol><li><p>前言:<br>大约从1996年开始, 很多HTTP/1.0浏览器和服务器都进行了扩展, 以支持一种被称为keep-alive连接的早期实验型持久连接。<br>这些早期的持久连接收到了一些互操作性设计方面问题的困扰, 这些问题在后期的HTTP/1.1版本中都得到了修正, 但很多客户端和服务器仍然在使用这些早期的keep-alive连接。</p></li><li><p>下图在”串行连接上实现了4个HTTP事务的时间线” 与 “在一条持久连接上实现同样事务” 所需的时间线进行了比较, <strong>显示了keep-alive连接的一些性能优点</strong><br> <strong>由于去除了创建连接和关闭连接的开销, 所以时间线有所缩减</strong><br> <img src="/img/http/keep-alive-vs-chuanxing.png" width="500/"></p></li></ol><h3 id="Keep-Alive操作"><a href="#Keep-Alive操作" class="headerlink" title="Keep-Alive操作"></a><strong>Keep-Alive操作</strong></h3><p>客户端和服务器要配合</p><ol><li><p>keep-alive已经不再使用了, 而且在当前的HTTP/1.1规范中也已经没有了对它的说明了。但浏览器和服务器对keep-alive握手的使用仍然相当广泛, 因此HTTP的实现者应该做好与之进行交互操作的准备.</p></li><li><p>实现HTTP/1.0 keep alive连接的客户端可以通过包含<code>Connection: Keep-Alive</code>首部请求将一条连接保持在打开状态。</p></li><li><p>如果服务器愿意为下一条请求将连接保持在打开状态, 就在响应中包含相同的首部。如果响应中没有<code>Connection: Keep-Alive</code>首部, 客户端就认为服务器不支持keep-alive, 会在发回响应报文之后关闭连接。</p></li></ol><h3 id="还有keep-alive首部"><a href="#还有keep-alive首部" class="headerlink" title="还有keep-alive首部"></a>还有keep-alive首部</h3><ol><li><p>注意, keep-Alive首部只是请求将连接保持在活跃状态。发出keep-alive请求之后, 客户端和服务器并不一定会同意进行keep-alive会话。<br> 它们可以在任意时刻关闭空闲的keep-alive连接, 并可随意限制keep-alive连接所处理事务的数量。</p></li><li><p>可以用<code>Keep-Alive通用首部字段</code>中指定的, 有逗号分隔的选项来调节keep-alive的行为:</p><ul><li>参数timeout: 是在Keep-Alive响应首部发送的, 它估计了服务器希望将连接保持在活跃状态的时间。这并不是一个承诺值。</li><li>参数max: 是在Keep-Alive响应首部发送的, 它估计了服务器还希望为多少个事务保持此连接的活跃状态。这并不是一个承诺值。</li><li>Keep-Alive首部还可以支持任意未经处理的属性, 这些属性主要用于诊断和调试。语法为 <code>name [=value]</code>。</li></ul></li><li><p>Keep-Alive首部完全是可选的, 但只有在提供了 Connection:Keep-Alive 时才能使用它。<br> 下面这个例子说明服务器最多还会为另外5个事务保持连接的打开状态, 或者将打开状态保持到连接空闲了2分钟之后。</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Connection: Keep-Alive</div><div class="line">Keep-Alive: max=<span class="number">5</span>, timeout=<span class="number">120</span></div></pre></td></tr></table></figure></li></ol><h3 id="keep-alive连接的限制和规则"><a href="#keep-alive连接的限制和规则" class="headerlink" title="keep-alive连接的限制和规则"></a>keep-alive连接的限制和规则</h3><ol><li><p>在HTTP/1.0中, keep-alive并不是默认使用的。客户端必须发送一个 <code>Connection: Keep-Alive</code> 请求首部来激活keep-alive连接。</p></li><li><p>Connection: Keep-Alive 首部必须随所有希望保持持久连接的报文一起发送。<br> 如果客户端没有发送Connection: Keep-Alive首部, 服务器就会在那条请求之后关闭连接。</p></li><li><p>客户端如果探明响应中没有Connection: Keep-Alive响应首部, 就可以知道服务器发出响应之后是否会关闭连接了。</p></li><li><p>一般都是在检测到连接关闭之后, 就可以确定报文实体主体部分的长度。如果想”无需检测到连接关闭 就能确定报文实体主体部分的长度”,<br> 那你的响应报文的实体主体部分必须有正确的Connect-Length, 有多部件媒体类型, 或者用分块传输编码的方式进行了编码。<br> 在一条keep-alive信道中回送错误的 Connection-Length 是很糟糕的事, 这样的话, 事务处理的另一端就无法精确地检测出一条报文的结束和另一条报文的开始了。</p></li><li><p>代理和网关必须执行Connection首部的规则, 代理或网关必须在将报文转发出去或将其高速缓存之前, 删除在Connection首部中命名的所有首部字段以及Connection首部本身。</p></li><li><p>严格来说, 不应该与无法确定是否支持Connection首部的代理服务器建立keep-alive连接, 以防止出现下面要介绍的<code>哑代理</code>问题, 在实际应用中不是总能做到这一点的。 </p></li><li><p>从技术上来讲, 应该忽略所有来自HTTP/1.0设备的Connection首部字段(包括Connection:Keep-Alive), 因为他们可能是由比较老的代理服务器误转发的。<br>但是实际上, 尽管可能会有在老代理上挂起的危险, 有些客户端和服务器还是会违反这条规则。</p></li><li><p>除非重复发送请求会产生其他副作用, 否则 “如果在客户端受到完整响应之前连接就关闭了, 那么客户端一定要做好重试请求的准备”。 </p></li></ol><h3 id="Keep-Alive和哑代理"><a href="#Keep-Alive和哑代理" class="headerlink" title="Keep-Alive和哑代理"></a>Keep-Alive和哑代理</h3><ol><li><p>正常情况下, 如果客户端与一台服务器对话, 客户端可以发送一个 Connection:Keep-Alive 首部来告知服务器它希望保持连接的活跃状态, 如果服务器支持keep-alive, 就回送一个 Connection:Keep-Alive 首部, 否则就不回送。</p></li><li><p>问题是出在代理上 — 尤其是那些不理解Connection首部, 而且不知道在沿着转发链路将报文转发出去之前应该将Connection首部删除的代理。<br> 很多老式或简单的代理都是<code>盲中继(blind relay)</code>, 他们只是将字节从一个连接转发到两一个连接中去, 不对Connection首部进行特殊处理。</p></li><li><p>下图就是一个Web客户端通过一个作为盲中继使用的哑代理与Web服务器进行对话的例子:<br> <img src="/img/http/blind-relay.png" width="500/"><br> 更多参考: P101<br> 盲中继的更多问题参考 4.5.7 (??)</p></li><li><p>为了防止此类代理通信问题的发生, 现在的代理都决不能转发Connection首部和所有名字出现在Connection值中的首部。<br> 另外还有几个不能作为Connection首部的值, 并且也不能被代理转发或作为缓存响应使用的首部:<br> Proxy-Authenticate, Proxy-Connection, Transfer-Encoding 和 Upgrade;</p></li></ol><h2 id="HTTP-1-1-persistent连接"><a href="#HTTP-1-1-persistent连接" class="headerlink" title="HTTP/1.1 persistent连接"></a>HTTP/1.1 persistent连接</h2><ol><li>HTTP/1.1主键停止了对keep-alive连接的支持, 用一种名为持久连接(persistent connection)的改进型设计取代了它。<br> 持久连接的目的与keep-alive连接的目的相同, 但机制更优一些。</li><li><p>与HTTP/1.0的keep-alive连接不同, HTTP/1.1持久连接在默认情况下是激活的。除非特别指明, 否则HTTP/1.1假定所有连接都是持久的。<br> 要在事务处理结束之后将连接关闭, HTTP/1.1应用程序必须向报文中显示地添加一个<code>Connection:close</code>首部。<br> 这是与以前的HTTP协议很重要的区别, 在以前的版本中, keep-alive连接要么是可选的, 要么根本就不支持。</p></li><li><p>HTTP/1.1客户端假定在收到响应后, 除非响应中包含了 <code>Connection:close</code>首部, 不然HTTP/1.1连接就仍维持在打开状态。<br> 但是, 客户端和服务器仍然可以随时关闭空闲的连接。 不发送 <code>Connection:close</code> 并不以为这服务器承诺永远将连接保持在打开状态。</p></li></ol><h3 id="persistent连接的限制和规则"><a href="#persistent连接的限制和规则" class="headerlink" title="persistent连接的限制和规则 (??)"></a>persistent连接的限制和规则 (??)</h3><ol><li>发送了 <code>Connection:close</code> 请求首部之后, 客户端就无法在那条连接上发送更多的请求了。</li><li>如果客户端不想在连接上发送其他请求了, 就应该在最后一条请求中发送一个 <code>Connection:close</code>  请求首部。</li><li>只有当连接上所有的报文都有正确的, 自定义报文长度时 – 也就是, 实体主体部分的长度都和响应 Connect-Length 一致, 或者是用分块传输编码方式编码的 — 连接才能持久保持。</li><li>HTTP/1.1的代理必须能够分别管理与客户端和服务器的持久连接 — 每个持久连接都值适用于一跳传输。</li><li>(由于较老的代理会转发Connection首部, 所以)HTTP/1.1的代理服务器不应该与HTTP/1.0客户端建立持久连接, 除非他们了解客户端的处理能力。<br> 实际上, 这一点是很难做到的, 很多厂商都违背了这一原则。</li><li>尽管服务器不应该试图在传输报文的过程中关闭连接, 而且在关闭连接之前至少应该响应一条请求, 但不管Connection首部取了什么值, HTTP/1.1设备都可以在任意时刻关闭连接。</li><li>HTTP/1.1应用程序必须能够从异步的关闭中恢复出来, 只要不存在可能会累积起来的副作用, 客户端都应该重试这条请求。(??)</li><li>除非重复发送请求会产生其他副作用, 否则 “如果在客户端收到完整响应之前连接就关闭了, 那么客户端必须要重新发送请求”</li><li>一个用户客户端对任何服务器或代理, 最多只能维护两条持久连接, 以防服务器过载。<br> 代理可能需要更多到服务器的连接来支持并发用户的通信, 所以如果有N个用户试图访问服务器的话, 代理最多要维持2N条到任意服务器或父代理的连接。</li></ol><h2 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h2><ol><li>HTTP/1.1允许在持久连接上可选地会用<strong>请求管道</strong>。这是在keep-alive连接上的进一步性能优化。在相应到达之前, 可以将多条请求放入队列。<br> 当第一条请求通过网络流向地球另一端的服务器时, 第二条和第三条也可以开始发送了。<br> 在高时延网络条件下, 这样做可以降低网络的回环时间, 提高性能。</li><li>如下图:<br> <img src="/img/http/pipeline-persistent-connections.png" width="550/"><h3 id="对管道化连接的限制"><a href="#对管道化连接的限制" class="headerlink" title="对管道化连接的限制"></a>对管道化连接的限制</h3></li><li><strong>如果HTTP客户端无法确认连接是持久的, 就不应该使用管道</strong>。</li><li>必须按照与请求相同的顺序回送HTTP响应。<strong>HTTP报文中没有序列号标签, 因此如果收到的响应失序了, 就没办法将其与请求匹配起来了</strong>。</li><li>HTTP客户端必须做好连接会在任意时刻关闭的准备, 还要准备好重发所有未完成的管道化请求。<br> 如果客户端打开了一条持久连接, 并立即发出了10条请求, 服务器可能在只处理了5条请求后关闭了连接, 剩下的5条请求会失败, 客户端必须能够应对这些过早关闭连接的情况, 重新发出这些请求。</li><li>HTTP客户端不应该用管道化的方式发送回产生副作用的请求(比如POST)。<br> 总之, 出错的时候, 管道化方式会阻塞客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全地重试<strong>POST这样的非幂等请求</strong>, 所以出错时, 就存在某些方法永远不会被执行的风险。</li></ol><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><h3 id="“任意”解除连接"><a href="#“任意”解除连接" class="headerlink" title="“任意”解除连接"></a>“任意”解除连接</h3><p>所有HTTP客户端, 服务器或代理都可以在任意时刻关闭一条TCP传输连接, 通常会在一条报文结束时关闭连接, 但出错的时候, 也可能在首部行中间, 或其他奇怪的地方关闭连接。<br>对管道化持久连接来说, 这种情形是很常见的。HTTP应用程序可以在经过任意一段时间之后，关闭持久连接。比如，在持久连接空闲一段时间之后，服务器可能会决定将其关闭。<br>但是，服务器永远都无法确定在它关闭”空闲”连接的那一刻，在线路的那一头的客户端有没有数据要发送。如果出现这种情况，客户端就会在写入半截请求报文时发现出现了连接错误。</p><h3 id="Conetent-Length-及-截尾操作"><a href="#Conetent-Length-及-截尾操作" class="headerlink" title="Conetent-Length 及 截尾操作"></a>Conetent-Length 及 截尾操作</h3><p>每条HTTP响应都应该有精确的Content-Length首部，用来描述响应主体的尺寸。<strong>如果老的HTTP服务器省略了Content-Length或者包含错误的长度指示，这样就要一来服务器发出连接关闭来说明数据的真是末尾</strong>。</p><h3 id="连接关闭容限-重试及幂等性"><a href="#连接关闭容限-重试及幂等性" class="headerlink" title="连接关闭容限,重试及幂等性"></a>连接关闭容限,重试及幂等性</h3><p>即使在非错误情况下,连接也可以在任意时刻关闭。<br>HTTP应用程序要做好正确处理非预期关闭的准备。<br>如果在客户端执行事务的过程中, 传输连接关闭了, 那么, 除非事务处理会带来一些副作用, 否则客户端就应该重新打开连接, 并重试一次。<br>对管道化连接来说, 这种情况更加严重一些。客户端可以将大量请求放入队列中排队, 但源端服务器可以关闭连接, 这样就会留下大量未处理的请求, 需要重新调度。</p><p>副作用是很重要的问题, 如果在发送出一些请求数据之后, 收到返回结果之前, 连接关闭了, 客户端就无法百分之百地确定服务器端实际激活了多少事务。<br>有些事务, 比如GET一个静态的HTML页面, 可以反复执行多次, 也不会有什么变化。而其他一些事务, 比如向一个在线书店POST一张订单, 就不能重复执行, 不然会有下多张订单的危险。</p><p>如果一个事务， 不管是执行一次还是很多次，得到的结果都相同, <strong>这个事务就是幂等的</strong>。实现者们可以认为GET、HEAD、PUT、DELETE、TRACE和OPTIONS方法都共享这一特性。客户端不应该以管道化方式传送非幂等请求(比如POST)。<br>否则，传输连接的过早终止就会造成一些不确定的后果。要发送一条非幂等请求，就需要等待来自前一条清求的响应状态。</p><p>尽管用户Agent代理可能会让操作员来选择是否对请求进行重试，但一定不能自动重试非幂等方法或序列。<br><strong>比如，大多数浏览器都会在重载一个缓存的POST响应时提供一个对话框，询问用户是否希望再次发起事务处理</strong>。</p><h3 id="正常关闭连接"><a href="#正常关闭连接" class="headerlink" title="正常关闭连接"></a>正常关闭连接</h3><ol><li><p>正常关闭连接<br>TCP连接是双向的。TCP连接的每一端都有一个输入队列和一个输出队列, 用于数据的读或写。放入一端输出队列中的数据最终会出现在另一端的输入队列中。</p></li><li><p>完全关闭与半关闭<br>应用程序可以关闭TCP输入和输出信道中的任意一个, 或者将两者都关闭了。<br>套接字调用close()会将TCP连接的输入和输出信道都关闭了, 这被称作 “完全关闭”。<br>还可以用套接字调用shutdown()单独关闭输入或输出信道。这被称为”半关闭”。<br><img src="/img/http/close-shutdown-pipeline.png" width="350/"></p></li><li><p>TCP关闭及重置错误<br>….</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《HTTP权威指南》– 第四章<br>《图解HTTP协议》<br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/HTTP</a><br><a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">https://tools.ietf.org/html/rfc2616</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常被误解的Connection首部&quot;&gt;&lt;a href=&quot;#常被误解的Connection首部&quot; class=&quot;headerlink&quot; title=&quot;常被误解的Connection首部&quot;&gt;&lt;/a&gt;常被误解的&lt;code&gt;Connection&lt;/code&gt;首部&lt;/h2&gt;
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>11. 内容协商与转码</title>
    <link href="http://blog.renyimin.com/2017/12/06/http/2017-12-06-HTTP-11/"/>
    <id>http://blog.renyimin.com/2017/12/06/http/2017-12-06-HTTP-11/</id>
    <published>2017-12-06T10:50:27.000Z</published>
    <updated>2018-05-09T06:26:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>一个URL常常需要代表若干不同的资源</p><blockquote><p>例如那种需要以多种语言提供其内容的网站站点。<br> 如果某个站点有 ‘说法语的’ 和 ‘说英语的’ 两种用户, 它可能想用这两种语言提供网站站点信息;<br> 理想情况下，服务器应当向英语用户发送英文版，向法语用户发送法文版; 而用户只要访问网站主页就可以得到相应语言的内容。</p></blockquote></li><li><p>HTTP提供了 <code>内容协商</code> 方法，允许客户端和服务器作这样的决定。<br> 通过这些方法，单一的URL就可以代表不同的资源(比如，同一个网站页面的法语版和英语版)，这些不同的版本称为<code>变体</code>。</p></li><li><p>除了根据 <code>内容协商</code> 来决定URL代表的是那种版本的资源。另外, 对于有些特定的URL来说, 服务器还可以根据一些<strong>其他原则</strong>来决定发送什么内容给客户端最合适。在有些场合下, 服务器甚至可以自动生成定制的页面。比如，服务器可以为手持设备把HTML页面转换成WML页面，这类动态内容变换被称为<strong>转码</strong>。这些变换动作是HTTP客户端和服务器之间进行内容协商的结果。</p></li></ol><h2 id="内容协商技术"><a href="#内容协商技术" class="headerlink" title="内容协商技术"></a>内容协商技术</h2><ol><li><p>共有3种不同的方法可以决定服务器上哪个页面最适合客户端: <code>让客户端来选择</code>, <code>服务器自动判定</code>, 或 <code>让中间代理来选</code>。这3种技术分别称为<code>客户端驱动的协商</code>、<code>服务器驱动的协商</code> 以及 <code>透明协商</code></p></li><li><p>内容协商技术摘要如下:<br><img src="/img/http/内容协商.png" width="600"></p></li></ol><h3 id="客户端驱动-300"><a href="#客户端驱动-300" class="headerlink" title="客户端驱动 (300)"></a>客户端驱动 (300)</h3><p>1.对于服务器来说，收到客户端请求时只是发回响应，在其中列出可用的页面，让客户端决定要看哪个，这是最容易的事情。</p><ul><li>很显然，这是服务器最容易实现的方式，而且客户端很可能选择到最佳的版本(只要列表中有让客户端选择的足够信息)。</li><li>不利之处是<strong>每个页面都需要两次请求</strong>: <strong>第一次获取列表</strong>，<strong>第二次获取选择的副本</strong>。<br>这种技术速度很慢且过程枯燥乏味，让用户厌烦。</li></ul><p>2.从实现原理上来说，服务器实际上有两种方法为客户端提供选项:</p><ul><li>一是发送回一个HTML文档，里面有到该页面的各种版本的链接和每个版本的描述信息;</li><li>另一种方法是发送回HTTP/1.1响应时，使用 <code>300 Multiple Choices</code> 响应代码。客户端浏览器收到这种响应时，在前一种情况下(发回html文档的情况)，会显示一个带有链接的页面; 在后一种情况下，可能会弹出对话窗口，让用户做选择。不管怎么样，决定是由客户端的浏览器用户作出的</li></ul><p>3.除了增加时延并且对每个页面都要进行繁琐的多次请求之外, 这种方法<strong>还有一个缺点</strong>: 它需要多个URL, 公共页面要一个, 其他每种特殊页面也都要一个。</p><h3 id="服务器驱动"><a href="#服务器驱动" class="headerlink" title="服务器驱动"></a>服务器驱动</h3><p>1.之前已经知道了客户端驱动的协商存在的若干缺点。大部分缺点都涉及客户端和服务器之间通信量的增长, 这些通信量用来决定什么页面才是对请求的最佳响应。</p><p>2.而减少额外通信量的一种方法是<strong>让服务器来决定发送哪个页面回去</strong>，但为了做到这一点，<strong>客户端必须发送有关客户偏好的足够信息</strong>，以便服务器能够作出准确的决策。服务器通过 <code>客户端请求的首部集</code> 来获得这方面的信息(客户偏好)!! 有以下两种机制可供HTTP服务器评估发送什么响应给客户端比较合适：</p><ul><li>检査 客户端请求中的<code>内容协商首部集</code>: 服务器察看客户端发送的 <code>Accept内容协商首部集</code>, 设法用相应的响应首部与之匹配;</li><li>根据其他(非内容协商)首部进行变通, 例如，服务器可以根据客户端发送的 <code>User-Agent</code> 首部来发送响应</li></ul><h4 id="客户端内容协商首部集"><a href="#客户端内容协商首部集" class="headerlink" title="客户端内容协商首部集"></a>客户端内容协商首部集</h4><p>1.客户端可以用下面列出的HTTP首部集发送用户的偏好信息</p><blockquote><p>Accept : 告知服务器发送何种媒体类型<br>Accept-Language : 告知服务器发送何种语言<br>Accept-Charset : 告知服务器发送何种字符集<br>Accept-Encoding : 告知服务器采用何种编码</p></blockquote><p>2.<strong>实体首部集</strong> 和 <strong>内容协商首部集</strong></p><ul><li><strong>注意</strong>: 内容协商首部集与实体首部非常类似(比如 <code>Accept-Encoding</code> 和 <code>Content-Encoding</code>)。不过, 这两种首部的用途截然不同:</li><li><p><code>实体首部集</code>,像运输标签,它们描述了把报文从服务器传输给客户端的过程中必须的各种报文主体属性; 如下列出的实体首部集来匹配客户端的<code>Accept内容协商首部集</code></p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Accet首部            实体首部</div><div class="line">Accept    　　　　　　Content-Type</div><div class="line">Accept-Language     Content-Language</div><div class="line">Accept-Charset      Content-Type</div><div class="line">Accept-Encoding     Content-Encoding</div></pre></td></tr></table></figure><p>  （由于HTTP是无状态的协议，表示服务器不会在不同的请求之间追踪客户端的偏好，所以客户端必须在每个请求中都发送其偏好信息）</p></li><li><p>而<code>内容协商首部集</code>是由客户端发送给服务器用来告知其偏好信息的, 以便服务器可以从文档的不同版本中选择出最符合客户端偏好的那个来提供服务;</p></li></ul><h4 id="内容协商首部中的质量值"><a href="#内容协商首部中的质量值" class="headerlink" title="内容协商首部中的质量值"></a>内容协商首部中的质量值</h4><p>1.HTTP协议中定义了质量值，允许客户端为每种偏好类别列出多种选项，并为每种偏好选项关联一个优先次序。<br>    例如，客户端可以发送下列形式的<code>Accept-Language</code>首部：<code>Accept-Language: en; q=0.5, fr; q=0.0 , nl; q=1.0, tr; q=0.0</code><br>    其中q值的范围从0.0-1.0(0.0是优先级最低的，而1.0是优先级最高的)。<br>    上面列出的那个首部，说明该客户端最愿意接收荷兰语(缩写为nl)文档，但英语(缩写为en)文档也行; 无论如何，这个客户端都不愿意收到法语(缩写为fr)或土耳 其语(缩写为tr)的版本;</p><p>2.<strong>注意</strong>: 偏好的排列顺序并不重要，只有与偏好相关的<code>q值</code>才是重要的;</p><h4 id="客户端其它请求首部集"><a href="#客户端其它请求首部集" class="headerlink" title="客户端其它请求首部集"></a>客户端其它请求首部集</h4><p>1.服务器也可以根据客户端其他请求首部集来匹配响应, 比如 <code>User-Agent</code> 首部。例如, 服务器知道老版本的浏览器不支持JavaScript语言，这样就可以向其发送不含有JavaScript的页面版本。</p><p>2.由于缓存需要尽力提供所缓存文档中正确的”最佳”版本，HTTP协议定义了服务器在响应中发送的 <code>Vary</code> 首部。<br>    这个首部告知<strong>缓存</strong>, <strong>客户端</strong>, 和<strong>所有下游的代理</strong>, 服务器根据哪些首部来决定发送响应的最佳版本。</p><h3 id="透明协商-vary首部"><a href="#透明协商-vary首部" class="headerlink" title="透明协商(vary首部)"></a>透明协商(vary首部)</h3><p>1.了支持<strong>透明内容协商</strong>，服务器必须有能力告知代理，服务器需要检査哪些请求首部，以便对客户端的请求进行最佳匹配。但是HTTP/1.1规范中没有定义任何透明协商机制, 不过却定义了 <code>Vary</code> 首部。服务器在响应中发送了Vary首部，以告知中间节点需要使用哪些请求首部进行内容协商</p><p>2.代理缓存可以为通过单个URL访问的文档保存不同的副本, <strong>如果服务器把它们的决策过程传给代理,这些代理就能代表服务器与客户端进行协商</strong>。<br>（缓存同时也是进行内容转码的好地方，因为部署在缓存里的通用转码器能对任意服务器，而不仅仅是一台服务器传来的内容进行转码）</p><p>3.对内容进行缓存的时候是假设内容以后还可以重用。然而，为了确保对客户端请求回送的是正确的已缓存响应, 缓存必须应用服务器在回送响应时所用到的大部分决策逻辑;</p><p>4.之前我们已经了解了客户端发送的<code>Accept内容协商首部集</code>; 也了解到, 为了给每条请求选择最佳的响应, 服务器使用了哪些与这些首部集匹配的相应<code>实体首部集</code>。其实, 代理缓存也必须使用相同的首部集来决定回送哪个已缓存的响应。</p><p>5.<strong>下图展示了涉及缓存的正确及错误的操作序列</strong>。</p><ul><li>缓存把第一个请求转发给服务器，并存储其响应。</li><li>对于第二个请求，缓存根据URL査找到了匹配的文档。但是，这份文档是法语版的，而请求者想要的是西班牙语版的。如果缓存只是把文档的法语版本发给请求者的话，它就犯了错误;</li><li>像上面2中提到的, 代理缓存也必须要根据客户端发送来的<code>内容协商首部</code>来给客户端返回正确的响应<br>  <img src="/img/http/cache-beiyong-error.png" width="550"></li></ul><h4 id="Vary首部"><a href="#Vary首部" class="headerlink" title="Vary首部"></a>Vary首部</h4><p>1.下面是浏览器和服务器发送的一些典型的请求及响应首部:<br>    <img src="/img/http/vary-01.png" width="490"></p><p>2.然而, 如果服务器的决策不是依据<code>Accept</code>首部集，而是比如<code>User-Agent</code>首部的话，情况会如何？<br>例如, 服务器可能知道老版本的浏览器不支持JavaScript语言, 因此可能会回送不包含JavaScript的页面版本。<br>如果服务器是根据其他首部来决定发送哪个页面的话, <strong>和Accept首部集一样, 缓存也必须知道这些首部是什么, 这样才能在选择回送的页面时做出同样的逻辑判断</strong>。</p><p>3.HTTP的 <code>Vary</code> 响应首部中列出了所有客户端请求首部, 服务器可用这些首部来选择文档或产生定制的内容(在常规的内容协商首部集之外的内容)。例如, 若所提供的文档取决于<code>User-Agent</code>首部, <code>Vary首部</code>就必须包含<code>User-Agent</code>;</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>当新的请求到达时, 代理缓存会根据<code>内容协商首部集</code>来寻找最佳匹配。但在把文档提供给客户端之前, <strong>它还必须检査服务器有没有在已缓存响应中发送Vary首部</strong>。</li><li>如果有Vary首部, 那么新请求中那些首部的值必须与旧的已缓存的响应的请求首部相同。(也就是说,代理缓存也会保存旧的请求的请求首部和响应首部, 下面一句话更加肯定这一点)</li><li>因为服务器可能会根据客户端请求的首部来改变响应, 为了实现透明协商, 代理缓存就必须为每个已缓存变体保存<strong>客户端请求首部</strong>和<strong>相应的服务器响应首部</strong>)<br> <img src="/img/http/vary-02.png" width="650"></li><li>如果某服务器的Vary首部看起来像 <code>Vary: User-Agent, Cookie</code> 这样，大量不同的User-Agent和Cookie值将会产生非常多的变体, 而代理缓存必须为每个变体保存其相应的文档版本。当缓存执行査找时，首先会对内容协商首部集进行内容匹配，然后比较请求的变体与缓存的变体。如果无法匹配，缓存就从原始服务器获取文档</li></ol><h2 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h2><ol><li><p>我们已经讨论了一个机制, 该机制可以让客户端和服务器从某个URL的一系列文档中挑选出最适合客户端的文档。但是, 实现这些机制的前提是，存在一些满足客户端需求的文档—不管是完全满足还是在一定程度上满足;</p></li><li><p>然而, 如果服务器没有能满足客户端需求的文档会怎么样呢？服务器可以给出一个错误响应。但理论上，服务器可以把现存的文档转换成某种客户端可用的文档, 这种选项称为<strong>转码</strong>;</p></li><li><p>下面列出了一些假设的转码</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">转换之前 　　　　　　　　　　　　转换之后</div><div class="line">HTML文档    　　　　　　　　　　WML文档</div><div class="line">高分辨率图像    　　　　　　　　低分辨率图像</div><div class="line">彩色图像    　　　　　　　　　　黑白图像</div><div class="line">有多个框架的复杂页面    　　　　没有很多框架或图像的简单文本页面</div><div class="line">有Java小应用程序的HTML页面    没有Java小应用程序的HTML页面</div><div class="line">有广告的页面    　　　　　　　　去除广告的页面</div></pre></td></tr></table></figure></li><li><p>有3种类别的转码: <strong>格式转换</strong>、<strong>信息综合</strong>以及<strong>内容注入</strong></p></li></ol><h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><ol><li><p>格式转换是指将数据从一种格式转换成另一种格式, 使之可以被客户端査看。通过HTML到WML的转换, 无线设备就可以访问通常供桌面客户端査看的文档了。通过慢速连接访问Web页面的客户端并不需要接收高分辨率图像, 如果通过格式转换降低图像分辨率和颜色来减小图像文件大小的话, 这类客户端就能更容易地査看图像比较丰富的页面了。</p></li><li><p>格式转换可以由如下<code>内容协商首部集</code>来驱动, 但也能由 <code>User-Agent</code> 首部来驱动。注意: <code>内容转换或转码</code> 与 <code>内容编码</code> 或 <code>传输编码</code> 是不同的, 后两者一般用于更高效或安全地传输内容, 而前两者则可使访问设备能够査看内容;</p><pre><code class="php">Accet首部            实体首部Accept    　　　　　　Content-TypeAccept-Language     Content-LanguageAccept-Charset      Content-TypeAccept-Encoding     Content-Encoding</code></pre></li></ol><h3 id="信息综合"><a href="#信息综合" class="headerlink" title="信息综合"></a>信息综合</h3><ol><li><p>从文档中提取关键的信息片段称为信息综合(information synthesis), 这是一种有用的转码操作。这种操作的例子包括根据小节标题生成文档的大纲，或者从页面中删除广告和商标</p></li><li><p>根据内容中的关键字对页面分类是更精细的技术, 有助于总结文档的精髓。这种技术常用于Web页面分类系统中，比如门户网站的Web页面目录</p></li></ol><h3 id="内容注入"><a href="#内容注入" class="headerlink" title="内容注入"></a>内容注入</h3><p>参见P423</p><h3 id="转码与静态预生成的对比"><a href="#转码与静态预生成的对比" class="headerlink" title="转码与静态预生成的对比"></a>转码与静态预生成的对比</h3><ol><li><p>转码的替代做法是在Web服务器上建立Web页面的不同副本, 例如一个是HTML, 一个是WML, 一个图像分辨率高，一个图像分辨率低；一个有多媒体内容，一个没有。</p></li><li><p>但是，这种方法不是很切合实际，原因很多：</p><ul><li>某个页面中的任何小改动都会牵扯很多页面，需要很多空间来存储各页面的不同版本，而且使页面编目和Web服务器编程(以提供正确的版本)变得更加困难。</li><li>有些转码操作，比如广告插入(尤其是定向广告插入)，就不能静态实现, 因为插入什么广告和请求页面的用户有关</li></ul></li><li><p>对单一的根页面进行即时转换，是比静态的预生成更容易的解决方案。<br> 但这样会在提供内容时增加时延。不过有时候其中一些计算可以由第三方进行，这样就减少了Web服务器上的计算负荷——比如可以由代理或缓存中的外部Agent完成转换</p></li><li><p>下图显示了在代理缓存中进行的转码<br> <img src="/img/http/zhuanma-01.png" width="430"></p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><http权威指南></http权威指南>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个URL常常需要代表若干不同的资源&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如那种需要以多种语言提供其内容的网站站点。
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>05. 缓存相关</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-05/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-05/</id>
    <published>2017-11-30T13:27:36.000Z</published>
    <updated>2018-05-09T06:26:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web缓存简介"><a href="#Web缓存简介" class="headerlink" title="Web缓存简介"></a>Web缓存简介</h2><p>1.Web缓存是指可以自动保存常见文档副本的HTTP设备。当Web请求抵达缓存设备时, 如果缓存设备本地有”已缓存的”副本, 就可以从本地设备而不是原始服务器中提取这个文档。</p><p>2.使用缓存的优点</p><ul><li>减少了冗余的数据传输, 节省了你的网络费用</li><li>缓解了网络本身的瓶颈问题, 不需要更多的带宽就能够更快地加载页面</li><li>降低了对原始服务器的要求, 服务器可以更快地响应, 避免过载的出现</li><li>降低了<strong>距离时延</strong>, 因为从较远的地方加载页面会更慢一些<br>即使带宽不是问题, 距离也可能成为问题。<strong>每台网络路由器都会增加因特网流量的时延</strong>。即使客户端和服务器之间没有太多的路由器, <strong>光速自身也会造成显著的时延</strong>。</li></ul><h2 id="缓存命中、缓存未命中"><a href="#缓存命中、缓存未命中" class="headerlink" title="缓存命中、缓存未命中"></a><code>缓存命中</code>、<code>缓存未命中</code></h2><ol><li><p>如果一些请求到达缓存设备时, 缓存设备可以用本地已有的副本为这些请求提供服务, 就被称为<strong>缓存命中</strong>;</p></li><li><p>如果一些请求到达缓存设备时, 缓存设备本地没有副本提供给这些请求, 而将请求转发给原始服务器, 这就被称为<strong>缓存未命中</strong>;</p></li><li><p>后面还有 <strong>再验证命中</strong> 和 <strong>再验证未命中</strong> 的概念;</p></li></ol><h2 id="文档过期时间"><a href="#文档过期时间" class="headerlink" title="文档过期时间"></a>文档过期时间</h2><ol><li><p>原始服务器的内容可能会发生变化，所以缓存还需要不时地对其进行检测, 看看他们保存的副本是否仍然是服务器上最新的副本;</p></li><li><p>原始服务器通过 老式的HTTP/1.0+的实体首部字段 <code>Expires</code> 或 新式的HTTP/1.1的通用首部字段 <code>Cache-Control:max-age</code> 可以向每个文档附加一个<strong>过期日期</strong>;</p><ul><li><code>Expires</code>实体首部字段 和 <code>Cache-Control:max-age</code>这个通用首部字段, 所做的事情本质上是一样的(但由于 <code>Cache-Control</code> 首部能使用相对时间, 所以更倾向与使用比较新的 <code>Cache-Control</code> 首部);</li><li>而 <code>Expires</code> 绝对日期依赖于计算机时钟的正确设置</li></ul></li><li><p>在缓存文档过期之前, 缓存设备可以随意使用这些副本, 而且无需与服务器做任何联系, 除非</p><ul><li>客户端请求中包含 “阻止提供缓存” 的首部 <code>Cache-Control:no-store</code>;</li><li>或者客户端请求中包含”只有经过验证才能返回缓存副本”的首部 <code>Cache-Control:no-cache</code>; </li></ul></li><li><p>但是一旦已缓存文档过期, 缓存设备就必须与服务器进行再验证核对, 除非你设置了 <code>Cache-Control:only-if-cached</code>,要求只使用缓存;</p></li><li><p>文档过期算法为: <code>expirationTime</code> = <code>responseTime(Date头)</code> + <code>freshnessLifetime(max-age/Exprie值)</code> - <code>currentAge(Age头)</code></p></li><li><p><strong>注意</strong>: </p><ul><li>有些服务器会回送一个 <code>Expires:0</code> 响应头, 试图将文档置于永远过期的状态, <strong>但这种语法是非法的</strong>, 可能给某个软件带来问题, 应该试着支持这种结构的输入, 但是不应该产生这种结构的输出;</li><li>而 <code>Cache-Control</code> 的 <code>max-age</code> 则可以设置 <code>Cache-Control: max-age=0</code>;</li></ul></li></ol><h2 id="缓存再验证"><a href="#缓存再验证" class="headerlink" title="缓存再验证"></a>缓存再验证</h2><p>文档过期后, 缓存需要到原始服务器查看其缓存文档有没有发生变化, 这种 <code>新鲜度检测</code> 被称为 <code>HTTP缓存再验证</code>;</p><p>但是仅仅是已缓存文档过期了, 还不能说明该过期文档和原始服务器上的文档有实际的区别, 这只是意味着<strong>到时间进行再验证了</strong>; 因为客户端还可以设置一些缓存控制项来进行影响;</p><h3 id="再验证依据"><a href="#再验证依据" class="headerlink" title="再验证依据"></a>再验证依据</h3><ol><li><p>为了有效地进行再验证, HTTP定义了一些特殊的请求, 不用从服务器上获取整个对象, 就可以快速检测出内容是否是最新的, HTTP的<code>条件方法</code>可以高效地实现再验证;</p></li><li><p>HTTP定义了5个条件请求首部, 对 <code>缓存再验证</code> 来说有用的2个首部是 <code>If-Mofified-Since</code> 和 <code>If-None-Match</code>, 所有的条件首部都以前缀<code>If-</code>开头。<br> <img src="/img/http/revalidate-01.png" width="500/"></p></li><li><p>再验证 请求首部字段 <code>If-Modified-Since</code></p><ul><li>如果自If-Modified-Since指定日期之后, 文档被修改了, <code>If-Modified-Since</code> 条件就为真, 通常GET就会成功执行, 携带新首部的新文档会被返回给缓存, 新首部除了其他信息之外, 还包含了一个新的过期日期;</li><li>如果自If-Modified-Since指定日期之后, 文档没被修改, <code>If-Modified-Since</code> 条件就为假, 会向客户端<strong>返回一个小的 304 Not Modified响应报文</strong>, 为了提高有效性, <strong>不会返回文档主体</strong>; 否则, 如果文档发生了变化, 就返回带有新主体的200响应;</li><li>请求首部字段 <code>If-Modified-Since</code> 和 实体首部字段 <code>Last-Modified</code> 配合工作;</li></ul></li><li><p>再验证 请求首部字段 <code>If-None-Match</code></p><ul><li>有些文档可能会被周期性地重写, 但实际包含的数据常常却是一样的。<strong>尽管内容没有发生变化, 但是修改日期会发生变化</strong>;</li><li>有些文档可能内容被修改了, 但是<strong>所做的修改并不重要</strong>, 不需要让世界范围内的缓存都重装数据(比如对拼写或注释的修改), 涉及到弱验证器;</li><li>有些服务器无法准确地判定其页面的最后修改日期;</li><li><p>有些服务器提供的文档会在亚秒间隙发生变化(比如,实时监视器), 对这些服务器来说, <strong>以秒为粒度的修改日期可能就不够用了</strong>;</p></li><li><p>为了解决上述问题, HTTP有一个被称为 <code>实体标签(ETag)</code> 的 <code>版本标识符</code>, 这个实体标签是附加到文档上的任意标签, 标签可能可能包含了文档序列号或版本名, 或是文档内容的校验及其他指纹信息。<br>当对文档进行修改时, 可以修改文档的实体标签来说明这个新的版本。这样, 如果实体标签被修改了, 缓存就可以用 <code>If-None-Match</code> 条件首部来GET文档的新副本了;</p></li><li><p>如果<code>If-None-Match</code> 与 <code>If-Modified-Since</code> 同时存在, 两个都要进行验证;</p></li><li><p>请求首部字段 <code>If-None-Match</code> 和 响应首部字段 <code>ETag</code> 配合工作;</p></li></ul></li></ol><h3 id="再验证命中"><a href="#再验证命中" class="headerlink" title="再验证命中"></a>再验证命中</h3><ol><li><p>缓存对副本进行再验证时, 会向原始服务器发送一个小的再验证请求。如果发现内容没有变化, 服务器会以一个小的 <code>304 Not Modified</code> 进行响应;<br> 只要缓存知道副本仍然有效, 就会再次将副本标识为暂时新鲜的, 并将副本提供给客户端, 这被称为<strong>再验证命中(revalidate hit)</strong> 或 <strong>缓慢命中(slow hit)</strong>;<br> <img src="/img/http/revalidate-hit-01.png" width="350/"></p></li><li><p>这种方式确实还是需要与原始服务器进行核对, 所以会比单纯的缓存命中要慢, 但是它并没有从服务器中获取对象数据, 所以要比缓存未命中要快一些。</p></li></ol><h3 id="再验证未命中"><a href="#再验证未命中" class="headerlink" title="再验证未命中"></a>再验证未命中</h3><ol><li><p>如果缓存发现原始服务器对象与已缓存副本不同, 则服务器会向客户端发送一条普通的, 带有完整内容的 <code>HTTP 200 OK</code> 响应;<br> <img src="/img/http/revalidate-not-hit-01.png" width="350/"></p></li><li><p>这种方式 不仅需要与原始服务器进行核对, 而且会从服务器中获取对象数据, 所以理论上貌似要比缓存未命中要慢一些;</p></li><li><p>如果再验证发现服务器对象已经被删除, 服务器就回送一个 <code>404 Not Found</code> 响应, <strong>缓存也会将其本地副本删除</strong>;</p></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>成功的再验证 比 缓存未命中 要快</strong><br><strong>失败的再验证 几乎和 缓存未命中 速度一样</strong></p><h4 id="弱验证器"><a href="#弱验证器" class="headerlink" title="弱验证器"></a>弱验证器</h4><p>1.只要原始服务器内容发生变化, 则实体标签就会变化, 正常情况下, 强验证器就会对比失败, 导致服务器会在一个 <code>200 OK</code> 响应中返回新的内容以及新的<code>Etag</code>标签;</p><p>2.有时, 服务器希望对文档进行一些不重要的修改, 并且不需要使所有已缓存副本都失效<br>    HTTP1.1支持的”弱验证器”, 就允许对一些内容做修改, 此时服务器会用前缀 <code>W/</code> 来标识弱验证器。<br>3.不管相关的实体值以何种方式发生了变化, 强实体标签都要发生变化, 而相关实体在语义上发生了比较重要的变化时, 弱实体标签页应该发生变化。</p><h2 id="公有和私有缓存"><a href="#公有和私有缓存" class="headerlink" title="公有和私有缓存"></a>公有和私有缓存</h2><p>1.通用首部字段(general header fields)<code>Cache-Control</code>有两个缓存响应指令: <code>public</code> 和 <code>private</code><br>2.缓存可以是<code>单个用户专用的</code>, 也可以是<code>数千名用户共享的</code> ;</p><ul><li>专用缓存被称为<code>私有缓存(private cache)</code>, 私有缓存是个人的缓存, 包含了单个用户最常用的页面 ;</li><li>共享缓存被称为<code>公有缓存(public cache)</code>, 公有缓存包含了某个用户团体常用页面 ;</li></ul><h3 id="私有缓存"><a href="#私有缓存" class="headerlink" title="私有缓存"></a>私有缓存</h3><p>私有缓存不需要很大的动力或存储空间, 这样就可以将其做的很小, 很便宜。<br>Web浏览器中就有内建的私有缓存—大多数浏览器都会将常用文档缓存在你个人电脑的磁盘和内存中, 并且允许用户去配置缓存的大小和各种设置;</p><h3 id="公有缓存"><a href="#公有缓存" class="headerlink" title="公有缓存"></a>公有缓存</h3><p>1.公有缓存是特殊的共享代理服务器, 被称为缓存代理服务器(caching proxy server), 或者更常见地被称为代理缓存(proxy cache)。<br>2.代理缓存会从自己本地缓存中给用户提供缓存资源, 或者代表用户与服务器进行联系。公有缓存会接受来自多个用户的访问, 所以通过它可以更好地减少冗余流量。<br>3.如下图: </p><ul><li>每个客户端都会重复地访问一个(还不在私有缓存中的)新的”热门”文档。每个私有缓存都要获取同一份文档, 这样它就会多次穿过网络。</li><li>而使用共享的公有缓存时, 对于这个流行的对象, 缓存只要取一次就行了, 它会用共享的副本为所有的请求服务, 以降低网络流量。<br><img src="/img/http/private-public-cache-01.png" width="400/"></li></ul><h2 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h2><p>1.之前在<a href="/2016/11/30/http/2016-11-30-HTTP-04/">各通用首部字段详解</a>已经对各选项进行了说明;</p><p>2.补充</p><ul><li>(<a href="https://stackoverflow.com/questions/33818854/what-is-difference-between-max-age-and-max-stale-in-cache-control-mechanism" target="_blank" rel="external">HTTP Cache-Control: max-age和max-stale=s的区别</a>)</li><li><code>immutable</code> : 属于缓存控制的一个扩展属性, <a href="http://www.jdon.com/performance/cache-control-immutable.html" target="_blank" rel="external">参考</a><blockquote><p>当一个支持immutable的客户端浏览器看到这个属性时, 它应该知道, 如果没有超过过期时间，那么服务器端该页面内容将不会改变, 这样浏览器就不应该再发送有条件的重新验证请求(比如通过If-None-Match 或 If-Modified-Since等条件再向服务器端发出更新检查);<br>也就是说, 通常过去我们使用304回复客户端该页面内容没有变化，但是如果用户按浏览器的刷新或F5键，浏览器会再次向服务器端发出该页面内容请求，服务器端如果确认该页面没有变化，那么发回304给客户端，不再发送该页面的实体内容，虽然这样节省了来回流量，但是如果大型网站的很多用户为了得到及时信息，经常会刷新浏览器，这就造成了大量刷新请求，向服务器端求证该页面是否改变，这会影响网站的带宽，也增加服务器端验证压力。<br><strong>而新的选项immutable可以杜绝这种现象</strong>。<br>immutable可以节省HTTP请求,缩短请求时间,这是因为服务器不必再处理304响应了。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web缓存简介&quot;&gt;&lt;a href=&quot;#Web缓存简介&quot; class=&quot;headerlink&quot; title=&quot;Web缓存简介&quot;&gt;&lt;/a&gt;Web缓存简介&lt;/h2&gt;&lt;p&gt;1.Web缓存是指可以自动保存常见文档副本的HTTP设备。当Web请求抵达缓存设备时, 如果缓存设备
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>04. 各通用首部字段详解</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-04/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-04/</id>
    <published>2017-11-30T11:50:02.000Z</published>
    <updated>2018-05-09T06:26:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cache-Control-缓存能力控制"><a href="#Cache-Control-缓存能力控制" class="headerlink" title="Cache-Control 缓存能力控制"></a>Cache-Control 缓存能力控制</h2><p>1.Cache-Control 缓存指令是单向的, 即请求中存在一个指令并不意味着响应中将存在同一个指令;</p><ul><li>该指令是可选的;</li><li>指令可以有多个选项, 选项之间通过 <code>,</code> 分隔;</li></ul><p>2.可以按请求和响应分为(P377)</p><ul><li>缓存请求指令(选项如下)<br><img src="/img/http/cache-control-request.png" width="500/"></li><li>缓存响应指令(选项如下)<br><img src="/img/http/cache-control-response.png" width="500/"></li></ul><p>3.注意 <code>no-cache</code> 和 <code>must-revalidate</code> 的区别</p><ul><li>no-cache: 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验;</li><li>must-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去原始服务器进行有效性校验。(这应该是缓存系统的默认行为, 但must-revalidate指令使得这个要求是明确的<a href="https://stackoverflow.com/questions/2932890/http-cache-control-max-age-must-revalidate" target="_blank" rel="external">参考</a>;</li><li><a href="https://segmentfault.com/a/1190000007317481" target="_blank" rel="external">可参考</a></li></ul><p>更多参考后面的博文<a href="/2016/11/30/http/2016-11-30-HTTP-05-cache/">缓存相关</a>中的介绍</p><h2 id="Pragma-兼容"><a href="#Pragma-兼容" class="headerlink" title="Pragma 兼容"></a>Pragma 兼容</h2><p>Pragma是HTTP1.1之前版本的历史遗留字段, 仅作为与HTTP1.0做向后兼容;<br>除了与只理解 <code>Pragma:no-cache</code> 的HTTP/1.0应用程序进行交互时使用; HTTP/1.1应用程序都应该使用Cache-Control:no-cache;</p><h2 id="Date-当前时间"><a href="#Date-当前时间" class="headerlink" title="Date 当前时间"></a>Date 当前时间</h2><p>简单来说就是HTTP报文的创建日期, 它会参与到缓存的<code>过期时间</code>运算中;</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="external">公式</a>: <code>expirationTime = responseTime(Date头) + freshnessLifetime(max-age/Exprie值) - currentAge(Age头)</code></li><li><p>默认情况下, Date 的值为当前时间</p></li><li><p>而响应首部字段中的 <code>Age</code> 头字段, 是告诉客户端, 源服务器创建的缓存在代理服务器上已经保存了多久, 字段的单位为秒; 代理创建响应时必须加上首部字段<code>Age</code>; </p></li></ul><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><ol><li>该首部字段具备两个作用: <code>控制不再转发给代理的首部字段</code> 和 <code>管理持久连接</code>;</li><li>更多参考<a href="/2017-04-21-HTTP-Connection-Keep-Alive/">HTTP - 并行连接, 持久连接</a></li><li>未完待续…</li></ol><h2 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h2><ol><li><p>使用首部字段Via, 是为了追踪客户端与服务器之间的请求和响应报文的传输路径;<br>报文在经过代理或者网关时, 会先在首部字段Via中附加该服务器的信息, 然后再进行转发。</p><blockquote><p>Via首部是为了追踪传输路径, 所以也经常会和TRACE方法一起使用, 比如代理服务器受到由TRACE方法发送过来的请求(其中Max-Forward:0)时, 代理服务器就不能再转发该请求了,<br>这种情况下, 代理服务器会将自身的信息附加到Via首部后, 返回该请求的响应。</p></blockquote></li><li><p>未完待续…</p></li></ol><h2 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h2><p><strong>传输编码</strong></p><ol><li>该通用首部字段规定了传输报文主体时采用的编码方式;</li><li>HTTP/1.1的传输编码方式仅对分块传输编码有效, 即只能设置为 <code>Transfer-Encoding:chunked</code>;</li><li>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding" target="_blank" rel="external">MDN Doc</a>;</li><li><code>Content-Encoding</code> 和 <code>Transfer-Encoding</code> 二者经常会结合来用, 其实就是针对 Transfer-Encoding 的分块再进行 Content-Encoding 压缩;</li></ol><h3 id="对比-请求首部字段Accept-encoding"><a href="#对比-请求首部字段Accept-encoding" class="headerlink" title="对比 请求首部字段Accept-encoding"></a>对比 请求首部字段Accept-encoding</h3><p><strong>内容编码</strong> (P369)</p><ol><li><p>请求首部字段 <code>Accept-encoding</code> 是将客户端用户代理(浏览器)所<strong>支持的内容编码方式</strong>(通常是某种压缩算法) 及 <strong>内容编码方式的优先级顺序</strong>, 通知给服务器;</p><ul><li>通过内容协商, 服务端会选择一个客户端支持的方式, 使用并在 响应报文的实体首部字段 <code>Content-Encoding</code> 中通知客户端, 服务器选择了哪种内容编码方式;</li><li>另外, 可以一次性指定多种内容编码! </li><li>也可以使用权重q值来表示相对优先级;</li></ul></li><li><p>正常情况下, 主要采用4种编码方式: <code>gzip</code>, <code>compress</code>, <code>deflate</code>, <code>identity</code>;</p></li><li><p>即使客户端和服务器都支持某些相同的压缩算法，但如果<code>Accept-encoding:identity</code>, 表示客户端告诉服务器对响应主体不要进行压缩, 出现的两种情况的常见情形是：</p><ul><li>要发送的数据已经经过压缩, 再次进行压缩不会导致被传输的数据量更小, 一些图像格式的文件会存在这种情况;</li><li>服务器超载, 无法承受压缩需求导致的计算开销, 通常, 如果服务器使用超过80%的计算能力, 微软建议不要压缩;</li></ul></li><li><p>只要identity(表示不需要进行任何编码)没有被明确禁止使用(没有明确通过 <code>identity;q=0</code> 或是 <code>*;q=0</code> 指令明确设置 identity 的权重值为0), 一旦禁止就表示 服务端必须进行编码;</p><ul><li>没有禁止identity, 则服务器禁止返回表示客户端错误的 <code>406 Not Acceptable</code> 响应;</li><li>禁止identity后, 服务器才可能因为实在没有合适的内容编码类型而, 返回表示客户端错误的<code>406 Not Acceptable</code></li></ul></li><li><p>参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Encoding" target="_blank" rel="external">MDN</a></p></li></ol><h3 id="对比-实体首部字段-Content-encoding"><a href="#对比-实体首部字段-Content-encoding" class="headerlink" title="对比 实体首部字段 Content-encoding"></a>对比 实体首部字段 <code>Content-encoding</code></h3><p><strong>内容编码</strong><br>实体首部字段 <code>Content-encoding</code> 会告诉客户端, 服务器对实体的主体部分选用的内容编码方式</p><h3 id="对比-请求首部字段Accept-charset"><a href="#对比-请求首部字段Accept-charset" class="headerlink" title="对比 请求首部字段Accept-charset"></a>对比 <strong>请求首部字段<code>Accept-charset</code></strong></h3><p>请求首部字段 <code>Accept-charset</code> 会告诉服务器, 用户代理(浏览器)所支持的<code>字符集</code>和<code>字符集的相对优先顺序</code>。(P388)</p><ul><li>可以一次性指定多种字符集;</li><li>也可以使用权重q值来表示相对优先级;</li></ul><h2 id="对比-请求首部字段Accept-Language"><a href="#对比-请求首部字段Accept-Language" class="headerlink" title="对比 请求首部字段Accept-Language"></a>对比 <strong>请求首部字段<code>Accept-Language</code></strong></h2><p>请求首部字段 <code>Accept-charset</code> 会告诉服务器, 用户代理(浏览器)所支持的<code>语言</code>和<code>语言的相对优先顺序</code>。</p><ul><li>可以一次性指定多种字符集;</li><li>也可以使用权重q值来表示相对优先级;</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>请求首部字段<code>Accept-encoding</code> 和 实体首部字段<code>Content-encoding</code>来决定内容压缩方式;</li><li>通用首部字段<code>Transfer-Encoding</code>用来决定响应实体是否分块;</li><li>请求首部字段<code>Accept-charset</code>, <code>Accept-Language</code> 是客户端告诉服务端自己能支持的字符编码和语言及其中的优先顺序;</li></ol><h2 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h2><h2 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h2><h2 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h2><p>~~未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Cache-Control-缓存能力控制&quot;&gt;&lt;a href=&quot;#Cache-Control-缓存能力控制&quot; class=&quot;headerlink&quot; title=&quot;Cache-Control 缓存能力控制&quot;&gt;&lt;/a&gt;Cache-Control 缓存能力控制&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>03. HTTP状态码详解</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-03/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-03/</id>
    <published>2017-11-30T06:30:12.000Z</published>
    <updated>2018-05-09T06:25:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h2><ol><li><code>101</code>: 参考博文<a href="2016/10/17/WebSocket/2017-10-28-websocket-02/">WebSocket简单示例分析</a> (做协议升级, 还会响应: <code>Connection: Upgrade</code>)<br>~~未完待续</li></ol><h2 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h2><blockquote><p><strong>Web API的设计与开发 P109</strong></p></blockquote><p><strong>200 OK</strong> : 200码非常出名, 似乎没有对它进一步说明的必要;</p><p><strong>201 Created</strong> : 当在服务器端创建数据成功时, 会返回201状态码;</p><ul><li>用于请求 <code>创建服务器对象</code>, 比如 <code>PUT操作</code> 成功创建资源后, 就应该返回 201码;</li></ul><p><strong>202 Accepted</strong> : 在异步处理客户端请求时, 它用来表示服务器端已经接受了来自客户端的请求, 但处理尚未结束;</p><ul><li>在文件格式转换, 处理远程通知(Apple Push Notification等)这类很耗时的场景中, 如果等到所有处理都结束后才向客户端返回响应消息, 就会花费相当长的时间, 造成应用可用性不高; 这时采用的方法是服务器向客户端返回一次响应消息, 然后立刻开始异步处理。</li><li>202状态码就被用于告知客户端服务器端已经开始处理请求, 但整个处理过程尚未结束;</li><li>比如: 以LinkedIn的参与讨论的API为例<br>如果成功参与讨论并发表意见, 服务器端通常会返回201状态码;<br>但如果需要得到群主的确认, 那么所发表的意见就无法立即在页面显示出来, 这时服务器端就需要返回202状态码; 从广义上来看, 该场景也属于异步处理, 但和程序设计里的异步执行当然不同;</li></ul><p><strong><a href="http://www.laruence.com/2011/01/20/1844.html" target="_blank" rel="external">204 No Content</a></strong> : 正如其字面意思, 当响应消息为空时会返回该状态码。</p><ul><li>其实就是告诉浏览器, 服务端执行成功了, 但是没什么数据返回给你, 所以你不用刷新页面, 也不用导向新的页面; </li><li>在用<code>DELETE</code>方法删除数据时, 服务器端通常会返回204状态码(阮一峰博文也提到过, 对<code>DELETE</code>适用);</li><li>除此之外, 也有人认为在使用 <code>PATCH</code> 方法更新数据时, 因为只是更新已有数据, 所以返回204状态码更加自然;</li><li>关于204状态码的讨论可以参考 p111;</li></ul><p><strong>205 Reset Content</strong> : 告诉浏览器, 页面表单需要被重置; </p><ul><li>205的意思是服务端在接收了浏览器POST请求以后, 处理成功以后, 告诉浏览器, 执行成功了, 请清空用户填写的Form表单, 方便用户再次填写;</li></ul><p><strong>206 Partial Content</strong> : 成功执行了一个部分或Range(范围)的请求; </p><ul><li>206响应中, 必须包含 <code>Content-Range</code>, <code>Date</code> 以及 <code>ETag</code>或<code>Content-Location</code>首部;</li></ul><h2 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h2><p><strong>300 Multiple Choices</strong> : 客户端驱动方式进行内容协商时, 服务器可能返回多个连接供客户端进行选择 (比如多语言网站可能会出现);</p><p><strong>301 Moved Permanently</strong> : 在请求的URL已经被移除时使用, 响应的Location首部中应该包含资源现在所处的URL; (比较适合永久重定向)</p><ul><li>比如你从 www.test.com/location.php 中location跳转到 www.test.com/index.html 时, 如果响应的是301;</li><li><p>则即便稍后取消了location.php中的跳转(或者修改了跳转地址), 由于浏览器还是会认为你之前的跳转是永久性的, 再次访问www.test.com/location.php仍然会跳转到之前的跳转链接(除非清浏览器缓存);</p></li><li><p>另外, 假设你之前是先访问www.test.com/test.html, 然后通过<strong>post</strong>提交到www.test.com/location.php, 最后由location.php再进行跳转的话, 会转成<strong>GET</strong>;</p></li></ul><p><strong>302 Found</strong>: 与301类似, 但是客户端应该使用Location首部给出的URL来进行<strong>临时</strong>定位资源, 将来的请求仍应该使用老的URL;</p><ul><li>比如你从 www.test.com/location.php 中location跳转到 www.test.com/index.html 时, 如果响应的是302;</li><li><p>如果稍后取消了location.php中的跳转, 再次访问www.test.com/location.php, 会发现不会进行跳转, 而是访问到 location.php 修改后的代码 (不用清浏览器缓存);</p></li><li><p>另外, 假设你之前是先访问www.test.com/test.html, 然后通过<strong>post</strong>提交到www.test.com/location.php, 最后由location.php再进行跳转的话, 会转成<strong>GET</strong>;</p></li></ul><p><strong>303 See Other</strong> : HTTP/1.1使用303来实现和302一样的<strong>临时</strong>重定向;</p><p><strong>307 Temporary Redirect</strong></p><ul><li>HTTP/1.1规范要求用307来取代302进行临时重定向; (302临时重定向留给HTTP/1.0)</li><li>所以他也具备302临时重定向的特点;</li><li>但是, 与 302, 303 不同, 它会将客户端的POST请求, 发送给location的目标页; 假设你之前是先访问www.test.com/test.html, 然后通过<strong>post</strong>提交到www.test.com/location.php, 最后由location.php再进行跳转的话, 仍然是<strong>POST</strong>;</li></ul><p><strong><a href="https://tools.ietf.org/html/draft-reschke-http-status-308-07" target="_blank" rel="external">308 Permanent Redirect</a></strong></p><ul><li>貌似不是rfc2616的标准</li><li>具备和301永久重定向的特点, 需要清除浏览器缓存才行;</li><li>但是, 与 301 不同, 它会将客户端的POST请求, 发送给location的目标页; 假设你之前是先访问www.test.com/test.html, 然后通过<strong>post</strong>提交到www.test.com/location.php, 最后由location.php再进行跳转的话, 仍然是<strong>POST</strong>;</li></ul><p><strong>304 Not Modified</strong> : 参考博文<a href="/2016/11/30/http/2016-11-30-HTTP-05-cache/">缓存相关</a></p><h2 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h2><blockquote><p><strong>Web API的设计与开发 P113</strong><br>4字头状态码主要用于描述因客户端请求的问题而引发的错误。<br>也就是说, 服务器端不存在问题, 但服务器端无法理解客户端发送的请求, 或虽然服务器端能够理解但请求却没有被执行, 当遇到这些情况引发的错误时, 服务器端便会向客户端返回这一类别的状态码。<br>因此, 当服务器端返回4字头的状态码时, 就表示客户端的访问方式发生了问题, 用户需要检查一下客户端的访问方式或访问的目标资源等。</p></blockquote><p><strong>400 Bad Request</strong> : 表示其他错误的意思, 即其他4字头状态码都无法描述的错误类型;</p><p><strong>401 Unauthorized</strong> : 表示<code>认证(Authentication)</code>类型的错误</p><ul><li>比如当需要先进行登录操作, 而却没有告诉服务器端所需的会话信息(比如token..), 服务器端就会返回401状态码, 告知客户端出错的大致原因;</li></ul><p><strong>403 Forbidden</strong> : 和401状态码比较相似, 所以也经常被混淆; 其实403表示的是<code>授权(Authotization)</code>类型的错误, 授权和认证的不同之处是:</p><ul><li><code>认证</code>表示”识别前来访问的是谁”, 而<code>授权</code>则表示”赋予特定用户执行特定操作的权限”</li><li>通俗地说: 401状态码表示”我不知道你是谁”, 403状态码表示”虽然知道你是谁, 但你没有执行该操作的权限”</li></ul><p><strong>404 Not Found</strong> : 表示访问的数据不存在, 但是</p><ul><li>例如当客户端湿度获取不存在的用户信息时, 或者试图访问原本就不存在的端点时, 服务器就会返回404状态码;</li><li>所以, 如果客户端想要获取用户信息, 却得到服务器端返回的404状态码, 客户端仅凭”404 Not Found”将难以区分究竟是用户不存在, 还是端点URI错误导致访问了原本不存在的URI;</li></ul><p><strong>405 Method Not Allowed</strong> : 表示虽然访问的端点存在, 但客户端使用的HTTP方法不被服务器端允许;</p><ul><li>比如客户端使用了POST方法来访问只支持GET方法的信息检索专用的API;</li><li>又比如客户端用了GET方法来访问更新数据专用的API等;</li></ul><p><strong>406 Not Acceptable</strong> : 服务器端API不支持客户端指定的数据格式时, 服务器端所返回的状态码; </p><ul><li>比如, 服务器端只支持JSON和XML输出的API被客户端指定返回YAML的数据格式时, 服务器端就会返回406状态码;</li></ul><p><strong>408 Request Timeout</strong> : 当客户端发送请求至服务器端所需的时间过长时, 就会触发服务器端的超时处理, 从而使服务器端返回该状态码;</p><p><strong>409 Conflict</strong>: 用于表示资源发生冲突时的错误 (est中就会有该错误码)</p><ul><li>比如通过指定ID等唯一键值信息来调用注册功能的API时, 倘若已有相同ID的数据存在, 就会导致服务器端返回409状态码;</li><li>在使用邮箱地址及Facebook ID等信息进行新用户注册时, 如果该邮箱地址或者ID已经被其他用户注册, 就会引起冲突, 这时服务器端就会返回409状态码告知客户端该邮箱地址或ID已被使用;</li></ul><p><strong>410 Gone</strong> : 和 404状态码 相同, 都表示访问资源不存在, 只是410状态码不单表示资源不存在, 还进一步告知<strong>资源曾经存在</strong>, 只是目前已经消失了;</p><ul><li>因此服务器端常在访问被删除的数据时返回该状态码, 但是为了返回该状态码, 服务器必须保存该数据已被删除的信息, 而且客户端也应该知晓服务器端保存了这样的信息;</li><li>但是在通过邮箱地址搜索用户信息的API中, 从保护个人信息的角度来说, <strong>返回410状态码的做法也会受到质疑</strong>; (所以在此种资源不存在的情况下, 为了稍微安全一些, 返回410状态码需要慎重)</li></ul><p><strong>413 Request Entity Too Large</strong> : 413也是比较容易出现的一种状态码, 表示请求实体过大而引发的错误</p><ul><li>请求消息体过长是指, 比如在上传文件这样的API中, 如果发送的数据超过了所允许的最大值, 就会引发这样的错误;</li></ul><p><strong>414 Request-URI Too Large</strong> : 414是表示请求首部过长而引发的错误</p><ul><li>如果在进行GET请求时, 查询参数被指定了过长的数据, 就会导致服务器端返回414状态码</li></ul><p><strong>415 Unsupported Media Type</strong> : 和406比较相似</p><ul><li>406我们知道是表示服务器端不支持客户端想要接收的数据格式</li><li>而415表示的是服务器端不支持客户端请求首部 <code>Content-Type</code> 里指定的数据格式, 也就是说, 当客户端通过POST,PUT,PATCH等方法发送的请求消息体的数据格式不被服务器支持时, 服务器端就会返回415状态码;</li><li>例如在只接收JSON格式的API里, 如果客户端请求时发送的是XML格式的数据去请求服务器端, 或者在 <code>Content-Type</code> 首部指定 <code>application/xml</code>, 都会导致该类型错误;</li></ul><p><strong>429 Too Many Requests</strong> : 是2012年RFC6585文档中新定义的状态码, 表示访问次数超过了所允许的范围;</p><ul><li>例如某API存在一小时内只允许访问100次的访问限制, 这种情况下入股哦客户端视图进行第101次访问, 服务器便会返回该状态码;</li><li>表示在一定的时间内用户发送了太多的请求, 即超出了”频次限制”, 在响应中，可以提供一个 <code>Retry-After</code> 首部来提示用户需要等待多长时间之后再发送新的请求;</li></ul><h2 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h2><ol><li><p>500 Internal Server Error : 服务端错误, 有可能是WEB应用存在错误</p></li><li><p>501 Not Implemented : 服务器不具备完成请求的功能, 例如, 服务器无法识别请求方法时可能会返回此状态码</p></li><li><p>503 Service Unavaliable : 用来说明服务器现在无法为请求提供服务, 但稍后可以; </p><ul><li>可以回送:响应首部 <code>Retry-After</code> 表示多久恢复;</li><li>不同的客户端与服务器端应用对于 Retry-After 首部的支持依然不太一致;</li><li>不过，一些爬虫程序，比如谷歌的爬虫程序Googlebot, 会遵循Retry-After响应首部的规则, 将其与503(Service Unavailable,当前服务不存在)响应一起发送有助于互联网引擎做出判断,在宕机结束之后继续对网站构建索引。</li><li>参考:<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Retry-After" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Retry-After</a></li></ul></li><li><p>504 Gateway Time-out: 复现这个错误码比较简单, 让你的php程序模拟耗时请求, 如下代码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">sleep(70);//模拟耗时，睡70秒</div><div class="line">echo &quot;睡醒了&quot;;</div></pre></td></tr></table></figure><p> 就会返回</p><pre><code>504 Gateway Time-outnginx/1.11.4</code></pre></li><li>505 HTTP Version Not Supported: 服务器收到的请求, 使用的是它无法支持的HTTP协议版本;</li></ol><p>参考:《HTTP权威指南》、《Web API的设计与开发》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1xx&quot;&gt;&lt;a href=&quot;#1xx&quot; class=&quot;headerlink&quot; title=&quot;1xx&quot;&gt;&lt;/a&gt;1xx&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;101&lt;/code&gt;: 参考博文&lt;a href=&quot;2016/10/17/WebSocket/2017-10-
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>02. HTTP各请求方法详解</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-02/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-02/</id>
    <published>2017-11-30T03:29:12.000Z</published>
    <updated>2018-05-09T06:27:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>HTTP/1.1 中实现的method, <a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">参考RFC2616</a>, 可以看到有: <code>OPTIONS</code>, <code>GET</code>, <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>, <code>CONNECT</code></p></li><li><p>RFC2616中提到: PATCH，LINK，UNLINK方法被定义，但并不常见;(&lt;图解http协议&gt;中也提到 <code>LINK</code>, <code>UNLINK</code>已经被http1.1废弃);</p></li><li><p>不同应用各自的实现不同, 有些应用会完整实现, 有些还会扩展, 有些可能会实现一部分;</p></li></ol><h2 id="PUT-对比POST"><a href="#PUT-对比POST" class="headerlink" title="PUT(对比POST)"></a>PUT(对比POST)</h2><ol><li><p><code>PUT</code>: 对已有资源进行更新操作, 所以是 update 操作;</p></li><li><p>put和post的区别<br> 在HTTP中, PUT被定义为 <a href="https://tools.ietf.org/html/rfc2616#section-9.1.2" target="_blank" rel="external"><code>idempotent(幂等性)</code></a> 的方法，POST则不是，<strong>这是一个很重要的区别</strong></p></li><li><p>应该用PUT还是POST ？</p></li></ol><ul><li><strong>取决于这个REST服务的行为是否是idempotent(幂等)的</strong><br>  假如发送两个请求, 希望服务器端是产生两个新数据，那就说明这个服务不是idempotent的, 因为多次使用产生了副作用了, 那就应该使用<code>POST</code>方法;<br>  但如果是希望后一个请求把第一个请求覆盖掉(这不正是修改么), 那这个服务就是idempotent的, 那就应该使用<code>PUT</code>方法;</li><li>虽然POST和PUT差别不大, 用错了也没关系, 但是你的服务一放到internet上，如果不遵从HTTP协议的规范，就可能给自己带来麻烦</li></ul><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><ol><li><p><code>POST</code>: 上面已经提过了, <strong>POST是非幂等的</strong>;</p></li><li><p>POST和PUT都可以上传文件或者创建新信息, 但主要看你的REST服务行为是否是幂等的;</p></li></ol><h2 id="PATCH-对比PUT"><a href="#PATCH-对比PUT" class="headerlink" title="PATCH(对比PUT)"></a>PATCH(对比PUT)</h2><p><strong>PATCH不是HTTP标准方法的，服务端需要考虑客户端是否能够支持的问题</strong></p><ol><li><p>对已有资源的操作</p><ul><li>用于资源的<strong>部分内容</strong>进行更新 (例如更新某一个字段, 具体比如说只更新用户信息的电话号码字段);   </li><li>而<code>PUT</code>则用于更新某个资源较完整的内容, 比如说用户要重填完整表单更新所有信息, 后台处理更新时可能只是保留内部记录ID不变;</li></ul></li><li><p>当资源不存在时: PATCH 可能会去创建一个新的资源, 这个意义上像是 saveOrUpdate 操作。</p></li><li><p>参考:</p><ul><li><a href="https://segmentfault.com/q/1010000005685904/" target="_blank" rel="external">https://segmentfault.com/q/1010000005685904/</a></li><li><a href="https://unmi.cc/restful-http-patch-method/" target="_blank" rel="external">https://unmi.cc/restful-http-patch-method/</a></li><li><a href="http://restcookbook.com/HTTP%20Methods/patch/" target="_blank" rel="external">http://restcookbook.com/HTTP%20Methods/patch/</a></li><li><a href="https://tools.ietf.org/html/rfc5789" target="_blank" rel="external">https://tools.ietf.org/html/rfc5789</a></li></ul></li></ol><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD和 <code>GET</code> 本质是一样的, 区别在于如果使用HEAD, 响应体将不会被返回，而仅仅返回HTTP头信息;<br>比如: 欲判断某个资源是否存在, 我们通常使用GET, <strong>但这里用HEAD则意义更加明确</strong>。</p><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>比较简单, 直接获取资源;</p><h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><p>这个方法使用比较少, 它用于获取当前URL所支持的方法;<br>若请求成功, 则它会在HTTP头中包含一个名为 <code>Allow</code> 的头, 值是服务器所支持的方法, 如 GET, POST;<br>之前跨域相关博文 <a href="/2016/09/18/2016-09-18-sameoriginpolicy-06/">CORS方案 not-so-simple request</a> 中的”预检”请求用的请求方法就是 <code>OPTIONS</code>;</p><h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><p>要求用隧道协议连接代理, 如使用SSL</p><h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><p>~~未完待续</p><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p><a href="https://tools.ietf.org/html/rfc2616#section-9.7" target="_blank" rel="external">参考</a></p><h2 id="PURGE"><a href="#PURGE" class="headerlink" title="PURGE"></a>PURGE</h2><p>非规范中定义的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;HTTP/1.1 中实现的method, &lt;a href=&quot;https://tools.ietf.org/html/rfc
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>01. HTTP协议预览</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-01/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-01/</id>
    <published>2017-11-30T03:25:12.000Z</published>
    <updated>2018-05-09T06:27:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p><a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">HTTP</a>(Hypertext Transfer Protocol 超文本传输协议), 是在万维网上进行通信时所使用的协议;</p></li><li><p>协议版本</p><ul><li>HTTP/0.9 有很多设计缺, 很快就被HTTP/1.0所取代了;(…只支持GET方法…)</li><li>HTTP/1.0 第一个得到广泛应用的HTTP版本;</li><li>HTTP/1.O+ 在HTTP/1.0上扩展了很多非官方的特性, 是非正式的HTTP扩展版本;(支持持久的keep-alivel连接)</li><li><strong>HTTP/1.1</strong> 是当前使用的版本</li><li>HTTP-NG(HTTP/2.0) 关注的是性能提升, 目前还未普及</li></ul></li><li><p>用于HTTP协议交互的信息被称为<code>HTTP报文</code></p><ul><li>请求端(客户端)的报文叫 <code>请求报文</code>;</li><li>响应端(服务器端)的叫 <code>响应报文</code>;</li></ul></li></ol><h2 id="请求报文结构"><a href="#请求报文结构" class="headerlink" title="请求报文结构"></a>请求报文结构</h2><h3 id="报文首部"><a href="#报文首部" class="headerlink" title="报文首部"></a>报文首部</h3><ol><li><p><strong>请求行</strong> : 包含了 <code>请求方法</code>,  <code>请求URL</code>, <code>客户端请求报文使用的HTTP协议版本</code> (如: <code>GET / HTTP/1.1</code>)</p></li><li><p>首部块</p><ul><li><p>请求首部字段</p></li><li><p>通用首部字段</p></li><li><p>实体首部字段</p></li><li><p>其他</p></li></ul></li></ol><h3 id="空行-CRLF"><a href="#空行-CRLF" class="headerlink" title="空行(CRLF)"></a>空行(CRLF)</h3><h3 id="报文主体"><a href="#报文主体" class="headerlink" title="报文主体"></a>报文主体</h3><h2 id="响应报文结构"><a href="#响应报文结构" class="headerlink" title="响应报文结构"></a>响应报文结构</h2><h3 id="报文首部-1"><a href="#报文首部-1" class="headerlink" title="报文首部"></a>报文首部</h3><ol><li><p><strong>状态行</strong> : 包含了 <code>服务端响应报文使用的HTTP协议版本</code>, <code>状态码</code>, <code>原因短语</code> (如: <code>HTTP/1.1 200 OK</code>)</p></li><li><p>首部块</p><ul><li>响应首部字段</li><li>通用首部字段</li><li>实体首部字段</li><li>其他 </li></ul></li></ol><h3 id="空行-CRLF-1"><a href="#空行-CRLF-1" class="headerlink" title="空行(CRLF)"></a>空行(CRLF)</h3><h3 id="报文主体-1"><a href="#报文主体-1" class="headerlink" title="报文主体"></a>报文主体</h3><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a><a href="/2016/11/30/http/2016-11-30-HTTP-03/">请求方法</a></h2><p>上面已经了解到, 在 “请求报文” -&gt; “报文首部” -&gt; “请求行” 中, 包含了 <code>请求方法</code>, 具体可参考 <a href="/2016/11/30/http/2016-11-30-HTTP-03/">各请求方法详解</a></p><h2 id="首部字段"><a href="#首部字段" class="headerlink" title="首部字段"></a>首部字段</h2><p>从上面还可以看到, 报文中的首部块有如下几种<code>首部字段</code></p><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><p>Cache-Control 缓存能力控制<br>Pragma 兼容Cache-control<br>Date 当前时间<br>Transfer-Encoding 传输编码<br>Accept-encoding 内容编码  (请求首部字段) (可能会导致服务器返回 <code>406 Not Acceptable</code>)<br>Content-encoding 内容编码 (实体首部字段)<br>Accept-charset  请求首部字段<br>可参考博文：<a href="/2016/11/30/http/2016-11-30-HTTP-04/">各通用首部字段详解</a></p><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><h2 id="状态码详解"><a href="#状态码详解" class="headerlink" title="状态码详解"></a>状态码详解</h2><p>可参考博文：<a href="/2016/11/30/http/2016-11-30-HTTP-03/">HTTP状态码详解</a></p><p>~~未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>70. 查询性能优化</title>
    <link href="http://blog.renyimin.com/2017/09/27/mysql/2017-09-27-mysql-70/"/>
    <id>http://blog.renyimin.com/2017/09/27/mysql/2017-09-27-mysql-70/</id>
    <published>2017-09-27T12:50:37.000Z</published>
    <updated>2018-03-08T06:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前已经了解了<code>索引优化</code>的相关内容, 它对于高性能是必不可少的, 但还不够, 还需要<code>合理设计查询</code>;</p><ul><li>如果查询写的很糟糕, 即使库表结构再合理, 索引再合适, 也无法实现高性能;</li><li>查询优化, 库表结构优化, 索引优化需要齐头并进, 一个不落;</li></ul><h2 id="慢查询基础"><a href="#慢查询基础" class="headerlink" title="慢查询基础"></a>慢查询基础</h2><h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><ul><li>确认应用程序是否在检索大量超过需要的数据, 你可能访问了太多的行, 也可能是太多的列;<br>比如: 总是返回全部的列; 只展示5条数据,你却查出100条;</li><li>确认<code>MySQL服务器层</code>是否在分析大量超过需要的数据行; (注意: 索引是在存储引擎层, 一旦服务器层分析的数据过多, 可能你的索引不太合适, 没有在存储引擎层过滤掉数据)<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>未完待续~~</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前已经了解了&lt;code&gt;索引优化&lt;/code&gt;的相关内容, 它对于高性能是必不可少的, 但还不够, 还需要&lt;code&gt;合理设计查询&lt;/co
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="查询性能优化" scheme="http://blog.renyimin.com/tags/%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>50. EXPLAIN 分析</title>
    <link href="http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-50/"/>
    <id>http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-50/</id>
    <published>2017-09-25T13:23:08.000Z</published>
    <updated>2018-03-16T06:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `user_info` (</div><div class="line">  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,</div><div class="line">  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">  `age`  INT(11) DEFAULT NULL,</div><div class="line">  PRIMARY KEY (`id`),</div><div class="line">  KEY `name_index` (`name`)</div><div class="line">) ENGINE = InnoDB, DEFAULT CHARSET = utf8;</div><div class="line"></div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);</div><div class="line"></div><div class="line">CREATE TABLE `order_info` (</div><div class="line">  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,</div><div class="line">  `user_id`      BIGINT(20)           DEFAULT NULL,</div><div class="line">  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">  `productor`    VARCHAR(30)          DEFAULT NULL,</div><div class="line">  PRIMARY KEY (`id`),</div><div class="line">  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</div><div class="line">)ENGINE = InnoDB,</div><div class="line">DEFAULT CHARSET = utf8;</div><div class="line"></div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);</div></pre></td></tr></table></figure></code></pre><h2 id="EXPLAIN-输出"><a href="#EXPLAIN-输出" class="headerlink" title="EXPLAIN 输出"></a>EXPLAIN 输出</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from user_info where id = 2;</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref   | rows | Extra |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">|  1 | SIMPLE      | user_info | const | PRIMARY       | PRIMARY | 8       | const |    1 | NULL  |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></code></pre><h2 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h2><ol><li><p>select_type 表示了查询的类型, 它的常用取值有:</p><ul><li><code>SIMPLE</code>, 表示此查询不包含 UNION 查询或子查询 (最常见的查询类别就是 <code>SIMPLE</code> 了)</li><li><code>PRIMARY</code>, 表示此查询是最外层的查询</li><li><code>UNION</code>, 表示此查询是 UNION 的第二或随后的查询</li><li><code>DEPENDENT UNION</code>, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li><code>UNION RESULT</code>, UNION 的结果</li><li><code>SUBQUERY</code>, 子查询中的第一个 SELECT</li><li><code>DEPENDENT SUBQUERY</code>: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li></ul></li><li><p>如果使用了<code>UNION</code>查询, 那么EXPLAIN 输出结果类似如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN ( SELECT * FROM user_info WHERE id IN ( 1, 2, 3 ) ) UNION</div><div class="line">( SELECT * FROM user_info WHERE id IN ( 3, 4, 5 ) );</div><div class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</div><div class="line">| id   | select_type  | table      | type  | possible_keys | key     | key_len | ref  | rows | Extra           |</div><div class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</div><div class="line">|    1 | PRIMARY      | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where     |</div><div class="line">|    2 | UNION        | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where     |</div><div class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | ALL   | NULL          | NULL    | NULL    | NULL | NULL | Using temporary |</div><div class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li></ol><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><ol><li>type 字段比较重要, 它<strong>提供了判断查询是否高效的重要依据依据</strong>; 通过 type 字段, 我们判断此次查询是 <strong>全表扫描</strong> 还是 <strong>索引扫描</strong> 等;</li><li><p>type 常用的取值有:</p><ul><li><p><code>system</code>: 表中只有一条数据, 这个类型是特殊的 <code>const</code> 类型; ??</p></li><li><p><code>const</code>: 针对<strong>主键</strong>或<strong>唯一索引</strong>的<strong>等值查询扫描</strong>, 最多只返回一行数据(const 查询速度非常快, 因为它仅仅读取一次即可)</p></li><li><p><code>eq_ref</code>: 此类型通常出现在多表的join查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果, 并且查询的比较操作通常是 =, <strong>查询效率较高</strong>, 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id;</div><div class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</div><div class="line">| id | select_type | table      | type   | possible_keys             | key                       | key_len | ref                     | rows | Extra                    |</div><div class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | order_info | index  | user_product_detail_index | user_product_detail_index | 254     | NULL                    |    9 | Using where; Using index |</div><div class="line">|  1 | SIMPLE      | user_info  | eq_ref | PRIMARY                   | PRIMARY                   | 8       | test.order_info.user_id |    1 | NULL                     |</div><div class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询, 例如下面这个例子中, 就使用到了 ref 类型的查询:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5;</div><div class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</div><div class="line">| id | select_type | table      | type  | possible_keys             | key                       | key_len | ref   | rows | Extra       |</div><div class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info  | const | PRIMARY                   | PRIMARY                   | 8       | const |    1 | NULL        |</div><div class="line">|  1 | SIMPLE      | order_info | ref   | user_product_detail_index | user_product_detail_index | 9       | const |    1 | Using index |</div><div class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>range: 表示使用<code>索引范围查询</code>, 通过索引字段范围获取表中部分数据记录; 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL (没用到索引), 并且 key_len 字段是此次查询中使用到的索引的最长的那个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT * FROM user_info WHERE id BETWEEN 2 AND 8;</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | range | PRIMARY       | PRIMARY | 8       | NULL |    7 | Using where |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>下面对比, 都使用了范围查询, 但是一个可以使用<strong>索引范围查询</strong>, 另一个不能使用索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name&gt;&apos;nihao&apos;;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra                    |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | user_info | range | name_index    | name_index | 152     | NULL |    1 | Using where; Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age&gt;10;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>另外, 可参考 P185: in语句虽然有时候 type结果也是range (不过, 对于真正的范围查询, 确实是无法使用范围列后面的其他索引了, 但是对于”多个等值条件查询”则没有这个限制)</p></li><li><p>index: 表示<strong>全索引扫描(full index scan)</strong>, 和 ALL 类型类似, 只不过ALL类型是全表扫描, <strong>而 index 类型则仅仅扫描所有的索引, 而不扫描数据</strong><br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据, 即 做的是<strong>覆盖索引</strong>, 当是这种情况时, Extra 字段会显示 <code>Using index</code></p><p>下面的例子中, 查询的 <code>name</code> 字段恰好是一个索引(<strong>做到了覆盖索引</strong>), 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据;<br>因此这样的情况下, type 的值是 <code>index</code>, 并且 Extra 的值是 Using index;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM user_info;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | index | NULL          | name_index | 152     | NULL |   10 | Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>下面不但使用了<code>全索引扫描</code>, 而且使用了<code>where条件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name=&apos;nihao&apos;;</div><div class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                    |</div><div class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using where; Using index |</div><div class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>但是, 如果不使用索引的话, 下面type就是<code>ALL</code>, 表示使用了<code>全表扫描</code>, 并且使用了where条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age=10;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age&gt;10;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name&gt;&apos;nihao&apos;;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra                    |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | user_info | range | name_index    | name_index | 152     | NULL |    1 | Using where; Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一, 通常来说, 我们的查询<strong>不应该出现 ALL 类型的查询</strong>, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难<br>如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</p></li><li></li></ul></li></ol><h2 id="type小结"><a href="#type小结" class="headerlink" title="type小结"></a>type小结</h2><p><strong>type 类型的性能比较</strong> : 通常来说, 不同的 type 类型的性能关系如: <code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code></p><ol><li>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的;</li><li>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快;</li><li>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了;</li></ol><h2 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h2><p>possible_keys 表示 MySQL 在查询时, 能够使用到的索引;<br>注意: 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到;(MySQL 在查询时具体使用了哪些索引, 由 key 字段决定)</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>此字段是 MySQL 在当前查询时所真正使用到的索引</p><h2 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h2><p>rows 也是一个重要的字段, MySQL 查询优化器根据统计信息, <strong>估算SQL要查找到结果集需要到表中扫描读取的数据行数</strong>(上面的例子可以看到, 基本上使用到了索引的话, 真正扫描的行数都很少); 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好</p><h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><p>Explain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ol><li><p><strong>Using filesort</strong>: 当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. </p><ul><li><p>一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</p></li><li><p>比如下面, <code>使用索引扫描做排序</code> 和 <code>不使用索引扫描做排序</code> 的效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM user_info ORDER BY name;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | index | NULL          | name_index | 152     | NULL |   10 | Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; EXPLAIN SELECT name FROM user_info ORDER BY age;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra          |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using filesort |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li></ul></li><li><p><code>Using index</code> 与 <code>Using index condition</code></p><ul><li>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li><li><p>比如下面, 第一个做到了<code>覆盖索引</code>扫描, 后面两个都没做到</p><pre><code>mysql&gt; EXPLAIN SELECT name FROM user_info where name=&apos;haha&apos;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                    |+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using where; Using index |+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+1 row in set (0.00 sec)mysql&gt; EXPLAIN SELECT name,age FROM user_info where name=&apos;haha&apos;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                 |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using index condition |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+1 row in set (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM user_info where name=&apos;haha&apos;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                 |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using index condition |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+1 row in set (0.00 sec)</code></pre></li></ul></li><li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备环境&quot;&gt;&lt;a href=&quot;#准备环境&quot; class=&quot;headerlink&quot; title=&quot;准备环境&quot;&gt;&lt;/a&gt;准备环境&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
</feed>
