<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2017-10-25T10:30:52.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Restful API 安全性相关知识 (持续完善中...)</title>
    <link href="http://blog.renyimin.com/2016/06/26/2016-06-26-restful-02-%E5%AE%89%E5%85%A8/"/>
    <id>http://blog.renyimin.com/2016/06/26/2016-06-26-restful-02-安全/</id>
    <published>2016-06-26T04:21:08.000Z</published>
    <updated>2017-10-25T10:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Restful-API-–-接口安全性"><a href="#Restful-API-–-接口安全性" class="headerlink" title="Restful API – 接口安全性"></a>Restful API – 接口安全性</h2><ul><li>其实整套方案可以参考微信公众平台中 进行 <code>服务器配置</code> 时, <a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419318479&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信推荐的签名校验策略</a>;</li></ul><p>首先请注意，开发者在接收消息和事件时，都需要进行消息加解密（某些事件可能需要回复，回复时也需要先进行加密）。但是，通过API主动调用接口（包括调用客服消息接口发消息）时，不需要进行加密。</p><p>服务器配置时设置的token其实就相当于自定义的通信私钥;</p><ul><li>涉及到的相关要点如下:<br><code>客户端的身份认证</code> : 判断请求来源是否合法;<br><code>敏感数据的加密, 防篡改</code> : HTTPS, 数据加密, 签名;<br><code>replay的防范</code> : 防止重放攻击, 在冗余重放时间(服务器间时间误差)内结合nonce参数来保证;<br><code>api请求速率限制</code> : 为防止恶意调用(例如，限制每个用户的API的使用是在?秒内最多?次的API调用，当然速率要调整好)。</li></ul><h2 id="微信公众平台上有很多涉及到接口交互安全性的地方可供参考-同时可参考微信开放平台PHP对接的demo文件"><a href="#微信公众平台上有很多涉及到接口交互安全性的地方可供参考-同时可参考微信开放平台PHP对接的demo文件" class="headerlink" title="微信公众平台上有很多涉及到接口交互安全性的地方可供参考 (同时可参考微信开放平台PHP对接的demo文件):"></a>微信公众平台上有很多涉及到接口交互安全性的地方可供参考 (同时可参考微信开放平台PHP对接的demo文件):</h2><p>1.微信公众平台配置服务器时设置的 <code>url</code>, <code>token</code> 以及生成 <code>EncodingAESKey</code> 是为了让你确保你的公众平台服务器能够安全地 <code>接收</code> 来自微信服务器的请求，当然, <a href="http://blog.csdn.net/zhutulang/article/details/50614042" target="_blank" rel="external">你也可以选择不进行校验</a>, 不过对于你的服务器来说当然就是比较危险的, 因为一旦你的接口地址泄露, 就有可能被恶意调用;</p><ul><li>开发者的服务器通过调用微信服务器上的基础接口, 对外提供了很多可能包含用户资料的接口, 这样就要防止外部恶意窃取和调用;</li></ul><p>2.而开发者服务器可以通过微信公众平台的 <code>AppID</code> 和 <code>AppSecret</code> 获取 <code>access_token</code>(全局access_token, 微信有还有一个授权access_token), 这个是 <code>微信服务器</code> 授予 <code>开发者服务器</code> 的token, 为了限制有这个令牌的服务器才被授权可以调用微信服务器的接口; </p><ul><li><p><a href="http://blog.renyimin.com/2016/03/24/OAuth-07/">属于OAuth的 Client Credentials Grant 授权方案(客户端以自己的名义, 而不是以用户的名义, 向”服务提供商”进行认证)</a>, 获取access_token的接口如下:<br><code>https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</code></p></li><li><p>如果你们公司有 <code>数据中心</code>, <code>支付中心</code>, <code>用户中心</code> 等比较核心的服务来为公司的各个系统提供接口支持, 那你可能就需要有一个后台 <code>授权服务系统</code>, 专门管理这些服务中心的接口对内部系统的授权, 可以为每个系统生成 <code>APPID</code>, <code>APP_SECRET</code><br>然后各系统使用 <code>APPID</code>, <code>APP_SECRET</code> 到 <code>授权服务系统</code> 申请access_token,然后使用access_token来决定是否能调用本服务中的接口;</p></li></ul><p>3.OAuth网页授权 (授权码模式, 客户端是以用户的名义 向”服务提供商”进行认证)</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h2><ul><li>为什么开发者服务器调用微信服务器接口的时候, 不采用上一种方式呢?<br>其接口本身就是开放出来供客户端服务器使用的, 都是基础的功能性的接口, 一般是由能提供access_token的开发者服务器调用;<br>不用对参数做过多校验, 只要开发者服务器被授权就可以调用;</li></ul><ul><li>微信公众平台并没有通过APPID和APPSECRET来对客户端(我们自己的开发者服务器)进行校验, 而是通过 <code>Token</code> 来识别调用我们的开发者服务器的, 这个token是自主设置，与公众平台wiki中常提的access_token不是一回事, 这个token只用于验证开发者服务器;</li><li>另外, 微信公众平台使用了APPID来对传输的内容进行加密;</li><li><a href="http://www.cnblogs.com/technology/p/wenxin_security.html" target="_blank" rel="external">注意</a>: 服务器url和token为了保证在泄露之后不被别人利用, 我们还需要对ToUserName进行校验, 验证ToUserName是否和你的公众号匹配, 否则你的公众平台服务器上的功能有可能被他人使用;)</li><li>微信的签名是使用 <code>SHA1</code> 生成的(<a href="">参考 密码相关</a>);</li></ul><p>3.</p><p><a href="https://segmentfault.com/q/1010000011674185?_ea=2728292" target="_blank" rel="external">https://segmentfault.com/q/1010000011674185?_ea=2728292</a></p><h2 id="客户端身份认证"><a href="#客户端身份认证" class="headerlink" title="客户端身份认证"></a>客户端身份认证</h2><ol><li><code>HTTP Basic</code><br><code>HTTP Digest</code><br><code>API KEY</code><br><code>Oauth</code><br><code>JWT</code></li></ol><p>下面就简单聊聊这些认证方式:</p><h3 id="HTTP-Basic"><a href="#HTTP-Basic" class="headerlink" title="HTTP Basic"></a>HTTP Basic</h3><p>可以网上自行搜索, 基本上不会采用, 因为安全性比较低;</p><h3 id="HTTP-Digest"><a href="#HTTP-Digest" class="headerlink" title="HTTP Digest"></a>HTTP Digest</h3><p>想了解可以网上自行搜索, 以后可能会进行补充, 暂时未做学习;</p><h3 id="API-KEY"><a href="#API-KEY" class="headerlink" title="API KEY"></a>API KEY</h3><h3 id="OAUTH2"><a href="#OAUTH2" class="headerlink" title="OAUTH2"></a>OAUTH2</h3><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>openid可以主要参考微信公众平台的: <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432" target="_blank" rel="external">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432</a></p><p>重点: <a href="http://blog.csdn.net/degwei/article/details/51489391" target="_blank" rel="external">http://blog.csdn.net/degwei/article/details/51489391</a><br><a href="http://wiki.connect.qq.com/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_server-side" target="_blank" rel="external">http://wiki.connect.qq.com/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_server-side</a><br><a href="http://wiki.open.qq.com/wiki/website/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7OpenID_OAuth2.0" target="_blank" rel="external">http://wiki.open.qq.com/wiki/website/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7OpenID_OAuth2.0</a><br>参考: <a href="http://www.searchsoa.com.cn/showcontent_75305.htm" target="_blank" rel="external">http://www.searchsoa.com.cn/showcontent_75305.htm</a></p><p>WSSE(WS-Security)<br>参考文档 : <a href="https://www.ibm.com/developerworks/cn/webservices/ws-secure/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/webservices/ws-secure/</a></p><p><a href="http://php-di.org/" target="_blank" rel="external">http://php-di.org/</a></p><p>UnionID<br>AppName<br>AppID<br>AppSecret(AppKey)<br>    当应用通过OpenAPI调用腾讯开放平台资源时需要的加密串，用来验证应用的合法性。AppKey在创建应用时分配<br>OpenID<br>    OpenID是与APP通信的用户key，跳转到应用首页后，URL后会带该参数。根据APPID以及QQ号码生成，不同的appid下同一个QQ号生成的OpenID是不一样的（目前不接受同一个开发者名下的不同应用之间对于同一个用户的OpenID的互通）。<br>    OpenID在每个应用中都是唯一，作为用户的唯一标识，访问OpenAPI时必需传入OpenID。 </p><p>qq开放平台的专业术语解释:<br><a href="http://wiki.open.qq.com/wiki/%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD#1.3_AppKey" target="_blank" rel="external">http://wiki.open.qq.com/wiki/%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD#1.3_AppKey</a></p><blockquote><blockquote><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">参考 阮一峰</a></p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Restful-API-–-接口安全性&quot;&gt;&lt;a href=&quot;#Restful-API-–-接口安全性&quot; class=&quot;headerlink&quot; title=&quot;Restful API – 接口安全性&quot;&gt;&lt;/a&gt;Restful API – 接口安全性&lt;/h2&gt;&lt;ul&gt;

      
    
    </summary>
    
      <category term="Restful" scheme="http://blog.renyimin.com/categories/Restful/"/>
    
    
      <category term="Restful" scheme="http://blog.renyimin.com/tags/Restful/"/>
    
  </entry>
  
  <entry>
    <title>04 - 授权码模式各阶段参数分析</title>
    <link href="http://blog.renyimin.com/2016/05/25/2016-05-25-OAuth-01-03/"/>
    <id>http://blog.renyimin.com/2016/05/25/2016-05-25-OAuth-01-03/</id>
    <published>2016-05-25T12:10:12.000Z</published>
    <updated>2017-10-25T08:44:37.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一阶段-第三方站点将导向授权页"><a href="#第一阶段-第三方站点将导向授权页" class="headerlink" title="第一阶段: 第三方站点将导向授权页"></a>第一阶段: 第三方站点将导向授权页</h4><ol><li><p>第三方应用将用户导向授权页时, 传递的参数如下:</p><ul><li><code>response_type</code>: 表示授权类型, 必选项, 此处由于采用的是授权码模式, 所以值固定为 “code”</li><li><p><code>client_id/AppID</code>: 表示客户端的ID, 必选项<br>由于你可能会有多个站点需要对接OAuth授权服务器, 所以一般在授权服务平台登录之后, 是可以创建多个 <code>应用</code> 的 (不同的站点对接授权服务器中不同的<code>应用</code>);<br>每个<code>应用</code>对应你的一个 <code>第三方站点</code>, 开放平台会为每个<code>应用(第三方站点)</code>生成相应的 <code>AppID</code> 和 <code>AppSecret/AppKey</code>, 主要用来验证应用的合法性;</p></li><li><p><code>redirect_uri</code>: 设定的重定向到<code>第三方站点URI</code>, 必选项</p></li><li><code>scope</code>: 表示申请的权限范围, 可选项</li><li><code>state</code>: 表示客户端的当前状态, 可以指定任意值, 认证服务器会原封不动地返回这个值</li></ul></li><li><p>下面是各开放平台的参数对比:</p><ul><li><p><a href="http://open.weibo.com/wiki/Oauth2/authorize" target="_blank" rel="external">新浪</a><br><img src="/img/oauth/oauth_sina.png" width="500" height="560" alt="sina" align="center"></p></li><li><p><a href="http://wiki.connect.qq.com/%E4%BD%BF%E7%94%A8authorization_code%E8%8E%B7%E5%8F%96access_token" target="_blank" rel="external">QQ</a><br><img src="/img/oauth/oauth_qq.png" width="500" height="560" alt="qq" align="center"></p></li><li><p><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信</a><br><img src="/img/oauth/oauth_wechat.png" width="500" height="560" alt="wechat" align="center"></p></li><li><p><a href="https://developer.github.com/apps/building-integrations/setting-up-and-registering-oauth-apps/about-authorization-options-for-oauth-apps/" target="_blank" rel="external">GitHub</a><br><img src="/img/oauth/oauth_github.png" width="500" height="560" alt="github" align="center"></p></li><li><p><a href="https://doc.open.alipay.com/docs/doc.htm?treeId=193&amp;articleId=105656&amp;docType=1#s5" target="_blank" rel="external">蚂蚁金服</a><br><img src="/img/oauth/oauth_alipay.png" width="500" alt="github" align="center"></p></li></ul></li><li><p>简单测试:</p><ul><li><p>redirect_uri<br>在OAuth服务器中为第三方站点创建 <code>应用</code> 的时候, 设定的回调地址, 无论在认证服务器, 还是在第三方站点, 都会对其进行校验, <code>以防篡改</code>;</p><p>新浪授权传递错误 redirect_uri<br><img src="/img/oauth/jianshu_sina_err01.png" width="450" height="240" alt="github" align="center"></p><p>简书qq授权传递错误 redirect_uri<br><img src="/img/oauth/jianshu_qq_err01.png" width="450" height="200" alt="github" align="center"></p></li><li><p>state<br>第三方站点会对state做校验<br>给了一个新的弹框用来进行授权, 但是如果恶意用户复制出弹框中的url, 之后再修改state并刷新页面, 授权后发现:<br><img src="/img/oauth/zhihu_auth_qq_01.png" width="500" height="100" alt="github" align="center"></p></li></ul></li><li><p>从上面各平台也可以看到, 返回参数相对比较简单;</p><ul><li>返回的code是和授权页登录的用户身份相关的; (后面的access_token也是通过code和用户身份关联起来的)</li></ul></li></ol><h4 id="第二阶段-通过Authorization-Code获取Access-Token"><a href="#第二阶段-通过Authorization-Code获取Access-Token" class="headerlink" title="第二阶段: 通过Authorization Code获取Access Token"></a>第二阶段: 通过Authorization Code获取Access Token</h4><ol><li><p>如果第三方站点的用户在第一阶段的授权页中选择对第三方站点授权, 那么就第三方站点就会收到授权服务器的Authorization Code, 进而进入本阶段;<br>(每个用户在授权后, 第三方站点都需要到授权服务器上为用户获取一个access_token, 这个access_token就是以后第三方站点从授权服务器上获取用户信息的凭证了, 一般在获取到access_token令牌之后, 可以存储到session中)</p></li><li><p>本阶段, 我们在自己的第三方站点中就可以使用第一阶段的Authorization Code获取Access Token:</p><ul><li><p><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信</a></p></li><li><p><a href="http://wiki.connect.qq.com/%E4%BD%BF%E7%94%A8authorization_code%E8%8E%B7%E5%8F%96access_token" target="_blank" rel="external">qq</a><br><img src="/img/oauth/access_token_qq.png" width="650" height="680" alt="github" align="center"></p></li><li><p>基本上入参就像QQ互联那样大概有5个 (需要对每个参数进行了解);</p></li></ul></li><li><p>本阶段的返回参数比较有讲究, 一般为如下三个</p><ul><li><p>access_token 授权令牌<br>access_token一般在获取到之后, 第三方站点可以将其 <code>保存到用户的session中</code> , 第三方站点之后要获取用户在授权服务器上的资源的时候, 就需要带上当前session中用户的access_token去获取;</p></li><li><p>expires_in    该access token的有效期,单位为秒 (微信公众平台access_token有效期为2小时, qq互联平台为3个月 可以作为参考)<br>设置access_token有效期也是为了定期修改access_token, 以提高安全性;<br>(并且微信对获取access_token这个基础API是有限制的，每天最多请求2000次, 因为有效期为2小时, 每天2000次也足够了;)</p></li><li><p>refresh_token 授权自动续期时使用 (微信公众平台refresh_token有效期为30天, qq互联平台具体不详, 可以作为参考)</p></li></ul></li><li><p>(可选)权限自动续期问题</p><ul><li><p>注意<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信公众平台</a>:<br>  1.若access_token已超时，那么进行refresh_token会获取一个新的access_token，新的超时时间, 并且一旦使用refresh_token来刷新access_token的话, refresh_token的过期时间也会更新(自动延期) ;<br>  2.若access_token未超时，那么进行refresh_token不会改变access_token，但超时时间会刷新，相当于续期access_token ;<br>  这里说的超时时间刷新, 指的自然是第三方站点和授权服务器上的超时时间都要更新了(只不过你如果只是做对接的话, 授权服务器这部分人家已经开发好了, 如果你是授权服务器也是自己开发的话, 那你就需要注意这里了)</p></li><li><p>其实第三方站点在受到授权服务器分配给当前用户的access_token之后, 假设说授权服务器返回access_token的过期时间为7200s(2小时), 那么第三方站点将access_token保存到用户session中, 并设置过期时间为6600s(中间可以有个10分钟的服务器时间差);</p></li><li><p>如果第三方站点在使用access_token为用户获取授权服务器中的资源时, 发现session中的access_token并没有过期, 那么请求后就需要为access_token续期(第三方站点和授权服务器上都要做续期)</p></li><li><p>如果第三方站点在使用access_token为用户获取授权服务器中的资源时, 发现session中的access_token过期, 则就需要使用<code>refresh_token</code>调用<code>生成access_token的api接口</code>重新生成access_token来进行续期；<br>  qq:<br>  <img src="/img/oauth/refresh_token_qq.png" width="650" height="640" alt="github" align="center"></p></li><li><p>这样下来, 基本上第三方站点只有在大于refresh_token的过期时间都没有调用过授权服务器的话, 才需要用户重新登录;</p></li></ul></li></ol><h4 id="第三阶段-比较简单-第三方站点通过access-token获取授权平台资源服务器上的用户资源"><a href="#第三阶段-比较简单-第三方站点通过access-token获取授权平台资源服务器上的用户资源" class="headerlink" title="第三阶段(比较简单): 第三方站点通过access_token获取授权平台资源服务器上的用户资源"></a>第三阶段(比较简单): 第三方站点通过access_token获取授权平台资源服务器上的用户资源</h4><ol><li><p>获取access_token后，进行接口调用，有以下前提：</p><ul><li>access_token有效且未超时；</li><li>微信用户已授权给第三方应用帐号相应接口作用域(scope);<br>也就是在授权服务器上还会使用access_token去检测对应的scope权限是否正确;</li></ul></li><li><p>许多开放平台在申请完access_token令牌之后, 都提供了对应接口来获取用户相关信息<br><a href="http://wiki.connect.qq.com/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_server-side" target="_blank" rel="external">QQ互联</a>提供了相应的接口, 使用Access Token来获取用户的OpenID;<br><a href="http://open.weibo.com/wiki/Oauth2/get_token_info" target="_blank" rel="external">新浪开放平台</a>提供了相应的接口来获取access_token对应的用户信息;<br><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="external">而微信公众平台</a>: 在获取access_token的时候, 会同时返回<code>openid</code>表示微信用户在本公众号中的唯一标识;</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;第一阶段-第三方站点将导向授权页&quot;&gt;&lt;a href=&quot;#第一阶段-第三方站点将导向授权页&quot; class=&quot;headerlink&quot; title=&quot;第一阶段: 第三方站点将导向授权页&quot;&gt;&lt;/a&gt;第一阶段: 第三方站点将导向授权页&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;第三方
      
    
    </summary>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/OAuth2-0/"/>
    
    
      <category term="后端架构" scheme="http://blog.renyimin.com/tags/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>03 - OAuth2.0的CSRF攻击</title>
    <link href="http://blog.renyimin.com/2016/05/24/2016-05-24-OAuth-01-02/"/>
    <id>http://blog.renyimin.com/2016/05/24/2016-05-24-OAuth-01-02/</id>
    <published>2016-05-24T11:27:36.000Z</published>
    <updated>2017-10-25T08:01:49.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>假设有如下几个角色:<br>受害者 <code>lant</code> ;<br>攻击者 <code>rymuscle</code> ;<br>第三方Web应用 <code>liangren网</code> (它允许用户将其在 <code>sandiruiqi网</code> 的账号 和 <code>liangren网</code> 的账号进行绑定) ;<br>OAuth2服务提供平台 <code>sandiruiqi网</code> ;</p></li><li><p>攻击流程</p><ul><li><p><code>攻击者rymuscle</code> 登录 <code>liangren网</code> 并且选择使用自己的 <code>sandiruiqi网</code> 账号登录 ;</p></li><li><p><code>liangren网</code> 将 <code>攻击者rymuscle</code> 重定向到 <code>sandiruiqi网</code> 的授权页(这时可能需要 <code>攻击者rymuscle</code> 登录过<code>sandiruiqi网</code>), <code>sandiruiqi网</code> 的授权页向 <code>攻击者rymuscle</code> 显示 “是否授权<code>liangren网</code>访问” ;</p></li><li><p><code>攻击者rymuscle</code> 在点击”同意授权”之后, 截获 <code>sandiruiqi网</code> 服务器返回的含有 <code>Authorization Code</code> 参数的HTTP响应 ;</p></li><li><p>然后 <code>攻击者rymuscle</code> 精心构造一个Web页面, 它会触发 <code>liangren网</code> 向 <code>sandiruiqi网</code> 发起<strong>令牌申请</strong>的请求, 而这个请求中的Authorization Code参数正是上一步 <code>攻击者rymuscle</code> 截获到的code ;</p></li><li><p><code>攻击者rymuscle</code> 将这个Web页面放到互联网上, 等待或者诱骗受害者来访问 ;</p></li><li><p>假设正好一个受害者 <code>lant</code> 访问了 <code>攻击者rymuscle</code> 准备的这个Web页面后, 令牌申请流程在 <code>受害者lant</code> 的浏览器里被顺利触发, <code>laingren网</code> 从 <code>sandiruiqi网</code> 那里获取到access_token, 但是这个token以及通过它进一步获取到的用户信息却都是攻击者 <code>攻击者rymuscle</code> 的 ;</p></li><li><p>也就是最终 <code>liangren网</code> 将 <code>攻击者rymuscle</code> 的 <code>sandiruiqi</code> 账号同 <code>lant</code> 的 <code>liangren网</code> 账号关联了起来</p><p>从此以后, <code>lant</code>只要没有察觉到自己最初被悄悄使用了 <code>攻击者rymuscle</code> 的<code>sandiruiqi网</code> 账号登录, 那么他在 <code>liangren网</code> 上的所有资料, 都可以被 <code>攻击者rymuscle</code> 所看到, 并且 <code>攻击者rymuscle</code> 可能在 <code>lant</code> 的账号中做一些非法操作;</p></li></ul></li><li><p>整体时序图分析</p><ul><li><p>先看标准oauth时序图<br><img src="/img/oauth/authorization_code.png" width="635" height="600" alt="qq" align="center"></p></li><li><p>下面是从网上copy的一张图, 从整体上来看, 这次攻击的时序图类似下图:<br><img src="/img/oauth/yihuajiemu_mawei.png" width="635" height="580" alt="sina" align="center"></p></li></ul></li><li><p>可以看到, 攻击的关键点在于:<br>OAuth2的认证流程是分为好几步来完成的, 在标准oauth图的第3步, 第三方应用在收到一个GET请求时, 除了能知道当前用户的cookie, 以及URL中的Authorization Code之外, 难以分辨出这个请求到底是用户本人的意愿, 还是攻击者利用用户的身份伪造出来的请求; 于是乎, 攻击者就能使用移花接木的手段, 提前准备一个含有自己的Authorization Code的请求, 并让受害者的浏览器来接着完成后续的令牌申请流程 ;</p></li><li><p>难点(涉及到了非state参数防御):<br> 尽管这个攻击既巧妙又隐蔽, 但是要成功进行这样的CSRF攻击也是比较困难的 :    </p><ul><li><p>整个攻击必须在短时间内完成, 因为OAuth2提供者颁发的Authorization Code有效期很短, <strong>OAuth2官方推荐的时间是不大于10分钟</strong>, 而一旦Authorization Code过期那么后续的攻击也就不能进行下去了;</p></li><li><p>一个Authorization Code只能被使用一次, 如果OAuth2提供者收到重复的Authorization Code, 它会拒绝当前的令牌申请请求, 不止如此, 根据OAuth2官方推荐, 它还可以把和这个已经使用过的Authorization Code相关联的access_token全部撤销掉, 进一步降低安全风险;</p><p>其实貌似只要做到Authorization Code只能被使用一次, 就可以防止csrf在此处的攻击了, 因为 <code>rymuscle</code> 在攻击的时候, 一旦获得 <code>Authorization Code</code>, 第三方站点服务器就会使用 <code>Authorization Code</code> 去申请access_token, 然后只要标记 <code>Authorization Code</code> 为已经使用, 那么 <code>受害者lant</code> 即使点击 <code>攻击者rymuscle</code> 构造好的链接也没用, 因为连接中的 <code>Authorization Code</code> 已经被标记为使用过了;</p></li><li><p>所以不一定非要使用下面的state参数来进行防御<br><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">比如微信公众平台的OAuth授权: state参数就是可选的</a><br><a href="http://open.weibo.com/wiki/Oauth2/authorize" target="_blank" rel="external">新浪开放平台的OAuth授权, state参数也是可选的</a><br>当然, 他们不一定做的是和此处一样的防御方案, 但明显不依赖于state参数来解决问题;</p></li></ul></li><li><p>state参数防御: 要防止这样的攻击其实很容易, 作为第三方应用的开发者, 只需在OAuth认证过程中加入 <code>state</code> 参数, 并验证它的参数值即可;</p><ul><li><p>在将用户重定向到OAuth2的Authorization Endpoint去的时候, 为用户生成一个随机的字符串, 并作为state参数加入到URL中 ;</p></li><li><p>在收到OAuth2服务提供者返回的Authorization Code请求的时候, 验证接收到的state参数值, 如果是正确合法的请求, 那么此时接受到的参数值应该和上一步提到的为该用户生成的state参数值完全一致, 否则就是异常请求;</p><p>但需要注意 <code>state参数</code> 需要具备下面几个特性:</p></li><li><p>不可预测性: 足够的随机, 使得攻击者难以猜到正确的参数值 ;<br>如果你每次生成的state都被放在一起, 比如一个库/缓存中存在很多state;<br>那么问题就是攻击者还是可以拿着自己的code再加上一个state, 来构造一个链接欺骗用户来点击;(假设state正好就在你的库/缓存中);</p></li><li><p>重点是关联性: state参数值可以和当前用户会话(user session)相互关联的<br>所以应该让state和具体的用户关联起来, 虽然用户还没有登录, 但是也可以让state放到session中 ;<br>然后攻击者要猜测出来一个state的话, 即便是已经生成过了, 但是也得正好攻击的是这个用户;</p></li><li><p>唯一性: 每个用户每次请求生成的state参数值都是唯一的 ;</p></li><li><p>时效性: state参数一旦被使用则立即失效 ;</p></li><li><p>参考 蚂蚁金服开放平台:<br><img src="/img/oauth/state_alipay.png" width="600" height="550" alt="wechat" align="center"></p></li></ul></li><li><p>其实可以结合以上各种方法一起来进行防御!</p></li></ol><blockquote><p><a href="http://insights.thoughtworkers.org/attack-aim-at-oauth2/" target="_blank" rel="external">参考 移花接木</a><br><a href="http://blog.sina.com.cn/s/blog_56b798f801018jyb.html" target="_blank" rel="external">参考 state参数漏洞</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">参考 阮一峰</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;假设有如下几个角色:&lt;br&gt;受害者 &lt;code&gt;lant&lt;/code&gt; ;&lt;br&gt;攻击者 &lt;code&gt;rymuscle&lt;/code&gt; ;&lt;br&gt;第三方Web应用 &lt;code&gt;liangren网&lt;/code&gt; (它允许用户将其在 &lt;code&gt;sandirui
      
    
    </summary>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/OAuth2-0/"/>
    
    
      <category term="后端架构" scheme="http://blog.renyimin.com/tags/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>02 - 授权码模式</title>
    <link href="http://blog.renyimin.com/2016/05/22/2016-05-22-OAuth-01-01/"/>
    <id>http://blog.renyimin.com/2016/05/22/2016-05-22-OAuth-01-01/</id>
    <published>2016-05-22T12:27:36.000Z</published>
    <updated>2017-10-25T08:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="授权码模式运行过程"><a href="#授权码模式运行过程" class="headerlink" title="授权码模式运行过程"></a>授权码模式运行过程</h2><ol><li>运行图<br><img src="/img/oauth/authorization_code.png" width="535" height="500" alt="qq" align="center"></li></ol><h2 id="运行过程分析"><a href="#运行过程分析" class="headerlink" title="运行过程分析"></a>运行过程分析</h2><p>1.向用户取得授权许可<br>对应图中的第1、2、3步;</p><p>2.申请访问令牌<br>access_token令牌的申请<br>对应图中的第4、5步;</p><p>3.使用令牌获取用户数据<br>开放平台在申请完access_token令牌之后, 都提供了对应接口来获取用户相关信息, 比如:<br><a href="http://wiki.connect.qq.com/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_server-side" target="_blank" rel="external">QQ互联</a>: 提供了相应的接口, 使用Access Token来获取用户的OpenID;<br><a href="http://open.weibo.com/wiki/Oauth2/get_token_info" target="_blank" rel="external">新浪开放平台</a>: 提供了相应的接口来获取access_token对应的用户信息;<br><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="external">而微信公众平台</a>: 在获取access_token的时候, 会同时返回<code>openid</code>表示微信用户在本公众号中的唯一标识;</p><p>这一过程中涉及了不少敏感参数和数据, 例如client_secret相当于是第三方应用自己的密码, access_token某种程度上来讲就是用户的session id, 由于这些参数以及数据极其特殊, 我们当然得确保它们的安全性, HTTPS加密传输以及安全存储是必不可少的防护手段, <strong>不过仅仅做到这些是远远不够的, 因为其实在这个流程里存在一个弱点， 容易被攻击者利用进行CSRF攻击, <a href="http://blog.renyimin.com/2016/05/24/2016-05-24-OAuth-01-02/">下一篇笔记将会详细分析</a> ; </strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;授权码模式运行过程&quot;&gt;&lt;a href=&quot;#授权码模式运行过程&quot; class=&quot;headerlink&quot; title=&quot;授权码模式运行过程&quot;&gt;&lt;/a&gt;授权码模式运行过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;运行图&lt;br&gt;&lt;img src=&quot;/img/oauth/authoriz
      
    
    </summary>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/OAuth2-0/"/>
    
    
      <category term="后端架构" scheme="http://blog.renyimin.com/tags/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>01 - OAuth(Open Authorization)开放式授权协议</title>
    <link href="http://blog.renyimin.com/2016/05/19/2016-05-19-OAuth-00/"/>
    <id>http://blog.renyimin.com/2016/05/19/2016-05-19-OAuth-00/</id>
    <published>2016-05-19T03:05:00.000Z</published>
    <updated>2017-10-27T02:19:29.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版"><a href="#OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版" class="headerlink" title="OAuth是一个关于授权(authorization)的开放网络标准, 目前的版本是2.0版"></a>OAuth是一个关于授权(authorization)的开放网络标准, 目前的版本是2.0版</h4><ul><li><p>OAuth之前的传统”授权”比较 简单, 直接, 暴力, 一般是直接提供自己资源服务器的账号和密码给第三方站点, 要知道这种做的法弊端太多:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1.如果用户在每个第三方站点都这样做, 那将会存在严重安全隐患:</div><div class="line">很多第三方网站为了后续的服务, 会保存用户资源服务器的账号和密码, 这样很不安全, </div><div class="line">因为难免有些第三方平台会由于自己的安全问题而导致用户的账号和密码泄露, 从而导致用户大量信息泄露 ;</div><div class="line"></div><div class="line">2.用户无法设定第三方站点的权利范围:</div><div class="line">第三方网站拥有了获取用户某个资源服务器的账号和密码后, 就拥有了资源服务器上的所有的资料, 用户没法限制第三方站点获取资源服务器上资源的权利范围和有效期 ;</div><div class="line"></div><div class="line">3.用户想收回第三方站点的权利不太方便:</div><div class="line">用户只有修改密码, 才能收回赋予第三方网站的权力, 否则第三方网站将会永久拥有用户资源服务器上资源的权利，但是这样做, 又会使得其他所有获得用户授权的第三方应用程序全部失效 ;</div><div class="line"></div><div class="line">或者, 一些良心第三方可以设置 用户账号 和 资源服务器账号的绑定和解绑, 但不一定所有第三方都会给你做, 如果不做解绑的话, 你还真就只有前一种方法能够收回权利 ;</div></pre></td></tr></table></figure></li><li><p>而OAuth的授权不会让 <code>第三方站点</code> 触及到用户在 <code>资源服务器</code> 上的帐号信息(如用户名与密码), 即第三方站点无需使用用户资源服务器上的账号与密码, 就可以获得该用户在 <code>资源服务器</code> 上的资源, 因此 OAuth 是安全的 ;</p></li></ul><h4 id="OAuth2-0协议定义了用于获得授权的”四种主要授权类型”"><a href="#OAuth2-0协议定义了用于获得授权的”四种主要授权类型”" class="headerlink" title="OAuth2.0协议定义了用于获得授权的”四种主要授权类型”"></a>OAuth2.0协议定义了用于获得授权的”四种主要授权类型”</h4><h5 id="1-授权码-Authorization-code-模式"><a href="#1-授权码-Authorization-code-模式" class="headerlink" title="1.授权码(Authorization code)模式"></a>1.<a href="http://localhost:4000/2016/03/19/OAuth-authorization-code01/" target="_blank" rel="external">授权码(Authorization code)模式</a></h5><ul><li>授权码模式是功能最完整、流程最严密的授权模式(标准的Server授权模式, 非常适合Server端的Web应用);</li><li>它的特点是: <code>通过客户端的后台服务器, 与&quot;服务提供商&quot;的认证服务器进行互动</code>;<br><img src="/img/oauth/oauth_authorization_code_01.png" width="711" height="514" alt="authorization_code_01" align="center"></li><li><p>运行流程图解</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">用户打开客户端以后，客户端要求用户给予授权。</div><div class="line">用户同意给予客户端授权。</div><div class="line">客户端使用上一步获得的授权，向认证服务器申请令牌。</div><div class="line">认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</div><div class="line">客户端使用令牌，向资源服务器申请获取资源。</div><div class="line">资源服务器确认令牌无误，同意向客户端开放资源</div></pre></td></tr></table></figure></li><li><p>场景:<br>  比如公司需要对接 QQ, 微博, 微信(网页授权) 等登录授权;<br>  或者公司达到可以做自己对外的开放平台;<br>  当然, 公司如果要做对外开放平台, 可能不止使用这一种模式:</p><pre><code>像微信网页授权使用的就是`授权码模式`； 但是微信的基础功能接口和开发者服务器交互的时候, 就使用到了`客户端模式`；而微信服务器涉及到和开发者服务器进行消息交互的时候, 还使用了类似`JWT`的签名校验来保证数据传输的安全;</code></pre></li></ul><h5 id="2-隐式授权模式-Implicit-Grant"><a href="#2-隐式授权模式-Implicit-Grant" class="headerlink" title="2.隐式授权模式(Implicit Grant)"></a>2.隐式授权模式(Implicit Grant)</h5><ul><li>也叫简化模式, 该模式<code>不通过第三方应用程序的服务器</code>, 而是直接在浏览器中向认证服务器申请令牌, 跳过了”授权码”这个步骤, 因此得名;</li><li>它的特点是: 所有步骤在浏览器中完成, 令牌对访问者是可见的;</li><li>流程图:<br><img src="/img/oauth/oauth_implict_01.png" width="660" height="570" alt="oauth_implict_01" align="center"></li><li>场景:</li></ul><h5 id="3-密码模式-Resource-Owner-Password-Credentials"><a href="#3-密码模式-Resource-Owner-Password-Credentials" class="headerlink" title="3.密码模式(Resource Owner Password Credentials)"></a>3.密码模式(Resource Owner Password Credentials)</h5><ul><li>用户向客户端提供自己的用户名和密码, 客户端使用这些信息，向”服务商提供商”索要授权 ;</li><li>这种模式要求用户提供用户名和密码来交换访问令牌access_token ;</li><li>它的特点是:<br>客户端仍然是以单个用户的名义向”服务提供商”进行认证;<br>在这种模式中, 用户必须把自己的密码给客户端, 但是客户端不得储存密码, 这通常用在 <code>用户对客户端高度信任的情况下</code>, 比如客户端也是系统的一部分;</li><li>流程图:<br><img src="/img/oauth/password_credentials_01.png" width="750" height="387" alt="password_credentials_01" align="center"></li><li><p>下图也可参考:<br><img src="/img/oauth/password_credentials_02.png" width="527" height="218" alt="password_credentials_02" align="center"></p></li><li><p>场景:<br>比如当third party application、authorization server、resource owner都是自己公司内的系统, Resource owner对third party application足够信任，所以我们就能采取这种模式来实现;<br>就像: 公司如果有多套内部后台系统, 开发人员和公司管理员可能就要准备多套账号, 比较麻烦, 为了解决这个问题, 可以做一个<code>账号中心</code>系统, 用户在登录各个系统后台的时候, 会先跳转到用户中心进行登录, 一旦登录成功之后, 就会给用户分发一个access_token, 用来在各个系统间作为登录认证 (这也实现了<code>SSO单点登录</code>);<br>(参考: <a href="http://www.cnblogs.com/richieyang/p/4918819.html" target="_blank" rel="external">http://www.cnblogs.com/richieyang/p/4918819.html</a>)</p></li></ul><h5 id="4-客户端模式-Client-Credentials"><a href="#4-客户端模式-Client-Credentials" class="headerlink" title="4.客户端模式(Client Credentials)"></a>4.客户端模式(Client Credentials)</h5><ul><li><p>客户端模式指客户端<code>以客户端自己的名义, 而不是以单个用户的名义</code>，向”服务提供商”进行认证;<br>严格地说, 客户端模式并不属于OAuth框架所要解决的问题;</p></li><li><p>流程图:<br><img src="/img/oauth/oauth_client_credentials_01.png" width="760" height="165" alt="oauth_client_credentials_01" align="center"></p></li><li><p>服务器 <code>不提供像用户数据这样的重要资源</code>，仅仅是一些开放的功能性API;<br>例如微信公众平台, Google Storage或Amazon S3 等开放平台提供的基础服务接口;</p></li><li><p>场景:<br>1.你自己实现了一套基础服务的Api(都是些基础功能接口, 并不涉及用户数据这种重要资源), <code>提供给内部其他系统通过认证的方式来调用</code>;<br>2.公司如果实力强悍的话, 也可以将公司开发的基础服务Api公开出来 <code>供外部其他第三方站点服务器</code> 来调用, 比如: <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183" target="_blank" rel="external">微信公众平台的开放接口其实就是使用这种方式</a>(但微信的网页授权采用的就是授权码模式):<br><img src="/img/oauth/oauth_client_credentials_02.png" width="699" height="475" alt="oauth_client_credentials_02" align="center"></p></li></ul><h4 id="客户端模式-Client-Credentials-和-用户密码模式-有时候比较容易混淆"><a href="#客户端模式-Client-Credentials-和-用户密码模式-有时候比较容易混淆" class="headerlink" title="客户端模式(Client Credentials) 和 用户密码模式 有时候比较容易混淆"></a>客户端模式(Client Credentials) 和 用户密码模式 有时候比较容易混淆</h4><p>1.客户端模式: 如果客户端以自己的身份向服务提供商进行认证, 那需要授权中心给各个应用(不管是内部系统还是第三方站点服务器)分配对应的AppID和AppSecret, 然后第三方应用使用这两个信息来向”认证服务器”申请access_token, 这种场景下, 认证服务器一般提供的接口都是功能性的基础服务接口;<br>2.用户密码模式: 如果客户端以单个用户身份向服务提供商进行认证, 只要用户账号密码能通过认证服务器, 认证服务器就会发放access_token, 当然这种场景需要的是<code>几方角色都属于本公司内部</code>;</p><p>当然这里所聊的是授权相关的知识, 并没有涉及数据传输的加密及签名校验, 但其实像微信公众平台这样开放平台, 除了基础服务接口供给开发者服务器调用时不需要做数据传输的加密和签名校验; 当微信服务器和开发者服务器涉及到用户消息数据的收发时, 会推荐对数据进行加密和签名校验;</p><blockquote><p>参考: <a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a><br>参考: <a href="http://www.cnblogs.com/richieyang/p/4918819.html" target="_blank" rel="external">http://www.cnblogs.com/richieyang/p/4918819.html</a><br>参考: <a href="http://www.dannysite.com/blog/176/" target="_blank" rel="external">http://www.dannysite.com/blog/176/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版&quot;&gt;&lt;a href=&quot;#OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版&quot; class=&quot;headerlink&quot; title=&quot;OA
      
    
    </summary>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/OAuth2-0/"/>
    
    
      <category term="后端架构" scheme="http://blog.renyimin.com/tags/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
</feed>
