<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2017-09-19T04:52:28.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Laravel-install-01</title>
    <link href="http://blog.renyimin.com/2016/04/15/Laravel-install-01/"/>
    <id>http://blog.renyimin.com/2016/04/15/Laravel-install-01/</id>
    <published>2016-04-15T08:34:13.000Z</published>
    <updated>2017-09-19T04:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="通过Composer下载安装"><a href="#通过Composer下载安装" class="headerlink" title="通过Composer下载安装"></a>通过Composer下载安装</h4><p>可以在终端中通过Composer的==create-project==命令来创建一个新的Laravel项目:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">composer create-project laravel/laravel [项目目录名] [项目版本号] --prefer-dist</div><div class="line"></div><div class="line">如果不写laravel下载下来后放置项目的目录名, 则默认为laravel;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">比如要下载Laravel的LTS版本(目前是Laravel5.1), 操作如下:</div><div class="line"></div><div class="line">composer create-project laravel/laravel vip 5.1.33 --prefer-dist</div><div class="line"></div><div class="line">或者</div><div class="line"></div><div class="line">composer create-project laravel/laravel vip 5.1.* --prefer-dist</div></pre></td></tr></table></figure><h4 id="应用Key的设置"><a href="#应用Key的设置" class="headerlink" title="应用Key的设置"></a>应用Key的设置</h4><p>如果你是通过Composer或者Laravel安装器安装的话, 该key的值已经通过key:generate命令生成好了;</p><p>(通常, 该字符串应该是32位长, 该key被配置在.env环境文件中(APP_KEY), 如果你还没有将.env.example文件重命名为.env, 现在立即这样做;如果应用key没有被设置, 用户sessions和其它加密数据将会有安全隐患!)</p><p>如果你不是通过composer安装的laravel, 生成key的方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">先创建一个.env文件</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">然后生成应用key:</div><div class="line"></div><div class="line">bogon:laravel renyimin$ php artisan key:generate</div><div class="line">Application key [7a7rsPOdMubimWYQRddpxEiTRuoQMScE] set successfully.</div><div class="line">bogon:laravel renyimin$</div></pre></td></tr></table></figure><p>你如果是使用Composer安装的话, 可以看到:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-06c8fbb330d8f53f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-740d1978831266b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><h4 id="nginx的设置"><a href="#nginx的设置" class="headerlink" title="nginx的设置:"></a>nginx的设置:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$uri $uri/ /index.php?$query_string</div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-2045d4084f87333c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">项目根目录配置到: 项目目录的 public 目录下;</div></pre></td></tr></table></figure><h4 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功:"></a>安装成功:</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-1d49b5e644607509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;通过Composer下载安装&quot;&gt;&lt;a href=&quot;#通过Composer下载安装&quot; class=&quot;headerlink&quot; title=&quot;通过Composer下载安装&quot;&gt;&lt;/a&gt;通过Composer下载安装&lt;/h4&gt;&lt;p&gt;可以在终端中通过Composer的==cre
      
    
    </summary>
    
      <category term="PHP框架" scheme="http://blog.renyimin.com/categories/PHP%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Laravel" scheme="http://blog.renyimin.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>OAuth 简介</title>
    <link href="http://blog.renyimin.com/2016/03/19/OAuth/"/>
    <id>http://blog.renyimin.com/2016/03/19/OAuth/</id>
    <published>2016-03-19T03:05:00.000Z</published>
    <updated>2017-09-19T04:49:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>该系列文章参考摘抄了很多网络上的资料, 结合自己的思路编写, 方便自己日后回顾, 也希望能给大家提供一定的帮助；</p><h4 id="什么是OAuth-开放式授权-Open-Authorization"><a href="#什么是OAuth-开放式授权-Open-Authorization" class="headerlink" title="什么是OAuth (开放式授权 Open Authorization)"></a>什么是OAuth (开放式授权 Open Authorization)</h4><p>1.OAuth是一个关于授权(authorization)的开放网络标准, 在全世界得到广泛应用, 目前的版本是2.0版;</p><p>2.与以往的授权方式不同之处是, OAuth的授权不会使第三方触及到用户的帐号信息(如用户名与密码), 即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权, 因此 OAuth 是安全的, OAuth 是 <code>Open Authorization(开放授权)</code> 的简写;</p><h4 id="OAuth协议版本"><a href="#OAuth协议版本" class="headerlink" title="OAuth协议版本"></a>OAuth协议版本</h4><p>1.0: 2007.12 (有过安全漏洞, 比较复杂不易用)</p><p>2.0: 2010年初 </p><h4 id="OAuth的应用场景"><a href="#OAuth的应用场景" class="headerlink" title="OAuth的应用场景"></a>OAuth的应用场景</h4><p><strong>最常见的, 我们经常会看到很多网站, 用户除了可以使用网站中自己的的账号密码登录之外, 还可以使用其他一些如 QQ, 微信, GitHub, 人人, 豆瓣 等账户进行登录</strong></p><p>作为第三方的网站, 要让用户使用自己的其他登录进行登录, 则必须要让用户进行授权, 也就是我们通常点击QQ登录之后腾讯为我们弹出的授权页,问我们同不同意使用自己的QQ账号登录这个第三方站点, 并且这个授权页上也有相应的授权范围给我们列出来;</p><p>腾讯其实用的就是OAuth2.0协议让我们对第三方站点进行的授权；</p><p><strong>再比如, 有一个”云冲印”的网站, 可以将用户储存在其他大平台(比如Google)的一些照片冲印出来;</strong></p><p>1.假设用户想在 “云冲印”平台上冲印自己Google账户上的照片, 首先”云冲印”平台得读取到用户储存在Google上的照片, 也就是说用户需要授权给”云冲印”;</p><p>2.这里所谓的”授权”其实就是给云冲印平台能够读取用户Google账户中照片的权限;</p><p>3.传统所谓”授权”做法, 最简单直接的就是用户直接将自己的Google账号和密码提供给”云冲印”平台, 这样后者就可以读取用户的照片了;</p><p>4.但这种做法有以下几个严重缺点:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">"云冲印"</span>作为第三方品台, 为了后续的服务, 会保存用户的Google账号和密码, 这样很不安全, 如果第三方平台都这么让用户提供密码的话, 难免有些第三方平台会由于自己的安全问题导致用户Google账户密码泄露, 这样将导致所有被密码保护的用户大量信息泄露;</div><div class="line"></div><div class="line"><span class="string">"云冲印"</span>拥有了获取用户储存在Google账户中的所有的资料的权力, 用户没法限制<span class="string">"云冲印"</span>获得授权的范围和有效期;</div><div class="line"></div><div class="line">用户只有修改密码, 才能收回赋予<span class="string">"云冲印"</span>的权力, 但是这样做, 会使得其他所有获得用户授权的第三方应用程序全部失效;</div></pre></td></tr></table></figure></p><p>OAuth就可以解决以上的问题;</p><h4 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h4><p>在详细讲解OAuth 2.0之前, 需要了解几个专用名词:</p><p>1.Third-party application: 第三方应用程序, 本文中又称”客户端”, 即上一节例子中的”云冲印”;</p><p>(之前愚蠢的我,一直给网站接入的 如 “QQ, 人人, 微信 等登录api” 叫第三方, 所以后来就和这里的”第三方”有点混淆了, 这里的第三方其实是针对”提供授权服务”的一方来说的, 之前说的第三方是针对你正在操作的网站来说的)</p><p> 2.Owner: 资源所有者, 用户自己;</p><p>3.Authorization server: 认证服务器, 即服务提供商专门用来处理认证的服务器;</p><p>(如QQ,google,人人, 微信提供给第三方平台的认证服务器)</p><p>4.Resource server: 资源服务器, 即服务提供商存放用户生成的资源的服务器(当然, 它与认证服务器, 可以是同一台服务器,也可以是不同的服务器)</p><p>(如你的QQ, google, 人人, 微信 账户中的资料所存放的服务器)</p><h4 id="OAuth的思路"><a href="#OAuth的思路" class="headerlink" title="OAuth的思路"></a>OAuth的思路</h4><p>使用OAuth授权标准, 其实就是”服务提供商”在 第三方客户端(也就是上面的云冲印网站或者你自己的网站) 与 “服务提供商”之间, 设置了一个授权层(authorization layer);</p><p>“第三方客户端” 不能去直接登录 “服务提供商” , 而只能跳转到接入的服务提供商的授权层页面; <strong>用户可以在授权层页面指定授权给第三方客户端的权限范围和有效期</strong> ;</p><p>“第三方客户端” 在登录授权层以后, 授权服务器会根据用户之前授予第三方客户端的权限, 给第三方客户端生成一种叫令牌(token)的东东, 它与用户的密码不同;</p><p>然后第三方客户端就可以使用令牌去资源服务器中请求资源, 资源服务器就会根据令牌中的的权限范围和有效期, 向”第三方客户端”开放用户储存的部分资料;</p><h4 id="OAuth的具体运行流程"><a href="#OAuth的具体运行流程" class="headerlink" title="OAuth的具体运行流程"></a>OAuth的具体运行流程</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">用户在第三方客户端网站点击 如QQ, 人人, 微信登录按钮 以后, 第三方客户端网站会跳转到相应的服务商(如QQ, 人人, 微信)提供的授权页面, 要求用户给予第三方客户端网站一定的授权;</div><div class="line"></div><div class="line">用户如果同意给予当前所在的第三方客户端网站授权;</div><div class="line"></div><div class="line">第三方客户端使用上一步获得的授权, 向(如QQ, 人人, 微信的)认证服务器申请令牌;</div><div class="line"></div><div class="line">认证服务器对第三方客户端进行认证以后, 确认无误, 同意发放令牌;</div><div class="line"></div><div class="line">第三方客户端使用令牌, 再去向(如QQ, 人人, 微信的)资源服务器申请获取资源;</div><div class="line"></div><div class="line">资源服务器确认令牌无误, 同意向第三方客户端开放资源;</div></pre></td></tr></table></figure><p>不难看出来, 上面六个步骤之中, 第二步是关键,即用户怎样才能给于客户端授权, 有了这个授权以后, 进而凭令牌获取资源;</p><h4 id="下面一一讲解客户端获取授权的四种模式"><a href="#下面一一讲解客户端获取授权的四种模式" class="headerlink" title="下面一一讲解客户端获取授权的四种模式:"></a>下面一一讲解客户端获取授权的四种模式:</h4><p>客户端必须得到用户的授权(authorization grant), 才能获得令牌(access token), OAuth 2.0定义了四种授权方式:</p><p><strong>授权码模式（authorization code）</strong></p><p>简化模式（implicit）</p><p>密码模式（resource owner password credentials）</p><p>客户端模式（client credentials）</p><p>参考: <a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">阮一峰</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该系列文章参考摘抄了很多网络上的资料, 结合自己的思路编写, 方便自己日后回顾, 也希望能给大家提供一定的帮助；&lt;/p&gt;
&lt;h4 id=&quot;什么是OAuth-开放式授权-Open-Authorization&quot;&gt;&lt;a href=&quot;#什么是OAuth-开放式授权-Open-Aut
      
    
    </summary>
    
      <category term="OAuth" scheme="http://blog.renyimin.com/categories/OAuth/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>PHP的Closure学习整理</title>
    <link href="http://blog.renyimin.com/2016/03/10/clusore-introduction/"/>
    <id>http://blog.renyimin.com/2016/03/10/clusore-introduction/</id>
    <published>2016-03-10T06:30:15.000Z</published>
    <updated>2017-09-19T04:55:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要是对网上现存的一些资料做了一些简单地整理, 一方面让自己对基础知识加深印象, 一方面便于日后自己随时回顾!</p><h4 id="JavaScript中的闭包"><a href="#JavaScript中的闭包" class="headerlink" title="JavaScript中的闭包"></a>JavaScript中的闭包</h4><p>在了解PHP的闭包之前, 我们可以先简单了解一下JavaScript的闭包是怎样的?</p><h5 id="Js的作用域"><a href="#Js的作用域" class="headerlink" title="Js的作用域"></a>Js的作用域</h5><p>1.要理解闭包，首先必须理解Javascript的 <strong>变量作用域</strong> ;</p><p>2.变量的作用域无非就是两种: <strong>全局变量</strong> 和 <strong>局部变量</strong> ;</p><p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量:<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var n=999;</div><div class="line">function f1()&#123;</div><div class="line">    alert(n);</div><div class="line">&#125;</div><div class="line">f1(); // 999</div></pre></td></tr></table></figure></p><p>另一方面, 在函数外部自然无法读取函数内的局部变量:<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function f1()&#123;</div><div class="line">    var n=999;  //这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</div><div class="line">&#125;</div><div class="line">alert(n); // error</div></pre></td></tr></table></figure></p><h5 id="如何从外部读取局部变量？"><a href="#如何从外部读取局部变量？" class="headerlink" title="如何从外部读取局部变量？"></a>如何从外部读取局部变量？</h5><p>出于种种原因, 我们有时候需要得到函数内的局部变量, 但是, 前面已经说过了, 正常情况下，这是办不到的, 只有通过变通方法才能实现;</p><p>于是, 我们可以在函数的内部, 再定义一个函数:<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function f1()&#123;</div><div class="line">    var n = 999;</div><div class="line">    function f2()&#123;</div><div class="line">        alert(n); // 999</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在上面的代码中, 函数f2就被包括在函数f1内部, 这时, f1内部的所有局部变量, 对f2都是可见的;<br>但是反过来就不行, f2内部的局部变量, 对f1就是不可见的; </p><p>这就是Javascript语言特有的”链式作用域”结构(chain scope), 子对象会一级一级地向上寻找所有父对象的变量; 所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function f1(a)&#123;</div><div class="line">    var n = &apos;局部变量&apos;;</div><div class="line">    function f2(c)&#123;</div><div class="line">       console.log(n);</div><div class="line">       console.log(a);</div><div class="line">       console.log(c);</div><div class="line">    &#125;</div><div class="line">    return f2;</div><div class="line">&#125;</div><div class="line">var result = f1(&apos;传递给函数的参数,也成了一个局部值&apos;);</div><div class="line">result(&apos;传递给闭包的参数1&apos;);</div><div class="line">console.log(&apos;&apos;);</div><div class="line">result(&apos;传递给闭包的参数2&apos;);</div><div class="line">//结果: </div><div class="line">局部变量    //可以看到我们就从外部取到了函数内部的局部变量</div><div class="line">传递给函数的参数,也成了一个局部值</div><div class="line">传递给闭包的参数1</div><div class="line"></div><div class="line">局部变量    //可以看到我们就从外部取到了函数内部的局部变量</div><div class="line">传递给函数的参数,也成了一个局部值</div><div class="line">传递给闭包的参数2</div></pre></td></tr></table></figure></p><h5 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h5><p>上一节代码中的f2函数, 就是闭包;</p><p>各种专业文献上对 “闭包”（closure）定义非常抽象，很难看懂;</p><p>我的理解是，闭包就是能够读取其他函数内部变量的函数;</p><p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量, 因此可以把闭包简单理解成 <strong>“定义在一个函数内部的函数”</strong> ;</p><p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁;</p><h5 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h5><p>1.闭包可以用在许多地方, 它的最大用处有两个:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">一个是前面提到的可以读取函数内部的变量; </div><div class="line">另一个就是让这些变量的值始终保持在内存中;</div></pre></td></tr></table></figure></p><p>2.怎么来理解上面的话呢？</p><p>之前的代码中, result 这个变量其实就是闭包函数f2, 它一共运行了两次;</p><p>而函数f1中的局部变量一直保存在内存中, 并没有在f1调用后被自动清除;</p><p><strong>原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后被垃圾回收机制（garbage collection）回收;</strong></p><h5 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h5><p>1.由于闭包会使得函数中的变量都被保存在内存中, 内存消耗很大, 所以不能滥用闭包, 否则会造成网页的性能问题, 在IE中可能导致内存泄露, 解决方法是, 在退出函数之前, 将不使用的局部变量全部删除;</p><p>2.闭包会在父函数外部改变父函数内部变量的值; 所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method）, 把内部变量当作它的私有属性（private value）, 这时一定要小心, 不要随便改变父函数内部变量的值;</p><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line">var object = &#123;</div><div class="line">    name : &quot;My Object&quot;,</div><div class="line">    getNameFunc : function()&#123;</div><div class="line">        return function()&#123;</div><div class="line">            return this.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">console.log(object.getNameFunc()());     // The Window</div></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line">var object = &#123;</div><div class="line">    name : &quot;My Object&quot;,</div><div class="line">    getNameFunc : function()&#123;</div><div class="line">        var that = this;</div><div class="line">        return function()&#123;</div><div class="line">            return that.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">console.log(object.getNameFunc()());    // My Object</div></pre></td></tr></table></figure><p>以上参考<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">阮一峰的博客</a>, 阮一峰大哥真的写的很好了, 本人这里只是过一遍, 然后稍微简化了一点点, 修改了一点列子, 便于自己理解;</p><h4 id="PHP的闭包"><a href="#PHP的闭包" class="headerlink" title="PHP的闭包"></a>PHP的闭包</h4><p>1.PHP的<code>闭包</code> 和 <code>匿名函数</code> 是在PHP5.3.0中引入, 这两个特性非常有用, 每个PHP开发者都应该掌握;</p><p>2.闭包是指在创建时, <strong>封装周围状态的函数</strong>, 即便闭包所在的环境不存在了, 闭包中封装的状态依然存在, 这个概念如果你看了之前的JavaScript相关闭包的概念, 应该理解起来不是太难;</p><p>3.匿名函数是没有名称的的函数, 匿名函数可以赋值给变量, 还能像其他任何PHP变量那样传递, 不过匿名函数仍是函数, 因此可以调用, 还可以传入参数, 匿名函数特别适合作为函数或方法的回调;</p><p>4.理论上讲, 闭包和匿名函数是不同的概念, 不过, PHP将其视为相同的概念, 所以一般在PHP中说闭包就是匿名函数, 说匿名函数也是指闭包;</p><p>5.PHP闭包和匿名函数使用的句法虽然和普通函数相同, 但是需要注意的是, 闭包和匿名函数其实是<strong>伪装成函数的对象</strong>, 如果审查PHP闭包或匿名函数, 会发现阀门是Closure类的实例; 闭包和字符串或证书一样, 也是<strong>一等值类型</strong> ;</p><h5 id="创建闭包"><a href="#创建闭包" class="headerlink" title="创建闭包"></a>创建闭包</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$closure = <span class="function"><span class="keyword">function</span> <span class="params">($name)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sprintf(<span class="string">'Hello %s'</span>, $name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var_dump($closure); <span class="comment">//object(Closure)#1 (1) &#123; ["parameter"]=&gt; array(1) &#123; ["$name"]=&gt; string(10) "" &#125; &#125;</span></div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;br/&gt;'</span>;</div><div class="line"><span class="keyword">echo</span> $closure(<span class="string">'Josh'</span>);  <span class="comment">//Hello Josh</span></div></pre></td></tr></table></figure><p>闭包对象的创建就这么简单;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">建议: 之所以能调用$closure变量, 是因为这个变量的值是一个闭包, 而且闭包对象实现了__invoke()魔术方法;</div><div class="line">只要变量名后面有(), PHP就会查找并调用__invoke()方法;</div></pre></td></tr></table></figure><p>通常情况下, 我们会把PHP的闭包对象当做函数和方法的回调来使用; 很多PHP的函数都会用到回调函数, 例如 array_map()和preg_replace_callback();<br>这是使用PHP匿名函数的绝佳时机! 记住, 闭包和其他值一样, 可以作为参数出传入其他PHP函数;</p><h5 id="PHP中闭包的-附加状态"><a href="#PHP中闭包的-附加状态" class="headerlink" title="PHP中闭包的 附加状态"></a>PHP中闭包的 <code>附加状态</code></h5><p>1.之前我们说的 array_map()和preg_replace_callback() 对闭包的使用, 主要是把匿名函数当做回调来使用;<br><strong>下面我们讨论的是如何为PHP闭包附加并封装状态;</strong></p><p><strong>2</strong>.JavaScript开发者可能对PHP的闭包感到奇怪, 因为通过之前对JavaScript中闭包的了解, <strong>它的闭包会自动封装应用的状态</strong>; 而PHP的闭包不会像真正的JS闭包那样自动封装应用的状态;<br><strong>在PHP中, 我们必须手动调用闭包对象的 <code>use关键字</code> , 或者闭包对象的 <code>bindTo()方法</code> 来把状态附加到PHP闭包上;</strong></p><h5 id="use关键字"><a href="#use关键字" class="headerlink" title="use关键字"></a>use关键字</h5><p>使用use关键字附加闭包状态比较常见, 我们先看这种方式;</p><p>使用use关键字把变量附加到闭包上时, 附加的变量会记住附加时赋给它的值:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enclosePerson</span><span class="params">($name)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">($doCommand)</span> <span class="title">use</span> <span class="params">($name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sprintf(<span class="string">'%s, %s'</span>, $name, $doCommand);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$clay = enclosePerson(<span class="string">'Clay'</span>);</div><div class="line"></div><div class="line"><span class="keyword">echo</span> $clay(<span class="string">'get me sweet tea!'</span>);</div></pre></td></tr></table></figure></p><p>在例子中, 具名函数enclosePerson()有个名为$name参数, 这个函数返回一个闭包对象, 而且这个闭包对象封装了$name参数;<br>即便返回的闭包对象已经跳出了enclosePerson()函数的作用域, 闭包对象也会记住$name参数的值, 因为$name变量仍在闭包中;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">使用<span class="keyword">use</span>关键字可以把多个参数传入闭包, 此时要像<span class="title">php</span>函数或方法的参数一样, 使用都好分割多个参数;</div></pre></td></tr></table></figure><h5 id="Closure对象的bindTo-方法"><a href="#Closure对象的bindTo-方法" class="headerlink" title="Closure对象的bindTo()方法"></a>Closure对象的bindTo()方法</h5><p>1.别忘了, php闭包是个对象(Closure对象), 与任何其他PHP对象类似, 每个闭包都可以使用$this关键字获取闭包的内部状态; </p><p>虽然闭包对象的默认状态没什么用, 只不过是有一个__invoke魔术方法和bindTo()方法而已; 但是bindTo()方法为闭包增加了一些有趣的潜力, 我们可以使用这个方法把closure对象内部的状态绑定到其他对象上;</p><p>2.<strong>bindTo()方法的第二个参数很重要, 其作用是指定绑定闭包的那个对象所属的PHP类; 因此, 闭包可以访问绑定闭包的对象中受保护和似有的成员变量;</strong></p><p>3.其实如果经常看一些php框架源码, 你会发现, PHP框架经常使用bindTo()方法把 <code>路由URL所映射的匿名回调函数</code> 绑定到 <code>应用对象上</code>, 这么做可以在这个匿名函数中使用$this关键字引用重要的应用对象:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">protected</span> $routes = [];</div><div class="line">    <span class="keyword">protected</span> $responseStatus = <span class="string">'200 OK'</span>;</div><div class="line">    <span class="keyword">protected</span> $responseContentType = <span class="string">'text/html'</span>;</div><div class="line">    <span class="keyword">protected</span> $responseBody = <span class="string">'Hello world'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addRoute</span><span class="params">($routePath, $routeCallback)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;routes[$routePath] = $routeCallback-&gt;bindTo(<span class="keyword">$this</span>, <span class="keyword">__CLASS__</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">($currentPath)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">foreach</span>(<span class="keyword">$this</span>-&gt;routes <span class="keyword">as</span> $routePath =&gt; $callBack)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> ($routePath === $currentPath) &#123;</div><div class="line">                $callBack();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        header(<span class="string">'HTTP/1.1 '</span> . <span class="keyword">$this</span>-&gt;responseStatus);</div><div class="line">        header(<span class="string">'Content-type: '</span> . <span class="keyword">$this</span>-&gt;responseContentType);</div><div class="line">        header(<span class="string">'Content-length: '</span> . mb_strlen(<span class="keyword">$this</span>-&gt;responseBody));</div><div class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;responseBody;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$app = <span class="keyword">new</span> App();</div><div class="line">$app-&gt;addRoute(<span class="string">'/user/getName'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;responseContentType = <span class="string">'application/json;charset=utf8'</span>;</div><div class="line">    <span class="keyword">$this</span>-&gt;responseBody = <span class="string">'&#123;"name": "renyimin"&#125;'</span>;</div><div class="line">&#125;);</div><div class="line">$app-&gt;dispatch(<span class="string">'/user/getName'</span>);</div><div class="line"></div><div class="line"><span class="comment">//结果返回: &#123;"name": "renyimin"&#125;</span></div></pre></td></tr></table></figure></p><p>上面例子其实就是通过在App应用类中, 使用匿名函数的bindTo()方法将匿名函数绑定到了App对象上, 所以你就可以在绑定路由与其匿名函数的时候, 在匿名函数中来通过$this来调用App对象中的一些受保护的属性, 从而设定本路由的返回信息;</p><blockquote><p>《Modern PHP》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要是对网上现存的一些资料做了一些简单地整理, 一方面让自己对基础知识加深印象, 一方面便于日后自己随时回顾!&lt;/p&gt;
&lt;h4 id=&quot;JavaScript中的闭包&quot;&gt;&lt;a href=&quot;#JavaScript中的闭包&quot; class=&quot;headerlink&quot; title=&quot;J
      
    
    </summary>
    
      <category term="PHP New Features" scheme="http://blog.renyimin.com/categories/PHP-New-Features/"/>
    
      <category term="PHP" scheme="http://blog.renyimin.com/categories/PHP-New-Features/PHP/"/>
    
    
      <category term="Closure(闭包)" scheme="http://blog.renyimin.com/tags/Closure-%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
</feed>
