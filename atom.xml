<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2017-11-15T03:02:20.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>04.与调度器之间通信--系统调用</title>
    <link href="http://blog.renyimin.com/2017/05/16/2017-05-16-Iterator-generator-yield-04/"/>
    <id>http://blog.renyimin.com/2017/05/16/2017-05-16-Iterator-generator-yield-04/</id>
    <published>2017-05-16T14:15:00.000Z</published>
    <updated>2017-11-15T03:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>调度器现在已经正常运行了, 下一个问题是：<strong>任务和调度器之间的通信</strong> ;</p></li><li><p>任务和调度器之间的通信:</p><ul><li><p>我们将使用与 <code>进程和操作系统之间会话</code> 所使用的方式来通信: <code>系统调用</code> ;</p></li><li><p>使用 <code>系统调用</code> 这种通信方式的理由是: 操作系统与进程相比, 两者是处在不同的权限级别上, 操作系统为了执行特权级别的操作(如杀死另一个进程), 就不得不以某种方式把控制传回给内核, 这样内核就可以执行所说的操作了;<br>(再说一遍, 这种行为在内部是通过使用中断指令来实现的, 过去使用的是通用的int指令, 如今使用的是更特殊并且更快速的syscall/sysenter指令)</p></li><li><p>而接下来我们的任务调度系统就要使用这种设计:<br>不是简单地把调度器传递给任务(这样就允许它做它想做的任何事), 我们将通过给yield表达式传递信息来与系统调用通信, 这儿yield既是中断,也是传递信息给调度器(和从调度器传递出信息)的方法;</p></li></ul></li><li><p>代码:</p><ul><li><p>任务类: 和之前没什么变化</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> $taskId;</div><div class="line">    <span class="keyword">protected</span> $coroutine;</div><div class="line">    <span class="keyword">protected</span> $sendValue = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">protected</span> $beforeFirstYield = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($taskId, Generator $coroutine)</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;taskId = $taskId;</div><div class="line">        <span class="keyword">$this</span>-&gt;coroutine = $coroutine;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;taskId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSendValue</span><span class="params">($sendValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;sendValue = $sendValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;beforeFirstYield) &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;beforeFirstYield = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;coroutine-&gt;current();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;coroutine-&gt;send(<span class="keyword">$this</span>-&gt;sendValue);</div><div class="line">            <span class="keyword">$this</span>-&gt;sendValue = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> !<span class="keyword">$this</span>-&gt;coroutine-&gt;valid();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>系统调用:系统调用是操作系统提供给程序设计人员的一种服务,程序设计人员在编写程序时,可以利用系统调用来请求操作系统的服务</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> $callback;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(callable $callback)</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;callback = $callback;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">(Task $task, Scheduler $scheduler)</span> </span>&#123;</div><div class="line">        $callback = <span class="keyword">$this</span>-&gt;callback;</div><div class="line">        <span class="keyword">return</span> $callback($task, $scheduler);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调度器: run方法相比之前做了一些修改</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> $taskId = <span class="number">0</span>;</div><div class="line">    <span class="comment">//protected $taskMap = []; // taskId =&gt; task</span></div><div class="line">    <span class="keyword">protected</span> $taskQueue;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;taskQueue = <span class="keyword">new</span> SplQueue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">newTask</span><span class="params">(Generator $coroutine)</span> </span>&#123;</div><div class="line">        $taskId = ++<span class="keyword">$this</span>-&gt;taskId;</div><div class="line">        $task = <span class="keyword">new</span> Task($taskId, $coroutine);</div><div class="line">        <span class="comment">//$this-&gt;taskMap[$taskId] = $task;</span></div><div class="line"></div><div class="line">        <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">        <span class="keyword">return</span> $taskId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">schedule</span><span class="params">(Task $task)</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;taskQueue-&gt;enqueue($task);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (!<span class="keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;</div><div class="line">            $task = <span class="keyword">$this</span>-&gt;taskQueue-&gt;dequeue();</div><div class="line">            $retval = $task-&gt;run();</div><div class="line">            <span class="comment">//如果yield返回的是个系统调用(每个任务第一次的yield返回的就是个系统调用)</span></div><div class="line">            <span class="keyword">if</span> ($retval <span class="keyword">instanceof</span> SystemCall) &#123;</div><div class="line">                <span class="keyword">echo</span> <span class="number">123</span> . PHP_EOL;</div><div class="line">                $retval($task, <span class="keyword">$this</span>);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ($task-&gt;isFinished()) &#123;</div><div class="line">                <span class="comment">//unset($this-&gt;taskMap[$task-&gt;getTaskId()]);</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>测试:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">require_once</span> <span class="string">"task.php"</span>;</div><div class="line"><span class="keyword">require_once</span> <span class="string">"scheduler.php"</span>;</div><div class="line"><span class="keyword">require_once</span> <span class="string">"systemCall.php"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SystemCall(<span class="function"><span class="keyword">function</span><span class="params">(Task $task, Scheduler $scheduler)</span> </span>&#123;</div><div class="line">        $task-&gt;setSendValue($task-&gt;getTaskId());<span class="comment">//这里主要是在任务运行一开始进行的系统调用中设置任务的id, 并将任务继续压栈 (总共就干两件事), </span></div><div class="line">        $scheduler-&gt;schedule($task);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//系统功能调用是操作系统提供给程序设计人员的一种服务。程序设计人员在编写程序时，可以利用系统调用来请求操作系统的服务</span></div><div class="line"><span class="comment">//用户程序只在用户态下运行，有时需要访问`系统核心功能`，这时就需要通过系统调用接口来使用 `系统调用`</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">($max)</span> </span>&#123;</div><div class="line">    $tid = (<span class="keyword">yield</span> getTaskId()); <span class="comment">// &lt;-- here's the syscall!</span></div><div class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $max; ++$i) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"This is task $tid iteration $i.\n"</span>;</div><div class="line">        <span class="keyword">yield</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$scheduler = <span class="keyword">new</span> Scheduler;</div><div class="line"><span class="comment">//添加两个任务到队列中</span></div><div class="line">$scheduler-&gt;newTask(task(<span class="number">10</span>));</div><div class="line">$scheduler-&gt;newTask(task(<span class="number">5</span>));</div><div class="line"><span class="comment">//运行调度器</span></div><div class="line">$scheduler-&gt;run();</div></pre></td></tr></table></figure></li></ul></li><li><p>结果和之前的简单任务调度一样;</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">renyimin$ php index1.php </div><div class="line"><span class="number">123</span>            <span class="comment">// 可以看到, 总共运行了两次系统调用(每个任务在一开始都是各自运行一次自己的系统调用)</span></div><div class="line"><span class="number">123</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">1.</span>  </div><div class="line">This is task <span class="number">2</span> iteration <span class="number">1.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">2.</span></div><div class="line">This is task <span class="number">2</span> iteration <span class="number">2.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">3.</span></div><div class="line">This is task <span class="number">2</span> iteration <span class="number">3.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">4.</span></div><div class="line">This is task <span class="number">2</span> iteration <span class="number">4.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">5.</span></div><div class="line">This is task <span class="number">2</span> iteration <span class="number">5.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">6.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">7.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">8.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">9.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">10.</span></div></pre></td></tr></table></figure></li></ol><blockquote><p>参考: <a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="external">http://www.laruence.com/2015/05/28/3038.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;调度器现在已经正常运行了, 下一个问题是：&lt;strong&gt;任务和调度器之间的通信&lt;/strong&gt; ;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任务和调度器之间的通信:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们将使用与 &lt;code&gt;进程和操作系统之间会话&lt;/code
      
    
    </summary>
    
      <category term="PHP高级" scheme="http://blog.renyimin.com/categories/PHP%E9%AB%98%E7%BA%A7/"/>
    
      <category term="Coroutine" scheme="http://blog.renyimin.com/categories/PHP%E9%AB%98%E7%BA%A7/Coroutine/"/>
    
    
      <category term="PHP高级" scheme="http://blog.renyimin.com/tags/PHP%E9%AB%98%E7%BA%A7/"/>
    
      <category term="Coroutine" scheme="http://blog.renyimin.com/tags/Coroutine/"/>
    
  </entry>
  
  <entry>
    <title>03.PHP - 如何使用协程来实施任务调度</title>
    <link href="http://blog.renyimin.com/2017/05/16/2017-05-16-Iterator-generator-yield-03/"/>
    <id>http://blog.renyimin.com/2017/05/16/2017-05-16-Iterator-generator-yield-03/</id>
    <published>2017-05-16T11:25:00.000Z</published>
    <updated>2017-11-15T08:15:13.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>从之前的知识可以了解到, 其实<code>(迭代器)生成器</code> 也只不过是一个函数, <strong>不同的是这个函数的返回值是依次返回, 而不是只返回一个单独的值</strong>; (也就是说, 生成器使你更方便的实现了迭代器) ;</p></li><li><p>为什么叫 <code>迭代生成器</code>, 因为它返回了一个 <code>迭代器</code>, 而这个迭代器实现了Iterator接口 ;</p></li><li><p>生成器为<strong>可中断的函数</strong>, 在它里面的 yield 构成了中断点 ;</p></li><li><p>再看一个简单的 <code>迭代生成器</code> 进行双向传输信息的 例子 :</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span><span class="params">()</span> </span>&#123;</div><div class="line">    $ret = (<span class="keyword">yield</span> <span class="string">'yield1'</span>);</div><div class="line">    var_dump($ret);</div><div class="line">    $ret = (<span class="keyword">yield</span> <span class="string">'yield2'</span>);</div><div class="line">    var_dump($ret);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">$gen = gen();</div><div class="line">var_dump($gen-&gt;current());    <span class="comment">// string(6) "yield1"</span></div><div class="line">var_dump($gen-&gt;send(<span class="string">'ret1'</span>)); <span class="comment">// string(4) "ret1"   (the first var_dump in gen)</span></div><div class="line">                              <span class="comment">// string(6) "yield2" (the var_dump of the -&gt;send() return value)</span></div><div class="line">var_dump($gen-&gt;send(<span class="string">'ret2'</span>)); <span class="comment">// string(4) "ret2"   (again from within gen)</span></div><div class="line">                              <span class="comment">// NULL               (the return value of -&gt;send())</span></div></pre></td></tr></table></figure></li><li><p>注意：</p><ul><li>yield表达式两边的括号在PHP7以前不是可选的, 也就是说在PHP5.5和PHP5.6中圆括号是必须的 ;</li><li>….</li></ul></li><li><p>什么是协程（Coroutine）？</p><ul><li><p>在协程出现之前，要实现多任务并发，在无OS（操作系统）时代，可以使用状态机的思想对多任务进行拆解，在单进程环境中运行多任务，但是这种模式下需要开发者对每个任务有清晰的了解，也要开发者自行开发与任务相关功能（如任务间的通讯）;</p></li><li><p>后来出现了OS（操作系统），咱们就开始使用OS提供的进程和线程功能来轻易实现多任务了。在OS中，进程的上下文切换是OS内核控制。但是后来却出现了一个问题，频繁的进程上下文切换导致了OS性能的降低（主要是短时执行消耗小的任务进程）;</p></li><li><p>为了解决这个问题，开始提出新的概念，就是在同一进程或线程中运行多个任务，这种问题就相当于回到了早期的无OS时代的多任务实现。而现在解决方案称为协程。其本质是，将将任务切换的部分工作从内核转移到应用层;</p></li></ul></li><li><p>协程特点:</p><ul><li>为应用层实现多任务提供了工具; </li><li>协程不允许多任务同时执行，要执行其它协程，必须使用关键字yield主动放弃cpu控制权; </li><li>协程需要自己写任务管理器，以及任务调度器； </li><li>减轻了OS处理零散任务和轻量级任务的负</li></ul></li><li><p>使用协程实现<strong>多任务协作</strong>，我们要解决的问题是你想并发地运行多任务(或者”程序”), 不过我们都知道CPU在一个时刻只能运行一个任务(不考虑多核的情况), 因此处理器需要在不同的任务之间进行切换,而且总是让每个任务运行 <code>一小会儿</code> ;</p><p><strong>多任务协作</strong> 这个术语中的”协作”很好的说明了如何进行这种切换的: 首先, 我们是通过调度器来调度每个任务运行的, 它而所谓协作就是要求当前正在运行的任务自动把控制传回给<code>调度器</code>, 这样就调度器就可以调度其他任务来运行了 ;</p></li><li><p>现在你应当明白 <code>协程</code> 和 <code>任务调度</code> 之间的关系:</p><ul><li>yield指令提供了任务中断自身的一种方法, 然后把控制交回给任务调度器, 因此协程可以运行多个任务; 更进一步, yield还可以用来在任务和调度器之间进行通信 ;</li><li>可以这么理解 :<br>调度器在调度任务的时候, 是通过模拟一个队列, 然后将使用调度器创建任务(其实就是将多个任务压栈), 之后由于每个任务执行一次就会执行<code>出栈</code>, <strong>并且就任务会通过yield中断当前任务并将控制权交给调度器</strong>, 调度器就可以通过这样就实现了轮询的方式执行多个任务 ; </li></ul></li><li><p>小疑问:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'foo'</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'bar'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$gen = gen();</div><div class="line">var_dump($gen-&gt;rewind());</div><div class="line">var_dump($gen-&gt;send(<span class="string">'something'</span>));</div><div class="line"></div><div class="line"><span class="comment">// 鸟哥博客相关讨论小结:</span></div><div class="line"><span class="comment">// 在send之前, 如果没有显示地调用current, 那么当$gen迭代器被创建的时候一个rewind()方法已经被隐式调用</span></div><div class="line"><span class="comment">// 所以实际上发生的应该类似:</span></div><div class="line"><span class="comment">//$gen-&gt;rewind();   //不过可惜的是, rewind的执行将虽然会导致第一个yield被执行, 但是却会忽略他的返回值.</span></div><div class="line"></div><div class="line"><span class="comment">//var_dump($gen-&gt;send('something')); // 真正当我们调用yield的时候, 我们得到的是第二个yield的值! 导致第一个yield的值被忽略.</span></div><div class="line">                                    <span class="comment">//string(3) "bar"</span></div></pre></td></tr></table></figure></li><li><p>先看一个简单的任务调度程序: 通过模拟cpu轮询来调度两个 循环打印的任务</p><ul><li><p>任务类: 主要作用是在其内部将<code>一个用轻量级的包装的协程函数</code>手动进行迭代</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> $taskId;</div><div class="line">    <span class="keyword">protected</span> $coroutine;</div><div class="line">    <span class="keyword">protected</span> $sendValue = <span class="keyword">null</span>;   <span class="comment">//在此处暂时还没有用</span></div><div class="line"> </div><div class="line">    <span class="comment">//通过添加 firstYieldTag 我们可以保证第一处 yield 的值能被正确返回, 因为之前我们已经了解到:</span></div><div class="line">    <span class="comment">//对生成器生成的迭代器进行手动迭代的话, 如果在send之前, 没有显示地调用current, 那么当迭代器被创建的时候一个rewind会默认执行, 但是不会有返回;</span></div><div class="line">    <span class="comment">//所以针对第一处yield, 要想看到返回值, 我们需要手动调用current</span></div><div class="line">    <span class="keyword">protected</span> $firstYieldTag = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($taskId, Generator $coroutine)</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;taskId = $taskId;</div><div class="line">        <span class="keyword">$this</span>-&gt;coroutine = $coroutine;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;taskId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 使用setSendValue()方法, 你可以指定哪些值将被发送到下次的恢复(现在暂时不会用到, 在之后会用到)</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSendValue</span><span class="params">($sendValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;sendValue = $sendValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//其实就是在这个run方法中做的手动迭代</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;firstYieldTag) &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;firstYieldTag = <span class="keyword">false</span>;  <span class="comment">// 第一次调用之后就进行标识</span></div><div class="line">            <span class="keyword">$this</span>-&gt;coroutine-&gt;current();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;coroutine-&gt;send(<span class="keyword">$this</span>-&gt;sendValue);</div><div class="line">            <span class="keyword">$this</span>-&gt;sendValue = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> !<span class="keyword">$this</span>-&gt;coroutine-&gt;valid();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调度器类:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> $taskId = <span class="number">0</span>;</div><div class="line">    <span class="comment">//protected $taskMap = []; // taskId =&gt; task</span></div><div class="line">    <span class="keyword">protected</span> $taskQueue;</div><div class="line"></div><div class="line">    <span class="comment">//调度器初始化其实就是简单创建了一个队列</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;taskQueue = <span class="keyword">new</span> SplQueue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">newTask</span><span class="params">(Generator $coroutine)</span> </span>&#123;</div><div class="line">        $taskId = ++<span class="keyword">$this</span>-&gt;taskId;<span class="comment">//简单通过递增的方法来设置 任务的唯一标识 任务id</span></div><div class="line">        $task = <span class="keyword">new</span> Task($taskId, $coroutine);<span class="comment">//通过 任务id 和 迭代器的生成器 来创建任务</span></div><div class="line">        <span class="comment">//将创建好的任务和任务id对应起来 存入数组</span></div><div class="line">        <span class="comment">//$this-&gt;taskMap[$taskId] = $task;</span></div><div class="line">        <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">        <span class="keyword">return</span> $taskId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//添加任务到队列</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">schedule</span><span class="params">(Task $task)</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;taskQueue-&gt;enqueue($task);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//运行调度器, 这里是模拟cpu并发 轮询执行任务的关键 (通过不断地将任务出栈和压栈)</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//如果任务队列不为空</span></div><div class="line">        <span class="keyword">while</span> (!<span class="keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;</div><div class="line">            <span class="comment">//将任务弹出队列 准备运行任务</span></div><div class="line">            $currentTask = <span class="keyword">$this</span>-&gt;taskQueue-&gt;dequeue();</div><div class="line">            <span class="comment">//然后运行任务 (其实每个任务就是 迭代器生成器 生成的 迭代器)</span></div><div class="line">            <span class="comment">//这里run其实就是对队列中的任务进行了 '一次' 迭代</span></div><div class="line">            $currentTask-&gt;run();</div><div class="line"></div><div class="line">            <span class="comment">// 如果弹出队列的任务(迭代器)如果运行结束(即 迭代器对象循环结束), 则从任务数组中删除任务</span></div><div class="line">            <span class="keyword">if</span> ($currentTask-&gt;isFinished()) &#123; </div><div class="line">                <span class="comment">//unset($this-&gt;taskMap[$task-&gt;getTaskId()]);</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//如果任务没有运行结束则继续将任务压入队列</span></div><div class="line">                <span class="keyword">$this</span>-&gt;schedule($currentTask);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>测试:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">require_once</span> <span class="string">"task.php"</span>;</div><div class="line"><span class="keyword">require_once</span> <span class="string">"scheduler.php"</span>;</div><div class="line"> </div><div class="line"><span class="comment">//第一个任务(一个`迭代器生成器`):</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">task1</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">10</span>; ++$i) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"This is task 1 iteration $i.\n"</span>;</div><div class="line">        <span class="keyword">yield</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//第二个任务(一个`迭代器生成器`):</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">task2</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">5</span>; ++$i) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"This is task 2 iteration $i.\n"</span>;</div><div class="line">        <span class="keyword">yield</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">$scheduler = <span class="keyword">new</span> Scheduler;</div><div class="line"><span class="comment">//创建两个任务到调度器的队列中</span></div><div class="line">$scheduler-&gt;newTask(task1());</div><div class="line">$scheduler-&gt;newTask(task2());</div><div class="line"><span class="comment">//运行调度器</span></div><div class="line">$scheduler-&gt;run();</div></pre></td></tr></table></figure></li><li><p>结果: 果然是两个任务交替执行各自的循环</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">renyimin$ php index.php</div><div class="line">This is task <span class="number">1</span> iteration <span class="number">1.</span></div><div class="line">This is task <span class="number">2</span> iteration <span class="number">1.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">2.</span></div><div class="line">This is task <span class="number">2</span> iteration <span class="number">2.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">3.</span></div><div class="line">This is task <span class="number">2</span> iteration <span class="number">3.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">4.</span></div><div class="line">This is task <span class="number">2</span> iteration <span class="number">4.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">5.</span></div><div class="line">This is task <span class="number">2</span> iteration <span class="number">5.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">6.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">7.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">8.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">9.</span></div><div class="line">This is task <span class="number">1</span> iteration <span class="number">10.</span></div></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>参考: <a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="external">http://www.laruence.com/2015/05/28/3038.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;从之前的知识可以了解到, 其实&lt;code&gt;(迭代器)生成器&lt;/code&gt; 也只不过是一个函数, &lt;strong&gt;不同的是这个函数的返回值是依次返回, 而不是只返回一个单独的值&lt;/strong&gt;; (也就是说, 生成器使你更方便的实现了迭代器) ;&lt;/p&gt;

      
    
    </summary>
    
      <category term="PHP高级" scheme="http://blog.renyimin.com/categories/PHP%E9%AB%98%E7%BA%A7/"/>
    
      <category term="Coroutine" scheme="http://blog.renyimin.com/categories/PHP%E9%AB%98%E7%BA%A7/Coroutine/"/>
    
    
      <category term="PHP高级" scheme="http://blog.renyimin.com/tags/PHP%E9%AB%98%E7%BA%A7/"/>
    
      <category term="Coroutine" scheme="http://blog.renyimin.com/tags/Coroutine/"/>
    
  </entry>
  
  <entry>
    <title>02.PHP - Generator (迭代)生成器</title>
    <link href="http://blog.renyimin.com/2017/05/13/2017-05-13-Iterator-generator-yield-02/"/>
    <id>http://blog.renyimin.com/2017/05/13/2017-05-13-Iterator-generator-yield-02/</id>
    <published>2017-05-13T04:15:00.000Z</published>
    <updated>2017-11-29T18:09:08.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Generator (迭代)生成器</p><ul><li>之所以叫 <code>迭代生成器</code>, 是因为生成的东西是个<code>迭代器对象</code>;( <a href="http://php.net/manual/zh/class.generator.php" target="_blank" rel="external">参考PHP: 生成器类的结构</a>, 会发现生成器这个类也确实实现了<code>迭代器</code>接口);<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">xrange</span><span class="params">($start, $end, $step = <span class="number">1</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> ($i = $start; $i &lt;= $end; $i += $step) &#123;</div><div class="line">        <span class="keyword">yield</span> $i;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$range = xrange(<span class="number">1</span>, <span class="number">1000000</span>);</div><div class="line">var_dump($range); <span class="comment">// object(Generator)#1</span></div><div class="line">var_dump($range <span class="keyword">instanceof</span> Iterator); <span class="comment">// bool(true)</span></div></pre></td></tr></table></figure></li></ul></li><li><p><code>生成器函数</code> 的核心是 <code>yield</code> 关键字</p><ul><li>它最简单的调用形式看起来像 return 的用法, 但普通 return 会返回值并<strong>终止</strong>函数的执行;<br>而 yield 会返回一个值给<code>循环调用此生成器的代码</code>, 并且只是<strong>暂停</strong> <code>生成器函数</code>的运行;<br>暂停当前过程，意味着将处理权转交由上一级继续进行，直至上一级再次调用<strong>被暂停的</strong> <code>生成器函数</code>，则<code>生成器函数</code>会从上一次暂停的位置继续执行;</li></ul></li><li><p>当然, <code>yield</code> 更重要的特性是除了可以返回一个值以外, 还能够接收一个值</p><ul><li><a href="http://php.net/manual/zh/class.generator.php" target="_blank" rel="external">参考PHP: 生成器类的结构</a>, 可以看到 Generator 类除了实现 Iterator 接口中的必要方法以外, 还有一个 <code>send</code> 方法, 这个方法就是向 yield 语句处传递一个值, 同时从 yield 语句处继续执行, 直至再次遇到 yield 后控制权回到外部 ;</li><li><p>测试代码:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printer</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    $i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="number">123</span> . <span class="string">"\n"</span>;</div><div class="line">        <span class="comment">//同时进行接收和发送</span></div><div class="line">        printf(<span class="string">"receive: %s\n"</span>, (<span class="keyword">yield</span> ++$i));</div><div class="line">        <span class="keyword">echo</span> <span class="number">456</span> . <span class="string">"\n"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$printer = printer();</div><div class="line">printf(<span class="string">"%d\n"</span>, $printer-&gt;current());    <span class="comment">//123</span></div><div class="line">                                        <span class="comment">//1  碰到yield则中断, 将$i发出, 并将控制权交给外部的调度器</span></div><div class="line"></div><div class="line">var_dump($printer-&gt;send(<span class="string">'hello'</span>));  <span class="comment">//receive: hello    调度器再次调度,继续开始</span></div><div class="line">                                    <span class="comment">//456</span></div><div class="line">                                    <span class="comment">//123</span></div><div class="line">                                    <span class="comment">//int(2) 碰到yield则中断, 将$i发出, 并将控制权交给外部的调度器</span></div><div class="line">printf(<span class="string">"%d\n"</span>, $printer-&gt;current());    <span class="comment">//yield发出的当前值果然是2</span></div><div class="line"></div><div class="line">var_dump($printer-&gt;send(<span class="string">'world'</span>));  <span class="comment">//receive: world    调度器再次调度,继续开始</span></div><div class="line">                                    <span class="comment">//456</span></div><div class="line">                                    <span class="comment">//123</span></div><div class="line">                                    <span class="comment">//int(3)碰到yield则中断, 将$i发出, 并将控制权交给外部的调度器</span></div><div class="line"></div><div class="line">printf(<span class="string">"%d\n"</span>, $printer-&gt;current());<span class="comment">//yield发出的当前值果然是3</span></div></pre></td></tr></table></figure></li><li><p>这儿yield没有作为一个语句来使用, 而是用作一个表达式, <strong>这样, 这个yield表达式 能被演化成一个值, 这个值就是调用者传递给send()方法的值</strong>;</p></li></ul></li><li><p><strong>到这里, 我们看到 <code>yield</code> 可以在其位置同时进行 <code>接收</code> 和 <code>返回</code> (双向传递), 当然, 这是实现 <code>协程</code> 的根本</strong>;</p></li><li><p>补充 ：</p><ul><li>另外, 我们可以使用生成器来重新实现 range() 函数, 标准的 range() 函数需要在内存中生成一个数组包含每一个在它范围内的值，然后返回该数组, 结果就是会产生多个很大的数组。 比如, 调用 range(0, 1000000) 将导致内存占用超过 100 MB ;</li><li>做为一种替代方法, 我们可以实现一个 xrange() 生成器, 只需要足够的内存来创建 Iterator 对象并在内部跟踪生成器的当前状态，这样只需要不到1K字节的内存;</li><li>例子:  即使你打印100W个键值对, 也不一次性将这些简直对放入变量中导致内存爆掉  <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">xrange</span><span class="params">($start, $limit, $step = <span class="number">1</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> ($i = $start; $i &lt;= $limit; $i += $step) &#123;</div><div class="line">        <span class="keyword">yield</span> $i + <span class="number">1</span> =&gt; $i;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">foreach</span> (xrange(<span class="number">0</span>, <span class="number">10000000000</span>, <span class="number">2</span>) <span class="keyword">as</span> $key =&gt; $value) &#123;</div><div class="line">    printf(<span class="string">"%d =&gt; %d"</span> . PHP_EOL, $key, $value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>参考: <a href="https://www.insp.top/article/php-knowledge-completion-generator-and-the-realization-of-coroutine" target="_blank" rel="external">https://www.insp.top/article/php-knowledge-completion-generator-and-the-realization-of-coroutine</a>    </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Generator (迭代)生成器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;之所以叫 &lt;code&gt;迭代生成器&lt;/code&gt;, 是因为生成的东西是个&lt;code&gt;迭代器对象&lt;/code&gt;;( &lt;a href=&quot;http://php.net/manual/zh/class.g
      
    
    </summary>
    
      <category term="PHP高级" scheme="http://blog.renyimin.com/categories/PHP%E9%AB%98%E7%BA%A7/"/>
    
      <category term="Coroutine" scheme="http://blog.renyimin.com/categories/PHP%E9%AB%98%E7%BA%A7/Coroutine/"/>
    
    
      <category term="PHP高级" scheme="http://blog.renyimin.com/tags/PHP%E9%AB%98%E7%BA%A7/"/>
    
      <category term="Coroutine" scheme="http://blog.renyimin.com/tags/Coroutine/"/>
    
  </entry>
  
  <entry>
    <title>01.PHP - Iterator (迭代器) 接口简介</title>
    <link href="http://blog.renyimin.com/2017/05/13/2017-05-13-Iterator-generator-yield-01/"/>
    <id>http://blog.renyimin.com/2017/05/13/2017-05-13-Iterator-generator-yield-01/</id>
    <published>2017-05-13T03:05:00.000Z</published>
    <updated>2017-11-15T02:38:25.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>迭代: 可以理解为是指反复执行一个过程, 每执行一次叫做一次迭代;</p><ul><li><p>在php中我们经常做迭代, 如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$mapping  =  [</div><div class="line"><span class="string">'red'</span> =&gt; <span class="string">'#FF0000'</span>,</div><div class="line"><span class="string">'green'</span> =&gt; <span class="string">'#00FF00'</span>,</div><div class="line"><span class="string">'blue'</span> =&gt; <span class="string">'##0000FF'</span></div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">foreach</span>  ($mapping  <span class="keyword">as</span>  $key  =&gt;  $value)  &#123;</div><div class="line">printf(<span class="string">"key:  %d  -  value:  %s  \n"</span>,  $key,  $value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>上述代码通过foreach对数组遍历并迭代输出其内容, 在foreach内部, 每次迭代都会将当前的元素的值赋给$value并将数组的指针移动指向下一个元素为下一次迭代做准备,从而实现顺序遍历;<br>像这样能够让外部的迭代自己内部数据的接口就是<code>迭代器接口</code>;<br>对应的那个被迭代的对象(这里是数组), 其实就是<code>迭代器对象</code>;</p></li></ul></li><li>PHP中提供的迭代器接口和类<ul><li>PHP提供了统一的迭代器接口<a href="http://php.net/manual/en/class.appenditerator.php" target="_blank" rel="external">预定义接口中</a>;</li><li>SPL标准库中也提供了多种<a href="http://php.net/manual/zh/book.spl.php" target="_blank" rel="external">迭代器类</a>;</li></ul></li><li><p>简单实现一个迭代器</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xrange</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">protected</span> $start;</div><div class="line">    <span class="keyword">protected</span> $limit;</div><div class="line">    <span class="keyword">protected</span> $step;</div><div class="line">    <span class="keyword">protected</span> $i;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($start, $limit, $step = <span class="number">0</span>)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;start = $start;</div><div class="line">        <span class="keyword">$this</span>-&gt;limit = $limit;</div><div class="line">        <span class="keyword">$this</span>-&gt;step  = $step;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">rewind</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;i = <span class="keyword">$this</span>-&gt;start;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;i += <span class="keyword">$this</span>-&gt;step;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">current</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">key</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">valid</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;i &lt;= <span class="keyword">$this</span>-&gt;limit;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">foreach</span> (<span class="keyword">new</span> Xrange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>) <span class="keyword">as</span> $key =&gt; $value) &#123;</div><div class="line">    printf(<span class="string">"%d %d"</span> . PHP_EOL, $key, $value);</div><div class="line">&#125;</div></pre></td></tr></table></figure> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ php Iterator.php </div><div class="line"><span class="number">0</span> <span class="number">0</span></div><div class="line"><span class="number">2</span> <span class="number">2</span></div><div class="line"><span class="number">4</span> <span class="number">4</span></div><div class="line"><span class="number">6</span> <span class="number">6</span></div><div class="line"><span class="number">8</span> <span class="number">8</span></div><div class="line"><span class="number">10</span> <span class="number">10</span></div></pre></td></tr></table></figure></li><li><p>补充:</p></li></ol><ul><li><p>可以将一个普通对象变成一个可被遍历的对象, 场景: 如一个StudentsContact对象, 这个对象是用于处理学生联系方式的, 通过 addStudent 方法注册学生, 通过 getAllStudent 获取全部注册的学生联系方式数组(比如获取一页学生联系方式列表), 我们以往是通过 StudentsContact::getAllStudent() 获取一个数组然后遍历该数组, 但是现在有了迭代器, 只要这个类继承这个接口, 就可以直接遍历该对象获取学生数组, 并且可以在获取之前在类的内部就对输出的数据做好处理工作;</p></li><li><p>PHP的迭代器可以让你利用 面向对象 实现常见的数据结构, 例如列表, 堆栈, 队列与图<strong><em> ; (有助于你使用纯面向对象的思想来设计你的程序)<br>特别说明一下 </em></strong>对对象的遍历<strong><em>,   一般人觉得所谓的</em></strong>遍历对象<em>*</em>就是对一个对象里的属性或者方法一个一个的取出来, 然后做输出或者处理; 实际上, 这里的迭代器对对象的遍历并不是这个意思, 可能这句话本身的描述有问题, 比如, 可以使用迭代器模拟一个<code>字符串对象的迭代器</code>类, 让PHP可以对这个字符串对象进行遍历;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">private</span> $string;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($string)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;string = <span class="keyword">$this</span>-&gt;strToArray($string);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">strToArray</span><span class="params">($string, $l = <span class="number">0</span>)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">//if ($l &gt; 0) &#123;</span></div><div class="line">            <span class="comment">//$ret = array();</span></div><div class="line">            <span class="comment">//$len = mb_strlen($string, "UTF-8");</span></div><div class="line">            <span class="comment">//for ($i = 0; $i &lt; $len; $i += $l) &#123;</span></div><div class="line">                <span class="comment">//$ret[] = mb_substr($string, $i, $l, "UTF-8");</span></div><div class="line">            <span class="comment">//&#125;</span></div><div class="line">            <span class="comment">//return $ret;</span></div><div class="line">        <span class="comment">//&#125;</span></div><div class="line">        <span class="keyword">return</span> preg_split(<span class="string">"//u"</span>, $string, <span class="number">-1</span>, PREG_SPLIT_NO_EMPTY);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">current</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> current(<span class="keyword">$this</span>-&gt;string);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> next(<span class="keyword">$this</span>-&gt;string);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">key</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> key(<span class="keyword">$this</span>-&gt;string);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">valid</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key(<span class="keyword">$this</span>-&gt;string) === <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">rewind</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        reset(<span class="keyword">$this</span>-&gt;string);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$string = <span class="keyword">new</span> String(<span class="string">'这个是什么213jdjlf'</span>);</div><div class="line"><span class="keyword">foreach</span> ($string <span class="keyword">as</span> $k =&gt; $v) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"&#123;$k&#125; =&gt; &#123;$v&#125;"</span> . <span class="string">"&lt;br/&gt;"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">结果:</div><div class="line"><span class="number">0</span> =&gt; 这</div><div class="line"><span class="number">1</span> =&gt; 个</div><div class="line"><span class="number">2</span> =&gt; 是</div><div class="line"><span class="number">3</span> =&gt; 什</div><div class="line"><span class="number">4</span> =&gt; 么</div><div class="line"><span class="number">5</span> =&gt; <span class="number">2</span></div><div class="line"><span class="number">6</span> =&gt; <span class="number">1</span></div><div class="line"><span class="number">7</span> =&gt; <span class="number">3</span></div><div class="line"><span class="number">8</span> =&gt; j</div><div class="line"><span class="number">9</span> =&gt; d</div><div class="line"><span class="number">10</span> =&gt; j</div><div class="line"><span class="number">11</span> =&gt; l</div><div class="line"><span class="number">12</span> =&gt; f</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;迭代: 可以理解为是指反复执行一个过程, 每执行一次叫做一次迭代;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在php中我们经常做迭代, 如下:&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
      <category term="PHP高级" scheme="http://blog.renyimin.com/categories/PHP%E9%AB%98%E7%BA%A7/"/>
    
      <category term="Coroutine" scheme="http://blog.renyimin.com/categories/PHP%E9%AB%98%E7%BA%A7/Coroutine/"/>
    
    
      <category term="PHP高级" scheme="http://blog.renyimin.com/tags/PHP%E9%AB%98%E7%BA%A7/"/>
    
      <category term="Coroutine" scheme="http://blog.renyimin.com/tags/Coroutine/"/>
    
  </entry>
  
  <entry>
    <title>07.小结 &quot;Jsonp&quot; 对比 &quot;CORS简单/非简单请求&quot;</title>
    <link href="http://blog.renyimin.com/2016/09/21/2016-09-21-sameoriginpolicy-07/"/>
    <id>http://blog.renyimin.com/2016/09/21/2016-09-21-sameoriginpolicy-07/</id>
    <published>2016-09-21T13:20:16.000Z</published>
    <updated>2017-10-28T02:30:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Jsonp-对比-CORS简单-非简单请求"><a href="#Jsonp-对比-CORS简单-非简单请求" class="headerlink" title="Jsonp 对比 CORS简单/非简单请求"></a>Jsonp 对比 CORS简单/非简单请求</h3><p>都可以方便实现跨域;</p><h4 id="Jsonp"><a href="#Jsonp" class="headerlink" title="Jsonp"></a>Jsonp</h4><p>简单适用, 老式浏览器全部支持, 服务器端改动很小;</p><p>但是JSONP只能发GET请求;</p><p>JSONP跨域发送Cookie的话, 只用设置好<code>cookie的domain属性</code>为顶级域名即可 ;</p><h3 id="CORS简单请求"><a href="#CORS简单请求" class="headerlink" title="CORS简单请求"></a>CORS简单请求</h3><p>服务端需要设置一些允许选项;</p><p>发送请求为 GET, POST, HEAD ;</p><p>跨域发送cookie的话, 不仅需要设置<code>cookie的domain属性</code>, 服务端和客户端都要对<code>Credentials</code> header属性进行设置;<br>跨域发送cookie的话, 服务端 <code>Access-Control-Allow-Origin</code> 不能设置为 * , 否则会提示 :<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Failed to load http:<span class="comment">//test.test.com/index.php?sex=renyimin&amp;age=100: </span></div><div class="line">The value of the <span class="string">'Access-Control-Allow-Origin'</span> header in the response must not be the wildcard <span class="string">'*'</span> when the request<span class="string">'s credentials mode is '</span><span class="keyword">include</span><span class="string">'. </span></div><div class="line"><span class="string">Origin '</span>http:<span class="comment">//www.test.com' is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span></div></pre></td></tr></table></figure></p><h3 id="CORS非简单请求"><a href="#CORS非简单请求" class="headerlink" title="CORS非简单请求"></a>CORS非简单请求</h3><p>服务端需要设置一些允许选项;</p><p>发送其他请求 (PUT) ..</p><p>可以设置自定义header头</p><p>cookie方面和 CORS简单请求一样</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Jsonp-对比-CORS简单-非简单请求&quot;&gt;&lt;a href=&quot;#Jsonp-对比-CORS简单-非简单请求&quot; class=&quot;headerlink&quot; title=&quot;Jsonp 对比 CORS简单/非简单请求&quot;&gt;&lt;/a&gt;Jsonp 对比 CORS简单/非简单请求&lt;/
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>06.Ajax请求不能发送 之 &quot;CORS方案 -- (not-so-simple request)&quot;</title>
    <link href="http://blog.renyimin.com/2016/09/18/2016-09-18-sameoriginpolicy-06/"/>
    <id>http://blog.renyimin.com/2016/09/18/2016-09-18-sameoriginpolicy-06/</id>
    <published>2016-09-18T12:10:16.000Z</published>
    <updated>2017-10-27T10:15:27.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="预检请求-preflight-说明"><a href="#预检请求-preflight-说明" class="headerlink" title="预检请求 preflight 说明"></a>预检请求 <code>preflight</code> 说明</h4><p>1.非简单请求是那种对服务器有特殊要求的请求, 比如请求方法是 <code>PUT</code> 或 <code>DELETE</code>, 或者 <code>Content-Type</code> 字段的类型是 <code>application/json</code> ;</p><p>2.非简单请求的CORS请求, 会在正式通信之前, 增加一次HTTP查询请求, 称为 <code>&quot;预检&quot;请求(preflight)</code> ;</p><ul><li>浏览器先询问服务器, 当前网页所在的域名是否在服务器的许可名单之中, 以及可以使用哪些HTTP动词和头信息字段;</li><li>只有得到肯定答复, 浏览器才会发出正式的XMLHttpRequest请求, 否则就报错 ;</li></ul><p>3.非简单请求会导致原先的一次请求变成两次, 第一次请求是 <code>预检请求</code> ;</p><p>4.”预检”请求用的请求方法是 <code>OPTIONS</code>，表示这个请求是用来<code>询问</code>的，头信息里面关键字段是Origin，表示请求来自哪个源 ;</p><h4 id="非简单请求的例子"><a href="#非简单请求的例子" class="headerlink" title="非简单请求的例子"></a>非简单请求的例子</h4><p>1.www.test.com/index.php</p><ul><li>本例子使用 <code>PUT</code> 来进行ajax请求, 满足 <code>非简单请求</code> 的条件 ;</li><li><p>另外, 本例还<code>自定义了请求时的 header 首部字段</code>, 也满足 <code>非简单请求</code> 的条件 ;</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="meta">?&gt;</span></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;Title&lt;/title&gt;</div><div class="line">    &lt;script src=<span class="string">"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=<span class="string">"text/javascript"</span> &gt;</div><div class="line">        $(document).ready(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">            $(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">//序列化name/value</span></div><div class="line">                <span class="keyword">var</span> data = $(<span class="string">"form"</span>).serializeArray();</div><div class="line">                $.ajax(&#123;</div><div class="line">                    <span class="comment">//这里用PUT, 则为 `非简单` 请求</span></div><div class="line">                    type: <span class="string">'PUT'</span>,</div><div class="line">                    url: <span class="string">'http://test.test.com/index.php'</span>,</div><div class="line">                    dataType: <span class="string">'json'</span>,</div><div class="line">                    data: data,</div><div class="line">                    <span class="comment">//或者如果你自定义了一些请求时的 header 首部字段, 那么请求就也是 复杂请求</span></div><div class="line">                    headers: &#123;<span class="string">"custom-header-field"</span> : <span class="string">"test"</span>&#125;,</div><div class="line">                    success: <span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;</div><div class="line">                        console.log(result);</div><div class="line">                    &#125;,</div><div class="line">                    timeout: <span class="number">3000</span></div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form name=<span class="string">"form"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"sex"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"btn"</span> value=<span class="string">"button"</span> /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></li></ul><p>2.test.test.com/index.php<br>    <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//服务器允许的 Origin</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.test.com"</span>);</div><div class="line"><span class="comment">//服务器允许的 methods</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Methods: PUT, GET, POST"</span>);</div><div class="line"><span class="comment">//服务器允许设置的头部字段</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Headers: custom-header-field"</span>);</div><div class="line"></div><div class="line">$arguments = file_get_contents(<span class="string">'php://input'</span>);</div><div class="line"><span class="keyword">echo</span> json_encode([<span class="string">'arguments'</span> =&gt; $arguments]);</div></pre></td></tr></table></figure></p><p>3.注意: 像上面例子的复杂跨域请求</p><ul><li><p>必须: 首先和简单请求一样, 服务器端的 <code>Access-Control-Allow-Origin</code> 是必须设置的, 不然首先就跨不了域;</p></li><li><p>必须: 其次, 是使用了 <code>get</code>, <code>post</code>, <code>head</code> 之外方法的 <code>复杂请求</code>, 那么就必须在服务端有对应的 <code>Access-Control-Allow-Method</code>, 否则:<br><img src="/img/cross-domain/not-simple-error01.png" width="597" height="133" alt="not-simple-error01" align="center"></p></li><li><p>可选: 如果你自定义了 <code>自定义首部字段</code> 的 <code>复杂请求</code>, 那么也要在服务端有对应的 <code>Access-Control-Allow-Headers</code>, 否则:<br><img src="/img/cross-domain/not-simple-error02.png" width="598" height="150" alt="not-simple-error02" align="center"></p></li></ul><p>4.另外需要关注的是: 如果你设置了自定义的首部字段, 那么即使你的请求类型是get, post, head, 自然也是复杂请求, 此时的HTTP请求方法显示的仍然如下:</p><pre><code>Request Method:OPTIONS</code></pre><h4 id="分析预检请求"><a href="#分析预检请求" class="headerlink" title="分析预检请求"></a>分析预检请求</h4><p>1.上面<code>www.test.com/index.php</code>代码进行ajax请求的时候, HTTP请求的方法是<code>PUT</code>, 所以浏览器会发现, 这是一个非简单请求, 就自动发出一个”预检”请求, 要求服务器确认可以这样请求 ;</p><p>2.所以请求应该是包括<code>预检请求</code>和<code>真正的请求</code>两个请求的:<br><img src="/img/cross-domain/2times_request.png" width="600" height="360" alt="2times_request" align="center"></p><p>3.下面是这个”预检”请求的HTTP头信息 和 回应信息:<br><img src="/img/cross-domain/preflight01.png" width="700" height="500" alt="preflight01" align="center"></p><p>4.可以看到, “预检”请求用的请求方法是OPTIONS, 表示这个请求是用来询问的, 头信息里面, 关键字段是Origin, 表示请求来自哪个源;</p><ul><li>除了Origin字段，”预检”请求的头信息包括两个特殊字段:<br>(1)<code>Access-Control-Request-Method</code> ：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT ;<br>(2)<code>Access-Control-Request-Headers</code>：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段, 上例是X-Custom-Header ;</li></ul><h4 id="分析预检响应"><a href="#分析预检响应" class="headerlink" title="分析预检响应"></a>分析预检响应</h4><p>1.从下面预检请求的截图中，可以看到预检请求的回应中, 服务器收到”预检”请求以后, 检查了 <code>Origin</code>、<code>Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code> 字段以后，确认允许跨源请求，就可以做出回应 ;<br><img src="/img/cross-domain/preflight01.png" width="700" height="500" alt="preflight01" align="center"></p><ul><li>并且预检请求部分是不会真的发送数据的:<br><img src="/img/cross-domain/preflight02.png" width="400" height="150" alt="preflight02" align="center"></li></ul><p>2.上面的HTTP回应中，关键的是 <code>Access-Control-Allow-Origin</code> 字段，表示 <code>http://www.test.com</code> 可以请求数据, <strong>该字段也可以设为星号</strong>，表示同意任意跨源请求 ;<br>    <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http:<span class="comment">//www.test.com</span></div><div class="line">或者</div><div class="line">Access-Control-Allow-Origin: *</div></pre></td></tr></table></figure></p><p>3.如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段 ; 这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 <code>XMLHttpRequest</code> 对象的 <code>onerror</code> 回调函数捕获;</p><ul><li>控制台会打印出如下的报错信息 ;<br><img src="/img/cross-domain/no-simple-error01.png" width="650" height="150" alt="no-simple-error01" align="center"></li></ul><p>4.服务器还可能回应的其他CORS相关字段如下:</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Methods: GET, POST, PUT</div><div class="line">Access-Control-Allow-Headers: X-Custom-Header</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Max-Age: 1728000</div></pre></td></tr></table></figure>（1）Access-Control-Allow-Methods该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。（2）Access-Control-Allow-Headers如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。（3）Access-Control-Allow-Credentials该字段与简单请求时的含义相同。（4）Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</code></pre><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><p>cors请求是否允许包含cookie?(和CORS简单请求是一样的要求)</p><ul><li>www.test.com/index.php  <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">setcookie(<span class="string">'address'</span>, json_encode([<span class="string">'city'</span> =&gt; <span class="string">'yuncheng'</span>, <span class="string">'town'</span> =&gt; <span class="string">'xiaoliang'</span>]), <span class="number">0</span>, <span class="string">'/'</span>, <span class="string">'.test.com'</span>);</div><div class="line"><span class="meta">?&gt;</span></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;Title&lt;/title&gt;</div><div class="line">    &lt;script src=<span class="string">"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=<span class="string">"text/javascript"</span> &gt;</div><div class="line">        $(document).ready(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">            $.ajaxSetup(&#123;crossDomain: <span class="keyword">true</span>, xhrFields: &#123;withCredentials: <span class="keyword">true</span>&#125;&#125;);</div><div class="line">            $(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">//序列化name/value</span></div><div class="line">                <span class="keyword">var</span> data = $(<span class="string">"form"</span>).serializeArray();</div><div class="line">                $.ajax(&#123;</div><div class="line">                    <span class="comment">//这里用PUT, 则为 `非简单` 请求</span></div><div class="line">                    type: <span class="string">'PUT'</span>,</div><div class="line">                    url: <span class="string">'http://test.test.com/index.php'</span>,</div><div class="line">                    dataType: <span class="string">'json'</span>,</div><div class="line">                    data: data,</div><div class="line">                    <span class="comment">//或者如果你自定义了一些请求时的 header 首部字段, 那么请求就也是 复杂请求</span></div><div class="line">                    headers: &#123;<span class="string">"custom-header-field"</span> : <span class="string">"test"</span>&#125;,</div><div class="line">                    success: <span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;</div><div class="line">                        console.log(result);</div><div class="line">                    &#125;,</div><div class="line">                    timeout: <span class="number">3000</span></div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form name=<span class="string">"form"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"sex"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"btn"</span> value=<span class="string">"button"</span> /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></li></ul><ul><li>test.test.com  <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//服务器允许的 Origin (如果要发送cookie的话复杂请求也不能为*)</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.test.com"</span>);</div><div class="line"><span class="comment">//服务器允许的 methods</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Methods: PUT, GET, POST"</span>);</div><div class="line"><span class="comment">//服务器允许设置的头部字段</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Headers: custom-header-field"</span>);</div><div class="line"><span class="comment">//要跨子域发cookie, 这个自然不能少</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Credentials: true"</span>);</div><div class="line"></div><div class="line">$arguments = file_get_contents(<span class="string">'php://input'</span>);</div><div class="line">$address = $_COOKIE[<span class="string">'address'</span>];</div><div class="line"><span class="keyword">echo</span> json_encode([<span class="string">'arguments'</span> =&gt; $arguments, <span class="string">'cookie'</span> =&gt; $address]);</div></pre></td></tr></table></figure></li></ul><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">参考 CORS</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;预检请求-preflight-说明&quot;&gt;&lt;a href=&quot;#预检请求-preflight-说明&quot; class=&quot;headerlink&quot; title=&quot;预检请求 preflight 说明&quot;&gt;&lt;/a&gt;预检请求 &lt;code&gt;preflight&lt;/code&gt; 说明&lt;/h4&gt;
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>05.Ajax请求不能发送 之 &quot;CORS方案 -- (simple request)&quot;</title>
    <link href="http://blog.renyimin.com/2016/09/18/2016-09-18-sameoriginpolicy-05/"/>
    <id>http://blog.renyimin.com/2016/09/18/2016-09-18-sameoriginpolicy-05/</id>
    <published>2016-09-18T04:45:07.000Z</published>
    <updated>2017-10-27T10:03:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CORS说明"><a href="#CORS说明" class="headerlink" title="CORS说明"></a>CORS说明</h3><p>1.CORS是一个W3C标准, 全称是 “跨域资源共享 “(Cross-origin resource sharing), 通俗说就是我们所熟知的跨域请求 ;</p><ul><li>众所周知，在以前，跨域可以采用 <code>代理</code>、<code>JSONP</code> 等方式，而在Modern浏览器面前，这些终将成为过去式，因为有了CORS ;</li><li>CORS在最初接触的时候只大概了解到，通过服务器端设置Access-Control-Allow-Origin响应头，即可使指定来源像访问同源接口一样访问跨域接口，但其实CORS的规范定义远不止这些 ;</li></ul><p>2.它允许浏览器向<strong>跨源</strong>服务器发出XMLHttpRequest请求, 也就是克服了AJAX只能同源使用的限制 ;</p><p>3.CORS需要浏览器和服务器同时支持 (目前, 所有浏览器都支持该功能, IE浏览器不能低于IE10) ;</p><p>4.整个CORS通信过程都是浏览器自动完成, 不需要用户参与 ;</p><ul><li><p>对于开发者来说, CORS通信与同源的AJAX通信没有差别, 代码完全一样, 浏览器一旦发现AJAX的请求是跨源的, 就会自动添加一些附加的头信息, 有时还会多出一次附加的请求, 但用户不会有感觉;</p></li><li><p>之所以<code>CORS通信与同源的AJAX通信的代码没有差别</code>, 是因为: <strong>其实实现CORS通信的关键是服务器, 只要服务器实现了CORS接口，就可以跨源通信 </strong></p></li></ul><h3 id="CORS的两类请求"><a href="#CORS的两类请求" class="headerlink" title="CORS的两类请求"></a>CORS的两类请求</h3><p>1.浏览器将CORS请求分成两类: 简单请求(simple request) 和 非简单请求(not-so-simple request)</p><p>2.以下情况会被归类为 <code>非简单请求</code> :</p><ul><li>请求以 GET, HEAD 或者 POST 以外的方法发起请求 ;</li><li>虽然使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型, 比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求 ;</li><li>使用自定义请求头（比如添加诸如 X-PINGOTHER）</li></ul><h3 id="简单请求代码案例"><a href="#简单请求代码案例" class="headerlink" title="简单请求代码案例"></a>简单请求代码案例</h3><p>1.客户端代码<br>    www.test.com/index.html :<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">   &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">   &lt;title&gt;Title&lt;/title&gt;</div><div class="line">   &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">   &lt;script type=&quot;text/javascript&quot; &gt;</div><div class="line">       $(document).ready(function()&#123;</div><div class="line">           $(&quot;#btn&quot;).click(function(k) &#123;</div><div class="line">               var data = $(&quot;form&quot;).serializeArray();//序列化name/value</div><div class="line">               $.ajax(&#123;</div><div class="line">                   type: &apos;GET&apos;,  //这里用GET</div><div class="line">                   url: &apos;http://test.test.com/index.php&apos;,</div><div class="line">                   dataType: &apos;json&apos;,  //类型</div><div class="line">                   data: data,</div><div class="line">                   success: function (result) &#123;//返回的json数据</div><div class="line">                       console.log(result); //回调输出</div><div class="line">                   &#125;,</div><div class="line">                   timeout: 3000</div><div class="line">               &#125;);</div><div class="line">           &#125;);</div><div class="line">       &#125;);</div><div class="line">   &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form name=&quot;form&quot;&gt;</div><div class="line">   &lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt;</div><div class="line">   &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;</div><div class="line">   &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p><p>2.服务端代码<br>test.test.com/index.php :<br>    <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.test.com"</span>);</div><div class="line"><span class="keyword">echo</span> json_encode([<span class="string">'name'</span> =&gt; <span class="string">'lant'</span>, <span class="string">'age'</span> =&gt; <span class="number">100</span>]);</div></pre></td></tr></table></figure></p><h3 id="基本流程分析"><a href="#基本流程分析" class="headerlink" title="基本流程分析"></a>基本流程分析</h3><p>1.对于简单请求，浏览器直接发出CORS请求, 具体来说, 就是在头信息之中, 自动增加一个Origin字段 ;</p><ul><li>浏览器发现这次跨源AJAX请求是简单请求, 就自动在头信息之中, 添加一个Origin字段:<br><img src="/img/cross-domain/ajax-simple-cors.png" width="670" height="420" alt="ajax-simple-cors" align="center"></li><li><strong>上面的头信息中, <code>Origin字段</code> 用来说明本次请求来自哪个源(协议 + 域名 + 端口), 服务器根据这个值, 决定是否同意这次请求 </strong>;</li></ul><p>2.如果Origin源不在服务器的许可范围内</p><ul><li>服务器仍然会返回一个正常的HTTP回应, 不过浏览器会发现, 这个回应的头信息并没有包含 <code>Access-Control-Allow-Origin</code> 字段(详见下文), 就知道出错了, 从而抛出一个错误, 被XMLHttpRequest的onerror回调函数捕获; </li><li><strong>注意, 这种错误无法通过状态码识别, 因为HTTP回应的状态码有可能是200</strong> ;<br><img src="/img/cross-domain/ajax-simple-cors02.png" width="590" height="260" alt="ajax-simple-cors02" align="center"></li></ul><p>3.当然, 如果Origin源在服务器设置的许可范围内</p><ul><li>服务器的响应就会多出如下几个头信息字段(当然也不一定是所有都包含, <strong>具体还得看服务器如何进行设置</strong>):  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://api.bob.com</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Expose-Headers: FooBar</div><div class="line">Content-Type: text/html; charset=utf-8</div></pre></td></tr></table></figure></li></ul><ul><li>重点分析 :<br>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头:<br>(1) <code>Access-Control-Allow-Origin</code><br>服务器要设置ajax请求可以跨域, 该字段是必须的, 它的值要么是请求时Origin字段的值，要么是一个<em>，表示接受任意域名的请求;<br>(2) <code>Access-Control-Allow-Credentials</code><br>该字段可选, 它的值是一个布尔值，表示是否允许发送Cookie, <em>*默认情况下，Cookie不包括在CORS请求之中</em></em>, 设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器;<br>注意, 这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。<br>(3) <code>Access-Control-Expose-Headers</code><br>该字段可选, CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma;<br>如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定;<br>上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</li></ul><h3 id="服务器端的具体设置"><a href="#服务器端的具体设置" class="headerlink" title="服务器端的具体设置"></a>服务器端的具体设置</h3><ol><li>服务器在设置的时候, 其实就是通过header函数设置上面的三个选项!</li><li><p>比如之前的例子中, 如果服务器只是简单的为了实现跨域, 直接设置如下选项即可:</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.test1.com"</span>);</div><div class="line"><span class="keyword">echo</span> json_encode([<span class="string">'name'</span> =&gt; <span class="string">'lant'</span>, <span class="string">'age'</span> =&gt; <span class="number">100</span>]);</div></pre></td></tr></table></figure></li></ol><h3 id="withCredentials-属性"><a href="#withCredentials-属性" class="headerlink" title="withCredentials 属性"></a>withCredentials 属性</h3><p><strong>CORS请求默认不发送<code>Cookie</code>和<code>HTTP认证信息</code> (Jsonp是会发送cookie信息的)</strong></p><p>1.之前在介绍<code>Access-Control-Allow-Credentials</code>选项的时候提到, CORS请求默认不发送Cookie和HTTP认证信息; 如果要把Cookie发到服务器:</p><ul><li><p>一方面要 <strong>服务器同意指定Access-Control-Allow-Credentials字段</strong> :</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Credentials: <span class="keyword">true</span></div><div class="line"><span class="comment">//php中设置如下:</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Credentials: true"</span>);</div></pre></td></tr></table></figure></li><li><p>另一方面, 开发者必须在AJAX请求中打开 <code>withCredentials</code> 属性:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.withCredentials = true;</div><div class="line">//jquery中设置withCredentials的代码如下:</div><div class="line">$.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;);</div></pre></td></tr></table></figure></li></ul><p>2.需要以上两方面都做到才可以</p><ul><li>否则，即使服务器同意发送Cookie，浏览器也不会发送 ;</li><li>但是, 如果省略 <code>withCredentials</code> 设置, 有的浏览器还是会一起发送Cookie, 这时, 可以显式关闭 <code>withCredentials</code> ;<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.withCredentials = <span class="keyword">false</span>;</div></pre></td></tr></table></figure></li></ul><p>3.<strong>需要注意的是</strong>:</p><ul><li><strong>如果要发送Cookie, <code>Access-Control-Allow-Origin</code> 就不能设为星号<code>*</code>, 必须指定明确的、与请求网页一致的域名</strong> ; </li><li><strong>同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传, 其他域名的Cookie并不会上传, 且(跨源)原网页代码中的document.cookie也无法读取服务器域名下的Cookie ;</strong></li></ul><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>1.域1中的代码(www.test.com/index.php)：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传, 其他域名的Cookie并不会上传, 且(跨源)原网页代码中的document.cookie也无法读取服务器域名下的Cookie</span></div><div class="line">setcookie(<span class="string">'address'</span>, json_encode([<span class="string">'city'</span> =&gt; <span class="string">'yuncheng'</span>, <span class="string">'town'</span> =&gt; <span class="string">'xiaoliang'</span>]), <span class="number">0</span>, <span class="string">'/'</span>, <span class="string">'.test.com'</span>);</div><div class="line"><span class="meta">?&gt;</span></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;Title&lt;/title&gt;</div><div class="line">    &lt;script src=<span class="string">"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=<span class="string">"text/javascript"</span> &gt;</div><div class="line">        $(document).ready(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="comment">//要在跨域请求服务器时在cors请求中包含cookie, 需要开启withCredentials属性</span></div><div class="line">            $.ajaxSetup(&#123;crossDomain: <span class="keyword">true</span>, xhrFields: &#123;withCredentials: <span class="keyword">true</span>&#125;&#125;);</div><div class="line"></div><div class="line">            $(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">(k)</span> </span>&#123;</div><div class="line">                <span class="keyword">var</span> data = $(<span class="string">"form"</span>).serializeArray();<span class="comment">//序列化name/value</span></div><div class="line">                $.ajax(&#123;</div><div class="line">                    type: <span class="string">'GET'</span>,  <span class="comment">//这里用GET</span></div><div class="line">                    url: <span class="string">'http://test.test.com/index.php'</span>,</div><div class="line">                    dataType: <span class="string">'json'</span>,  <span class="comment">//类型</span></div><div class="line">                    data: data,</div><div class="line">                    success: <span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;<span class="comment">//返回的json数据</span></div><div class="line">                        console.log(result); <span class="comment">//回调输出</span></div><div class="line">                    &#125;,</div><div class="line">                    timeout: <span class="number">3000</span></div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form name=<span class="string">"form"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"sex"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"btn"</span> value=<span class="string">"button"</span> /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p><p>2.域2中的代码(test.test.comindex.php):<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.test.com"</span>);</div><div class="line"><span class="comment">//服务器允许前端在跨域cors请求时包含cookie</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Credentials: true"</span>);</div><div class="line">$address = $_COOKIE[<span class="string">'address'</span>];</div><div class="line"><span class="keyword">echo</span> json_encode([<span class="string">'name'</span> =&gt; <span class="string">'lant'</span>, <span class="string">'age'</span> =&gt; <span class="number">100</span>, <span class="string">'address'</span> =&gt; $address]);</div></pre></td></tr></table></figure></p><p>3.效果:<br><img src="/img/cross-domain/cors-cookie.png" width="590" height="260" alt="cors-cookie" align="center"></p><p>4.两个注意点</p><ul><li><p>如果域1中在html中设置了 <code>withCredentials</code> 为 true :</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;);</div></pre></td></tr></table></figure><p>  那么在对应的ajax请求的域2中必须设置</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">header(<span class="string">"Access-Control-Allow-Credentials: true"</span>);</div></pre></td></tr></table></figure><p>  否则, 报错如下:<br>  <img src="/img/cross-domain/haha-server-withCredentials.png" width="500" height="160" alt="haha-server-withCredentials" align="center"></p></li><li><p>如果两边都不设置 <code>withCredentials</code> 属性的话, 也就是默认请求不带cookie, 那么即使请求方域1中设置了domain属性为 <code>.test.com</code> 的cookie值, 服务方(test.test.com)中也获取不到cookie, 因为域1默认请求就没有带cookie ;</p></li></ul><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">参考 阮一峰</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">参考 阮一峰 CORS</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CORS说明&quot;&gt;&lt;a href=&quot;#CORS说明&quot; class=&quot;headerlink&quot; title=&quot;CORS说明&quot;&gt;&lt;/a&gt;CORS说明&lt;/h3&gt;&lt;p&gt;1.CORS是一个W3C标准, 全称是 “跨域资源共享 “(Cross-origin resource sh
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>04. Ajax请求不能发送 之 &quot;JSONP方案&quot;</title>
    <link href="http://blog.renyimin.com/2016/09/17/2016-09-17-sameoriginpolicy-04/"/>
    <id>http://blog.renyimin.com/2016/09/17/2016-09-17-sameoriginpolicy-04/</id>
    <published>2016-09-17T11:27:31.000Z</published>
    <updated>2017-10-27T09:32:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>1.JSONP是服务器与客户端 <strong>跨源通信</strong> 的常用方法, 最大特点就是<code>简单适用</code>, <code>老式浏览器全部支持</code>, <code>服务器端改造非常小</code> ;</p><p>2.但是，<strong>JSONP只能发GET请求</strong> ;</p><p>3.<strong>注意:</strong> JSONP跨子域发送Cookie的话, 只用设置好<code>cookie的domain属性</code>为顶级域名即可 ;</p><ul><li><p>ajax使用jsonp跨域的时候是可以轻松像上面这样带上cookie给所跨的域 ;</p></li><li><p>而下一篇介绍的ajax使用cors方案跨域的话, 除了设置了cookie的 <code>document.domain</code> 为两个地址的顶级域名, 却也不能带上cookie, 还需要注意 前端和服务端的 <code>withCredentials</code> 头字段 ;</p></li></ul><h3 id="jsonp跨域请求案例"><a href="#jsonp跨域请求案例" class="headerlink" title="jsonp跨域请求案例"></a>jsonp跨域请求案例</h3><p>www.test.com/index.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Title&lt;/title&gt;</div><div class="line">    &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot; &gt;</div><div class="line">        $(document).ready(function()&#123;</div><div class="line">            //注意, 此时jsonp是会带上cookie的(当然, 如果你不设置cookie的domain, test.test.com自然获取不到www.test.com域的cookie)</div><div class="line">            document.cookie = &quot;name=value; domain=test.com&quot;;</div><div class="line">            $(&quot;#btn&quot;).click(function() &#123;</div><div class="line">                var data = $(&quot;form&quot;).serializeArray();//序列化name/value</div><div class="line">                $.ajax(&#123;</div><div class="line">                    type: &apos;GET&apos;,  //这里用GET</div><div class="line">                    url: &apos;http://test.test.com/index.php&apos;,</div><div class="line">                    dataType: &apos;jsonp&apos;,  //类型</div><div class="line">                    data: data,</div><div class="line">                    jsonp: &apos;callback&apos;, //jsonp回调参数，必需</div><div class="line">                    async: false,</div><div class="line">                    success: function (result) &#123;//返回的json数据</div><div class="line">                        console.log(result); //回调输出</div><div class="line">                    &#125;,</div><div class="line">                    timeout: 3000</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form name=&quot;form&quot;&gt;</div><div class="line">    &lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt;</div><div class="line">    &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;</div><div class="line">    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p><p>test.test.com/index.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//jsonp回调参数，必需</span></div><div class="line">$callback = <span class="keyword">isset</span>($_GET[<span class="string">'callback'</span>]) ? trim($_GET[<span class="string">'callback'</span>]) : <span class="string">''</span>;</div><div class="line"></div><div class="line">$sex = <span class="keyword">isset</span>($_GET[<span class="string">'sex'</span>]) ? trim($_GET[<span class="string">'sex'</span>]) : <span class="string">''</span>;</div><div class="line">$age = <span class="keyword">isset</span>($_GET[<span class="string">'age'</span>]) ? trim($_GET[<span class="string">'age'</span>]) : <span class="string">''</span>;</div><div class="line"></div><div class="line">$data = [<span class="string">"sex"</span> =&gt; $sex, <span class="string">"age"</span> =&gt; $age];</div><div class="line">$res = json_encode($data); <span class="comment">//json 数据</span></div><div class="line"><span class="comment">// 不能用return</span></div><div class="line"><span class="keyword">echo</span> $callback . <span class="string">'('</span> . $res . <span class="string">')'</span>;  <span class="comment">//返回格式，必需</span></div></pre></td></tr></table></figure></p><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JSONP&quot;&gt;&lt;a href=&quot;#JSONP&quot; class=&quot;headerlink&quot; title=&quot;JSONP&quot;&gt;&lt;/a&gt;JSONP&lt;/h3&gt;&lt;p&gt;1.JSONP是服务器与客户端 &lt;strong&gt;跨源通信&lt;/strong&gt; 的常用方法, 最大特点就是&lt;code&gt;简
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>03.同源策略的限制 之 &quot;Ajax请求不能发送&quot;</title>
    <link href="http://blog.renyimin.com/2016/09/16/2016-09-16-sameoriginpolicy-03/"/>
    <id>http://blog.renyimin.com/2016/09/16/2016-09-16-sameoriginpolicy-03/</id>
    <published>2016-09-16T05:04:17.000Z</published>
    <updated>2017-10-27T09:33:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同源策略的限制-Ajax请求不能发送"><a href="#同源策略的限制-Ajax请求不能发送" class="headerlink" title="同源策略的限制 - Ajax请求不能发送"></a>同源策略的限制 - Ajax请求不能发送</h2><ol><li><p>同源政策规定, AJAX请求只能发给同源的网址, 否则就报错 ;</p></li><li><p>除了架设服务器代理(浏览器请求同源服务器，再由后者请求外部服务), 有三种方法规避这个限制 :<br> <strong><a href="http://localhost:4000/2016/09/17/2016-09-17-sameoriginpolicy-04/" target="_blank" rel="external">JSONP</a></strong></p><p> <strong><a href="http://blog.renyimin.com">CORS</a></strong></p><p> <strong><a href="http://blog.renyimin.com">WebSocket</a></strong></p></li></ol><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">参考</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同源策略的限制-Ajax请求不能发送&quot;&gt;&lt;a href=&quot;#同源策略的限制-Ajax请求不能发送&quot; class=&quot;headerlink&quot; title=&quot;同源策略的限制 - Ajax请求不能发送&quot;&gt;&lt;/a&gt;同源策略的限制 - Ajax请求不能发送&lt;/h2&gt;&lt;ol&gt;

      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>02.同源策略的限制 之 &quot;Cookie无法读取&quot;</title>
    <link href="http://blog.renyimin.com/2016/09/15/2016-09-15-sameoriginpolicy-02/"/>
    <id>http://blog.renyimin.com/2016/09/15/2016-09-15-sameoriginpolicy-02/</id>
    <published>2016-09-15T13:10:13.000Z</published>
    <updated>2017-10-27T09:18:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>之前学习同源策略基础知识的时候, 了解了同源策略的 <code>三种行为</code> 限制:</p><ol><li><code>Cookie</code>、<code>LocalStorage</code> 和 <code>IndexDB</code> 无法读取</li><li><code>DOM</code> 无法获得 </li><li><p><code>AJAX</code> 请求不能发送 </p></li><li><p>不过这里需要注意一点: <strong>“同源策略”的限制, 并没有限制住CSRF攻击</strong><br>“同源策略的限制”并不会导致 B站点中嵌入的 <code>A站点超链接去读取A站点用户的cookie</code>;<br>假如你当前已经登录了邮箱，或bbs，同时你又访问了另外一个站点，假设这就是一个钓鱼网站; 这个网站上面可能因为某个图片吸引你，你去点击一下，此时可能就会触发一个js的点击事件，去构造一个bbs发帖的请求，去往你的bbs站点发帖，由于当前你的浏览器状态已经是登陆状态，所以session登陆cookie信息都会跟正常的请求一样，纯天然的利用当前的登陆状态，让用户在不知情的情况下，帮你发帖或干其他事情; (这也就是我们通常所说的CSRF攻击, CSRF攻击的主要目的是让用户在不知情的情况下攻击自己已登录的一个系统，类似于钓鱼);</p></li></ol><h3 id="同源策略的限制之”Cookie无法读取”"><a href="#同源策略的限制之”Cookie无法读取”" class="headerlink" title="同源策略的限制之”Cookie无法读取”"></a>同源策略的限制之”Cookie无法读取”</h3><ol><li><p>本篇构造跨域的场景来模拟”Cookie无法读取”的限制, 方法主要有:</p><ul><li>B站<code>&lt;a href=&quot;A&quot;&gt;test&lt;/a&gt;</code>超链接无法读取B站点的cookie; (而csrf所讨论的是B站<code>&lt;a href=&quot;A&quot;&gt;test&lt;/a&gt;</code>超链接可以读取A站点自己的cookie)</li><li><p>不通过B站超链接, 而是直接打开另一个网页来访问A站点, 结果当然也是A站点读不到B站点的Cookie ;</p></li><li><p>暂时不会涉及到 <code>Ajax请求所涉及的cookie传递问题</code>, 这个问题属于同源策略的第三种限制 <code>AJAX请求不能发送</code>;</p></li></ul></li><li><p>例子 :<br> A网页是 <code>http://www.test.com/index.html</code>，B网页是 <code>http://test.test.com/index.html</code> :<br> A: www.test.com/index.html (此处是使用js来设置cookie进行测试; 当然, 用服务端代码php测试也是OK的)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Title&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script type=&quot;application/javascript&quot;&gt;</div><div class="line">    document.cookie=&quot;name=value;&quot;;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p> <img src="/img/cross-domain/cookie-disabled-01.png" width="650" height="272" alt="cookie-disabled-01" align="center"></p><p> B: test.test.com/index.html</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script type=&quot;application/javascript&quot;&gt;</div><div class="line">    console.log(document.cookie);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p> // 可以看到, 同顶级域名也不能跨子域名获取cookie<br> <img src="/img/cross-domain/cookie-disabled-02.png" width="650" height="272" alt="cookie-disabled-02" align="center"></p><p> //同理, 直接在<code>http://www.test.com/index.html</code>中超链接点击到<code>http://test.test.com/index.html</code>也是获取不到cookie的 ;</p></li></ol><h3 id="合理规避Cookie无法读取的限制"><a href="#合理规避Cookie无法读取的限制" class="headerlink" title="合理规避Cookie无法读取的限制"></a><code>合理</code>规避Cookie无法读取的限制</h3><ol><li>虽然同源导致的这些限制是必要, 但是有些情况下, 其实我们是需要 <code>合理</code> 规避Cookie无法读取的限制的 ;</li><li>比如: 如果两个网页的顶级域名相同, 只是二级域名不同的话, 浏览器其实是允许你通过设置 <code>document.domain</code> 来共享 Cookie 的;</li><li><p>例子:<br> A网页是 <code>http://www.test.com/index.html</code>，B网页是 <code>http://test.test.com/index.html</code>, 那么只要设置相同的 <code>document.domain</code>，两个网页就可以共享Cookie :<br> A: www.test.com/index.html (此处是使用js来设置cookie进行测试; 当然, 用php代码也是OK的)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Title&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script type=&quot;application/javascript&quot;&gt;</div><div class="line">    document.cookie=&quot;name=value; domain=test.com&quot;;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p> <img src="/img/cross-domain/cookie-share.png" width="559" height="272" alt="cookie-share" align="center"></p><p> B: test.test.com/index.html</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script type=&quot;application/javascript&quot;&gt;</div><div class="line">    console.log(document.cookie);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p> <img src="/img/cross-domain/cookie-share02.png" width="300" height="275" alt="cookie-share" align="center"></p></li><li><p>注意:<br>这种方法只适用于 <code>Cookie</code> 和 <code>iframe 窗口(DOM无法获取)</code>; 而 LocalStorage 和 IndexDB 无法通过这种方法来规避同源政策，而要使用之后会介绍的PostMessage API ;</p></li></ol><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">参考 阮一峰</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h3&gt;&lt;p&gt;之前学习同源策略基础知识的时候, 了解了同源策略的 &lt;code&gt;三种行为&lt;/code&gt; 限制:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Coo
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>01.浏览器的同源策略(Same origin policy)</title>
    <link href="http://blog.renyimin.com/2016/09/15/2016-09-15-sameoriginpolicy-01/"/>
    <id>http://blog.renyimin.com/2016/09/15/2016-09-15-sameoriginpolicy-01/</id>
    <published>2016-09-15T11:21:54.000Z</published>
    <updated>2017-10-27T08:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a><code>同源策略</code></h3><p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策；</p><p>最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”，所谓 “同源” 指的是 <strong>“三个相同”</strong> ：</p><p><strong>1.协议相同</strong><br><code>http://blog.renyimin.com</code> 和 <code>https://blog.renyimin.com</code> 就不是同一个源 ；</p><p><strong>2.域名完全相同</strong><br><code>http://blog.renyimin.com/test/index.php</code> 和 <code>http://blog.renyimin.com/welcome/index.html</code> 就是同一个源; 但是 <code>http://www.renyimin.com/test/index.php</code> 和 <code>http://blog.renyimin.com/test/index.php</code> 就不是同一个源 ；<br>请注意：localhost和127.0.0.1虽然都指向本机, 但也不是同一个源 ;</p><p><strong>3.端口相同</strong><br><code>http://www.renyimin.com:8080/test/index.php</code> 和 <code>http://www.renyimin.com:80/test/index.php</code> 就不是同一个源 ;</p><p>再举例来说，<code>http://www.example.com/dir/page.html</code> 这个网址，协议是 <code>http://</code>，域名是 <code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略），它的同源情况如下：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http://www.example.com/dir2/other.html：同源</div><div class="line"></div><div class="line">http://example.com/dir/other.html：不同源（域名不同）</div><div class="line"></div><div class="line">http://v2.www.example.com/dir/other.html：不同源（域名不同）</div><div class="line"></div><div class="line">http://www.example.com:81/dir/other.html：不同源（端口不同）</div></pre></td></tr></table></figure></code></pre><h3 id="同源策略目的"><a href="#同源策略目的" class="headerlink" title="同源策略目的"></a>同源策略目的</h3><p>1.为了保证用户信息的安全，防止恶意的网站窃取数据;<br>比如:用户登录一家银行网站后，又去浏览其他站点, 如果没有同源策略限制, 其他站点就也能读取银行网站的 Cookie, 会发生什么？</p><ul><li>如果 Cookie 包含用户银行的私密信息，这些信息就会泄漏给第三方站点, 当然, cookie中包含的敏感信息通常经过加密，很难将其反向破解, 但这并不意味着绝对安全;</li><li>不去获取cookie中的信息, 而是直接偷取Cookie去骗取银行网站的信任;</li></ul><p>2.由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了 ;</p><h3 id="同源策略的限制"><a href="#同源策略的限制" class="headerlink" title="同源策略的限制"></a>同源策略的限制</h3><p>随着互联网的发展, “同源政策”越来越严格, 目前, 如果非同源, 共有三种行为受到限制:</p><ol><li><code>Cookie</code>、<code>LocalStorage</code> 和 <code>IndexDB</code> 无法读取</li><li><code>DOM</code> 无法获得 </li><li><code>AJAX</code> 请求不能发送 </li></ol><p>(可能我平时更过关注到的是1，3这两点限制)</p><ol><li>不过这里需要注意一点: <strong>“同源策略”的限制, 并没有限制住CSRF攻击</strong><br>“同源策略的限制”并不会导致 B站点中嵌入的 <code>A站点超链接去读取A站点用户的cookie</code>;<br>假如你当前已经登录了邮箱，或bbs，同时你又访问了另外一个站点，假设这就是一个钓鱼网站; 这个网站上面可能因为某个图片吸引你，你去点击一下，此时可能就会触发一个js的点击事件，去构造一个bbs发帖的请求，去往你的bbs站点发帖，由于当前你的浏览器状态已经是登陆状态，所以session登陆cookie信息都会跟正常的请求一样，纯天然的利用当前的登陆状态，让用户在不知情的情况下，帮你发帖或干其他事情; (这也就是我们通常所说的CSRF攻击, CSRF攻击的主要目的是让用户在不知情的情况下攻击自己已登录的一个系统，类似于钓鱼);</li></ol><p>最后, 虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响, 接下来将详细介绍如何在需要的时候合理地去规避”同源政策”的限制 ;</p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">参考 阮一峰</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;&lt;code&gt;同源策略&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策；&lt;/p&gt;
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>04 - 授权码模式各阶段参数分析</title>
    <link href="http://blog.renyimin.com/2016/05/25/2016-05-25-OAuth-04/"/>
    <id>http://blog.renyimin.com/2016/05/25/2016-05-25-OAuth-04/</id>
    <published>2016-05-25T12:10:12.000Z</published>
    <updated>2017-10-25T08:44:37.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一阶段-第三方站点将导向授权页"><a href="#第一阶段-第三方站点将导向授权页" class="headerlink" title="第一阶段: 第三方站点将导向授权页"></a>第一阶段: 第三方站点将导向授权页</h4><ol><li><p>第三方应用将用户导向授权页时, 传递的参数如下:</p><ul><li><code>response_type</code>: 表示授权类型, 必选项, 此处由于采用的是授权码模式, 所以值固定为 “code”</li><li><p><code>client_id/AppID</code>: 表示客户端的ID, 必选项<br>由于你可能会有多个站点需要对接OAuth授权服务器, 所以一般在授权服务平台登录之后, 是可以创建多个 <code>应用</code> 的 (不同的站点对接授权服务器中不同的<code>应用</code>);<br>每个<code>应用</code>对应你的一个 <code>第三方站点</code>, 开放平台会为每个<code>应用(第三方站点)</code>生成相应的 <code>AppID</code> 和 <code>AppSecret/AppKey</code>, 主要用来验证应用的合法性;</p></li><li><p><code>redirect_uri</code>: 设定的重定向到<code>第三方站点URI</code>, 必选项</p></li><li><code>scope</code>: 表示申请的权限范围, 可选项</li><li><code>state</code>: 表示客户端的当前状态, 可以指定任意值, 认证服务器会原封不动地返回这个值</li></ul></li><li><p>下面是各开放平台的参数对比:</p><ul><li><p><a href="http://open.weibo.com/wiki/Oauth2/authorize" target="_blank" rel="external">新浪</a><br><img src="/img/oauth/oauth_sina.png" width="500" height="560" alt="sina" align="center"></p></li><li><p><a href="http://wiki.connect.qq.com/%E4%BD%BF%E7%94%A8authorization_code%E8%8E%B7%E5%8F%96access_token" target="_blank" rel="external">QQ</a><br><img src="/img/oauth/oauth_qq.png" width="500" height="560" alt="qq" align="center"></p></li><li><p><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信</a><br><img src="/img/oauth/oauth_wechat.png" width="500" height="560" alt="wechat" align="center"></p></li><li><p><a href="https://developer.github.com/apps/building-integrations/setting-up-and-registering-oauth-apps/about-authorization-options-for-oauth-apps/" target="_blank" rel="external">GitHub</a><br><img src="/img/oauth/oauth_github.png" width="500" height="560" alt="github" align="center"></p></li><li><p><a href="https://doc.open.alipay.com/docs/doc.htm?treeId=193&amp;articleId=105656&amp;docType=1#s5" target="_blank" rel="external">蚂蚁金服</a><br><img src="/img/oauth/oauth_alipay.png" width="500" alt="github" align="center"></p></li></ul></li><li><p>简单测试:</p><ul><li><p>redirect_uri<br>在OAuth服务器中为第三方站点创建 <code>应用</code> 的时候, 设定的回调地址, 无论在认证服务器, 还是在第三方站点, 都会对其进行校验, <code>以防篡改</code>;</p><p>新浪授权传递错误 redirect_uri<br><img src="/img/oauth/jianshu_sina_err01.png" width="450" height="240" alt="github" align="center"></p><p>简书qq授权传递错误 redirect_uri<br><img src="/img/oauth/jianshu_qq_err01.png" width="450" height="200" alt="github" align="center"></p></li><li><p>state<br>第三方站点会对state做校验<br>给了一个新的弹框用来进行授权, 但是如果恶意用户复制出弹框中的url, 之后再修改state并刷新页面, 授权后发现:<br><img src="/img/oauth/zhihu_auth_qq_01.png" width="500" height="100" alt="github" align="center"></p></li></ul></li><li><p>从上面各平台也可以看到, 返回参数相对比较简单;</p><ul><li>返回的code是和授权页登录的用户身份相关的; (后面的access_token也是通过code和用户身份关联起来的)</li></ul></li></ol><h4 id="第二阶段-通过Authorization-Code获取Access-Token"><a href="#第二阶段-通过Authorization-Code获取Access-Token" class="headerlink" title="第二阶段: 通过Authorization Code获取Access Token"></a>第二阶段: 通过Authorization Code获取Access Token</h4><ol><li><p>如果第三方站点的用户在第一阶段的授权页中选择对第三方站点授权, 那么就第三方站点就会收到授权服务器的Authorization Code, 进而进入本阶段;<br>(每个用户在授权后, 第三方站点都需要到授权服务器上为用户获取一个access_token, 这个access_token就是以后第三方站点从授权服务器上获取用户信息的凭证了, 一般在获取到access_token令牌之后, 可以存储到session中)</p></li><li><p>本阶段, 我们在自己的第三方站点中就可以使用第一阶段的Authorization Code获取Access Token:</p><ul><li><p><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信</a></p></li><li><p><a href="http://wiki.connect.qq.com/%E4%BD%BF%E7%94%A8authorization_code%E8%8E%B7%E5%8F%96access_token" target="_blank" rel="external">qq</a><br><img src="/img/oauth/access_token_qq.png" width="650" height="680" alt="github" align="center"></p></li><li><p>基本上入参就像QQ互联那样大概有5个 (需要对每个参数进行了解);</p></li></ul></li><li><p>本阶段的返回参数比较有讲究, 一般为如下三个</p><ul><li><p>access_token 授权令牌<br>access_token一般在获取到之后, 第三方站点可以将其 <code>保存到用户的session中</code> , 第三方站点之后要获取用户在授权服务器上的资源的时候, 就需要带上当前session中用户的access_token去获取;</p></li><li><p>expires_in    该access token的有效期,单位为秒 (微信公众平台access_token有效期为2小时, qq互联平台为3个月 可以作为参考)<br>设置access_token有效期也是为了定期修改access_token, 以提高安全性;<br>(并且微信对获取access_token这个基础API是有限制的，每天最多请求2000次, 因为有效期为2小时, 每天2000次也足够了;)</p></li><li><p>refresh_token 授权自动续期时使用 (微信公众平台refresh_token有效期为30天, qq互联平台具体不详, 可以作为参考)</p></li></ul></li><li><p>(可选)权限自动续期问题</p><ul><li><p>注意<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信公众平台</a>:<br>  1.若access_token已超时，那么进行refresh_token会获取一个新的access_token，新的超时时间, 并且一旦使用refresh_token来刷新access_token的话, refresh_token的过期时间也会更新(自动延期) ;<br>  2.若access_token未超时，那么进行refresh_token不会改变access_token，但超时时间会刷新，相当于续期access_token ;<br>  这里说的超时时间刷新, 指的自然是第三方站点和授权服务器上的超时时间都要更新了(只不过你如果只是做对接的话, 授权服务器这部分人家已经开发好了, 如果你是授权服务器也是自己开发的话, 那你就需要注意这里了)</p></li><li><p>其实第三方站点在受到授权服务器分配给当前用户的access_token之后, 假设说授权服务器返回access_token的过期时间为7200s(2小时), 那么第三方站点将access_token保存到用户session中, 并设置过期时间为6600s(中间可以有个10分钟的服务器时间差);</p></li><li><p>如果第三方站点在使用access_token为用户获取授权服务器中的资源时, 发现session中的access_token并没有过期, 那么请求后就需要为access_token续期(第三方站点和授权服务器上都要做续期)</p></li><li><p>如果第三方站点在使用access_token为用户获取授权服务器中的资源时, 发现session中的access_token过期, 则就需要使用<code>refresh_token</code>调用<code>生成access_token的api接口</code>重新生成access_token来进行续期；<br>  qq:<br>  <img src="/img/oauth/refresh_token_qq.png" width="650" height="640" alt="github" align="center"></p></li><li><p>这样下来, 基本上第三方站点只有在大于refresh_token的过期时间都没有调用过授权服务器的话, 才需要用户重新登录;</p></li></ul></li></ol><h4 id="第三阶段-比较简单-第三方站点通过access-token获取授权平台资源服务器上的用户资源"><a href="#第三阶段-比较简单-第三方站点通过access-token获取授权平台资源服务器上的用户资源" class="headerlink" title="第三阶段(比较简单): 第三方站点通过access_token获取授权平台资源服务器上的用户资源"></a>第三阶段(比较简单): 第三方站点通过access_token获取授权平台资源服务器上的用户资源</h4><ol><li><p>获取access_token后，进行接口调用，有以下前提：</p><ul><li>access_token有效且未超时；</li><li>微信用户已授权给第三方应用帐号相应接口作用域(scope);<br>也就是在授权服务器上还会使用access_token去检测对应的scope权限是否正确;</li></ul></li><li><p>许多开放平台在申请完access_token令牌之后, 都提供了对应接口来获取用户相关信息<br><a href="http://wiki.connect.qq.com/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_server-side" target="_blank" rel="external">QQ互联</a>提供了相应的接口, 使用Access Token来获取用户的OpenID;<br><a href="http://open.weibo.com/wiki/Oauth2/get_token_info" target="_blank" rel="external">新浪开放平台</a>提供了相应的接口来获取access_token对应的用户信息;<br><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="external">而微信公众平台</a>: 在获取access_token的时候, 会同时返回<code>openid</code>表示微信用户在本公众号中的唯一标识;</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;第一阶段-第三方站点将导向授权页&quot;&gt;&lt;a href=&quot;#第一阶段-第三方站点将导向授权页&quot; class=&quot;headerlink&quot; title=&quot;第一阶段: 第三方站点将导向授权页&quot;&gt;&lt;/a&gt;第一阶段: 第三方站点将导向授权页&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;第三方
      
    
    </summary>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/tags/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>03 - OAuth2.0的CSRF攻击</title>
    <link href="http://blog.renyimin.com/2016/05/24/2016-05-24-OAuth-03/"/>
    <id>http://blog.renyimin.com/2016/05/24/2016-05-24-OAuth-03/</id>
    <published>2016-05-24T11:27:36.000Z</published>
    <updated>2017-10-25T08:01:49.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>假设有如下几个角色:<br>受害者 <code>lant</code> ;<br>攻击者 <code>rymuscle</code> ;<br>第三方Web应用 <code>liangren网</code> (它允许用户将其在 <code>sandiruiqi网</code> 的账号 和 <code>liangren网</code> 的账号进行绑定) ;<br>OAuth2服务提供平台 <code>sandiruiqi网</code> ;</p></li><li><p>攻击流程</p><ul><li><p><code>攻击者rymuscle</code> 登录 <code>liangren网</code> 并且选择使用自己的 <code>sandiruiqi网</code> 账号登录 ;</p></li><li><p><code>liangren网</code> 将 <code>攻击者rymuscle</code> 重定向到 <code>sandiruiqi网</code> 的授权页(这时可能需要 <code>攻击者rymuscle</code> 登录过<code>sandiruiqi网</code>), <code>sandiruiqi网</code> 的授权页向 <code>攻击者rymuscle</code> 显示 “是否授权<code>liangren网</code>访问” ;</p></li><li><p><code>攻击者rymuscle</code> 在点击”同意授权”之后, 截获 <code>sandiruiqi网</code> 服务器返回的含有 <code>Authorization Code</code> 参数的HTTP响应 ;</p></li><li><p>然后 <code>攻击者rymuscle</code> 精心构造一个Web页面, 它会触发 <code>liangren网</code> 向 <code>sandiruiqi网</code> 发起<strong>令牌申请</strong>的请求, 而这个请求中的Authorization Code参数正是上一步 <code>攻击者rymuscle</code> 截获到的code ;</p></li><li><p><code>攻击者rymuscle</code> 将这个Web页面放到互联网上, 等待或者诱骗受害者来访问 ;</p></li><li><p>假设正好一个受害者 <code>lant</code> 访问了 <code>攻击者rymuscle</code> 准备的这个Web页面后, 令牌申请流程在 <code>受害者lant</code> 的浏览器里被顺利触发, <code>laingren网</code> 从 <code>sandiruiqi网</code> 那里获取到access_token, 但是这个token以及通过它进一步获取到的用户信息却都是攻击者 <code>攻击者rymuscle</code> 的 ;</p></li><li><p>也就是最终 <code>liangren网</code> 将 <code>攻击者rymuscle</code> 的 <code>sandiruiqi</code> 账号同 <code>lant</code> 的 <code>liangren网</code> 账号关联了起来</p><p>从此以后, <code>lant</code>只要没有察觉到自己最初被悄悄使用了 <code>攻击者rymuscle</code> 的<code>sandiruiqi网</code> 账号登录, 那么他在 <code>liangren网</code> 上的所有资料, 都可以被 <code>攻击者rymuscle</code> 所看到, 并且 <code>攻击者rymuscle</code> 可能在 <code>lant</code> 的账号中做一些非法操作;</p></li></ul></li><li><p>整体时序图分析</p><ul><li><p>先看标准oauth时序图<br><img src="/img/oauth/authorization_code.png" width="635" height="600" alt="qq" align="center"></p></li><li><p>下面是从网上copy的一张图, 从整体上来看, 这次攻击的时序图类似下图:<br><img src="/img/oauth/yihuajiemu_mawei.png" width="635" height="580" alt="sina" align="center"></p></li></ul></li><li><p>可以看到, 攻击的关键点在于:<br>OAuth2的认证流程是分为好几步来完成的, 在标准oauth图的第3步, 第三方应用在收到一个GET请求时, 除了能知道当前用户的cookie, 以及URL中的Authorization Code之外, 难以分辨出这个请求到底是用户本人的意愿, 还是攻击者利用用户的身份伪造出来的请求; 于是乎, 攻击者就能使用移花接木的手段, 提前准备一个含有自己的Authorization Code的请求, 并让受害者的浏览器来接着完成后续的令牌申请流程 ;</p></li><li><p>难点(涉及到了非state参数防御):<br> 尽管这个攻击既巧妙又隐蔽, 但是要成功进行这样的CSRF攻击也是比较困难的 :    </p><ul><li><p>整个攻击必须在短时间内完成, 因为OAuth2提供者颁发的Authorization Code有效期很短, <strong>OAuth2官方推荐的时间是不大于10分钟</strong>, 而一旦Authorization Code过期那么后续的攻击也就不能进行下去了;</p></li><li><p>一个Authorization Code只能被使用一次, 如果OAuth2提供者收到重复的Authorization Code, 它会拒绝当前的令牌申请请求, 不止如此, 根据OAuth2官方推荐, 它还可以把和这个已经使用过的Authorization Code相关联的access_token全部撤销掉, 进一步降低安全风险;</p><p>其实貌似只要做到Authorization Code只能被使用一次, 就可以防止csrf在此处的攻击了, 因为 <code>rymuscle</code> 在攻击的时候, 一旦获得 <code>Authorization Code</code>, 第三方站点服务器就会使用 <code>Authorization Code</code> 去申请access_token, 然后只要标记 <code>Authorization Code</code> 为已经使用, 那么 <code>受害者lant</code> 即使点击 <code>攻击者rymuscle</code> 构造好的链接也没用, 因为连接中的 <code>Authorization Code</code> 已经被标记为使用过了;</p></li><li><p>所以不一定非要使用下面的state参数来进行防御<br><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">比如微信公众平台的OAuth授权: state参数就是可选的</a><br><a href="http://open.weibo.com/wiki/Oauth2/authorize" target="_blank" rel="external">新浪开放平台的OAuth授权, state参数也是可选的</a><br>当然, 他们不一定做的是和此处一样的防御方案, 但明显不依赖于state参数来解决问题;</p></li></ul></li><li><p>state参数防御: 要防止这样的攻击其实很容易, 作为第三方应用的开发者, 只需在OAuth认证过程中加入 <code>state</code> 参数, 并验证它的参数值即可;</p><ul><li><p>在将用户重定向到OAuth2的Authorization Endpoint去的时候, 为用户生成一个随机的字符串, 并作为state参数加入到URL中 ;</p></li><li><p>在收到OAuth2服务提供者返回的Authorization Code请求的时候, 验证接收到的state参数值, 如果是正确合法的请求, 那么此时接受到的参数值应该和上一步提到的为该用户生成的state参数值完全一致, 否则就是异常请求;</p><p>但需要注意 <code>state参数</code> 需要具备下面几个特性:</p></li><li><p>不可预测性: 足够的随机, 使得攻击者难以猜到正确的参数值 ;<br>如果你每次生成的state都被放在一起, 比如一个库/缓存中存在很多state;<br>那么问题就是攻击者还是可以拿着自己的code再加上一个state, 来构造一个链接欺骗用户来点击;(假设state正好就在你的库/缓存中);</p></li><li><p>重点是关联性: state参数值可以和当前用户会话(user session)相互关联的<br>所以应该让state和具体的用户关联起来, 虽然用户还没有登录, 但是也可以让state放到session中 ;<br>然后攻击者要猜测出来一个state的话, 即便是已经生成过了, 但是也得正好攻击的是这个用户;</p></li><li><p>唯一性: 每个用户每次请求生成的state参数值都是唯一的 ;</p></li><li><p>时效性: state参数一旦被使用则立即失效 ;</p></li><li><p>参考 蚂蚁金服开放平台:<br><img src="/img/oauth/state_alipay.png" width="600" height="550" alt="wechat" align="center"></p></li></ul></li><li><p>其实可以结合以上各种方法一起来进行防御!</p></li></ol><blockquote><p><a href="http://insights.thoughtworkers.org/attack-aim-at-oauth2/" target="_blank" rel="external">参考 移花接木</a><br><a href="http://blog.sina.com.cn/s/blog_56b798f801018jyb.html" target="_blank" rel="external">参考 state参数漏洞</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">参考 阮一峰</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;假设有如下几个角色:&lt;br&gt;受害者 &lt;code&gt;lant&lt;/code&gt; ;&lt;br&gt;攻击者 &lt;code&gt;rymuscle&lt;/code&gt; ;&lt;br&gt;第三方Web应用 &lt;code&gt;liangren网&lt;/code&gt; (它允许用户将其在 &lt;code&gt;sandirui
      
    
    </summary>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/tags/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>02 - 授权码模式</title>
    <link href="http://blog.renyimin.com/2016/05/22/2016-05-22-OAuth-02/"/>
    <id>http://blog.renyimin.com/2016/05/22/2016-05-22-OAuth-02/</id>
    <published>2016-05-22T12:27:36.000Z</published>
    <updated>2017-10-25T08:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="授权码模式运行过程"><a href="#授权码模式运行过程" class="headerlink" title="授权码模式运行过程"></a>授权码模式运行过程</h2><ol><li>运行图<br><img src="/img/oauth/authorization_code.png" width="535" height="500" alt="qq" align="center"></li></ol><h2 id="运行过程分析"><a href="#运行过程分析" class="headerlink" title="运行过程分析"></a>运行过程分析</h2><p>1.向用户取得授权许可<br>对应图中的第1、2、3步;</p><p>2.申请访问令牌<br>access_token令牌的申请<br>对应图中的第4、5步;</p><p>3.使用令牌获取用户数据<br>开放平台在申请完access_token令牌之后, 都提供了对应接口来获取用户相关信息, 比如:<br><a href="http://wiki.connect.qq.com/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_server-side" target="_blank" rel="external">QQ互联</a>: 提供了相应的接口, 使用Access Token来获取用户的OpenID;<br><a href="http://open.weibo.com/wiki/Oauth2/get_token_info" target="_blank" rel="external">新浪开放平台</a>: 提供了相应的接口来获取access_token对应的用户信息;<br><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="external">而微信公众平台</a>: 在获取access_token的时候, 会同时返回<code>openid</code>表示微信用户在本公众号中的唯一标识;</p><p>这一过程中涉及了不少敏感参数和数据, 例如client_secret相当于是第三方应用自己的密码, access_token某种程度上来讲就是用户的session id, 由于这些参数以及数据极其特殊, 我们当然得确保它们的安全性, HTTPS加密传输以及安全存储是必不可少的防护手段, <strong>不过仅仅做到这些是远远不够的, 因为其实在这个流程里存在一个弱点， 容易被攻击者利用进行CSRF攻击, <a href="http://blog.renyimin.com/2016/05/24/2016-05-24-OAuth-01-02/">下一篇笔记将会详细分析</a> ; </strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;授权码模式运行过程&quot;&gt;&lt;a href=&quot;#授权码模式运行过程&quot; class=&quot;headerlink&quot; title=&quot;授权码模式运行过程&quot;&gt;&lt;/a&gt;授权码模式运行过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;运行图&lt;br&gt;&lt;img src=&quot;/img/oauth/authoriz
      
    
    </summary>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/tags/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>01 - OAuth(Open Authorization)开放式授权协议</title>
    <link href="http://blog.renyimin.com/2016/05/19/2016-05-19-OAuth-01/"/>
    <id>http://blog.renyimin.com/2016/05/19/2016-05-19-OAuth-01/</id>
    <published>2016-05-19T03:05:00.000Z</published>
    <updated>2017-10-27T02:19:29.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版"><a href="#OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版" class="headerlink" title="OAuth是一个关于授权(authorization)的开放网络标准, 目前的版本是2.0版"></a>OAuth是一个关于授权(authorization)的开放网络标准, 目前的版本是2.0版</h4><ul><li><p>OAuth之前的传统”授权”比较 简单, 直接, 暴力, 一般是直接提供自己资源服务器的账号和密码给第三方站点, 要知道这种做的法弊端太多:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1.如果用户在每个第三方站点都这样做, 那将会存在严重安全隐患:</div><div class="line">很多第三方网站为了后续的服务, 会保存用户资源服务器的账号和密码, 这样很不安全, </div><div class="line">因为难免有些第三方平台会由于自己的安全问题而导致用户的账号和密码泄露, 从而导致用户大量信息泄露 ;</div><div class="line"></div><div class="line">2.用户无法设定第三方站点的权利范围:</div><div class="line">第三方网站拥有了获取用户某个资源服务器的账号和密码后, 就拥有了资源服务器上的所有的资料, 用户没法限制第三方站点获取资源服务器上资源的权利范围和有效期 ;</div><div class="line"></div><div class="line">3.用户想收回第三方站点的权利不太方便:</div><div class="line">用户只有修改密码, 才能收回赋予第三方网站的权力, 否则第三方网站将会永久拥有用户资源服务器上资源的权利，但是这样做, 又会使得其他所有获得用户授权的第三方应用程序全部失效 ;</div><div class="line"></div><div class="line">或者, 一些良心第三方可以设置 用户账号 和 资源服务器账号的绑定和解绑, 但不一定所有第三方都会给你做, 如果不做解绑的话, 你还真就只有前一种方法能够收回权利 ;</div></pre></td></tr></table></figure></li><li><p>而OAuth的授权不会让 <code>第三方站点</code> 触及到用户在 <code>资源服务器</code> 上的帐号信息(如用户名与密码), 即第三方站点无需使用用户资源服务器上的账号与密码, 就可以获得该用户在 <code>资源服务器</code> 上的资源, 因此 OAuth 是安全的 ;</p></li></ul><h4 id="OAuth2-0协议定义了用于获得授权的”四种主要授权类型”"><a href="#OAuth2-0协议定义了用于获得授权的”四种主要授权类型”" class="headerlink" title="OAuth2.0协议定义了用于获得授权的”四种主要授权类型”"></a>OAuth2.0协议定义了用于获得授权的”四种主要授权类型”</h4><h5 id="1-授权码-Authorization-code-模式"><a href="#1-授权码-Authorization-code-模式" class="headerlink" title="1.授权码(Authorization code)模式"></a>1.<a href="http://localhost:4000/2016/03/19/OAuth-authorization-code01/" target="_blank" rel="external">授权码(Authorization code)模式</a></h5><ul><li>授权码模式是功能最完整、流程最严密的授权模式(标准的Server授权模式, 非常适合Server端的Web应用);</li><li>它的特点是: <code>通过客户端的后台服务器, 与&quot;服务提供商&quot;的认证服务器进行互动</code>;<br><img src="/img/oauth/oauth_authorization_code_01.png" width="711" height="514" alt="authorization_code_01" align="center"></li><li><p>运行流程图解</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">用户打开客户端以后，客户端要求用户给予授权。</div><div class="line">用户同意给予客户端授权。</div><div class="line">客户端使用上一步获得的授权，向认证服务器申请令牌。</div><div class="line">认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</div><div class="line">客户端使用令牌，向资源服务器申请获取资源。</div><div class="line">资源服务器确认令牌无误，同意向客户端开放资源</div></pre></td></tr></table></figure></li><li><p>场景:<br>  比如公司需要对接 QQ, 微博, 微信(网页授权) 等登录授权;<br>  或者公司达到可以做自己对外的开放平台;<br>  当然, 公司如果要做对外开放平台, 可能不止使用这一种模式:</p><pre><code>像微信网页授权使用的就是`授权码模式`； 但是微信的基础功能接口和开发者服务器交互的时候, 就使用到了`客户端模式`；而微信服务器涉及到和开发者服务器进行消息交互的时候, 还使用了类似`JWT`的签名校验来保证数据传输的安全;</code></pre></li></ul><h5 id="2-隐式授权模式-Implicit-Grant"><a href="#2-隐式授权模式-Implicit-Grant" class="headerlink" title="2.隐式授权模式(Implicit Grant)"></a>2.隐式授权模式(Implicit Grant)</h5><ul><li>也叫简化模式, 该模式<code>不通过第三方应用程序的服务器</code>, 而是直接在浏览器中向认证服务器申请令牌, 跳过了”授权码”这个步骤, 因此得名;</li><li>它的特点是: 所有步骤在浏览器中完成, 令牌对访问者是可见的;</li><li>流程图:<br><img src="/img/oauth/oauth_implict_01.png" width="660" height="570" alt="oauth_implict_01" align="center"></li><li>场景:</li></ul><h5 id="3-密码模式-Resource-Owner-Password-Credentials"><a href="#3-密码模式-Resource-Owner-Password-Credentials" class="headerlink" title="3.密码模式(Resource Owner Password Credentials)"></a>3.密码模式(Resource Owner Password Credentials)</h5><ul><li>用户向客户端提供自己的用户名和密码, 客户端使用这些信息，向”服务商提供商”索要授权 ;</li><li>这种模式要求用户提供用户名和密码来交换访问令牌access_token ;</li><li>它的特点是:<br>客户端仍然是以单个用户的名义向”服务提供商”进行认证;<br>在这种模式中, 用户必须把自己的密码给客户端, 但是客户端不得储存密码, 这通常用在 <code>用户对客户端高度信任的情况下</code>, 比如客户端也是系统的一部分;</li><li>流程图:<br><img src="/img/oauth/password_credentials_01.png" width="750" height="387" alt="password_credentials_01" align="center"></li><li><p>下图也可参考:<br><img src="/img/oauth/password_credentials_02.png" width="527" height="218" alt="password_credentials_02" align="center"></p></li><li><p>场景:<br>比如当third party application、authorization server、resource owner都是自己公司内的系统, Resource owner对third party application足够信任，所以我们就能采取这种模式来实现;<br>就像: 公司如果有多套内部后台系统, 开发人员和公司管理员可能就要准备多套账号, 比较麻烦, 为了解决这个问题, 可以做一个<code>账号中心</code>系统, 用户在登录各个系统后台的时候, 会先跳转到用户中心进行登录, 一旦登录成功之后, 就会给用户分发一个access_token, 用来在各个系统间作为登录认证 (这也实现了<code>SSO单点登录</code>);<br>(参考: <a href="http://www.cnblogs.com/richieyang/p/4918819.html" target="_blank" rel="external">http://www.cnblogs.com/richieyang/p/4918819.html</a>)</p></li></ul><h5 id="4-客户端模式-Client-Credentials"><a href="#4-客户端模式-Client-Credentials" class="headerlink" title="4.客户端模式(Client Credentials)"></a>4.客户端模式(Client Credentials)</h5><ul><li><p>客户端模式指客户端<code>以客户端自己的名义, 而不是以单个用户的名义</code>，向”服务提供商”进行认证;<br>严格地说, 客户端模式并不属于OAuth框架所要解决的问题;</p></li><li><p>流程图:<br><img src="/img/oauth/oauth_client_credentials_01.png" width="760" height="165" alt="oauth_client_credentials_01" align="center"></p></li><li><p>服务器 <code>不提供像用户数据这样的重要资源</code>，仅仅是一些开放的功能性API;<br>例如微信公众平台, Google Storage或Amazon S3 等开放平台提供的基础服务接口;</p></li><li><p>场景:<br>1.你自己实现了一套基础服务的Api(都是些基础功能接口, 并不涉及用户数据这种重要资源), <code>提供给内部其他系统通过认证的方式来调用</code>;<br>2.公司如果实力强悍的话, 也可以将公司开发的基础服务Api公开出来 <code>供外部其他第三方站点服务器</code> 来调用, 比如: <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183" target="_blank" rel="external">微信公众平台的开放接口其实就是使用这种方式</a>(但微信的网页授权采用的就是授权码模式):<br><img src="/img/oauth/oauth_client_credentials_02.png" width="699" height="475" alt="oauth_client_credentials_02" align="center"></p></li></ul><h4 id="客户端模式-Client-Credentials-和-用户密码模式-有时候比较容易混淆"><a href="#客户端模式-Client-Credentials-和-用户密码模式-有时候比较容易混淆" class="headerlink" title="客户端模式(Client Credentials) 和 用户密码模式 有时候比较容易混淆"></a>客户端模式(Client Credentials) 和 用户密码模式 有时候比较容易混淆</h4><p>1.客户端模式: 如果客户端以自己的身份向服务提供商进行认证, 那需要授权中心给各个应用(不管是内部系统还是第三方站点服务器)分配对应的AppID和AppSecret, 然后第三方应用使用这两个信息来向”认证服务器”申请access_token, 这种场景下, 认证服务器一般提供的接口都是功能性的基础服务接口;<br>2.用户密码模式: 如果客户端以单个用户身份向服务提供商进行认证, 只要用户账号密码能通过认证服务器, 认证服务器就会发放access_token, 当然这种场景需要的是<code>几方角色都属于本公司内部</code>;</p><p>当然这里所聊的是授权相关的知识, 并没有涉及数据传输的加密及签名校验, 但其实像微信公众平台这样开放平台, 除了基础服务接口供给开发者服务器调用时不需要做数据传输的加密和签名校验; 当微信服务器和开发者服务器涉及到用户消息数据的收发时, 会推荐对数据进行加密和签名校验;</p><blockquote><p>参考: <a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a><br>参考: <a href="http://www.cnblogs.com/richieyang/p/4918819.html" target="_blank" rel="external">http://www.cnblogs.com/richieyang/p/4918819.html</a><br>参考: <a href="http://www.dannysite.com/blog/176/" target="_blank" rel="external">http://www.dannysite.com/blog/176/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版&quot;&gt;&lt;a href=&quot;#OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版&quot; class=&quot;headerlink&quot; title=&quot;OA
      
    
    </summary>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/tags/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
