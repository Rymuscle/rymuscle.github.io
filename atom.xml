<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2018-04-04T02:30:39.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP7语法新特性</title>
    <link href="http://blog.renyimin.com/2018/04/04/PHP/2018-04-04-php7new-base/"/>
    <id>http://blog.renyimin.com/2018/04/04/PHP/2018-04-04-php7new-base/</id>
    <published>2018-04-04T01:32:02.000Z</published>
    <updated>2018-04-04T02:30:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="null合并运算符"><a href="#null合并运算符" class="headerlink" title="null合并运算符 ??"></a>null合并运算符 <code>??</code></h3><ol><li><p><code>??</code> : 如果变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数;</p></li><li><p>先回顾一下 <code>isset</code> 用法: 只有 <code>显示声明为null</code> 或者 <code>未声明</code> 的变量, isset的结果为false</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$a = 0;</div><div class="line">$b = 0.0;</div><div class="line">$c = &apos;&apos;;</div><div class="line">$d = &apos;0&apos;;</div><div class="line">$e = &apos;0.0&apos;;</div><div class="line">$f = &apos;null&apos;;</div><div class="line">$g = [];</div><div class="line">$h = [&apos;name&apos; =&gt; &apos;renyimin&apos;, &apos;age&apos; =&gt; null];</div><div class="line">$i = null;</div><div class="line">var_dump(isset($a));    // true</div><div class="line">var_dump(isset($b));    // true</div><div class="line">var_dump(isset($c));    // true</div><div class="line">var_dump(isset($d));    // true</div><div class="line">var_dump(isset($e));    // true</div><div class="line">var_dump(isset($f));    // true</div><div class="line">var_dump(isset($g));    // true</div><div class="line"></div><div class="line">var_dump(isset($h[&apos;age&apos;])); // false</div><div class="line">// 注意: array_key_exists 即使键的值为null, 结果也是true</div><div class="line">var_dump(array_key_exists(&apos;age&apos;, $h));  // true</div><div class="line"></div><div class="line">var_dump(isset($h[&apos;address&apos;])); // false</div><div class="line">// 注意: array_key_exists 即使键的值为null, 结果也是true, 除非键真的不存在</div><div class="line">var_dump(array_key_exists(&apos;address&apos;, $h));  // false</div><div class="line"></div><div class="line">var_dump(isset($h[&apos;address&apos;])); // false</div><div class="line">var_dump(isset($i));    // false</div><div class="line">var_dump(isset($j));    // false</div></pre></td></tr></table></figure></li><li><p><code>??</code> 示例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$a = 0;</div><div class="line">$c = $a ?? 10;  // 相当于 $c = isset($a) ? $a : 10;</div><div class="line">echo $c;</div></pre></td></tr></table></figure></li></ol><p>~~ 未完待续</p><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;null合并运算符&quot;&gt;&lt;a href=&quot;#null合并运算符&quot; class=&quot;headerlink&quot; title=&quot;null合并运算符 ??&quot;&gt;&lt;/a&gt;null合并运算符 &lt;code&gt;??&lt;/code&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;??&lt;/code
      
    
    </summary>
    
      <category term="PHP" scheme="http://blog.renyimin.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.renyimin.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>23. 门面（Facades）</title>
    <link href="http://blog.renyimin.com/2018/04/01/Laravel/2018-04-01-Laravel-23/"/>
    <id>http://blog.renyimin.com/2018/04/01/Laravel/2018-04-01-Laravel-23/</id>
    <published>2018-03-31T22:06:34.000Z</published>
    <updated>2018-04-02T05:34:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建自定义门面类"><a href="#创建自定义门面类" class="headerlink" title="创建自定义门面类"></a>创建自定义门面类</h2><ol><li>先创建好自己的自定义服务类;</li><li>在 <code>App/Facades/</code> 下创建一个指向 <code>自定义服务类</code> 的门面类;</li><li>然后需要到配置文件<code>config/app.php</code>中的<code>aliases</code>数组中去注册门面类的别名;</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建自定义门面类&quot;&gt;&lt;a href=&quot;#创建自定义门面类&quot; class=&quot;headerlink&quot; title=&quot;创建自定义门面类&quot;&gt;&lt;/a&gt;创建自定义门面类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;先创建好自己的自定义服务类;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;App/Faca
      
    
    </summary>
    
      <category term="Laravel" scheme="http://blog.renyimin.com/categories/Laravel/"/>
    
    
      <category term="Laravel" scheme="http://blog.renyimin.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>21. Laravel中的&quot;服务容器&quot;</title>
    <link href="http://blog.renyimin.com/2018/03/31/Laravel/2018-03-31-Laravel-21/"/>
    <id>http://blog.renyimin.com/2018/03/31/Laravel/2018-03-31-Laravel-21/</id>
    <published>2018-03-31T12:10:39.000Z</published>
    <updated>2018-04-01T10:03:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>Laravel服务容器是一个用于管理类依赖和执行依赖注入的强大工具;</p><p>几乎所有的<code>服务容器绑定</code>都是在<code>服务提供者</code>中完成; 如果一个类没有基于任何接口那么就没有必要将其绑定到容器, 容器并不需要被告知如何构建对象, 因为它会使用PHP的反射服务自动解析出具体的对象;</p><ul><li>正如上一篇<a href="/2018/03/31/Laravel/2018-03-31-Laravel-20/">Laravel中的”服务提供者”</a>中聊过的, 使用<code>服务提供者</code>一个比较重要的原因就是因为在服务提供者中进行绑定时, 可以对 <code>类与抽象</code> 之间进行绑定, 这样, 在做依赖注入的时候, 就可以对抽象进行依赖, 而不是依赖具体的自定义服务类;</li><li>而你的类如果没有基于任何接口, 自然也就没必要使用”服务提供者”了, Laravel容器并不需要被告知如何构建该对象，因为它会使用PHP的反射服务自动解析出具体的对象;</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><ol><li>在一个服务提供者中, 可以通过<code>$this-&gt;app</code>变量访问容器<ul><li>然后, 可以使用<code>bind()</code>方法注册一个绑定, 该方法需要两个参数, 第一个参数是我们想要注册的类名或接口名称, 第二个参数是返回类的实例的闭包, 如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public function register()</div><div class="line">&#123;</div><div class="line">    $this-&gt;app-&gt;singleton(&apos;test&apos;, function ($app) &#123;</div><div class="line">        return new TestService();</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- 也可以使用 `singleton()` 方法注册一个`单例绑定`, 它只需要解析一次的类或接口到容器，然后接下来对容器的调用将会返回同一个实例:在上一篇[Laravel中的&quot;服务提供者&quot;](/2018/03/31/Laravel/2018-03-31-Laravel-20/)中进行过测试, 使用`singleton()`方法的话, 在控制器中<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var_dump(app(&apos;test&apos;) === app(&apos;test&apos;)); // true</div></pre></td></tr></table></figure>但是如果使用的是`bind()`, 则是false</code></pre><h3 id="绑定’接口’到’具体实现’"><a href="#绑定’接口’到’具体实现’" class="headerlink" title="绑定’接口’到’具体实现’"></a>绑定’接口’到’具体实现’</h3><ol><li>在绑定的时候需要注意, 只绑定<code>具体服务类</code>到服务容器中的话, 当在其他类中注入这个<code>具体服务类</code>的时候, 依赖的可是个具体, 不是抽象;</li><li>为了可以在构造器或者任何其它, 进行注入依赖的地方可以做 <code>接口的类型</code> 的提示(而不是具体类型的提示), 还需要将<code>接口绑定到实现</code>, 如上一篇中的: <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public function register()</div><div class="line">&#123;</div><div class="line">    // 注意此处进行容器绑定的时候, 直接使用了$this-&gt;app即可获取服务器容器</div><div class="line">    $this-&gt;app-&gt;singleton(&apos;test&apos;, function ($app) &#123;</div><div class="line">        return new TestService();</div><div class="line">    &#125;);</div><div class="line">    // `接口`绑定到`实现`</div><div class="line">    $this-&gt;app-&gt;bind(TestContract::class, function ($app) &#123;</div><div class="line">        return new TestService();</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="多个类使用同一个接口"><a href="#多个类使用同一个接口" class="headerlink" title="多个类使用同一个接口"></a>多个类使用同一个接口</h3><ol><li><p>上面的绑定方式, 虽然在注入的地方可以使用<code>接口类型</code>的提示, 但由于绑定的是接口和某一个具体实现, 所以在注入的时候, 最终注入的还是绑定的那个具体实现</p><ul><li>如果在”服务提供者”中, 将接口绑定到多个具体实现上, 后面的覆盖前面的;</li><li><p>即使不通过依赖, 而是指定具体类, 也无法保证注入的是哪个具体类, 还是会使用”服务提供者”中最后绑定到接口上的具体类,如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public function register()</div><div class="line">&#123;</div><div class="line">    // 注意此处进行容器绑定的时候, 直接使用了$this-&gt;app即可获取服务器容器</div><div class="line">    $this-&gt;app-&gt;singleton(&apos;test&apos;, function ($app) &#123;</div><div class="line">        return new TestService();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    $this-&gt;app-&gt;singleton(&apos;test1&apos;, function ($app) &#123;</div><div class="line">        return new Test1Service();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    // 绑定接口到具体实现</div><div class="line">    $this-&gt;app-&gt;bind(TestContract::class, function ($app) &#123;</div><div class="line">        return new Test1Service();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    // 绑定接口到具体实现</div><div class="line">    $this-&gt;app-&gt;bind(TestContract::class, function ($app) &#123;</div><div class="line">        return new TestService();</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public function test()</div><div class="line">&#123;</div><div class="line">    // 即便此处指明调用Test1Service</div><div class="line">    $this-&gt;testManyBind(app(Test1Service::class));</div><div class="line">&#125;</div><div class="line"></div><div class="line">public function testManyBind(TestContract $testService)</div><div class="line">&#123;</div><div class="line">    // 这里最终调用的还是TestService, 但是如果在&quot;服务提供者中&quot;, 将接口绑定到具体的顺序调换, 则会调用Test1Service</div><div class="line">    $this-&gt;testService-&gt;callMe(&apos;PostControler&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li><li><p>所以, 如果接口有多个具体实现, 而且希望做到根据配置来决定应该给依赖注入哪个具体实现, 该怎么进行绑定呢?</p><ul><li>比如, 根据配置获取具体类(<code>app(&#39;test1&#39;)</code>), 然后传入<code>testManyBind</code>, 并且保证注入的就是test1? 该如何绑定</li><li>再如, 如何在不同的方法自动注入不同的具体实现? 该如何绑定?</li></ul></li></ol><h3 id="上下文绑定"><a href="#上下文绑定" class="headerlink" title="上下文绑定"></a>上下文绑定</h3><ol><li><p>有时侯我们可能有两个类使用同一个接口, 但我们希望在每个类中注入不同实现, 可以如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public function register()</div><div class="line">&#123;</div><div class="line">    // 注意此处进行容器绑定的时候, 直接使用了$this-&gt;app即可获取服务器容器</div><div class="line">    $this-&gt;app-&gt;singleton(&apos;test&apos;, function ($app) &#123;</div><div class="line">        return new TestService();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    $this-&gt;app-&gt;singleton(&apos;test1&apos;, function ($app) &#123;</div><div class="line">        return new Test1Service();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    // 下面的用法, 表示: 当在PostsController类中注入的时候, 使用的就是Test1Service</div><div class="line">    // 即便 `接口绑定的TestService具体实现`在后面, 真正注入的也是Test1Service</div><div class="line">    $this-&gt;app-&gt;when(PostsController::class)</div><div class="line">        -&gt;needs(TestContract::class)</div><div class="line">        -&gt;give(function () &#123;</div><div class="line">            return new Test1Service();</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    // 绑定接口到具体实现</div><div class="line">    $this-&gt;app-&gt;bind(TestContract::class, function ($app) &#123;</div><div class="line">        return new TestService();</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>上面这样, 就可以做到:<br> 比方一个日志记录类, 具体类有: 记录日志到库, 记录日志到文件, 记录日志到memcache;<br> 你就可以在”服务提供者”中将所有的 具体类都绑定到接口, 并且指定将来哪个类去使用哪种记录方式;<br> 当然, 一般都是统一的, 除非有上面这种需求!</p></li></ol><h3 id="设置标签"><a href="#设置标签" class="headerlink" title="设置标签"></a>设置标签</h3><ol><li><p>少数情况下, 你可能需要使用到 <code>某类服务下的多种服务</code>, 即, 可能需要在一个类中使用到同一个接口的多个不同的具体实现;</p><ul><li>此时, 可以在<code>服务提供者</code>中通过<code>tag</code>方法给用到的具体实现都分配一个标签, 然后将多个不同实现通过<code>$app-&gt;tagged(&#39;aggregator&#39;,...)</code>聚合到一个<code>聚合服务中</code>;</li><li>然后可以在某个类(比如controller, repository)中通过<code>app(&#39;aggregator&#39;)</code>来使用聚合的多个具体类; </li><li>也可以直接在通过一个接口下创建一个聚合服务类, 然后将多个具体实现聚合给这个聚合服务类, 然后将聚合服务分配给你所需要的类;</li></ul></li><li><p>例子:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public function register()</div><div class="line">&#123;</div><div class="line">    // TestContract接口下的TestService具体实现</div><div class="line">    $this-&gt;app-&gt;singleton(&apos;test&apos;, function ($app) &#123;</div><div class="line">        return new TestService();</div><div class="line">    &#125;);</div><div class="line">    // TestContract接口下的Test1Service具体实现</div><div class="line">    $this-&gt;app-&gt;singleton(&apos;test1&apos;, function ($app) &#123;</div><div class="line">        return new Test1Service();</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    // 把上面两个具体实现聚合起来, 打上标签&apos;t&apos;</div><div class="line">    $this-&gt;app-&gt;tag([&apos;test&apos;, &apos;test1&apos;], &apos;t&apos;);</div><div class="line">    // 然后把上面两个具体实现聚合到 新的具体实现`AggregatorService`上</div><div class="line">    // 使得被分配的类中可以使用app(&apos;aggregator&apos;)来调取聚合的多个服务</div><div class="line">    $this-&gt;app-&gt;bind(&apos;aggregator&apos;, function ($app) &#123;</div><div class="line">        return new AggregatorService($app-&gt;tagged(&apos;t&apos;));</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    // 最后将具体实现 AggregatorService 绑定到接口 TestContract 上, 并分配给 使用的类(控制器或者repository)</div><div class="line">    $this-&gt;app-&gt;bind(TestContract::class, function ($app) &#123;</div><div class="line">        return new AggregatorService($app-&gt;tagged(&apos;t&apos;));</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 控制器中:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public function __construct(PostsRepository $postsRepository, TestContract $testService)</div><div class="line">&#123;</div><div class="line">    $this-&gt;postsRepository = $postsRepository;</div><div class="line">    $this-&gt;testService = $testService;</div><div class="line">    var_dump($this-&gt;testService-&gt;services);die; // 获取到同一个契约下的两个具体服务了</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="从容器中解析对象"><a href="#从容器中解析对象" class="headerlink" title="从容器中解析对象"></a>从容器中解析对象</h3><ol><li><p>可以使用<code>注入</code>或者<code>app()方法</code>从容器中获取绑定好的对象;</p><ul><li>注意, <code>$this-&gt;app</code> 可以在<code>服务提供者</code>中直接使用, 要在控制器中, 需要使用 <code>app()</code>方法;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 这两种方法都行</div><div class="line">$this-&gt;app-&gt;make(&apos;FooBar&apos;);</div><div class="line">$this-&gt;app[&apos;FooBar&apos;];</div></pre></td></tr></table></figure></li></ul></li><li><p>容器事件: 服务容器在每一次解析对象时都会触发一个事件, 可以使用<code>resolving</code>方法监听该事件, 从而允许你在对象被传递给消费者之前为其设置额外属性</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$this-&gt;app-&gt;resolving(function ($object, $app) &#123;</div><div class="line">    // 容器解析所有类型对象时调用</div><div class="line">&#125;);</div><div class="line"></div><div class="line">$this-&gt;app-&gt;resolving(function (FooBar $fooBar, $app) &#123;</div><div class="line">    // 容器解析“FooBar”对象时调用</div><div class="line">&#125;);</div></pre></td></tr></table></figure></li></ol><p><a href="http://laravelacademy.org/post/93.html" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Laravel服务容器是一个用于管理类依赖和执行依赖注入的强大工具;&lt;/p&gt;
&lt;p&gt;几乎所有的&lt;code&gt;服务容器绑定&lt;/code&gt;都是在&lt;code&gt;服务提供者&lt;/code&gt;中完成; 如果一个类没有基于任何接口那么就没有必要将其绑定到容器, 容器并不需要被告知如何构建对象,
      
    
    </summary>
    
      <category term="Laravel" scheme="http://blog.renyimin.com/categories/Laravel/"/>
    
    
      <category term="Laravel" scheme="http://blog.renyimin.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>20. Laravel中的&quot;服务提供者&quot;</title>
    <link href="http://blog.renyimin.com/2018/03/31/Laravel/2018-03-31-Laravel-20/"/>
    <id>http://blog.renyimin.com/2018/03/31/Laravel/2018-03-31-Laravel-20/</id>
    <published>2018-03-31T02:51:28.000Z</published>
    <updated>2018-03-31T12:37:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>一开始通过手册了解Laravel中的服务提供者时, 以为要想在类中(比如控制器)注入自己的<code>服务类</code>只有使用<code>服务提供者</code>才可以; 但后来发现, 其实即使不使用<code>服务提供者</code>, 只要自己创建好自己的服务目录, 然后定义好自己的服务类, 就可以在类(比如控制器)中进行注入和使用的;</p></li><li><p>既然这样, 那么使用 <code>服务提供者</code> 到底有哪些好处?</p></li></ol><ul><li><p>在注入时, <strong>可以做到对抽象的依赖, 而不是只能依赖具体</strong>, 尽可能做到<code>开闭原则</code>(只用修改配置就可以选择使用的具体服务类)<br><code>服务提供者</code>的一个主要作用就是让你在服务提供者中 将你的服务类绑定到容器, 此时你还可以将<code>类与接口</code>,<code>类与抽象</code>的依赖关系绑定好;<br>如果不绑定<code>类与接口</code>, <code>类与抽象</code>的关系, 当你在注入自定义类时, 你是无法注入<code>接口/抽象</code>的, 也就是无法做到对抽象的依赖, 而只能依赖你具体的类;</p></li><li><p>同时也做到了解耦<br>只用定义好对抽象的依赖, 不用定义对具体的依赖, 也不用直接对类进行实例化;</p></li><li><p>除了通过<code>注入</code>方式来使用类名, 也可以使用<code>app(&#39;test&#39;)</code>来直接得到服务类来使用;<br>  当然, 即使你没有通过服务提供者, 也可以使用<code>app(&#39;test&#39;)</code>来直接得自定义的服务类;<br>  即使不使用<code>服务提供者</code>, 并且也不通过注入的方式来使用服务类, 也别在使用 <code>new</code> 这么老土的实例化方式了, 可以直接通过<code>app()</code>来获取自定义的服务类;</p></li></ul><h2 id="“服务提供者”的使用"><a href="#“服务提供者”的使用" class="headerlink" title="“服务提供者”的使用"></a>“服务提供者”的使用</h2><ol><li><p>定义自己的服务类</p><ul><li>先在<code>App</code>目录下创建<code>Services</code>目录 (用来存放一个个的<code>服务目录</code>)</li><li>在<code>Services</code>目录下创建某个<code>服务目录</code>(比如Test服务)</li><li>在<code>服务目录</code>中先定义<code>契约接口</code> (可以定义<code>Contract</code>目录并在目录中定义接口文件, 也可以直接定义接口文件) </li><li>在<code>服务目录</code>中定义具体服务类</li></ul></li><li><p>编写服务提供者</p><ul><li><code>php artisan make:provider TestServiceProvider</code>在<code>App/Providers</code>下生成响应的服务提供者文件</li><li>在服务提供者文件中的<code>register</code>方法中: 将<code>自定义服务类</code>绑定到容器中, 绑定<code>自定义服务类</code>与<code>接口</code>,<code>抽象</code>之间的关系;</li></ul></li><li><p>注册服务提供者到 <code>config/app.php</code> 中的 <code>providers</code>数组中;</p></li><li><p>可参考 <a href="">github项目中的具体应用</a>;</p></li></ol><h2 id="一些小细节"><a href="#一些小细节" class="headerlink" title="一些小细节"></a>一些小细节</h2><ol><li><p>服务提供者在创建好之后, 除了 <code>register()</code> 还有一个 <code>boot()</code>:</p><ul><li><code>register()</code>方法用于绑定接口和实现, 初始化配置等, 在这个函数中不能保证其它服务已经完全加载完毕; 因此只能用于注册相关的工作, 不能调用其它服务;</li><li>而<code>boot()</code>调用的时候, 所有的服务都已经注册完毕, 可以放心的使用Laravel中注册的对象, 可以调用其它服务;</li></ul></li><li><p>延迟加载服务提供者</p><ul><li><p>如果你的提供者仅仅只是在服务容器中注册绑定, 你可以<code>延迟加载</code>该绑定, 直到注册绑定真的需要时再加载;<br>Laravel编译并保存所有延迟服务提供者提供的服务及服务提供者的类名。然后，只有当你尝试解析其中某个服务时Laravel才会加载其服务提供者。<br>延迟加载这样的一个提供者将会提升应用的性能，因为它不会在每次请求时都从文件系统加载。</p></li><li><p>想要延迟加载一个提供者, 需要设置<code>defer</code>属性为<code>true</code>并定义一个<code>provides</code>方法, 该方法返回该提供者注册的服务容器绑定:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">namespace App\Providers;</div><div class="line"></div><div class="line">use App\Services\Test\TestContract;</div><div class="line">use App\Services\Test\TestService;</div><div class="line">use Illuminate\Support\ServiceProvider;</div><div class="line"></div><div class="line">class TestServiceProvider extends ServiceProvider</div><div class="line">&#123;</div><div class="line"></div><div class="line">    protected $defer = true;</div><div class="line"></div><div class="line">    public function boot()</div><div class="line">    &#123;</div><div class="line">        //</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function register()</div><div class="line">    &#123;</div><div class="line">        // 注意此处进行容器绑定的时候, 直接使用了$this-&gt;app即可获取服务器容器</div><div class="line">        $this-&gt;app-&gt;singleton(&apos;test&apos;, function ($app) &#123;</div><div class="line">            return new TestService();</div><div class="line">        &#125;);</div><div class="line">        // 绑定接口到具体实现</div><div class="line">        $this-&gt;app-&gt;bind(TestContract::class, function ($app) &#123;</div><div class="line">            return new TestService();</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function provides()</div><div class="line">    &#123;</div><div class="line">        return [TestService::class];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li></ol><p><a href="http://laravelacademy.org/post/91.html" target="_blank" rel="external">参考</a><br><a href="http://laravelacademy.org/post/796.html" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一开始通过手册了解Laravel中的服务提供者时, 以为要想在类中(比如控制器)注入自己的&lt;code&gt;服务类&lt;/code&gt;
      
    
    </summary>
    
      <category term="Laravel" scheme="http://blog.renyimin.com/categories/Laravel/"/>
    
    
      <category term="Laravel" scheme="http://blog.renyimin.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>103. 分区管理</title>
    <link href="http://blog.renyimin.com/2018/03/28/mysql/2018-03-28-mysql-103/"/>
    <id>http://blog.renyimin.com/2018/03/28/mysql/2018-03-28-mysql-103/</id>
    <published>2018-03-28T02:41:26.000Z</published>
    <updated>2018-03-28T02:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h2><p>MySQL5.1 提供了许多修改分区表的方式, 添加、删除、重新定义、合并或拆分已经存在的分区是可能的, 所有这些操作都可以通过使用<code>ALTER TABLE</code>命令的分区扩展来实现; 当然, 也有获得分区表和分区信息的方式;</p><h3 id="drop删除分区及数据"><a href="#drop删除分区及数据" class="headerlink" title="drop删除分区及数据"></a>drop删除分区及数据</h3><ol><li><p><code>mysql&gt; alter table user drop partition p4;</code></p></li><li><p><strong>注意</strong>: </p><ul><li><p>只能对每个分区进行删除, 不能针对每个子分区进行删除操作, 删除分区后子分区连同数据一并被删除;</p></li><li><p>删除分区后, 数据也被删除了;</p></li><li><p><strong><code>drop partition</code>删除分区的语法, 只能用于 <code>range/list</code> 分区</strong> (如果用来删除hash分区或者key分区,则会报错)</p></li><li><p>如果要删除 <code>hash/key</code> 分区, 则直接使用下面remove来移除分区即可, 一般也不直接删除数据;</p></li></ul></li></ol><h3 id="remove移除分区"><a href="#remove移除分区" class="headerlink" title="remove移除分区"></a>remove移除分区</h3><ol><li><p>使用remove移除分区, 注意仅仅是移除分区, <strong>并不会删除数据</strong> (和drop PARTITION不一样, 后者会连同数据一起删除)</p></li><li><p><code>ALTER TABLE tablename REMOVE PARTITIONING;</code> 这样就可以将一个原本分区的数据表变成不分区的表</p><ul><li><p>移除分区前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">0B    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p><code>ALTER TABLE</code>user<code>REMOVE PARTITIONING;</code> 移除分区后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user.MYD</div><div class="line">4.0K    user.MYI</div><div class="line">12K    user.frm</div></pre></td></tr></table></figure></li></ul></li><li><p>注意: 该语法是可以适用于 <code>range/list/key/hash</code> 类型的分区的;</p></li></ol><h3 id="创建不同类型分区"><a href="#创建不同类型分区" class="headerlink" title="创建不同类型分区"></a>创建不同类型分区</h3><h3 id="分区创建索引-整表创建索引"><a href="#分区创建索引-整表创建索引" class="headerlink" title="分区创建索引(整表创建索引)"></a>分区创建索引(整表创建索引)</h3><h3 id="新增分区"><a href="#新增分区" class="headerlink" title="新增分区"></a>新增分区</h3><h3 id="新增不同类型分区"><a href="#新增不同类型分区" class="headerlink" title="新增不同类型分区"></a>新增不同类型分区</h3><h3 id="合并分区"><a href="#合并分区" class="headerlink" title="合并分区"></a>合并分区</h3><ol><li><p>原本分区结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">4.0K    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p>合并 p2, p3这两个分区 </p><ul><li>分区并无子分区<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE tb_sub_ev REORGANIZE PARTITION p2,p3 INTO (</div><div class="line">    PARTITION m_p2_p3 VALUES LESS THAN (2000)</div><div class="line">    ( SUBPARTITION n0,</div><div class="line">        SUBPARTITION n1</div><div class="line">    ) </div><div class="line">);</div></pre></td></tr></table></figure></li></ul></li></ol><h3 id="拆分分区"><a href="#拆分分区" class="headerlink" title="拆分分区"></a>拆分分区</h3><h3 id="重新分区"><a href="#重新分区" class="headerlink" title="重新分区"></a>重新分区</h3><h2 id="每日自动新增分区"><a href="#每日自动新增分区" class="headerlink" title="每日自动新增分区"></a>每日自动新增分区</h2><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分区管理&quot;&gt;&lt;a href=&quot;#分区管理&quot; class=&quot;headerlink&quot; title=&quot;分区管理&quot;&gt;&lt;/a&gt;分区管理&lt;/h2&gt;&lt;p&gt;MySQL5.1 提供了许多修改分区表的方式, 添加、删除、重新定义、合并或拆分已经存在的分区是可能的, 所有这些操作都可以
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>102. 分区键, 主键, 唯一索引关系</title>
    <link href="http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-102/"/>
    <id>http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-102/</id>
    <published>2018-03-27T07:46:51.000Z</published>
    <updated>2018-03-28T02:09:40.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>若表有 <code>primary key</code> 或 <code>unique key</code>, 在对表进行分区时, 需要注意: <code>分区键</code> 必须包含在primary key或unique key列内, 这是为了确保主键的效率, 否则同一主键区的数据一个在Ａ分区, 一个在Ｂ分区, 显然会比较麻烦;<br> 可以说: 在分区表上, 用于分区表达式里的每一个字段都必须是<code>唯一性索引</code>的<code>一部分</code>;</p></li><li><p>如何理解上面的概念?</p></li><li><p>如果表中既有<code>主键</code>, 也有<code>唯一索引</code>: 无论<code>单列键</code>还是<code>多列键</code>分区都会失败</p><ul><li><p>单列唯一索引键分区报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `user` (  </div><div class="line">    `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;,  </div><div class="line">    `name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">    `sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男，1为女&apos;,</div><div class="line">`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,</div><div class="line">    PRIMARY KEY (`id`),</div><div class="line">UNIQUE KEY `age_unique` (`age`)</div><div class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8</div><div class="line">PARTITION BY RANGE COLUMNS (`age`)</div><div class="line">(</div><div class="line">PARTITION p0 VALUES LESS THAN (3),  </div><div class="line">PARTITION p1 VALUES LESS THAN (6),</div><div class="line">PARTITION p2 VALUES LESS THAN (9),  </div><div class="line">PARTITION p3 VALUES LESS THAN (12),  </div><div class="line">PARTITION p4 VALUES LESS THAN (MAXVALUE)</div><div class="line">);</div><div class="line">// 1503 - A PRIMARY KEY must include all columns in the table&apos;s partitioning function, Time: 0.011000s</div></pre></td></tr></table></figure></li><li><p>单列主键分区报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>),</p><pre><code>UNIQUE KEY `age_unique` (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);<br>// 1503 - A UNIQUE INDEX must include all columns in the table’s partitioning function, Time: 0.008000s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 多列(主键和唯一索引键)分区报错</div></pre></td></tr></table></figure><p>// 两列做分区也是失败的, 如下会报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>),</p><pre><code>UNIQUE KEY `age_unique` (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>,<code>age</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3, 10),<br>  PARTITION p1 VALUES LESS THAN (6, 15),<br>  PARTITION p2 VALUES LESS THAN (9, 20),<br>  PARTITION p3 VALUES LESS THAN (12, 25),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);<br>// 1503 - A PRIMARY KEY must include all columns in the table’s partitioning function, Time: 0.012000s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">4. 表中只有`主键`: 分区键属于主键内的键即可 (多列分区, 需要将列与主键一起作为主键才行)</div><div class="line">    - 分区键属于主键内的键即可</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 如果想多列分区, 则需要将多余的列与主键一起作为主键</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>, <code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>,<code>age</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3, 10),<br>  PARTITION p1 VALUES LESS THAN (6, 15),<br>  PARTITION p2 VALUES LESS THAN (9, 20),<br>  PARTITION p3 VALUES LESS THAN (12, 25),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">5. 表中只有`唯一索引`: 分区键属于`唯一索引键`内的键即可 (多列分区, 需要将多个列一起作为唯一索引)</div><div class="line">    - 分区键属于`唯一索引键`内的键即可</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  UNIQUE KEY (<code>id</code>, <code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 多列分区报错(竟然是报主键错): 1503 - A PRIMARY KEY must include all columns in the table&apos;s partitioning function, Time: 0.012000s</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br><code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br><code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br><code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,<br>  <code>age</code> int(2) NOT NULL DEFAULT ‘0’ COMMENT ‘年龄’,<br>UNIQUE KEY id_u (<code>id</code>),<br>  UNIQUE KEY age_u (<code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>, <code>age</code>)<br>(<br>PARTITION p0 VALUES LESS THAN (3,10),<br>PARTITION p1 VALUES LESS THAN (6,15),<br>PARTITION p2 VALUES LESS THAN (9,20),<br>PARTITION p3 VALUES LESS THAN (12,25),<br>PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- **多个唯一索引: 无论单列分区还是多列分区, 都会报错**</div></pre></td></tr></table></figure><p>// 单列分区报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  UNIQUE KEY id_u (<code>id</code>),</p><pre><code>UNIQUE KEY age_u (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);<br>```</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li></ul></li></ol><ul><li>要进行分区, 表中不能同时存在<code>主键</code>和<code>唯一索引键</code>, 也不能存在多个唯一索引键;</li><li>分区的键必须包含在<code>主键</code>内 或者 包含在<code>唯一索引键</code>内;</li><li>本篇只是测试了<code>range</code>这种分区类型, 其实上面的限制对于<code>range/list/hash/key</code>类型的分区都适用;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;若表有 &lt;code&gt;primary key&lt;/code&gt; 或 &lt;code&gt;unique key&lt;/code&gt;, 在对表进行分区时, 需要注意: &lt;code&gt;分区键&lt;/code&gt; 必须包含在primary key或unique key列内, 这是为了确保主键
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>101. 分区,分表,分库</title>
    <link href="http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-101/"/>
    <id>http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-101/</id>
    <published>2018-03-27T03:37:12.000Z</published>
    <updated>2018-03-28T02:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>MySQL是从5.1开始支持分区功能的, 在MySQL中, 数据是以文件的形势存在磁盘上的, 默认放在 ‘/mysql/data/‘ 下(可以通过my.cnf中的datadir来指定)</p></li><li><p>MyISAM引擎中, 一张表主要对应着三个文件: </p><ul><li><code>.frm</code>(与表相关的元数据信息都存放在frm文件, 包括表结构的定义信息等)</li><li><code>.myd</code>(存放表数据)</li><li><code>.myi</code>(存表索引)</li></ul></li><li><p>InnoDB引擎中, 一张表也是对应着三个文件: </p><ul><li><code>.frm</code>(和MyISAM差不多)</li><li><code>.ibd</code>文件和<code>.ibdata</code>文件, 都是存放innodb数据的文件, 之所以用两种文件来存放innodb的数据, 是因为innodb的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据, 还是用独享表空间存放存储数据<br>独享表空间存储方式使用.ibd文件,并且每个表一个ibd文件;<br>共享表空间存储方式使用.ibdata文件，所有表共同使用一个ibdata文件<br>可在mysql的配置文件通过<code>innodb_file_per_table</code>进行配置</li></ul></li><li><p>如果一张表的数据量太大, <code>.ibd</code>, <code>.myd</code>, <code>.myi</code> 之类的文件就会变的很大, 查找数据就会变的很慢, 此时就可以利用mysql的分区功能, 在物理上将这一张表对应的三个文件, 分割成许多个小块, 这样之后, 如果查找一条数据时, 就不用全部查找了, 只要知道这条数据在哪一块, 然后在那一块找即可;<br> 如果表的数据太大, 可能一个磁盘放不下, 此时, 还可以把数据分配到不同的磁盘里面去;</p></li></ol><h2 id="查看当前MySQL版本是否支持分区"><a href="#查看当前MySQL版本是否支持分区" class="headerlink" title="查看当前MySQL版本是否支持分区"></a>查看当前MySQL版本是否支持分区</h2><ol><li><p>对于MySQL5.6以下版本, 如果查询结果显示Empty, 表示不支持分区:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show variables like &apos;%partition%&apos;;</div><div class="line">Empty set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>对于mysql5.6以及以上版本, 需要使用下面的查询命令:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show plugins;</div></pre></td></tr></table></figure><p> 上面的查询方法会显示所有插件, 如果有如下插件的话, 表示支持分区:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| partition                  | ACTIVE   | STORAGE ENGINE     | NULL    | GPL     |</div></pre></td></tr></table></figure></li></ol><h2 id="分区的2种方式"><a href="#分区的2种方式" class="headerlink" title="分区的2种方式"></a>分区的2种方式</h2><h3 id="横向分区"><a href="#横向分区" class="headerlink" title="横向分区"></a>横向分区</h3><p>横向分区: 比如, 有1000W条数据, 分成十份, 前10W条数据放到第一个分区, 第二个10W条数据放到第二个分区, 依此类推; </p><ul><li>也就是把表分成了十份(和使用<code>merge</code>来分表有点像, 取出一条数据的时候, 这条数据包含了表结构中的所有字段);</li><li>横向分区, 并没有改变表的结构;</li></ul><h3 id="纵向分区"><a href="#纵向分区" class="headerlink" title="纵向分区"></a>纵向分区</h3><p>纵向分区: 比如, 在设计用户表的时候, 开始的时候没有考虑好, 把用户的所有信息都放到了一张表里面去, 这样这个表里面就会有比较大的字段, 如个人简介..等, 而这些简介也许不会有好多人去看，所以等到有人要看的时候, 再去查找(分表的时候, 可以把这样的大字段与主表分开来);</p><h2 id="横向分区-1"><a href="#横向分区-1" class="headerlink" title="横向分区"></a>横向分区</h2><p>mysql提供的分区属于第一种 <code>横向分区</code>, 并且细分成很多种方式</p><h3 id="range分区"><a href="#range分区" class="headerlink" title="range分区"></a>range分区</h3><ol><li><p>按照<code>RANGE</code>分区的表是通过如下方式进行分区的, 分区表达式的值位于一个给定的连续区间内的那些行, 会被放到一个分区中</p><ul><li><p>创建表同时进行分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `user` (  </div><div class="line">`id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;,  </div><div class="line">`name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">`sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男，1为女&apos;,  </div><div class="line">PRIMARY KEY (`id`)  </div><div class="line">) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1  </div><div class="line">PARTITION BY RANGE (id) (  </div><div class="line">PARTITION p0 VALUES LESS THAN (3),  </div><div class="line">PARTITION p1 VALUES LESS THAN ( 6 ),</div><div class="line">PARTITION p2 VALUES LESS THAN (9),  </div><div class="line">PARTITION p3 VALUES LESS THAN (12),  </div><div class="line">PARTITION p4 VALUES LESS THAN MAXVALUE  </div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>查看分区效果 (到数据表文件的存放处 <code>$ cd /Library/Application\ Support/appsolute/MAMP\ PRO/db/mysql56/</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">0B    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">0B    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">0B    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">0B    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">0B    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p>插入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">INSERT INTO `test`.`user` (`name` ,`sex`)VALUES (&apos;tank&apos;, &apos;0&apos;)  </div><div class="line">,(&apos;zhang&apos;,1),(&apos;ying&apos;,1),(&apos;张&apos;,1),(&apos;映&apos;,0),(&apos;test1&apos;,1),(&apos;tank2&apos;,1)  </div><div class="line">,(&apos;tank1&apos;,1),(&apos;test2&apos;,1),(&apos;test3&apos;,1),(&apos;test4&apos;,1),(&apos;test5&apos;,1),(&apos;tank3&apos;,1)  </div><div class="line">,(&apos;tank4&apos;,1),(&apos;tank5&apos;,1),(&apos;tank6&apos;,1),(&apos;tank7&apos;,1),(&apos;tank8&apos;,1),(&apos;tank9&apos;,1)  </div><div class="line">,(&apos;tank10&apos;,1),(&apos;tank11&apos;,1),(&apos;tank12&apos;,1),(&apos;tank13&apos;,1),(&apos;tank21&apos;,1),(&apos;tank42&apos;,1);</div></pre></td></tr></table></figure></li><li><p>再次查看分区效果<br>如下可以看到, 文件大小都是4.0K, 从这儿我们可以看出<strong>MyISAM引擎下, 分区的最小区块是4K (InnoDB貌似是96k)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">4.0K    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li></ul></li><li><p>数据测试</p><ul><li><p>初始数据为25条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select count(id) as count from user;</div><div class="line">+-------+</div><div class="line">| count |</div><div class="line">+-------+</div><div class="line">|    25 |</div><div class="line">+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>删除第四个分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; alter table user drop partition p4; </div><div class="line">Query OK, 0 rows affected (0.15 sec)</div><div class="line">Records: 0  Duplicates: 0  Warnings: 0</div></pre></td></tr></table></figure></li><li><p>可以发现, 存放在第四个分区里面的14条数据丢失了, 剩下的3个分区只有11条数据  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select count(id) as count from user; </div><div class="line">+-------+</div><div class="line">| count |</div><div class="line">+-------+</div><div class="line">|    11 |</div><div class="line">+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>查看分区文件, 发现第四个分区确实被删除了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li></ul></li><li><p>小结: 可以发现, 在进行range分区后</p><ul><li>会生成一个 <code>.par</code>文件,用来存储分区信息;</li><li>MyISAM/InnoDB引擎, 原有的 <code>.frm</code> 表结构文件没有被分隔;</li><li>MyISAM引擎, 原有的 <code>.MYD</code>数据文件, <code>.MYI</code>索引文件都被分隔了;</li><li>InnoDB引擎, 原有的 <code>.idb</code>数据文件被分隔了;</li></ul></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li></ul></li></ol><h3 id="List分区"><a href="#List分区" class="headerlink" title="List分区"></a>List分区</h3><ol><li><p>RANGE分区是从属于一个连续区间值的集合, 而LIST分区是基于某列的值从属于一个值列表集中的一个值</p></li><li><p>如果不用主键, 如下list分区可以创建成功，一般情况下, 一张表肯定会有一个主键(所以如果需要用其他键来做分区, 参考下一篇博文<a href="2017/12/17/mysql/2017-12-17-mysql-102/">分区键, 主键, 唯一索引关系</a>)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `list_part` (  </div><div class="line">`id` int(11) NOT NULL COMMENT &apos;用户ID&apos;,  </div><div class="line">`province_id` int(2) NOT NULL DEFAULT 0 COMMENT &apos;省&apos;,  </div><div class="line">`name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">`sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男, 1为女&apos;</div><div class="line">) ENGINE=INNODB DEFAULT CHARSET=utf8</div><div class="line">PARTITION BY LIST (province_id) (  </div><div class="line">PARTITION p0 VALUES IN (1,2,3,4,5,6,7,8),  </div><div class="line">PARTITION p1 VALUES IN (9,10,11,12,16,21),  </div><div class="line">PARTITION p2 VALUES IN (13,14,15,19),  </div><div class="line">PARTITION p3 VALUES IN (17,18,20,22,23,24)</div><div class="line">);</div><div class="line"></div><div class="line">// 创建成功, 会看到分区效果 (InnoDB默认分区最小是96k)</div><div class="line">$ ls |grep list_part |xargs du -sh</div><div class="line">96K    list_part#P#p0.ibd</div><div class="line">96K    list_part#P#p1.ibd</div><div class="line">96K    list_part#P#p2.ibd</div><div class="line">96K    list_part#P#p3.ibd</div><div class="line">12K    list_part.frm</div><div class="line">4.0K    list_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="hash分区"><a href="#hash分区" class="headerlink" title="hash分区"></a>hash分区</h3><ol><li><p>HASH分区主要用来确保数据在预先确定数目的分区中平均分布, 你所要做的只是</p><ul><li>对将要被哈希的列值, 指定一个列值或表达式;</li><li>指定被分区的表将要被分割成的分区数量;</li><li>对HASH分区，使用的用户函数必须返回一个大于0的整数值;</li></ul></li><li><p>创建表同时进行hash分区</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `hash_part` (  </div><div class="line">`id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;评论ID&apos;,  </div><div class="line">`comment` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;评论&apos;,  </div><div class="line">`ip` varchar(25) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;来源IP&apos;,  </div><div class="line">PRIMARY KEY (`id`)  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1  </div><div class="line">PARTITION BY HASH(id)  </div><div class="line">PARTITIONS 3;</div></pre></td></tr></table></figure></li><li><p>查看分区效果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ls |grep hash_part |xargs du -sh</div><div class="line">96K    hash_part#P#p0.ibd</div><div class="line">96K    hash_part#P#p1.ibd</div><div class="line">96K    hash_part#P#p2.ibd</div><div class="line">12K    hash_part.frm</div><div class="line">4.0K    hash_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="key分区"><a href="#key分区" class="headerlink" title="key分区"></a>key分区</h3><ol><li><p>按照KEY进行分区, 类似于按照HASH分区</p><ul><li>HASH分区是使用用户定义的表达式</li><li>而KEY分区的哈希函数是由MySQL服务器提供</li></ul></li><li><p>创建表同时进行key分区</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `key_part` (  </div><div class="line">`news_id` int(11) NOT NULL  COMMENT &apos;新闻ID&apos;,  </div><div class="line">`content` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;新闻内容&apos;,  </div><div class="line">`u_id` varchar(25) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;来源IP&apos;,  </div><div class="line">`create_time` DATE NOT NULL DEFAULT &apos;0000-00-00 00:00:00&apos; COMMENT &apos;时间&apos;  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8  </div><div class="line">PARTITION BY LINEAR HASH(YEAR(create_time))  </div><div class="line">PARTITIONS 3;</div></pre></td></tr></table></figure></li><li><p>查看分区效果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ls |grep key_part |xargs du -sh</div><div class="line">96Kkey_part#P#p0.ibd</div><div class="line">96Kkey_part#P#p1.ibd</div><div class="line">96Kkey_part#P#p2.ibd</div><div class="line">12Kkey_part.frm</div><div class="line">4.0Kkey_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h3><ol><li><p>子分区是分区表中每个分区的再次分割, 对于已经通过<code>RANGE</code>或<code>LIST</code>分区了的表再进行子分区是可能的, 子分区既可以使用<code>HASH</code>分区, 也可以使用<code>KEY</code>分区; 这也被称为复合分区(composite partitioning)</p><ul><li>如果一个分区中创建了子分区, 其他分区也要有子分区</li><li>如果创建了子分区, 每个分区中的<strong>子分区数必须相同</strong></li><li>同一分区内的子分区, 名字不相同, 不同分区内的子分区名子可以相同(5.1.50不适用)</li></ul></li><li><p>创建表同时, 进行子分区操作</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `sub_part` (  </div><div class="line">`news_id` int(11) NOT NULL  COMMENT &apos;新闻ID&apos;,  </div><div class="line">`content` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;新闻内容&apos;,  </div><div class="line">`u_id`  int(11) NOT NULL DEFAULT 0 COMMENT &apos;来源IP&apos;,  </div><div class="line">`create_time` DATE NOT NULL DEFAULT &apos;0000-00-00 00:00:00&apos; COMMENT &apos;时间&apos;  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8  </div><div class="line">PARTITION BY RANGE(YEAR(create_time))  </div><div class="line">SUBPARTITION BY HASH(TO_DAYS(create_time))(  </div><div class="line">    PARTITION p0 VALUES LESS THAN (1990)(</div><div class="line">        SUBPARTITION s0,SUBPARTITION s1,SUBPARTITION s2</div><div class="line">    ),  </div><div class="line">    PARTITION p1 VALUES LESS THAN (2000)(</div><div class="line">        SUBPARTITION s3,SUBPARTITION s4,SUBPARTITION good</div><div class="line">    ),  </div><div class="line">    PARTITION p2 VALUES LESS THAN MAXVALUE(</div><div class="line">        SUBPARTITION tank0,SUBPARTITION tank1,SUBPARTITION tank3</div><div class="line">    )  </div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>查看分区后, 数据表文件结构</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ ls |grep sub_part |xargs du -sh</div><div class="line">96K    sub_part#P#p0#SP#s0.ibd</div><div class="line">96K    sub_part#P#p0#SP#s1.ibd</div><div class="line">96K    sub_part#P#p0#SP#s2.ibd</div><div class="line">96K    sub_part#P#p1#SP#good.ibd</div><div class="line">96K    sub_part#P#p1#SP#s3.ibd</div><div class="line">96K    sub_part#P#p1#SP#s4.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank0.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank1.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank3.ibd</div><div class="line">12K    sub_part.frm</div><div class="line">4.0K    sub_part.par</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;MySQL是从5.1开始支持分区功能的, 在MySQL中, 数据是以文件的形势存在磁盘上的, 默认放在 ‘/mysql/d
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>yield 协程</title>
    <link href="http://blog.renyimin.com/2018/01/13/PHP/2018-01-13-yield/"/>
    <id>http://blog.renyimin.com/2018/01/13/PHP/2018-01-13-yield/</id>
    <published>2018-01-13T05:20:31.000Z</published>
    <updated>2018-04-04T09:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h2 id="迭代生成器"><a href="#迭代生成器" class="headerlink" title="迭代生成器"></a>迭代生成器</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li><p>(迭代)生成器也是一个函数, 返回的是一个<code>迭代器</code>, 而这个<code>迭代器</code>实现了<code>Iterator接口</code>, 所以叫<code>迭代生成器</code>;</p></li><li><p>和普通函数不同, 由于(迭代)生成器返回的是一个迭代器, 所以(迭代)生成器函数中的返回值可以依次返回, 而不是只返回一个单独的值; 或者换句话说, (迭代)生成器使你能更方便的实现了迭代器接口;</p></li><li><p>引用网上常见的示例</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">function xrange($start, $end, $step = 1) &#123;</div><div class="line">    for ($i = $start; $i &lt;= $end; $i += $step) &#123;</div><div class="line">        yield $i;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// var_dump(xrange(1, 1000000));   // object(Generator)[1]</div><div class="line">foreach (xrange(1, 1000000) as $num) &#123;</div><div class="line">    echo $num;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>上面这个 xrange() 函数提供了和PHP的内建函数range()一样的功能, 但是不同的是range()函数返回的是一个包含值从1到100万0的数组; <strong>而xrange()函数返回的是依次输出这些值的一个迭代器, 而不会真正以数组形式返回</strong>;</p><ul><li>这种方法的优点是显而易见的, 它可以让你在处理大数据集合的时候不用一次性的加载到内存中, 甚至你可以处理无限大的数据流;</li><li>当然, 也可以不通过生成器来实现这个功能, 而是可以通过继承Iterator接口实现, 但通过使用生成器实现起来会更方便, 不用再去实现iterator接口中的5个方法了;</li></ul></li></ol><h3 id="生成器内部"><a href="#生成器内部" class="headerlink" title="生成器内部"></a>生成器内部</h3><ol><li><p>要从<code>生成器</code>认识<code>协程</code>, 理解它内部是如何工作是非常重要的: 生成器是一种可中断的函数, 在它里面的<code>yield</code>构成了中断点;<br> 像上面的例子, 调用xrange(1,1000000)的时候, xrange()函数里代码其实并没有真正地运行, 它只是返回了一个迭代器;</p></li><li><p>调用迭代器的方法一次, 其中的代码运行一次, 例如:</p><ul><li>如果你调用生成器返回的迭代器的rewind方法 <code>$range-&gt;rewind()</code>, 那么xrange()里的代码就会运行到控制流第一次出现yield的地方, 而函数内传递给yield语句的返回值, 可以通过$range-&gt;current()获取;</li><li>为了继续执行生成器中yield后的代码, 你就需要调用迭代器的 <code>$range-&gt;next()</code> 方法, 这将再次启动生成器, 直到下一次yield语句出现; 因此, 连续调用next()和current()方法, 你就能从生成器里获得所有的值,直到再没有yield语句出现;</li><li>对xrange()来说, 这种情形出现在$i超过$end时, 在这种情况下, 控制流将到达函数的终点, 因此将不执行任何代码, 一旦这种情况发生, vaild()方法将返回假, 这时迭代结束;</li><li><p>示例1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">function gen() &#123;</div><div class="line">    var_dump(&apos;cat&apos;);</div><div class="line">    yield &apos;t&apos;;</div><div class="line">    var_dump(&apos;dog&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$gen = gen();</div><div class="line">$gen-&gt;rewind();   // 指针会走到第一个yield处, 所以会经过 cat</div><div class="line">var_dump($gen-&gt;current());  // 获取第一个yield处的值</div><div class="line">var_dump(&apos;----------&apos;);</div><div class="line">$gen-&gt;next();  // 会往下走, 走到下一个yield处, 所以会经过 dog</div><div class="line">var_dump($gen-&gt;current());  // 获取下一个yield处的值 (但是后面已经没有yield了, 所以为null)</div><div class="line"></div><div class="line">// 结果:</div><div class="line">string(3) &quot;cat&quot;</div><div class="line">string(1) &quot;t&quot;</div><div class="line">string(10) &quot;----------&quot;</div><div class="line">string(3) &quot;dog&quot;</div><div class="line">NULL</div></pre></td></tr></table></figure></li><li><p>示例2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">function gen() &#123;</div><div class="line">    var_dump(&apos;cat&apos;);</div><div class="line">    yield &apos;t&apos;;</div><div class="line">    var_dump(&apos;dog&apos;);</div><div class="line">    yield &apos;g&apos;;</div><div class="line">    var_dump(&apos;pig&apos;);</div><div class="line">    yield &apos;p&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$gen = gen();</div><div class="line">$gen-&gt;rewind();   // 指针会走到第一个yield处, 所以会经过 cat</div><div class="line">var_dump($gen-&gt;current());  // 获取第一个yield处的值</div><div class="line">var_dump(&apos;----------&apos;);</div><div class="line"></div><div class="line">$gen-&gt;next();  // 会往下走, 走到下一个yield处, 所以会经过 dog</div><div class="line">var_dump($gen-&gt;current());  // 获取下一个yield处的值 (但是后面已经没有yield了, 所以为null)</div><div class="line">var_dump(&apos;----------&apos;);</div><div class="line"></div><div class="line">$gen-&gt;next();  // 会往下走, 走到下一个yield处, 所以会经过 pig</div><div class="line">var_dump($gen-&gt;current());  // 获取下一个yield处的值 (p)</div><div class="line"></div><div class="line">var_dump(&apos;----------&apos;);</div><div class="line">$gen-&gt;next();  // 会往下走, 什么也没有</div><div class="line">var_dump($gen-&gt;current());  // 获取下一个yield处的值 (为null)</div><div class="line"></div><div class="line">// 结果</div><div class="line">string(3) &quot;cat&quot;</div><div class="line">string(1) &quot;t&quot;</div><div class="line">string(10) &quot;----------&quot;</div><div class="line">string(3) &quot;dog&quot;</div><div class="line">string(1) &quot;g&quot;</div><div class="line">string(10) &quot;----------&quot;</div><div class="line">string(3) &quot;pig&quot;</div><div class="line">string(1) &quot;p&quot;</div><div class="line">string(10) &quot;----------&quot;</div><div class="line">NULL</div></pre></td></tr></table></figure></li></ul></li><li><p>上面示例中使用(迭代)生成器时, <code>yield</code> 都只是简单地作为一个<code>语句</code>来使用, 这样只能实现 <strong>生成器到调用者的单向通信</strong>;</p></li></ol><p>迭代器在进行循环(迭代)前, 需要先进行<code>rewind</code>;</p><h3 id="简单理解-协程-Coroutine"><a href="#简单理解-协程-Coroutine" class="headerlink" title="简单理解 协程(Coroutine)"></a>简单理解 <code>协程(Coroutine)</code></h3><ol><li><p>协程的支持是在迭代生成器的基础上, 增加了<strong>调用者可以回送数据给生成器</strong>的功能(调用者发送数据给被调用的生成器函数), <strong>这就把生成器到调用者的单向通信</strong>转变为<strong>两者之间的双向通信</strong>;</p></li><li><p>调用者传递数据给生成器, 是通过迭代器的<code>send()</code>方法实现的; 下面就是一个简单的协程示例, 用来演示这种通信如何运行的</p><ul><li><p>下面例子可以看到在生成器内部, <code>yield</code> 不再是简单的语句, 而是一个可以接收调用者参数并进行赋值的<code>表达式</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">function gen() &#123;</div><div class="line">    var_dump(&apos;cat&apos;);</div><div class="line">    $ret1 = (yield &apos;yield1&apos;);</div><div class="line">    var_dump($ret1 . &apos;dog&apos;);</div><div class="line">    $ret2 = (yield &apos;yield2&apos;);</div><div class="line">    var_dump($ret2 . &apos;pig&apos;);</div><div class="line">&#125;</div><div class="line">$gen = gen();</div><div class="line">$gen-&gt;rewind();     // 指针会走到第一个 yield 处, 所以会经过 cat</div><div class="line">// cat</div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;current());</div><div class="line">// yield1</div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;send(&apos;lala&apos;));   // 如果第一次send之前没有rewind将指针指向第一个yield, 则send会: 自动先进行一次rewind</div><div class="line">                                // 2. 由于指针还在第一个yield处, 此时send传递参数还是传到第一个yield处 (yield &apos;yield1&apos;)</div><div class="line">                                // 3. 执行next 到下一个yield (会经过 $ret.dog )</div><div class="line">                                // 4. 返回next之后的yield值(yield &apos;yield2&apos; )</div><div class="line">// laladog</div><div class="line">// yield2</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;current());      // 到了第二个yield处, 由于没有传递至, 所以可以通过current直接获取 yield &apos;yield2&apos; 传给调用者的 &apos;yield2&apos;</div><div class="line">// yield2</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;send(&apos;haha&apos;));   // 由于指针没变, 还在第二个yield处, 传递了 haha 给生成器</div><div class="line">                                // 然后执行了next 继续往下走, 会经过 var_dump($ret . &apos;pig&apos;);</div><div class="line">                                // 返回next之后的yield值 (已经进行了next, 而之后没有yield了, 所以会返回null)</div><div class="line">// hahapig</div><div class="line">// null</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;current());      // 由于上面已经走了next, 而下面啥都没有了......</div><div class="line">// null</div></pre></td></tr></table></figure></li><li><p>第一次send会默认执行rewind</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">function gen() &#123;</div><div class="line">    var_dump(&apos;cat&apos;);</div><div class="line">    $ret1 = (yield &apos;yield1&apos;);</div><div class="line">    var_dump($ret1 . &apos;dog&apos;);</div><div class="line">    $ret2 = (yield &apos;yield2&apos;);</div><div class="line">    var_dump($ret2 . &apos;pig&apos;);</div><div class="line">&#125;</div><div class="line">$gen = gen();</div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;send(&apos;lala&apos;));   // 如果第一次send之前没有rewind将指针指向第一个yield, 则send会: 自动先进行一次rewind (所以也会经过 cat )</div><div class="line">                                // 2. 由于指针还在第一个yield处, 此时send传递参数还是传到第一个yield处 (yield &apos;yield1&apos;)</div><div class="line">                                // 3. 执行next 到下一个yield (会经过 $ret.dog )</div><div class="line">                                // 4. 返回next之后的yield值(yield &apos;yield2&apos; )</div><div class="line">// cat</div><div class="line">// laladog</div><div class="line">// yield2</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;current());      // 到了第二个yield处, 由于没有传递至, 所以可以通过current直接获取 yield &apos;yield2&apos; 传给调用者的 &apos;yield2&apos;</div><div class="line">// yield2</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;send(&apos;haha&apos;));   // 由于指针没变, 还在第二个yield处, 传递了 haha 给生成器</div><div class="line">                                // 然后执行了next 继续往下走, 会经过 var_dump($ret . &apos;pig&apos;);</div><div class="line">                                // 返回next之后的yield值 (已经进行了next, 而之后没有yield了, 所以会返回null)</div><div class="line">// hahapig</div><div class="line">// null</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;current());      // 由于上面已经走了next, 而下面啥都没有了......</div><div class="line">// null</div><div class="line"></div><div class="line">//function foo() &#123;</div><div class="line">//    $string = yield;</div><div class="line">//    echo $string;</div><div class="line">//    for ($i = 1; $i &lt;= 3; $i++) &#123;</div><div class="line">//        yield $i;</div><div class="line">//    &#125;</div><div class="line">//&#125;</div><div class="line">//</div><div class="line">//$generator = foo();</div><div class="line">//$generator-&gt;send(&apos;Hello world!&apos;);</div><div class="line">//foreach ($generator as $value) echo &quot;$value\n&quot;;</div></pre></td></tr></table></figure></li></ul></li><li><p>更多小例子 (<a href="http://php.net/manual/zh/generator.send.php" target="_blank" rel="external">可参考PHP手册</a>)</p><ul><li><p>可以迭代三次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">function printer() &#123;</div><div class="line">    $i = 3;</div><div class="line">    while ($i&gt;0) &#123;</div><div class="line">        echo 33;</div><div class="line">        $string = yield;</div><div class="line">        echo $string;</div><div class="line">        $i--;</div><div class="line">        echo $i;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$printer = printer();</div><div class="line">$printer-&gt;send(&apos;Hello world!&apos;);</div><div class="line">echo &quot;&lt;br/&gt;++++++++++&lt;br/&gt;&quot;;</div><div class="line">$printer-&gt;send(&apos;haha&apos;);</div><div class="line">echo &quot;&lt;br/&gt;++++++++++&lt;br/&gt;&quot;;</div><div class="line">$printer-&gt;send(&apos;heihei&apos;);</div></pre></td></tr></table></figure></li><li><p>可以一直迭代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">function printer() &#123;</div><div class="line">    while (true) &#123;</div><div class="line">        echo 33;</div><div class="line">        $string = yield;</div><div class="line">        echo $string;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$printer = printer();</div><div class="line">$printer-&gt;send(&apos;Hello world!&apos;);</div><div class="line">echo &quot;&lt;br/&gt;++++++++++&lt;br/&gt;&quot;;</div><div class="line">$printer-&gt;send(&apos;haha&apos;);</div><div class="line">echo &quot;&lt;br/&gt;++++++++++&lt;br/&gt;&quot;;</div><div class="line">$printer-&gt;send(&apos;heihei&apos;);</div><div class="line">echo &quot;&lt;br/&gt;++++++++++&lt;br/&gt;&quot;;</div><div class="line">$printer-&gt;send(&apos;heihei2&apos;);</div></pre></td></tr></table></figure></li></ul></li><li><p>个人感觉重点在于理解调用者发出<code>send()</code>后, <code>send()</code>的执行包括<code>next()</code>及<code>返回</code> (以及, 如果是初次执行send的话, 会隐式执行<code>rewind</code>); </p><ul><li>也可以参考<a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="external">鸟哥博客对send的说明</a><br><img src="/img/PHP/yield-send.png" width="400/"></li></ul></li></ol><h2 id="协程实现任务调度"><a href="#协程实现任务调度" class="headerlink" title="协程实现任务调度"></a>协程实现<code>任务调度</code></h2><ol><li><p>上面的例子比较简单, 可能无法体系会到协程的优点, 接下来可以尝试利用<code>协程</code>去实现<code>多任务调度</code></p><ul><li>要解决的问题是当你想并发地运行多任务(或者”程序”)时, 我们都知道CPU在一个时刻只能运行一个任务(不考虑多核的情况), 因此处理器需要在不同的任务之间进行切换, 而且总是让每个任务<code>运行一小会儿</code>;</li><li>多任务协作这个术语中的<code>协作</code>很好的说明了如何进行这种切换的: 它要求当前正在运行的任务<strong>自动</strong>把控制传回给调度器, 这样就可以运行其他任务了;<br>这与<code>抢占多任务</code>相反, 抢占多任务是这样的: 调度器可以中断运行了一段时间的任务, 不管它喜欢还是不喜欢;<br>协作多任务在Windows的早期版本(windows95)和Mac OS中有使用, 不过它们后来都切换到使用抢先多任务了, <strong>理由相当明确</strong>: 如果你依靠程序自动交出控制的话, <strong>那么一些恶意的程序将很容易占用整个CPU, 不与其他任务共享</strong>;</li></ul></li><li><p>现在你应当明白协程和任务调度之间的关系: </p><ul><li>yield指令提供了任务中断自身的一种方法, 然后把控制交回给任务调度器;</li><li><p>因此协程可以运行多个其他任务, 更进一步来说, <code>yield</code>可以用来在<code>任务</code>和<code>调度器</code>之间进行通信;</p><p>手册中这个例子有空可以稍稍微品味一下: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">function nums() &#123;</div><div class="line">    for ($i = 0; $i &lt; 5; ++$i) &#123;</div><div class="line">        //get a value from the caller</div><div class="line">        $cmd = (yield $i);</div><div class="line"></div><div class="line">        if($cmd == &apos;stop&apos;) return;//exit the function</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$gen = nums();</div><div class="line">foreach($gen as $v)</div><div class="line">&#123;</div><div class="line">    if($v == 3)//we are satisfied</div><div class="line">        $gen-&gt;send(&apos;stop&apos;);</div><div class="line"></div><div class="line">    echo &quot;&#123;$v&#125;\n&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li><li><p>多任务调度的实现</p><ul><li><p>两个使用协程函数的任务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function task1() &#123;</div><div class="line">    for ($i = 1; $i &lt;= 10; ++$i) &#123;</div><div class="line">        echo &quot;This is task 1 iteration $i.\n&quot;;</div><div class="line">        yield;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function task2() &#123;</div><div class="line">    for ($i = 1; $i &lt;= 5; ++$i) &#123;</div><div class="line">        echo &quot;This is task 2 iteration $i.\n&quot;;</div><div class="line">        yield;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Task任务类包装 任务协程函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">/**</div><div class="line"> * 如代码, 一个任务就是用任务ID标记的一个协程(函数).</div><div class="line"> * 使用setSendValue()方法, 你可以指定哪些值将被发送到下次的恢复(在之后你会了解到我们需要这个),</div><div class="line"> * run()函数确实没有做什么, 除了调用send()方法的协同程序</div><div class="line"> * 要理解为什么添加了一个 beforeFirstYieldflag变量</div><div class="line"> */</div><div class="line">class Task &#123;</div><div class="line">    protected $taskId;</div><div class="line">    protected $coroutine;</div><div class="line">    protected $sendValue = null;</div><div class="line">    protected $beforeFirstYield = true;</div><div class="line"></div><div class="line">    public function __construct($taskId, Generator $coroutine) &#123;</div><div class="line">        $this-&gt;taskId = $taskId;</div><div class="line">        $this-&gt;coroutine = $coroutine;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function getTaskId() &#123;</div><div class="line">        return $this-&gt;taskId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//    public function setSendValue($sendValue) &#123;</div><div class="line">//        $this-&gt;sendValue = $sendValue;</div><div class="line">//    &#125;</div><div class="line"></div><div class="line">    public function run() &#123;</div><div class="line">        // 由于send的特性, 会导致先next, 所以下面在设置了一个初始标志beforeFirstYield, 初始时, 先获取了current</div><div class="line">        if ($this-&gt;beforeFirstYield) &#123;</div><div class="line">            $this-&gt;beforeFirstYield = false;</div><div class="line">            return $this-&gt;coroutine-&gt;current();</div><div class="line">        &#125; else &#123;</div><div class="line">            // 注意: 执行send之后会返回next之后的yield值</div><div class="line">            $retval = $this-&gt;coroutine-&gt;send(&apos;目前还没用到双向通信&apos;);</div><div class="line">            return $retval;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function isFinished() &#123;</div><div class="line">        return !$this-&gt;coroutine-&gt;valid();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>实现Scheduler调度器类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Scheduler &#123;</div><div class="line">    protected $maxTaskId = 0;</div><div class="line">    protected $taskMap = []; // taskId =&gt; task</div><div class="line">    protected $taskQueue;</div><div class="line"></div><div class="line">    public function __construct() &#123;</div><div class="line">        $this-&gt;taskQueue = new SplQueue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function newTask(Generator $coroutine) &#123;</div><div class="line">        // 生成任务id</div><div class="line">        $tid = ++$this-&gt;maxTaskId;</div><div class="line">        // 将协程函数封包到Task类中 作为任务</div><div class="line">        $task = new Task($tid, $coroutine);</div><div class="line">        // 放入调度器的任务池中</div><div class="line">        $this-&gt;taskMap[$tid] = $task;</div><div class="line">        // 将任务放入调度器的队列中</div><div class="line">        $this-&gt;schedule($task);</div><div class="line">        return $tid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function schedule(Task $task) &#123;</div><div class="line">        $this-&gt;taskQueue-&gt;enqueue($task);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function run() &#123;</div><div class="line">        while (!$this-&gt;taskQueue-&gt;isEmpty()) &#123;</div><div class="line">            // 从调度器队列中弹出任务, 准备执行</div><div class="line">            $task = $this-&gt;taskQueue-&gt;dequeue();</div><div class="line">            // 执行任务</div><div class="line">            $task-&gt;run();</div><div class="line"></div><div class="line">            // 如果任务执行完毕, 则从调度器的任务池中清除任务</div><div class="line">            if ($task-&gt;isFinished()) &#123;</div><div class="line">                unset($this-&gt;taskMap[$task-&gt;getTaskId()]);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 否则, 再次将弹出的任务放入调度器的任务队列中</div><div class="line">                $this-&gt;schedule($task);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>测试 test.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">require_once &apos;Task.php&apos;;</div><div class="line">require_once &apos;Scheduler.php&apos;;</div><div class="line"></div><div class="line">function task1() &#123;</div><div class="line">    for ($i = 1; $i &lt;= 10; ++$i) &#123;</div><div class="line">        echo &quot;This is task 1 iteration $i.\n&quot;;</div><div class="line">        yield;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function task2() &#123;</div><div class="line">    for ($i = 1; $i &lt;= 5; ++$i) &#123;</div><div class="line">        echo &quot;This is task 2 iteration $i.\n&quot;;</div><div class="line">        yield;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$scheduler = new Scheduler;</div><div class="line">$scheduler-&gt;newTask(task1());</div><div class="line">$scheduler-&gt;newTask(task2());</div><div class="line">$scheduler-&gt;run();</div></pre></td></tr></table></figure></li></ul></li><li><p>当然, 上面是具有两个简单任务(没什么意义的任务)的调度器;</p></li></ol><h2 id="任务和调度器之间的通信"><a href="#任务和调度器之间的通信" class="headerlink" title="任务和调度器之间的通信"></a>任务和调度器之间的通信</h2><ol><li><p>上面可以看到, 调度器已经运行了, 那么我们来看下一个问题: <strong>任务和调度器之间的通信</strong>;</p></li><li><p>接下来将模拟 进程和操作系统进行会话时的方式 – <code>系统调用</code>, 来做任务和调度器之间的通信<br>我们需要<code>系统调用</code>的理由是操作系统与进程相比它处在不同的权限级别上, 因此为了执行特权级别的操作(如杀死另一个进程), 就不得不以某种方式把控制传回给内核, 这样内核就可以执行所说的操作了;<br> 再说一遍, 这种行为在内部是通过使用<code>中断指令</code>来实现的. 过去使用的是通用的int指令, 如今使用的是更特殊并且更快速的syscall/sysenter指令;</p></li><li><p>我们的任务调度系统将反映这种设计: 不是简单地把调度器传递给任务(这样就允许它做它想做的任何事), 我们将通过给yield表达式传递信息来与系统调用通信, 这儿yield即是中断, 也是传递信息给调度器(和从调度器传递出信息)的方法;</p></li><li><p>为了说明系统调用, 我们对可调用的系统调用做一个小小的封装:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure></li></ol><p>~~未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h2&gt;&lt;h2 id=&quot;迭代生成器&quot;&gt;&lt;a href=&quot;#迭代生成器&quot; class=&quot;headerlink&quot; title=&quot;迭代生成器&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="PHP" scheme="http://blog.renyimin.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.renyimin.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>15.实战compose编排集成环境</title>
    <link href="http://blog.renyimin.com/2017/10/21/docker/2017-10-21-15-docker/"/>
    <id>http://blog.renyimin.com/2017/10/21/docker/2017-10-21-15-docker/</id>
    <published>2017-10-21T03:50:08.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker-Composer编排<code>nginx+phpfpm+mysql+redis+mongo</code>集成环境<br>Github仓库地址:<a href="https://github.com/rymuscle/docker-composer-lnmp" target="_blank" rel="external">https://github.com/rymuscle/docker-composer-lnmp</a></p><h2 id="定义项目目录结构"><a href="#定义项目目录结构" class="headerlink" title="定义项目目录结构"></a>定义项目目录结构</h2><ol><li><p>为了在项目启动后, 能方便地对各项服务服务进行配置, 观察日志, 持久化数据, 并且保证容器不过于臃肿; 我们在项目中的各服务在启动时, 我们就需要将诸如: 服务的<code>配置文件</code>, <code>日志文件</code>, 数据库服务的<code>数据文件目录</code>, Nginx服务的<code>项目目录</code>等从容器的存储层用挂载数据卷的方式持久化出来;</p></li><li><p>要对各服务进行数据挂载, 因此在使用Docker-Composer编排环境项目前, 要先定义好项目的目录结构, 本人目前的目录结构如下 (基本已做到见名知意):</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">├── docker-compose.yml</div><div class="line">├── mongo</div><div class="line">│   ├── Dockerfile</div><div class="line">│   └── data</div><div class="line">├── mysql</div><div class="line">│   ├── Dockerfile</div><div class="line">│   ├── conf</div><div class="line">│   ├── data</div><div class="line">│   ├── env_config.env</div><div class="line">│   └── log</div><div class="line">├── nginx</div><div class="line">│   ├── Dockerfile</div><div class="line">│   ├── conf</div><div class="line">│   └── log</div><div class="line">├── php</div><div class="line">│   ├── php56</div><div class="line">│   │   ├── Dockerfile</div><div class="line">│   │   ├── conf</div><div class="line">│   │   └── log</div><div class="line">│   └── php72</div><div class="line">│       ├── Dockerfile</div><div class="line">│       ├── conf</div><div class="line">│       └── log</div><div class="line">├── redis</div><div class="line">│   ├── Dockerfile</div><div class="line">│   ├── conf</div><div class="line">│   ├── data</div><div class="line">│   └── log</div><div class="line">└── site</div></pre></td></tr></table></figure></li><li><p>目录结构说明</p></li></ol><ul><li>每个服务下面都放置了一份属于容器自己的<code>Dockerfile</code>文件, 方便对容器进行单独定制 (比如php可能需要安装一些扩展, 就可以放在自己的Dockerfile中进行)</li><li>因为挂载会使用 本机文件/目录 覆盖 容器中的目录/文件, 所以<strong>各服务的配置文件需要提前准备好</strong>, 然后挂载到容器服务的对应目录下(可以直接对应文件,也可以对应目录),<ul><li>各容器的配置文件, 日志等的路径, 可以到<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>上参考具体容器的详情</li><li>拿到各容器的中的的配置文件路径后, 需要使用先启动容器, 然后使用 <code>docker cp</code> 将配置文件/目录拷贝到本地</li></ul></li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在挂载项目根目录<code>site</code>时需要注意, 由于nginx和php-fpm为各自独立的服务(分布式部署方式), 所以</p><ul><li>本机<code>site</code>目录挂载到nginx容器中的项目目录 和 本机<code>site</code>目录挂载到php-fpm容器中的项目目录应该一样, 比如都是 <code>./site:/www</code></li><li>在nginx配置时稍加注意, php-fpm才可以正确找到项目路径</li></ul><h2 id="准备各容器镜像"><a href="#准备各容器镜像" class="headerlink" title="准备各容器镜像"></a>准备各容器镜像</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">renyimindembp:php56 renyimin$ docker pull nginx:1.12.2</div><div class="line">renyimindembp:php56 renyimin$ docker pull mongo:3.2</div><div class="line">renyimindembp:php56 renyimin$ docker pull redis:3.2</div><div class="line">renyimindembp:php56 renyimin$ docker pull mysql:5.6</div><div class="line">renyimindembp:php56 renyimin$ docker pull php:5.6-fpm</div><div class="line">renyimindembp:php56 renyimin$ docker pull php:7.2-fpm</div><div class="line">renyimindembp:php56 renyimin$ docker images</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">mysql                                                 5.6                 0248eeb807c7        4 days ago          256MB</div><div class="line">nginx                                                 1.12.2              a810e4ccb26c        2 weeks ago         108MB</div><div class="line">php                                                   5.6-fpm             aaf299648ff3        2 weeks ago         367MB</div><div class="line">php                                                   7.2-fpm             60245f64ed12        2 weeks ago         367MB</div><div class="line">redis                                                 3.2                 3859b0a6622a        2 weeks ago         99.7MB</div><div class="line">mongo                                                 3.2                 56d7fa068c3d        2 weeks ago         300MB</div></pre></td></tr></table></figure></code></pre><h2 id="从容器中获取配置文件"><a href="#从容器中获取配置文件" class="headerlink" title="从容器中获取配置文件"></a>从容器中获取配置文件</h2><h3 id="启动上面所有容器"><a href="#启动上面所有容器" class="headerlink" title="启动上面所有容器"></a>启动上面所有容器</h3><p>容器的启动方式最好也参考一下<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>上相关资料 (比如mysql在启动时就需要<code>-e</code>设置环境变量来提供root用户密码)</p><ol><li><p>nginx 容器启动: <code>$ docker run -d --name nginx nginx:1.12.2</code></p></li><li><p>mysql 容器启动: <code>$ docker run --name mysql -e MYSQL_ROOT_PASSWORD=renyimin -d mysql:5.6</code></p></li><li><p>php:fpm5.6容器的启动: <code>docker run -d --name php-5.6-fpm php:5.6-fpm</code> 即可启动</p></li><li><p>php:fpm7.2容器的启动: <code>docker run -d --name php-7.2-fpm php:7.2-fpm</code> 即可启动</p></li><li><p>mongo容器的启动: <code>docker run -d --name mg mongo:3.2</code></p></li><li><p>redis容器的启动: <code>docker run -d --name redis redis:3.2</code></p></li><li><p>结果如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">renyimindembp:php56 renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                                NAMES</div><div class="line">145a629c84be        nginx:1.12.2        &quot;nginx -g &apos;daemon ...&quot;   3 seconds ago        Up 2 seconds        80/tcp                               nginx</div><div class="line">72390d1e2aa1        mysql:5.6           &quot;docker-entrypoint...&quot;   56 seconds ago       Up 56 seconds       3306/tcp                             mysql</div><div class="line">6b5019214fc1        mongo:3.2           &quot;docker-entrypoint...&quot;   About a minute ago   Up About a minute   27017/tcp                            mg</div><div class="line">7524ffe44739        redis:3.2           &quot;docker-entrypoint...&quot;   About a minute ago   Up About a minute   6379/tcp                             redis</div><div class="line">8716df7a08fb        php:7.2-fpm         &quot;docker-php-entryp...&quot;   About an hour ago    Up 27 minutes       9000/tcp                             php-7.2-fpm</div><div class="line">2d2d5bb12a68        php:5.6-fpm         &quot;docker-php-entryp...&quot;   About an hour ago    Up About an hour    9000/tcp                             php-5.6-fpm</div></pre></td></tr></table></figure></li></ol><h3 id="docker-cp-获取配置文件"><a href="#docker-cp-获取配置文件" class="headerlink" title="docker cp 获取配置文件"></a><code>docker cp</code> 获取配置文件</h3><p>各容器的配置文件, 日志等的路径, 可以到<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>上参考具体容器的详情<br>最后需要手动调整一下目录结构即可</p><ol><li><p>nginx</p><ul><li>拷贝nginx默认配置文件到设定的 nginx/conf 目录 :<br><code>docker cp 8d572e88f735:/etc/nginx/ /Users/renyimin/Desktop/docker-compose/nginx/conf/</code></li></ul></li><li><p>mysql</p><ul><li>拷贝mysql默认数据库文件到设定的 mysql/data 目录<br><code>docker cp 72390d1e2aa1:/var/lib/mysql /Users/renyimin/Desktop/docker-compose/mysql/data</code></li><li>拷贝mysql默认配置文件到设定的 mysql/conf 目录<br><code>docker cp 72390d1e2aa1:/etc/mysql/ /Users/renyimin/Desktop/docker-compose/mysql/conf/</code></li></ul></li><li><p>php56</p><ul><li>拷贝php56默认配置文件到设定的 php56/conf 目录<br><code>docker cp 2d2d5bb12a68:/usr/local/etc/php/ /Users/renyimin/Desktop/docker-compose/php/php56/conf/</code><br><code>docker cp 2d2d5bb12a68:/usr/local/etc/php-fpm.d/ /Users/renyimin/Desktop/docker-compose/php/php56/conf/</code></li></ul></li><li><p>php72</p><ul><li>拷贝php72默认配置文件到设定的 php72/conf 目录<br><code>docker cp 8716df7a08fb:/usr/local/etc/php/ /Users/renyimin/Desktop/docker-compose/php/php72/conf/</code><br><code>docker cp 8716df7a08fb:/usr/local/etc/php-fpm.d/ /Users/renyimin/Desktop/docker-compose/php/php72/conf/</code></li></ul></li><li><p>mongo</p><ul><li>拷贝mongo默认数据库文件到设定的 mongo/data 目录 (mongo容器的/data有configdb和db两个目录)<br><code>docker cp 6b5019214fc1:/data/ /Users/renyimin/Desktop/docker-compose/mongo/</code></li></ul></li><li><p>redis</p><ul><li>拷贝redis默认数据库文件到设定的 redis/data 目录<br><code>docker cp 7524ffe44739:/data /Users/renyimin/Desktop/docker-compose/redis/data</code></li><li>拷贝redis默认配置文件到设定的 redis/conf 目录<br><code>docker cp 7524ffe44739:/usr/local/etc/redis/ /Users/renyimin/Desktop/docker-compose/redis/conf/</code></li></ul></li></ol><h2 id="整理各个服务的Dockerfile"><a href="#整理各个服务的Dockerfile" class="headerlink" title="整理各个服务的Dockerfile"></a>整理各个服务的Dockerfile</h2><ol><li>首先, 每个服务的 <code>FROM</code> 和 <code>MAINTAINER</code> 需要写在Dockerfile的开头;</li><li>这里主要定制了php-fpm的 <code>Dockerfile</code>, 安装哪些扩展主要是参考<ul><li><a href="https://hub.docker.com/_/php/" target="_blank" rel="external">Docker Hub</a>上php容器的介绍</li><li><a href="https://github.com/twang2218/docker-lnmp" target="_blank" rel="external">https://github.com/twang2218/docker-lnmp</a></li><li><a href="https://www.awaimai.com/2120.html#53_docker-composeyml" target="_blank" rel="external">歪麦博客</a></li></ul></li><li>最后在Dockerfile中完成对扩展的安装 <ul><li>如何安装扩展可以参考<a href="https://hub.docker.com/_/php/" target="_blank" rel="external">Docker Hub</a> 和 <a href="https://my.oschina.net/antsky/blog/1591418" target="_blank" rel="external">这里</a></li><li><strong>注意如何清理?</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 貌似源码安装的软件需要如下进行清理:</div><div class="line">RUN docker-php-source extract \</div><div class="line">    # 此处开始执行你需要的操作 \</div><div class="line">    &amp;&amp; docker-php-source delete</div></pre></td></tr></table></figure></li></ul></li></ol><ol><li>如果稍后需要安装其他扩展, 在Dockerfile文件中定制即可, 然后 <code>docker-compose up -d --build php(docker-composer.yml中设定的服务名)</code> 重新构建即可 </li></ol><h2 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写docker-compose.yml</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line"></div><div class="line">services:</div><div class="line">  nginx:</div><div class="line">    build:</div><div class="line">      context: ./nginx/</div><div class="line">      dockerfile: Dockerfile</div><div class="line">      #args:</div><div class="line">    ports:</div><div class="line">      - &quot;8090:80&quot;</div><div class="line">    volumes:</div><div class="line">      - ./site/:/www:rw</div><div class="line">      - ./nginx/conf/conf.d:/etc/nginx/conf.d/:ro</div><div class="line">      - ./nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro</div><div class="line">      - ./nginx/log/:/var/log/nginx/:rw</div><div class="line">    depends_on:</div><div class="line">      - php</div><div class="line">    networks:</div><div class="line">      - frontend</div><div class="line">  php:</div><div class="line">    build: ./php/php72/</div><div class="line">    expose:</div><div class="line">      - &quot;9000&quot;</div><div class="line">    volumes:</div><div class="line">      - ./site/:/www:rw</div><div class="line">      - ./php/php72/conf/php/:/usr/local/etc/php/</div><div class="line">      - ./php/php72/conf/php-fpm.d/:/usr/local/etc/php-fpm.d/:rw</div><div class="line">      - ./php/php72/log/php-fpm/:/var/log/:rw</div><div class="line">    depends_on:</div><div class="line">      - mysql</div><div class="line">      - redis</div><div class="line">      - mongo</div><div class="line">    networks:</div><div class="line">      - frontend</div><div class="line">      - backend</div><div class="line"></div><div class="line">  mysql:</div><div class="line">    build: ./mysql/</div><div class="line">    ports:</div><div class="line">      - &quot;3307:3306&quot;</div><div class="line">    volumes:</div><div class="line">      - ./mysql/conf/:/etc/mysql/:rw</div><div class="line">      - ./mysql/data/:/var/lib/mysql/:rw</div><div class="line">      - ./mysql/log/:/var/log/mysql/:rw</div><div class="line">    env_file: ./mysql/env_config.env</div><div class="line">    environment:</div><div class="line">      TZ: &apos;Asia/Shanghai&apos;</div><div class="line">      MYSQL_ROOT_PASSWORD: &quot;renyimin&quot;</div><div class="line">    networks:</div><div class="line">      - backend</div><div class="line"></div><div class="line">  mongo:</div><div class="line">      build: ./mongo/</div><div class="line">      ports:</div><div class="line">        - 27018:27017</div><div class="line">      volumes:</div><div class="line">        - ./mongo/data:/data:rw</div><div class="line">        - ./mongo/data:/var/log/mongodb/:rw</div><div class="line"></div><div class="line">  redis:</div><div class="line">    build: ./redis/</div><div class="line">    volumes:</div><div class="line">      - ./redis/conf/:/usr/local/etc/redis</div><div class="line">      - ./redis/data/:/data:rw</div><div class="line">      - ./redis/log/:/var/log/</div><div class="line">    ports:</div><div class="line">      - &quot;6380:6379&quot;</div><div class="line"></div><div class="line">networks:</div><div class="line">    frontend:</div><div class="line">    backend:</div></pre></td></tr></table></figure></code></pre><h2 id="编排"><a href="#编排" class="headerlink" title="编排"></a>编排</h2><p>编排构建过程可能会有点慢(视网络快慢, 因为需要安装一些php扩展)</p><h2 id="小细节问题"><a href="#小细节问题" class="headerlink" title="小细节问题"></a>小细节问题</h2><ol><li><p>如果修改docker-compose.yml文件中某个容器的配置, 需要如何单独重新构建这个容器?</p><ul><li><code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> , 如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 当docker-compose.yml中nginx服务的相关配置没有改动时</div><div class="line">renyimindembp:docker-compose renyimin$ docker-compose up --no-deps -d nginx</div><div class="line">dockercompose_nginx_1 is up-to-date</div><div class="line"># 当docker-compose.yml中nginx服务的相关配置被改动后</div><div class="line">renyimindembp:docker-compose renyimin$ docker-compose up --no-deps -d nginx</div><div class="line">Recreating dockercompose_nginx_1 ... done</div><div class="line">renyimindembp:docker-compose renyimin$</div></pre></td></tr></table></figure></li></ul></li><li><p>如果修改了某个容器的配置文件, 如何单独重启这个容器? </p><ul><li>注意, 此时<code>docker-compose up --no-deps -d nginx</code>重新构建会发现docker-compose.yml中nginx服务的相关配置并没有改动, 所以不会生效</li><li>此时应该重启这个容器: <code>docker-compose restart nginx</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindembp:docker-compose renyimin$ docker-compose restart nginx</div><div class="line">Restarting dockercompose_nginx_1 ... done</div><div class="line">renyimindembp:docker-compose renyimin$</div></pre></td></tr></table></figure></li></ul></li></ol><ol><li>每次 <code>docker-compose up</code> 会重新构建所有容器<ul><li>但是只构建<code>docker-compose.yml</code>中配置发生变化的容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">renyimindembp:docker-compose renyimin$ docker-compose up -d</div><div class="line">dockercompose_mongo_1 is up-to-date</div><div class="line">dockercompose_redis_1 is up-to-date</div><div class="line">dockercompose_mysql_1 is up-to-date</div><div class="line">dockercompose_php_1 is up-to-date</div><div class="line">dockercompose_nginx_1 is up-to-date</div><div class="line">renyimindembp:docker-compose renyimin$</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="pecl扩展安装问题"><a href="#pecl扩展安装问题" class="headerlink" title="pecl扩展安装问题"></a>pecl扩展安装问题</h2><p>代理问题:  参考<a href="https://www.awaimai.com/2120.html讨论" target="_blank" rel="external">https://www.awaimai.com/2120.html讨论</a><br>未完待续~~ (安装mongo, redis, memcached 扩展)</p><p>参考:<a href="https://yeasy.gitbooks.io/docker_practice/content/compose/commands.html#up" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/compose/commands.html#up</a><br>参考:<a href="https://github.com/twang2218/docker-lnmp" target="_blank" rel="external">https://github.com/twang2218/docker-lnmp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker-Composer编排&lt;code&gt;nginx+phpfpm+mysql+redis+mongo&lt;/code&gt;集成环境&lt;br&gt;Github仓库地址:&lt;a href=&quot;https://github.com/rymuscle/docker-composer-lnmp&quot;
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>14.Compose模板文件</title>
    <link href="http://blog.renyimin.com/2017/10/19/docker/2017-10-19-14-docker/"/>
    <id>http://blog.renyimin.com/2017/10/19/docker/2017-10-19-14-docker/</id>
    <published>2017-10-19T10:50:08.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://yeasy.gitbooks.io/docker_practice/content/compose/compose_file.html" target="_blank" rel="external">docker-compose.yml</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/content/compose/compose_file.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;docker-compose.yml&lt;/
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>13.Compose命令</title>
    <link href="http://blog.renyimin.com/2017/10/19/docker/2017-10-19-13-docker/"/>
    <id>http://blog.renyimin.com/2017/10/19/docker/2017-10-19-13-docker/</id>
    <published>2017-10-19T06:27:53.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Compose命令说明"><a href="#Compose命令说明" class="headerlink" title="Compose命令说明"></a>Compose命令说明</h2><ol><li><p>命令作用的对象: 对于<code>Compose</code>来说, 大部分命令所作用的对象既可以是<code>项目本身</code>, 也可以指定为<code>项目中的服务或者容器</code>。如果没有特别的说明, 命令针对的对象将是项目, 这意味着项目中所有的服务都会受到命令影响。</p></li><li><p>命令格式: </p><ul><li>docker-compose 命令的基本的使用格式是: <code>docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</code></li><li>执行<code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</li></ul></li><li><p>命令选项:</p><ul><li><p><code>-f, --file FILE</code> 指定使用的Compose模板文件,默认为docker-compose.yml, 可以多次指定。</p></li><li><p><code>-p, --project-name NAME</code> 指定项目名称,<strong>默认将使用所在目录名称作为项目名</strong>。</p></li><li><p><code>--x-networking</code> 使用Docker的可拔插网络后端特性</p></li><li><p><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 bridge</p></li><li><p><code>--verbose</code> 输出更多调试信息。</p></li><li><p><code>-v, --version</code> 打印版本并退出。</p></li></ul></li></ol><h2 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h2><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>打印compose的版本信息 <code>docker-compose version</code></p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><p>列出Compose模板文件中包含的镜像 <code>docker-compose images</code></p><h3 id="build"><a href="#build" class="headerlink" title="build ??"></a>build ??</h3><ol><li>构建(重新构建)项目中的服务容器, 格式为 <code>docker-compose build [options] [SERVICE...]</code><ul><li>服务容器一旦构建后, 将会带上一个标记名, 例如对于<code>web项目</code>中的一个<code>db容器</code>, 可能叫web_db</li><li>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务</li></ul></li><li>选项包括：<ul><li><code>--force-rm</code> 删除构建过程中的临时容器</li><li><code>--no-cache</code> 构建镜像过程中不使用 cache(这将加长构建过程)</li><li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li></ul></li></ol><h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><ol><li><p>该命令十分强大, 它将尝试自动完成包括构建镜像, (重新)创建服务, 启动服务, 并关联服务相关容器的一系列操作。</p><ul><li>链接的服务都将会被自动启动, 除非已经处于运行状态; (可以说，大部分时候都可以直接通过该命令来启动一个项目。)</li><li>格式为 docker-compose up [options] [SERVICE…]。</li></ul></li><li><p>默认情况, <code>docker-compose up</code> 启动的容器都在前台, 控制台将会同时打印所有容器的输出信息, 可以很方便进行调试。当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p></li><li><p>如果使用 <code>docker-compose up -d</code>, 将会在后台启动并运行所有的容器, 一般推荐生产环境下使用该选项。</p></li><li><p>默认情况, 如果服务容器已经存在, <code>docker-compose up</code>将会尝试停止容器, 然后重新创建(保持使用 <code>volumes-from</code> 挂载的卷), 以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。<br> 如果用户不希望容器被停止并重新创建, 可以使用 <code>docker-compose up --no-recreate</code>。<br> 这样将只会启动处于停止状态的容器, 而忽略已经运行的服务;</p></li><li><p>如果用户只想重新部署某个服务, 可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务, 启动新服务, 并不会影响到其所依赖的服务。</p></li></ol><h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>打印某个容器端口所映射的公共端口, 格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code></p><ul><li><code>--protocol=proto</code> 指定端口协议, tcp(默认值)或者 udp</li><li><code>--index=index</code> 如果同一服务存在多个容器, 指定命令对象容器的序号(默认为 1)</li></ul><h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>在指定服务上执行一个命令, 格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code></p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>进入指定的容器</p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>通过发送SIGKILL信号来强制停止服务容器, 格式为 <code>docker-compose kill [options] [SERVICE...]</code><br>支持通过 -s 参数来指定发送的信号, 例如, 通过<code>$ docker-compose kill -s SIGINT</code>指令发送SIGINT信号</p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>查看各个服务容器内运行的进程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Compose命令说明&quot;&gt;&lt;a href=&quot;#Compose命令说明&quot; class=&quot;headerlink&quot; title=&quot;Compose命令说明&quot;&gt;&lt;/a&gt;Compose命令说明&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;命令作用的对象: 对于&lt;code&gt;Compose&lt;
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>12.Docker三剑客 之 Compose</title>
    <link href="http://blog.renyimin.com/2017/10/19/docker/2017-10-19-12-docker/"/>
    <id>http://blog.renyimin.com/2017/10/19/docker/2017-10-19-12-docker/</id>
    <published>2017-10-19T03:07:53.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Compose简介"><a href="#Compose简介" class="headerlink" title="Compose简介"></a>Compose简介</h2><ol><li><p><a href="https://github.com/docker/compose" target="_blank" rel="external">Compose 项目</a>是Docker官方的开源项目, 负责快速在集群中部署分布式应用。</p></li><li><p>Compose定位是「定义和运行多个Docker容器的应用(Defining and running multi-container Docker applications)」。</p></li><li><p>通过之前的学习，已经知道使用一个Dockerfile模板文件, 可以让用户很方便的定义一个单独的应用容器。然而, 在日常工作中, 经常会碰到需要多个容器相互配合来完成某项任务的情况。<br> 例如要实现一个Web项目, 除了 <code>Web服务容器</code> 本身, 往往还需要再加上后端的 <code>数据库服务容器</code>，甚至还包括 <code>负载均衡容器</code> 等。</p></li><li><p>Compose 恰好满足了这样的需求, 它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件(YAML格式)来定义 <strong>一组相关联的应用容器</strong> 为一个<strong>项目(project)</strong>。</p></li><li><p>Compose 中有两个重要的概念:</p><ul><li>服务(service): 一个应用容器，实际上可以包括若干运行相同镜像的容器实例。 </li><li>项目(project): 由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li></ul></li><li><p>Compose的默认管理对象是<strong>项目</strong>, 通过子命令对项目中的一组容器进行便捷地生命周期管理。<br>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。   </p></li></ol><h2 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h2><ol><li>Compose 目前支持 Linux、macOS、Windows 10 三大平台。</li><li>Compose 可以通过 Python 的包管理工具 <code>pip</code> 进行安装，也可以直接下载编译好的二进制文件使用，甚至直接运行在 Docker 容器中。</li><li><p>PIP 安装</p><ul><li>这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。</li><li>执行安装命令: <code>pip install -U docker-compose</code></li></ul></li><li><p>安装成功后，可以查看 docker-compose 命令的用法: <code>$ docker-compose -h</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Compose简介&quot;&gt;&lt;a href=&quot;#Compose简介&quot; class=&quot;headerlink&quot; title=&quot;Compose简介&quot;&gt;&lt;/a&gt;Compose简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/docke
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>11.高级网络配置</title>
    <link href="http://blog.renyimin.com/2017/10/19/docker/2017-10-19-11-docker/"/>
    <id>http://blog.renyimin.com/2017/10/19/docker/2017-10-19-11-docker/</id>
    <published>2017-10-19T02:20:31.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker虚拟网络原理"><a href="#Docker虚拟网络原理" class="headerlink" title="Docker虚拟网络原理"></a>Docker虚拟网络原理</h2><ol><li><p>当Docker启动时, 会自动在主机上创建一个<code>docker0虚拟网桥</code>, 实际上是 Linux 的一个 bridge, 可以理解为一个软件交换机。它会在 挂载到它上面的哪些网口 之间转发信息。</p></li><li><p>同时, Docker随机分配一个本地未占用的私有网段中的一个地址给<code>docker0</code>接口, 比如典型的172.17.42.1,掩码为255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段(172.17.0.0/16)的地址。</p></li><li><p>当创建一个Docker容器的时候,同时会创建了一对<code>veth pair</code>接口(当数据包发送到一个接口时, 另外一个接口也可以收到相同的数据包)</p><ul><li>这对接口一端在容器内,即 <code>eth0</code>; </li><li>另一端在本地并被挂载到<code>docker0</code>网桥, 名称以 veth 开头(例如 vethAQI2QT);</li></ul></li><li><p>通过这种方式, 主机可以跟容器通信, 容器之间也可以相互通信, Docker就创建了在主机和所有容器之间一个虚拟共享网络。<br><img src="/img/docker/network.png" width="350/"></p></li></ol><p>接下来的部分将介绍在一些场景中, Docker 所有的网络定制配置, 以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认的网络配置。</p><p>未完待续….</p><p>参考: <a href="https://yeasy.gitbooks.io/docker_practice/content/advanced_network/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/advanced_network/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker虚拟网络原理&quot;&gt;&lt;a href=&quot;#Docker虚拟网络原理&quot; class=&quot;headerlink&quot; title=&quot;Docker虚拟网络原理&quot;&gt;&lt;/a&gt;Docker虚拟网络原理&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当Docker启动时, 会自动在主机上创建
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>10.Docker中的网络功能</title>
    <link href="http://blog.renyimin.com/2017/10/17/docker/2017-10-17-10-docker/"/>
    <id>http://blog.renyimin.com/2017/10/17/docker/2017-10-17-10-docker/</id>
    <published>2017-10-17T10:15:23.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><ol><li><p>容器中可以运行一些网络应用, 要让外部也可以访问这些应用, 可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 8090:80 --name testVip --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div></pre></td></tr></table></figure></li><li><p>使用 <code>docker ps</code> 可以看到本地主机的 8090 被映射到了容器的 80 端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                       NAMES</div><div class="line">27863a3a8f70        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   39 minutes ago      Up 39 minutes       3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   testVip</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure><p>此时访问本机的 8090 端口即可访问容器内 web 应用提供的界面。</p></li></ol><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><ol><li><p>使用 <code>docker port 容器名</code>  来查看当前映射的端口配置, 也可以查看到绑定的地址</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                       NAMES</div><div class="line">27863a3a8f70        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   45 minutes ago      Up 45 minutes       3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   testVip</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker port testVip</div><div class="line">80/tcp -&gt; 0.0.0.0:8090</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></li><li><p>注意:</p><ul><li><code>-p</code> 可以多次使用来绑定多个端口</li><li>容器有自己的内部网络和 ip 地址(使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置)</li></ul></li></ol><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>容器的连接(linking)系统是除了端口映射外, 另一种跟容器中应用交互的方式。该系统会在源和接收容器之间创建一个隧道, 接收容器可以看到源容器指定的信息。<br>相对于端口映射, 这种方式主要用来做内部链接, 不暴露链接接口给外部</p><h3 id="自定义容器命名"><a href="#自定义容器命名" class="headerlink" title="自定义容器命名"></a><strong>自定义容器命名</strong></h3><ol><li>连接系统依据<strong>容器的名称</strong>来执行。因此，首先需要自定义一个好记的容器命名。虽然当创建容器的时候, 系统默认会分配一个名字。</li><li>自定义命名容器有2个好处:<ul><li>自定义的命名，比较好记，比如一个web应用容器我们可以给它起名叫web</li><li>当要连接其他容器时候，可以作为一个有用的参考点，比如连接web容器到db容器</li></ul></li><li>使用 <code>--name</code> 标记可以为容器自定义命名(使用 docker ps 来验证设定的命名)<ul><li>注意:<strong>容器的名称是唯一的</strong>。如果已经命名了一个叫 web 的容器，当你要再次使用 web 这个 名称的时候，需要先用 docker rm 来删除之前创建的同名容器。<h3 id="–rm"><a href="#–rm" class="headerlink" title="–rm"></a>–rm</h3>在执行 <code>docker run</code> 的时候如果添加 <code>--rm</code> 标记，则容器在终止后会立刻删除。注意, <code>--rm</code> 和 <code>-d</code> 参数不能同时使用。</li></ul></li></ol><h2 id="容器互联-1"><a href="#容器互联-1" class="headerlink" title="容器互联"></a>容器互联</h2><p>使用 <code>--link name:alias</code> 参数可以让容器之间安全的进行交互, 其中 <code>name</code> 是要链接的容器的名称, <code>alias</code> 是这个连接的别名;</p><ol><li><p>下面先创建一个新的数据库容器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 3307:3306 --name db --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div><div class="line">fd29cafa699da868a57f559630c6fb7f5dcf30705f884c9fa7feb4a373bba37c</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></li><li><p>然后创建一个新的 web 容器，并将它连接到 db 容器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 8090:80 --name web --link db:db --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div><div class="line">0e20f11d0f57fedb9d5fee96c8d9d56b67a7c62ded101fd92abf12bba04d09e4</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></li><li><p>使用 <code>docker ps</code> 来查看容器的连接</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                                       NAMES</div><div class="line">0e20f11d0f57        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   About a minute ago   Up About a minute   3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   web</div><div class="line">fd29cafa699d        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   About a minute ago   Up About a minute   80/tcp, 15672/tcp, 0.0.0.0:3307-&gt;3306/tcp   db</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure><p> (理论上可以看到自定义命名的容器 db 和 web, db 容器的 names 列有 db 也有 web/db。这表示 web 容器链接到 db 容器，web 容器将被允许访问 db 容器的信息。)<br> 但实际上貌似没有在names列看到有web/db</p></li><li><p>Docker 在两个互联的容器之间创建了一个安全隧道，而且不用映射它们的端口到宿主主机 上。在启动 db 容器的时候可以不用使用 -p 和 -P 标记，从而避免了暴露数据库端口到外部网络上。</p></li><li><p>Docker 通过 2 种方式为容器公开连接信息:</p><ul><li>环境变量</li><li>更新 /etc/hosts 文件</li></ul></li><li><p>使用 <code>env</code> 命令来查看 web 容器的环境变量</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run --rm --name web2 --link db:db vipservice env</div></pre></td></tr></table></figure><p> 更多参考书上…</p></li><li><p>除了环境变量, Docker 还添加 host 信息到父容器的 <code>/etc/hosts</code> 的文件。下面是父容器 web 的 <code>hosts</code> 文件</p><ul><li><p>这里有 2 个 hosts，第一个是 web 容器，web 容器用 id 作为他的主机名，第二个是 db 容器 的 ip 和主机名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                       NAMES</div><div class="line">297c83c40bc4        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   9 minutes ago       Up 8 minutes        3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   web</div><div class="line">46985aa1ab7b        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   9 minutes ago       Up 9 minutes        80/tcp, 15672/tcp, 0.0.0.0:3307-&gt;3306/tcp   db</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker exec -it web /bin/sh</div><div class="line">sh-4.2# cat /etc/hosts</div><div class="line">127.0.0.1localhost</div><div class="line">::1localhost ip6-localhost ip6-loopback</div><div class="line">fe00::0ip6-localnet</div><div class="line">ff00::0ip6-mcastprefix</div><div class="line">ff02::1ip6-allnodes</div><div class="line">ff02::2ip6-allrouters</div><div class="line">172.17.0.2db 46985aa1ab7b</div><div class="line">172.17.0.3297c83c40bc4</div><div class="line">sh-4.2#</div></pre></td></tr></table></figure></li><li><p>可以在 web 容器中安装 ping 命令来测试跟db容器的连通, 用 ping 来测试db容器，它会解析成 172.17.0.2 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sh-4.2# ping db</div><div class="line">PING db (172.17.0.2) 56(84) bytes of data.</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=1 ttl=64 time=0.243 ms</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=2 ttl=64 time=0.330 ms</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=3 ttl=64 time=0.136 ms</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=4 ttl=64 time=0.129 ms</div></pre></td></tr></table></figure></li><li><p>用户可以链接多个父容器到子容器，比如可以链接多个 web 到 db 容器上。</p></li></ul></li></ol><p>参考: <a href="https://yeasy.gitbooks.io/docker_practice/content/network/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/network/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;外部访问容器&quot;&gt;&lt;a href=&quot;#外部访问容器&quot; class=&quot;headerlink&quot; title=&quot;外部访问容器&quot;&gt;&lt;/a&gt;外部访问容器&lt;/h2&gt;&lt;h3 id=&quot;端口映射&quot;&gt;&lt;a href=&quot;#端口映射&quot; class=&quot;headerlink&quot; title=&quot;端
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>09.Docker数据管理</title>
    <link href="http://blog.renyimin.com/2017/10/17/docker/2017-10-17-09-docker/"/>
    <id>http://blog.renyimin.com/2017/10/17/docker/2017-10-17-09-docker/</id>
    <published>2017-10-17T06:40:23.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>容器中管理数据主要有两种方式：<code>数据卷(Volumes)</code> 和 <code>挂载主机目录(Bind mounts)</code></p><h2 id="数据卷-Volumes"><a href="#数据卷-Volumes" class="headerlink" title="数据卷(Volumes)"></a>数据卷(Volumes)</h2><ol><li>数据卷 是一个可供<strong>一个或多个</strong>容器使用的特殊目录, 它绕过UFS, 可以提供很多有用的特性:<ul><li>数据卷 可以在容器之间共享和重用</li><li>对 数据卷 的修改会立马生效</li><li>对 数据卷 的更新，不会影响镜像</li><li>数据卷 默认会一直存在，即使容器被删除</li></ul></li><li>注意: 数据卷 的使用, 类似于 Linux 下对目录或文件进行 <code>mount</code>，镜像中的被指定为挂载点的目录中的文件会隐藏掉, 能显示看的是挂载的数据卷。</li></ol><h2 id="数据卷操作"><a href="#数据卷操作" class="headerlink" title="数据卷操作"></a>数据卷操作</h2><p>(在主机里使用)</p><ol><li>创建一个数据卷: <code>docker volume create my-vol</code> (其实还有一种方式就是在docker run的时候直接指定一个数据卷名, 就会自动帮你创建数据卷)</li><li>查看所有数据卷: <code>docker volume ls</code></li><li>查看指定数据卷的信息: <code>docker volume inspect my-vol</code><br> 查看容器的数据卷挂载信息: <code>docker inspect 容器名</code></li><li><p>删除数据卷 <code>$ docker volume rm my-vol</code></p><ul><li>数据卷 是被设计用来<strong>持久化</strong>数据的, 它的生命周期独立于容器, Docker不会在容器被删除后自动删除数据卷, 并且<strong>也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷</strong>。</li><li>如果需要在删除容器的同时移除数据卷, 可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令, <strong>这个命令貌似只是移除该容器和数据卷之间的关系</strong>, 除非这个数据卷没有任何容器引用了, 才可以使用下面介绍的命令来删除掉。</li></ul></li><li><p><strong>无主的数据卷</strong>可能会占据很多空间，要清理请使用命令 <code>$ docker volume prune</code></p><ul><li>可以看到清除时会提醒你 <code>WARNING! This will remove all volumes not used by at least one container</code></li><li>清除的是没有被<strong>至少一个</strong>容器使用的数据卷!</li></ul></li></ol><h2 id="创建并启动容器时-挂载数据卷"><a href="#创建并启动容器时-挂载数据卷" class="headerlink" title="创建并启动容器时,挂载数据卷"></a>创建并启动容器时,挂载数据卷</h2><ol><li>在使用 <code>docker run</code> 命令的时候, 还可以使用 <code>--mount</code> 参数来将<code>数据卷</code>挂载到容器里, 另外, 在一次 <code>docker run</code> 中可以挂载多个数据卷。</li><li><p>下面创建一个名为 <code>my-first-vol</code> 的数据卷</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">localhost:~ renyimin$ docker volume create my-first-vol</div><div class="line">my-first-vol</div><div class="line">localhost:~ renyimin$ </div><div class="line">localhost:~ renyimin$ docker volume inspect my-first-vol</div><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;CreatedAt&quot;: &quot;2017-04-26T13:43:16Z&quot;,</div><div class="line">        &quot;Driver&quot;: &quot;local&quot;,</div><div class="line">        &quot;Labels&quot;: &#123;&#125;,</div><div class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-first-vol/_data&quot;,</div><div class="line">        &quot;Name&quot;: &quot;my-first-vol&quot;,</div><div class="line">        &quot;Options&quot;: &#123;&#125;,</div><div class="line">        &quot;Scope&quot;: &quot;local&quot;</div><div class="line">    &#125;</div><div class="line">]</div><div class="line">localhost:~ renyimin$</div></pre></td></tr></table></figure></li><li><p>创建并运行一个名为 <code>web</code> 的容器, 同时加载上面的<code>数据卷</code>到容器内的 <code>/test-vol</code> 目录</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">localhost:~ renyimin$ docker run -d -p 5000:5000 --name myFirstRegistry --mount source=my-first1-vol,target=/test-vol registry</div><div class="line">45e2da7a8ee3c51ae682ff78d02c9779531a79fe2f7a58739023cd19ab48b09d</div><div class="line">localhost:~ renyimin$ docker exec -it myFirstRegistry /bin/sh</div><div class="line">/ # ls</div><div class="line">bin            entrypoint.sh  home           linuxrc        mnt            root           sbin           sys            tmp            var</div><div class="line">dev            etc            lib            media          proc           run            srv            test-vol       usr</div><div class="line">/ #</div></pre></td></tr></table></figure><ul><li>容器中会自动创建虚拟机中的挂载目录;</li><li>另外, 之前我们创建的数据卷是 <code>my-first-vol</code>, 此次运行容器时, 加载的数据卷<strong>却是</strong> <code>my-first1-vol</code>,<br>后面通过查看容器在<code>&quot;Mounts&quot;</code>key下面的数据卷信息, 会发现在启动容器时如果指定的数据卷不存在, 则会自动创建;<br>通过<code>docker volume ls</code>也可以看到现在有<code>my-first-vol</code> 和 <code>my-first1-vol</code> 这两个我们创建的数据卷;</li></ul></li><li><p>可以在主机里使用以下命令查看 <code>myFirstRegistry</code> 容器的信息, 数据卷信息在 <code>&quot;Mounts&quot;</code> Key 下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ docker inspect myFirstRegistry</div><div class="line">&quot;Mounts&quot;: [</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;volume&quot;,</div><div class="line">        &quot;Name&quot;: &quot;my-first1-vol&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-first1-vol/_data&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/test-vol&quot;,</div><div class="line">        &quot;Driver&quot;: &quot;local&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;z&quot;,</div><div class="line">        &quot;RW&quot;: true,</div><div class="line">        &quot;Propagation&quot;: &quot;&quot;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;volume&quot;,</div><div class="line">        &quot;Name&quot;: &quot;4fde6460059e4f0f07bc1c91ed852da7884b872dffc66bc4e237a260c7248250&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/4fde6460059e4f0f07bc1c91ed852da7884b872dffc66bc4e237a260c7248250/_data&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/var/lib/registry&quot;,</div><div class="line">        &quot;Driver&quot;: &quot;local&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;&quot;,</div><div class="line">        &quot;RW&quot;: true,</div><div class="line">        &quot;Propagation&quot;: &quot;&quot;</div><div class="line">    &#125;</div><div class="line">],</div></pre></td></tr></table></figure></li></ol><h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><ol><li><p>挂载一个主机目录作为数据卷: 使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 8090:80 --name testVip --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha vipservice</div><div class="line">2dea428aa379aaf415e5eff38b76f43d64e77b6b34d25bb5e353354ba897cee6</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker exec -it 2dea428aa379aaf415e5eff38b76f43d64e77b6b34d25bb5e353354ba897cee6 /bin/sh</div><div class="line">sh-4.2# cd /</div><div class="line">sh-4.2# ls</div><div class="line">anaconda-post.log  bindata  dev  etchaha  home  lib  lib64lost+found  media  mntopt  proc  root  run  run.sh  sbin  srv  sys  tmp  usrvar</div><div class="line">sh-4.2# cd haha</div><div class="line">sh-4.2# ls</div><div class="line">myfirstregistry  registry.tar</div><div class="line">sh-4.2#</div></pre></td></tr></table></figure></li><li><p>上面的命令会加载主机的 <code>/Users/renyimin/Desktop/testVip</code> 目录到容器的 <code>/haha</code> 目录, 这个功能在进行测试的时候十分方便, 比如, 你可以放置一些程序到本地目录中,来查看容器是否正常工作。<strong>本地目录的路径必须是绝对路径</strong>, 以前使用 <code>-v</code> 参数时, 如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在, Docker 会报错。</p></li><li><p>查看容器的挂载信息, 发现和数据卷相比, <code>Type</code>信息是<code>bind</code>而不是<code>volume</code>, 并且没有数据卷的<code>name</code>信息, <code>docker volume ls</code> 也不会看到有新的数据卷被创建, 所以…可以认为只是一次简单的目录绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker inspect testVip</div><div class="line">&quot;Mounts&quot;: [</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;bind&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/Users/renyimin/Desktop/testVip&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/haha&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;&quot;,</div><div class="line">        &quot;RW&quot;: true,</div><div class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure></li><li><p>选择 <code>-v</code> 还是 <code>--mount</code> 参数?</p><ul><li>Docker 新用户应该选择 <code>--mount</code> 参数，经验丰富的 Docker 使用者对 <code>-v</code> 或者 <code>--volume</code> 已经很熟悉了，但是推荐使用 <code>--mount</code> 参数;</li><li>可以理解为, <strong><code>--mount</code> 参数应该可以挂载数据卷, 也可以代替-v来进行目录关联</strong>。</li></ul></li><li><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <strong>只读</strong></p><ul><li><p>加了 readonly 之后，就挂载为 只读 了。如果你在容器内 /haha 目录新建文件，会显示如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 8090:80 --name testVip --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div><div class="line">27863a3a8f70fa4bddb9c97fabfee2db7f35d5615d4b90ad0be13717dc23d092</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker exec -it 27863a3a8f70fa4bddb9c97fabfee2db7f35d5615d4b90ad0be13717dc23d092 /bin/sh</div><div class="line">sh-4.2# </div><div class="line">sh-4.2# cd /</div><div class="line">sh-4.2# ls</div><div class="line">anaconda-post.log  bindata  dev  etchaha  home  lib  lib64lost+found  media  mntopt  proc  root  run  run.sh  sbin  srv  sys  tmp  usrvar</div><div class="line">sh-4.2# cd haha</div><div class="line">sh-4.2# ls</div><div class="line">myfirstregistry  registry.tar</div><div class="line">// 可以看到报错了</div><div class="line">sh-4.2# touch a.txt</div><div class="line">touch: cannot touch &apos;a.txt&apos;: Read-only file system</div><div class="line">sh-4.2#</div></pre></td></tr></table></figure></li><li><p>查看数据卷的具体信息 <code>$ docker inspect testVip</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&quot;Mounts&quot;: [</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;bind&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/Users/renyimin/Desktop/testVip&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/haha&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;&quot;,</div><div class="line">        &quot;RW&quot;: false,</div><div class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</div><div class="line">    &#125;</div><div class="line">],</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="数据卷挂载的问题"><a href="#数据卷挂载的问题" class="headerlink" title="数据卷挂载的问题"></a>数据卷挂载的问题</h2><p>上面提到的数据卷, 对很多容器都非常有用, 比如 </p><ul><li>mysql容器中存储数据文件的 <code>/var/lib/mysql</code> 目录你就需要挂载数据卷;</li><li>mysql, php-fpm, nginx等容器中, 关于服务配置的目录你也需要挂载到数据卷, 这些配置你可能需要进行改动;</li></ul><p>但是挂载数据卷有个问题, 一旦挂载之后, 容器中的目录就是空的, 原本服务的配置文件就被清空了, 也就导致有些容器在挂载数据卷之后, 无法正常启动;</p><h2 id="docker-cp-命令"><a href="#docker-cp-命令" class="headerlink" title="docker cp 命令"></a>docker cp 命令</h2><ol><li><p>可以将本地目录/文件拷贝到容器, 也可以将容器中的目录/文件拷贝到本地; 格式: </p><ul><li><code>docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</code></li><li><code>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</code></li></ul></li><li><p>所以为了避免挂载导致容器无法正常启动, 挂载的可以这样来:</p><ul><li>先确定你需要挂载的容器中目录的位置(比如: nginx容器中的配置文件在<code>/etc/nginx/conf.d/default.conf</code> )</li><li>使用 <code>docker cp</code> 命令, 将需要映射的目录从容器复制到本地; (比如:  <code>docker cp nginx_test:/etc/nginx/ ./conf/</code>)</li><li>然后再将本地default.conf文件挂载到nginx容器的/etc/nginx/conf.d/default.conf</li></ul></li></ol><p>参考: <a href="https://yeasy.gitbooks.io/docker_practice/content/data_management/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/data_management/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;容器中管理数据主要有两种方式：&lt;code&gt;数据卷(Volumes)&lt;/code&gt; 和 &lt;code&gt;挂载主机目录(Bind mounts)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据卷-Volumes&quot;&gt;&lt;a href=&quot;#数据卷-Volumes&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>08.容器--基本操作</title>
    <link href="http://blog.renyimin.com/2017/10/17/docker/2017-10-17-08-docker/"/>
    <id>http://blog.renyimin.com/2017/10/17/docker/2017-10-17-08-docker/</id>
    <published>2017-10-17T04:01:08.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>1.镜像(Image)和容器(Container)的关系, 就像是面向对象程序设计中的 类 和 实例 的关系一样, 镜像是静态的定义, 容器是镜像运行时的实体。容器可以被 <code>创建</code>、<code>启动</code>、<code>停止</code>、<code>删除</code>、<code>暂停</code>等。</p><p>2.容器的实质是<strong>进程</strong>，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。</p><ul><li>因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。</li><li>容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会把容器和虚拟机搞混。</li></ul><p>3.前面讲过镜像使用的是<strong>分层存储</strong>，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。<br><code>容器存储层</code>的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，<strong>任何保存于容器存储层的信息都会随容器的删除而丢失</strong>。</p><p>4.按照 Docker 最佳实践的要求, 容器不应该向其存储层内写入任何数据，<strong>容器存储层要保持无状态化</strong></p><ul><li>所有的文件写入操作，都应该使用<code>数据卷(Volume)</code>、或者<code>绑定宿主目录</code>，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</li><li>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</li></ul><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a><strong>容器操作</strong></h2><p>启动容器有两种方式：<strong>一种是基于镜像新建一个容器并启动</strong>, <strong>另外一个是将在终止状态(stopped)的容器启动</strong></p><h3 id="创建并启动"><a href="#创建并启动" class="headerlink" title="创建并启动"></a>创建并启动</h3><p>1.因为 Docker 的容器<strong>实在太轻量级了</strong>, 很多时候用户都是<strong>随时删除和新创建容器</strong>。 </p><p>2.新建并启动一个容器, 所需要的命令主要为 <code>docker run</code>, 例如: <code>$ docker run -d -p 5000:5000 --name myFirstRegistry registry</code>, 是根据名为registry的镜像创建并运行一个名为myFirstRegistry容器;</p><p>3.当利用 <code>docker run</code> 来创建容器时, Docker 在后台运行的标准操作包括:</p><ul><li>检查本地是否存在指定的镜像, 不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统, 并在只读的镜像层外面挂载一层可读写层 </li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 </li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p>4.<strong>容器被启动后, 设置的挂载目录, 端口映射都会随着此容器, 容器stop后, 再次start, 这些设置都还在;</strong></p><h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker start [containerID or NAME]</code> 命令, 直接将一个已经终止的容器启动运行。 </p><h3 id="守护态运行容器"><a href="#守护态运行容器" class="headerlink" title="守护态运行容器"></a>守护态运行容器</h3><p>其实更多时候, 我们需要让容器在后台运行, 而不是直接运行容器并展示出结果, 此时只用在运行时加上 <code>-d 参数</code>即可; (在容器的第一种启动方式中已经介绍过了)</p><h3 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h3><p>可以通过 <code>docker ps</code> 命令来查看正在运行的容器信息</p><p>可以通过 <code>docker ps -a</code> 命令来查看 正在运行的和终止的 容器信息</p><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>可以使用 <code>docker stop [containerID or NAME]</code> 来终止一个运行中的容器</p><h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><p>可以使用 <code>docker restart [containerID or NAME]</code> 来重启一个运行中的容器</p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>1.可以使用 <code>docker rm 容器ID/容器NAME</code> 来删除一个<strong>处于终止状态</strong>的容器。 </p><p>2.如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>可参考<a href="https://yeasy.gitbooks.io/docker_practice/content/container/attach_exec.html" target="_blank" rel="external">书中介绍</a></p><p>本人通常使用 <code>docker exec -it [containerID or NAME] /bin/sh</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;容器&quot;&gt;&lt;a href=&quot;#容器&quot; class=&quot;headerlink&quot; title=&quot;容器&quot;&gt;&lt;/a&gt;容器&lt;/h2&gt;&lt;p&gt;1.镜像(Image)和容器(Container)的关系, 就像是面向对象程序设计中的 类 和 实例 的关系一样, 镜像是静态的定义, 容器
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>07.Docker Registry 仓库</title>
    <link href="http://blog.renyimin.com/2017/10/17/docker/2017-10-17-07-docker/"/>
    <id>http://blog.renyimin.com/2017/10/17/docker/2017-10-17-07-docker/</id>
    <published>2017-10-17T03:30:08.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公开-Docker-Registry"><a href="#公开-Docker-Registry" class="headerlink" title="公开 Docker Registry"></a>公开 Docker Registry</h2><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务</p><ul><li>一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</li><li>最常使用的Registry公开服务是官方的 <code>Docker Hub</code>, 这也是默认的 Registry，并拥有大量的高质量的官方镜像。</li></ul><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务(Registry Mirror)，这些镜像服务被称为<strong>加速器</strong>。</p><p>但是, 有时候使用 Docker Hub 或其他公共仓库可能不方便(比如, 有时候我们的服务器无法访问互联网 或者 你不希望将自己的镜像放到公网当中)，则可以创建一个 <code>本地仓库供</code> 私人使用。</p><h2 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h2><p>1.除了使用公开服务外, 用户还可以在本地搭建私有Docker Registry, <a href="https://docs.docker.com/registry/" target="_blank" rel="external"><code>docker-registry</code></a>是官方提供的工具, 可以用于构建私有的镜像仓库。</p><p>2.安装运行 <code>docker-registry</code></p><ul><li><p>你可以通过获取官方<code>registry</code>镜像来在本地运行一个自己的私有镜像仓库 (如 <code>$ docker run -d -p 5000:5000 --restart=always --name registry registry</code>, 将使用官方的registry镜像来启动一个私有仓库)</p></li><li><p>默认情况下, 仓库中的镜像会被创建在容器的 <code>/var/lib/registry</code> 目录下, 你可以通过 <code>-v</code> 参数来将镜像文件存放到本地的指定路径中。</p></li><li><p>另外, 可以将私有仓库的配置文件指定到本地的路径下 (如 ~/Desktop/registry-config/ 下 )</p></li></ul><p>3.我们大可不必这么麻烦, 只是简单运行一个私有仓库服务 <code>$ docker run -d -p 5000:5000 --restart=always --name registry registry</code></p><h3 id="查看私有仓库中镜像"><a href="#查看私有仓库中镜像" class="headerlink" title="查看私有仓库中镜像"></a>查看私有仓库中镜像</h3><p>1.用 <code>curl</code> 查看仓库中的镜像, 可以看到你的私有仓库暂时还是空的</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl 127.0.0.1:5000/v2/_catalog</div><div class="line">&#123;&quot;repositories&quot;:[]&#125;</div><div class="line">$</div></pre></td></tr></table></figure></code></pre><p>2.还可以在浏览器中直接查看私有仓库中的镜像(并且内网其他机器也可以通过内网地址来访问你所搭建的私有仓库的镜像):<br><img src="/img/docker/private_registry_01.png" width="200/"><br><img src="/img/docker/private_registry_02.png" width="200/"></p><h3 id="上传镜像到私有仓库中"><a href="#上传镜像到私有仓库中" class="headerlink" title="上传镜像到私有仓库中"></a>上传镜像到私有仓库中</h3><p>1.之前我们已经通过获取官方 <code>registry镜像</code> 来创建好了自己的私有仓库, 接下来就可以使用 <code>docker tag</code> 来标记一个镜像, 然后推送它到仓库。</p><p>2.先查看一下本地已有的镜像 <code>docker image ls</code> :</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div></pre></td></tr></table></figure></code></pre><p>3.使用 <code>docker tag</code> 将 <code>registry:lates</code> 这个镜像标记为一个新的本地镜像 <code>127.0.0.1:5000/registry:latest</code> ; </p><ul><li><p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker tag registry:latest 127.0.0.1:5000/registry:latest</div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div></pre></td></tr></table></figure></li><li><p>这样, 假设你的小组成员需要尝试在本地搭建自己的私有仓库的话，就不用去公共镜像仓库去下载了, 只用在内网就可以方便地下载registry镜像</p></li></ul><p>4.使用 docker push 上传标记的镜像</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker push 127.0.0.1:5000/registry:latest</div><div class="line">The push refers to a repository [127.0.0.1:5000/registry]</div><div class="line">9113493eaae1: Pushed </div><div class="line">621c2399d41a: Pushed </div><div class="line">59e80739ed3f: Pushed </div><div class="line">febf19f93653: Pushed </div><div class="line">e53f74215d12: Pushed </div><div class="line">latest: digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c size: 1364</div></pre></td></tr></table></figure></code></pre><p>5.然后查看仓库中的镜像，可以看到镜像已经被成功上传了</p><ul><li><p>curl 查看</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl 127.0.0.1:5000/v2/_catalog</div><div class="line">&#123;&quot;repositories&quot;:[&quot;registry&quot;]&#125;</div></pre></td></tr></table></figure></li><li><p>浏览器查看<br><img src="/img/docker/private_registry_03.png" width="200/"><br><img src="/img/docker/private_registry_04.png" width="200/"></p></li></ul><h3 id="上传私有仓库问题"><a href="#上传私有仓库问题" class="headerlink" title="上传私有仓库问题"></a>上传私有仓库问题</h3><p>1.如果上传的时候, 打包的镜像使用的是本机的内网地址, 最后在上传的时候, 你会发现<strong>如下报错信息</strong>:</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker push 192.168.1.3:5000/registry:latest</div><div class="line">The push refers to a repository [192.168.1.3:5000/registry]</div><div class="line">Get https://192.168.1.3:5000/v2/: http: server gave HTTP response to HTTPS client</div><div class="line">renyimindembp:vipvip renyimin$</div></pre></td></tr></table></figure></code></pre><p>2.此时, 你需要将内网地址配置到本机docker的 <code>insecure registries</code> 中, 如下:<br><img src="/img/docker/insecure_registries_01.png" width="300"></p><p>3.之后, 无论本机还是在同一内网中的其他机器也都可以推送镜像到仓库中了(之前打包好的两个镜像, 都可以成功推送到私有仓库中):</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ docker push 192.168.1.3:5000/registry</div><div class="line">The push refers to a repository [192.168.1.3:5000/registry]</div><div class="line">9113493eaae1: Pushed </div><div class="line">621c2399d41a: Pushed </div><div class="line">59e80739ed3f: Pushed </div><div class="line">febf19f93653: Pushed </div><div class="line">e53f74215d12: Pushed </div><div class="line">latest: digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c size: 1364</div><div class="line">   </div><div class="line">$ docker push 127.0.0.1:5000/registry</div><div class="line">The push refers to a repository [127.0.0.1:5000/registry]</div><div class="line">9113493eaae1: Layer already exists </div><div class="line">621c2399d41a: Layer already exists </div><div class="line">59e80739ed3f: Layer already exists </div><div class="line">febf19f93653: Layer already exists </div><div class="line">e53f74215d12: Layer already exists </div><div class="line">latest: digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c size: 1364</div></pre></td></tr></table></figure></code></pre><h3 id="从私有仓库中下载镜像"><a href="#从私有仓库中下载镜像" class="headerlink" title="从私有仓库中下载镜像"></a>从私有仓库中下载镜像</h3><p>1.先删除已有镜像</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">192.168.1.3:5000/registry                             latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line"></div><div class="line">$ docker image rm 127.0.0.1:5000/registry:latest 192.168.1.3:5000/registry:latest</div><div class="line">Untagged: 127.0.0.1:5000/registry:latest</div><div class="line">Untagged: 127.0.0.1:5000/registry@sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line">Untagged: 192.168.1.3:5000/registry:latest</div><div class="line">Untagged: 192.168.1.3:5000/registry@sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line"></div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">renyimindembp:vipvip renyimin$</div></pre></td></tr></table></figure></code></pre><p>2.再尝试从私有仓库中下载这个镜像 (两个地址都可以下载, 也是因为之前配置了 <code>Insecure registries</code>, 这里最后才可以使用内网地址来下载)</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">$ docker pull 127.0.0.1:5000/registry:latest</div><div class="line">latest: Pulling from registry</div><div class="line">Digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line">Status: Downloaded newer image for 127.0.0.1:5000/registry:latest</div><div class="line"></div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line"></div><div class="line">$ docker pull 192.168.1.3:5000/registry:latest</div><div class="line">latest: Pulling from registry</div><div class="line">Digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line">Status: Downloaded newer image for 192.168.1.3:5000/registry:latest</div><div class="line"></div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">192.168.1.3:5000/registry                             latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div></pre></td></tr></table></figure></code></pre><h2 id="几个简单问题"><a href="#几个简单问题" class="headerlink" title="几个简单问题"></a>几个简单问题</h2><p>1.<a href="https://docs.docker.com/registry/spec/api/#deleting-an-image" target="_blank" rel="external">删除<code>仓库</code>镜像</a><br>    自己的docker仓库中存放的镜像, 时间长了难免存在一些废弃的镜像在里面, 如果不删除就造成空间的浪费。<br>2.容器启动之后, 如果忘记挂载某个目录, 能否再进行挂载?<br>其实没有必要, 直接停止删除, 重开一个即可！</p><p><del>~~未完待续</del>~~    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;公开-Docker-Registry&quot;&gt;&lt;a href=&quot;#公开-Docker-Registry&quot; class=&quot;headerlink&quot; title=&quot;公开 Docker Registry&quot;&gt;&lt;/a&gt;公开 Docker Registry&lt;/h2&gt;&lt;p&gt;Docker
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>06.其他方法定制 -- (镜像/容器 的 导入导出)</title>
    <link href="http://blog.renyimin.com/2017/10/14/docker/2017-10-14-06-docker/"/>
    <id>http://blog.renyimin.com/2017/10/14/docker/2017-10-14-06-docker/</id>
    <published>2017-10-14T12:15:28.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="镜像-save-load"><a href="#镜像-save-load" class="headerlink" title="镜像 (save/load)"></a>镜像 (save/load)</h2><p>1.<code>docker save nginx:v1 &gt; alpine-latest.tar.gz</code>：将指定<strong>镜像</strong>导出为 <code>镜像存储文件</code>;</p><p>2.再使用 <code>docker load -i alpine-latest.tar.gz</code> 命令将 <code>镜像存储文件</code> 导入到本地镜像库;</p><h2 id="容器-export-import"><a href="#容器-export-import" class="headerlink" title="容器(export/import)"></a>容器(export/import)</h2><p>1.<code>docker export container_id &gt; my_container.tar</code>：将一个<strong>容器</strong>导出为 <code>容器快照文件</code>;<br>2.再使用 <code>docker import my_container.tar imageName:tag</code> 命令将 <code>容器快照文件</code> 导入为一个新的镜像到本地镜像库;<br>3.测试, 将nginx_v1容器导出, 并在本地重新生成nginx:v3镜像, 然后运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 运行中的nginx_v1容器</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</div><div class="line">d5d17a25cc35        nginx:v1            &quot;nginx -g &apos;daemon ...&quot;   2 hours ago         Up 11 minutes       0.0.0.0:8089-&gt;80/tcp     nginx_v1</div><div class="line">0e7070854958        registry            &quot;/entrypoint.sh /e...&quot;   26 hours ago        Up About an hour    0.0.0.0:5000-&gt;5000/tcp   registry</div><div class="line">//导出容器为 容器快照文件</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker export nginx_v1 &gt; nginx_v1.tar</div><div class="line">//将 nginx_v1的容器快照文件, 重新导入为一个新的本地镜像 nginx:v3</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker import nginx_v1.tar nginx:v3</div><div class="line">sha256:985fba7fd176d79685322d184bc79b81ca4365619bc0a773672e5c87cfc701cd</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker images</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">nginx                                                 v3                  985fba7fd176        10 seconds ago      107MB</div><div class="line">nginx                                                 v1                  8b748aee8b23        2 hours ago         109MB</div><div class="line">nginx                                                 latest              e548f1a579cf        8 days ago          109MB</div><div class="line">// 运行新镜像, 发现报错</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker run -d --name nginx_v3 nginx:v3</div><div class="line">docker: Error response from daemon: No command specified.</div><div class="line">See &apos;docker run --help&apos;.</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$</div></pre></td></tr></table></figure></p><p>4.解决方案, 通过<code>docker import 导入容器快照文件</code>生成的镜像, 在初次创建并启动(run)时, 需要提供快照文件所对应的容器的<code>COMMAND</code>字段, 可以通过<code>docker ps</code>查看, 如果命令太长, 则需要使用 <code>docker inspect 容器名</code> 查看 <code>cmd</code> 字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker run -d --name nginx_v3 nginx:v3 nginx &apos;-g&apos; &apos;daemon off;&apos;</div><div class="line">0fb30bafe266248bbb58e31d9dcab7479f4a59494fcc636f7f7dfd2df498066d</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</div><div class="line">0fb30bafe266        nginx:v3            &quot;nginx -g &apos;daemon ...&quot;   2 seconds ago       Up 1 second                                  nginx_v3</div><div class="line">d5d17a25cc35        nginx:v1            &quot;nginx -g &apos;daemon ...&quot;   2 hours ago         Up 19 minutes       0.0.0.0:8089-&gt;80/tcp     nginx_v1</div><div class="line">0e7070854958        registry            &quot;/entrypoint.sh /e...&quot;   26 hours ago        Up About an hour    0.0.0.0:5000-&gt;5000/tcp   registry</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$</div></pre></td></tr></table></figure></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1.可以使用 <code>docker load</code> 来导入<code>镜像存储文件</code>到本地镜像库。<br>2.也可以使用 <code>docker import</code> 来导入一个<code>容器快照文件</code>到本地镜像库。<br>3.这两者的区别在于:</p><ul><li><code>镜像存储文件</code>将保存完整记录, 体积也要大</li><li>而<code>容器快照文件</code>将丢弃所有的历史记录和元数据信息(即仅保存容器当时的快照状态)</li><li>此外，从容器快照文件导入时可以<strong>重新指定标签</strong>等元数据信息</li></ul><ol><li>另外, 使用<code>docker save</code>保存的<code>镜像存储文件</code>, 不能使用 <code>docker import</code> 来导入成镜像, 这样导入的镜像无法运行起来</li></ol><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>在初次为公司内部准备镜像时, 可以启动一个基础镜像, 然后在容器中做好软件安装, 完成各种配置工作之后:</p><ul><li>可以手动commit成功新的 <code>镜像:tag</code>, 然后将镜像push到私有仓库供给大家下载使用;</li><li>可以简单将容器直接export成容器快照文件, 然后import为新的 <code>镜像:tag</code>, 然后push到私有仓库供给大家下载使用; </li><li>或者通过Dockerfile定制脚本及<code>docker build</code>来构建新的 <code>镜像:tag</code>, 然后push到私有仓库供给大家下载使用; </li></ul><p><strong>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡, 这里的消亡是指容器被删除, 而不是stop容器, stop容器后, 容器中发生的改变不会被忽略, 除非容器被删除掉</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>如果只是做集成环境的镜像, 比如lnmp全部在一个镜像中运行, 自己觉着可以:</p><ul><li>使用一个基础镜像运行起容器, 然后自己安装各种环境, 最后可以直接 <code>export</code> 导出容器为快照文件, 然后分发给组员;(如果需要再次修改环境信息, 直接修改好, 然后导出新的容器快找文件给组员即可)</li><li>可以在容器中构建好各环境之后, <code>commit</code> 手动构建好镜像, 然后将镜像 <code>push</code> 到仓库中, 供组员使用 (变动频次较高的时候不方便, 因为这样会导致容器变得越来越臃肿); </li><li>可以使用<code>Dockerfile</code>对镜像进行定制(如果镜像比较基础, 可能编写的比较多), 然后将镜像 <code>push</code> 到仓库中, 供组员使用</li></ul></li><li><p>如果做多容器部署, 需要使用到docker-compose….<br>未完待续~~</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://yeasy.gitbooks.io/docker_practice/content/image/other.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/image/other.html</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/content/container/import_export.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/container/import_export.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;镜像-save-load&quot;&gt;&lt;a href=&quot;#镜像-save-load&quot; class=&quot;headerlink&quot; title=&quot;镜像 (save/load)&quot;&gt;&lt;/a&gt;镜像 (save/load)&lt;/h2&gt;&lt;p&gt;1.&lt;code&gt;docker save nginx:
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>05.镜像 - Dockerfile常见指令详解</title>
    <link href="http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/"/>
    <id>http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/</id>
    <published>2017-10-13T02:25:07.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h2><ol><li>所谓定制镜像, <strong>是以一个镜像为基础, 在其上进行定制</strong>。<code>FROM</code> 就用来指定基础镜像, 因此一个 Dockerfile 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</li><li>格式: <code>FROM 镜像名[:标签]</code></li></ol><h2 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h2><ol><li>指定镜像的作者和联系方式信息(执行<code>docker inspect image</code> 输出中有相应的字段记录该信息)</li><li>格式:<code>MAINTAINER author &quot;e-mail&quot;</code> 指定作者名和E-mail</li></ol><h2 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h2><ol><li><p><code>RUN</code>指令是用来执行<code>命令行命令</code>的。(由于命令行的强大能力, RUN指令在定制镜像时是最常用的指令之一)</p></li><li><p>其格式有两种：</p><ul><li>shell 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样, 如: <code>RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code></li><li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code> , 这更像是函数调用中的格式, 如: <code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code>。</li></ul></li><li><p>虽然RUN就像Shell脚本一样可以执行命但是我们也不能像Shell脚本一样把每个命令对应一个RUN, 因为每一个RUN的行为, 就像手工建立commit镜像的过程一样:新建立一层，在其上执行这些命令, 执行结束后, commit 这一层的修改, 构成新的镜像。</p><ul><li><p>像下面的这种写法，创建了 7 层镜像, 这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。<strong>结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。这是很多初学 Docker 的人常犯的一个错误</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN apt-get update</div><div class="line">RUN apt-get install -y gcc libc6-dev make</div><div class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</div><div class="line">RUN mkdir -p /usr/src/redis</div><div class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</div><div class="line">RUN make -C /usr/src/redis</div><div class="line">RUN make -C /usr/src/redis install</div></pre></td></tr></table></figure></li><li><p>上面的 Dockerfile 正确的写法应该是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN buildDeps=&apos;gcc libc6-dev make&apos; \</div><div class="line">    &amp;&amp; apt-get update \</div><div class="line">    &amp;&amp; apt-get install -y $buildDeps \</div><div class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \</div><div class="line">    &amp;&amp; mkdir -p /usr/src/redis \</div><div class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</div><div class="line">    &amp;&amp; make -C /usr/src/redis \</div><div class="line">    &amp;&amp; make -C /usr/src/redis install \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</div><div class="line">    &amp;&amp; rm redis.tar.gz \</div><div class="line">    &amp;&amp; rm -r /usr/src/redis \</div><div class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</div></pre></td></tr></table></figure><blockquote><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层, 这只是一层的事情。<br><strong>在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建</strong>。<br>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，因为<strong>镜像是多层存储，每一层的东西并不会在下一层被删除</strong>，会一直跟随着镜像。<br>因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p></blockquote></li></ul></li></ol><h2 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h2><ol><li>这个指令很简单,就是设置环境变量而已,无论是后面的其它指令,如RUN,还是运行时的应用,都可以直接使用这里定义的环境变量。</li><li><code>ENV</code>设置环境变量格式有两种:<ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul></li><li>下面例子中演示了”设置环境变量”, “如何换行”, 以及对”含有空格的值用双引号括起来”的办法, 这和Shell下的行为是一致的 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ENV VERSION=1.0 DEBUG=on \</div><div class="line">NAME=&quot;Happy Feet&quot;</div></pre></td></tr></table></figure></li></ol><h2 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h2><ol><li><p>构建参数和ENV的效果一样, 都是设置环境变量。所不同的是,<code>ARG</code>所设置的环境变量,在将来容器运行时是<strong>不会存在</strong>这些环境变量的;但是不要因此就使用ARG保存密码之类的信息, 因为 <code>docker history</code> 还是可以看到所有值的;</p></li><li><p>Dockerfile 中的ARG指令是定义参数名称及其默认值, 该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖</p></li><li><p>格式: <code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p></li></ol><h2 id="WORKDIR-切换工作目录"><a href="#WORKDIR-切换工作目录" class="headerlink" title="WORKDIR 切换工作目录"></a>WORKDIR 切换工作目录</h2><ol><li>使用 <code>WORKDIR</code> 指令可以来指定接下来之后各层的工作目录, <strong>如该目录不存在, WORKDIR 会帮你建立目录</strong>。</li><li>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code></li><li><p>之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写, 这种错误的理解还可能会导致出现下面这样的错误:</p><ul><li><p>如果将下面这个 Dockerfile 进行构建镜像运行后, 会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 hello </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RUN cd /app #第一层 `RUN cd /app` 的执行仅仅是当前进程的工作目录变更, 一个内存上的变化而已, 其结果不会造成任何文件变更。</div><div class="line">RUN echo &quot;hello&quot; &gt; world.txt #而到第二层的时候, 启动的是一个全新的容器, 跟第一层的容器更完全没关系, 自然不可能继承前一层构建过程中的内存变化</div></pre></td></tr></table></figure></li><li><p>原因其实很简单, 在Shell中, 上面连续的两行是同一个进程执行环境, 而在 Dockerfile 中, 这两行 RUN 命令的执行环境根本不同, 是两个完全不同的容器。(这就是对 Dokerfile 构建分层存储的概念不了解所导致的错误)</p></li><li>之前说过每一个RUN都是启动一个容器、执行命令、然后提交存储层文件变更</li></ul></li></ol><h2 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h2><ol><li><p><code>USER</code> 指令和 WORKDIR 相似, <strong>都是改变环境状态并影响以后的层</strong> (<code>WORKDIR</code>是改变工作目录, 而<code>USER</code>则是改变之后层执行RUN,CMD以及ENTRYPOINT这类命令时的身份)。</p></li><li><p>格式: <code>USER &lt;用户名&gt;</code></p></li><li><p>注意: USER只是帮助你切换到指定用户而已, <strong>这个用户必须是事先建立好的, 否则无法切换</strong>。</p></li><li><p>如果以root执行的脚本, 在执行期间希望改变身份, 比如希望以某个已经建立好的用户来运行某个服务进程, 不要使用 <code>su</code> 或者 <code>sudo</code>, 这些都需要比较麻烦的配置, 而且在TTY缺失的环境下经常出错。</p><ul><li>建议使用 <code>gosu</code> ，可以从其<a href="https://github.com/tianon/gosu" target="_blank" rel="external">项目网站</a>看到进一步的信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</div><div class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</div><div class="line"># 下载 gosu</div><div class="line">RUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot; \</div><div class="line">    &amp;&amp; chmod +x /usr/local/bin/gosu \</div><div class="line">    &amp;&amp; gosu nobody true</div><div class="line"># 设置 CMD，并以另外的用户执行</div><div class="line">CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ]</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h2><ol><li><p>容器运行时应该尽量保持<code>容器存储层</code>不发生写操作, 对于像数据库这类需要保存动态数据的应用, 其数据库文件应该保存于<code>卷(volume)</code>中。</p></li><li><p>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在Dockerfile中, 可以事先指定某些目录挂载为匿名卷, 这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p></li><li><p>格式为: <code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></p></li><li><p><code>VOLUME /data</code> : 容器中的 “/data” 目录就会在运行时自动挂载为匿名卷, 任何向 /data 中写入的信息都不会记录进容器存储层。<br>当然，运行时可以覆盖这个挂载设置。比如:<code>docker run -d -v mydata:/data xxxx</code> 在这行命令中, 就使用了 mydata 这个命名卷挂载到了 /data 这个位置, 替代了 Dockerfile 中定义的匿名卷的挂载配置。</p></li></ol><h2 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h2><ol><li><p><code>EXPOSE</code>指令是声明运行时为容器提供的映射端口, 这<strong>只是一个声明, 并不会自动在宿主进行端口映射</strong>。</p></li><li><p>格式为:<code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p></li><li><p>在 Dockerfile 中写入这样的声明有两个好处</p><ul><li>一个是帮助镜像使用者理解这个镜像服务的守护端口, 以方便配置映射;</li><li>另一个用处则是在运行时使用随机端口映射时, 也就是 <code>docker run -P</code> 时, 会自动随机映射 <code>EXPOSE</code> 的端口。</li></ul></li><li><p>要将 <code>EXPOSE</code> 和 在运行时使用<code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来</p><ul><li><code>-p</code> 是映射宿主端口和容器端口, 换句话说, 就是将容器的对应端口服务公开给外界访问;</li><li>而 <code>EXPOSE</code> 仅仅是声明, 容器打算使用什么端口而已, <strong>并不会自动在宿主进行端口映射</strong>;</li></ul></li></ol><h2 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h2><ol><li><p><code>CMD</code> 指令的格式和 RUN 相似，也是两种格式:</p><ul><li>shell 格式: <code>CMD &lt;命令&gt;</code></li><li>exec 格式: <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li></ul></li><li><p>但是如果指定了 <code>ENTRYPOINT</code> 指令，用 CMD 指定的就是具体的参数 <code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。</p></li><li><p>Docker不是虚拟机, 容器就是进程, 那么在启动容器的时候, CMD 指令就是用于指定默认的容器主进程的启动命令的。</p><ul><li><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令<br>比如ubuntu镜像默认的CMD是<code>/bin/bash</code>, 如果我们直接 <code>docker run -it ubuntu</code> 的话, 会直接进入 bash ;<br>我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>, 这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了, 输出了系统版本信息。 </p></li><li><p>在指令格式上, 一般推荐使用 <code>exec</code> 格式, 这类格式在解析时会被解析为JSON数组，因此一定要使用双引号, 而不要使用单引号。</p></li><li><p>如果使用 shell 格式的话，实际的命令会被包装为<code>sh -c</code>的参数的形式进行执行。比如 <code>CMD echo $HOME</code> 在实际执行中，会将其变更为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code><br>这就是为什么我们可以使用环境变量的原因, 因为这些环境变量会被shell进行解析处理。</p></li></ul></li><li><p>Docker不是虚拟机, 容器中的应用都应该以前台执行, 而不是像虚拟机、物理机里面那样, 用 <code>upstart/systemd</code> 去启动后台服务, <strong>容器内没有后台服务的概念</strong>。</p><ul><li><p>一些初学者将 CMD 写为 <code>CMD service nginx start</code>, 然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。<br>这就是因为没有搞明白前台、后台的概念, 没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p></li><li><p>对于容器而言, 其启动程序就是容器应用进程, 容器就是为了主进程而存在的，主进程退出, 容器就失去了存在的意义, 从而退出, 其它辅助进程不是它需要关心的东西。<br>而使用 <code>service nginx start</code> 命令，则是希望upstart来以后台守护进程形式启动nginx服务, <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>, 因此主进程实际上是sh, 那么当 <code>service nginx start</code> 命令结束后, sh也就结束了, sh 作为主进程退出了, 自然就会令容器退出。</p></li><li><p>正确的做法是直接执行nginx可执行文件，并且要求以前台形式运行。比如: <code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code></p></li></ul></li></ol><h2 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h2><ol><li><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样, 都是在指定容器启动程序及参数。 </p><ul><li>ENTRYPOINT 在运行时也可以被替代, 不过比CMD要略显繁琐, 需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定;</li><li>当指定了 ENTRYPOINT 后, <strong>CMD 的含义就发生了改变</strong>, 不再是直接的运行其命令, 而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令, 换句话说实际执行时, 将变为:<code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code></li></ul></li><li><p><code>ENTRYPOINT</code> 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。</p></li><li><p>有了<code>CMD</code>后, 为什么还要有<code>ENTRYPOINT</code>? 这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处? <a href="https://yeasy.gitbooks.io/docker_practice/content/image/dockerfile/entrypoint.html" target="_blank" rel="external">参考书中</a></p><ul><li>场景一：让镜像变成像命令一样使用</li><li>场景二：应用运行前的准备工作</li></ul></li></ol><h2 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h2><ol><li><p>和RUN指令一样, 也有两种格式:</p><ul><li><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li></ul></li><li><p>COPY 指令将从 <code>构建上下文目录</code> 中 <code>&lt;源路径&gt;</code>目录/ 复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如:<code>COPY package.json /usr/src/app/</code></p><ul><li>&lt;源路径&gt; 可以是多个, 甚至可以是通配符</li><li>&lt;目标路径&gt; 可以是容器内的绝对路径, 也可以是相对于工作目录的相对路径(工作目录可以用 <code>WORKDIR</code> 指令来指定)。</li><li>目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</li></ul></li><li><p>此外, 还需要注意一点, 使用 COPY 指令, 源文件的各种元数据都会保留。比如读、写、执 行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p></li></ol><h2 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h2><ol><li><p><code>ADD</code> 指令 和 <code>COPY</code> 的格式和性质基本一致, 但是在 COPY 基础上增加了一些功能:</p><ul><li><p>比如 &lt;源路径&gt; 可以是一个 URL , 这种情况下, Docker 引擎会试图去下载这个链接的文件放 到 &lt;目标路径&gt; 去, 下载后的文件权限自动设置为 600 , 如果这并不是想要的权限, 则需要增加额外的一层 RUN 进行权限调整<br>另外, 如果下载的是个压缩包, 需要解压缩, 也一样, 还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令, 然后使用 wget 或 者 curl 工具下载, 处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并 不实用，而且不推荐使用。</p></li><li><p>如果 &lt;源路径&gt; 为一个tar压缩文件的话,压缩格式为 gzip , bzip2 以及 xz 的情况下, ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去<br>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。</p></li></ul></li><li><p>在 Docker 官方的最佳实践文档中要求，尽可能的使用 COPY ，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。<strong>最适合使用ADD 的场合，就是所提及的需要自动解压缩的场合</strong>。</p></li><li><p>另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD 。</p></li></ol><h2 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h2><h2 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h2><ol><li><p>格式：<code>ONBUILD &lt;其它指令&gt;</code></p></li><li><p><code>ONBUILD</code> 是一个特殊的指令, 它后面跟的是其它指令, 比如 RUN, COPY 等, 而这些指令, 在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像, 去构建下一级镜像的时候才会被执行。</p></li><li><p>Dockerfile 中的其它指令都是为了定制当前镜像而准备的, 唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p></li><li><p>假设我们要制作Node.js所写的应用的镜像, 我们都知道Node.js使用npm进行包管理, 所有依赖、配置、启动信息等会放到package.json文件里。</p><ul><li>在拿到程序代码后, 需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。</li><li><p>然后就可以通过 <code>npm start</code> 来启动应用, 因此, 一般来说会这样写 Dockerfile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FROM node:slim</div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">COPY ./package.json /app</div><div class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ]</div><div class="line">COPY . /app/</div><div class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</div></pre></td></tr></table></figure></li><li><p>把这个 Dockerfile 放到 Node.js 项目的根目录, 构建好镜像后, 就可以直接拿来启动容器运行。</p></li></ul></li><li><p>但是如果我们还有第二个 Node.js 项目也差不多呢？好吧, 那就再把这个Dockerfile复制到第二个项目里。那如果有第三个项目呢?再复制么?文件的副本越多,版本控制就越困难,让我们继续看这样的场景维护的问题。</p><ul><li>如果第一个Node.js项目在开发过程中, 发现这个Dockerfile里存在问题,比如敲错字了、或者需要安装额外的包, 然后开发人员修复了这个 Dockerfile, 再次构建, 问题解决。</li><li>第一个项目没问题了,但是第二个项目呢?虽然最初 Dockerfile 是复制、粘贴自第一个项目的,但是并不会因为第一个项目修复了 Dockerfile, 而第二个项目的 Dockerfile 就会被自动修复。</li></ul></li><li><p>那么我们可不可以做一个基础镜像, 然后各个项目使用这个基础镜像呢? 这样基础镜像更新, 各个项目不用同步Dockerfile的变化, 重新构建后就继承了基础镜像的更新?</p><ul><li><p>其实是可以的, 那么上面的这个 Dockerfile 就会变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FROM node:slim</div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</div></pre></td></tr></table></figure></li><li><p>这里我们把项目相关的构建指令拿出来, 放到子项目里去。假设这个基础镜像的名字为my-node的话, 各个项目内的自己的 Dockerfile 就变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FROM my-node</div><div class="line">COPY ./package.json /app</div><div class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ]</div><div class="line">COPY . /app/</div></pre></td></tr></table></figure><p>基础镜像变化后, 各个项目都用这个 Dockerfile 重新构建镜像, 会继承基础镜像的更新。</p></li></ul></li><li><p>此时问题只解决了一半, 如果这个Dockerfile里面有些东西需要调整, 比如 npm install 都需要加一些参数, 那怎么办?</p><ul><li>这一行 RUN 是不可能放入基础镜像的, 因为涉及到了当前项目的 ./package.json, 难道又要一个个修改么?</li><li>所以说, 这样制作基础镜像, 只解决了原来的 Dockerfile 的前4条指令的变化问题, 而后面三条指令的变化则完全没办法处理。</li></ul></li><li><p><code>ONBUILD</code> 可以解决这个问题, 用ONBUILD重新写一下基础镜像的 Dockerfile:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FROM node:slim</div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">ONBUILD COPY ./package.json /app</div><div class="line">ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]</div><div class="line">ONBUILD COPY . /app/</div><div class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</div></pre></td></tr></table></figure></li></ol><p>这次我们回到原始的 Dockerfile，但是这次将项目相关的指令加上 ONBUILD，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 Dockerfile 就变成了简单地：<code>FROM my-node</code>, 只有这么一行。<br>当在各个项目目录中, 用这个只有一行的 Dockerfile 构建镜像时, 之前基础镜像的那三行 ONBUILD 就会开始执行, 成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>, 生成应用镜像。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FROM-指定基础镜像&quot;&gt;&lt;a href=&quot;#FROM-指定基础镜像&quot; class=&quot;headerlink&quot; title=&quot;FROM 指定基础镜像&quot;&gt;&lt;/a&gt;FROM 指定基础镜像&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;所谓定制镜像, &lt;strong&gt;是以一个镜像为基础, 在
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>04.定制镜像 - Dockerfile脚本</title>
    <link href="http://blog.renyimin.com/2017/10/12/docker/2017-10-12-04-docker/"/>
    <id>http://blog.renyimin.com/2017/10/12/docker/2017-10-12-04-docker/</id>
    <published>2017-10-12T15:05:07.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Dockerfile定制镜像"><a href="#使用Dockerfile定制镜像" class="headerlink" title="使用Dockerfile定制镜像"></a>使用Dockerfile定制镜像</h2><ol><li><p>通过之前<code>docker commit</code>的学习了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 <code>Dockerfile</code>。</p></li><li><p>Dockerfile是一个文本文件，其内包含了一条条的指令, <strong>每一条指令构建一层</strong>，因此每一条指令的内容，就是描述该层应当如何构建。</p></li><li><p>在使用Dockerfile脚本定制镜像时, 有很多指令可以使用;</p></li></ol><h2 id="Dockerfile指令详解"><a href="#Dockerfile指令详解" class="headerlink" title="Dockerfile指令详解"></a>Dockerfile指令详解</h2><p>参考下一篇博文<a href="/2017/10/13/2017-10-13-05-docker/">05.Dockerfile指令详解</a></p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>1.还以之前定制 nginx 镜像为例，下面使用Dockerfile来定制</p><ul><li><p>在一个空白目录中，建立一个文本文件，并命名为 Dockerfile, 其内容为如下:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FROM nginx</div><div class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</div></pre></td></tr></table></figure></li><li><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code></p></li></ul><p>2.在 Dockerfile 文件所在目录执行</p><ul><li><p>从命令的输出结果如下</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:image_build renyimin$ docker build -t nginx:v5 .</div><div class="line">Sending build context to Docker daemon  2.048kB</div><div class="line">Step 1/2 : FROM nginx</div><div class="line"> ---&gt; e548f1a579cf</div><div class="line">Step 2/2 : RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</div><div class="line"> ---&gt; Running in 5dc1025063e7</div><div class="line"> ---&gt; 65c15ffa7c7c</div><div class="line">Removing intermediate container 5dc1025063e7</div><div class="line">Successfully built 65c15ffa7c7c</div><div class="line">Successfully tagged nginx:v5</div><div class="line">renyimindeMacBook-Pro:image_build renyimin$</div></pre></td></tr></table></figure></li><li><p>可以看到镜像的构建过程: 在Step2中, RUN指令重新启动了一个容器 <code>5dc1025063e7</code>，执行了所要求的命令，并最后提交了新的层 <code>65c15ffa7c7c</code>, 随后删除了所用到的容器<code>5dc1025063e7</code></p></li></ul><p>3.这里我们使用了 <code>docker build</code> 命令进行镜像构建, 其格式为: <code>docker build [选项] &lt;上下文路径/URL/-&gt;</code></p><ul><li>在这里我们指定了最终镜像的名称 <code>-t nginx:v5</code>，构建成功后, <code>docker images</code> 就会看到这个新镜像  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:image_build renyimin$ docker images</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">nginx                                                 v5                  65c15ffa7c7c        5 minutes ago       109MB</div></pre></td></tr></table></figure></li></ul><p>4.启动这个新镜像: <code>docker run -d -p 8098:80 --name nginx_v5 nginx:v5</code></p><ul><li><p>执行过程</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:image_build renyimin$ docker run -d -p 8098:80 --name nginx_v5 nginx:v5</div><div class="line">247dfedcf52c3cbfd652302a8f2226274661cea77200092b54044d37e0a2ae25</div><div class="line">renyimindeMacBook-Pro:image_build renyimin$ </div><div class="line">renyimindeMacBook-Pro:image_build renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</div><div class="line">247dfedcf52c        nginx:v5            &quot;nginx -g &apos;daemon ...&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8098-&gt;80/tcp     nginx_v5</div><div class="line">d762abfc1ab6        nginx:latest        &quot;nginx -g &apos;daemon ...&quot;   8 minutes ago       Up 8 minutes        0.0.0.0:8090-&gt;80/tcp     nginx_l</div><div class="line">0e7070854958        registry            &quot;/entrypoint.sh /e...&quot;   2 days ago          Up 39 hours         0.0.0.0:5000-&gt;5000/tcp   registry</div><div class="line">renyimindeMacBook-Pro:image_build renyimin$</div></pre></td></tr></table></figure></li><li><p>对比定制前后<br><img src="/img/docker/dockerfile_test_01.png" width="400/"></p></li></ul><h3 id="镜像构建上下文-Context"><a href="#镜像构建上下文-Context" class="headerlink" title="镜像构建上下文(Context)"></a>镜像构建上下文(Context)</h3><p>上面在构建镜像时, 如果注意, 会看到 <code>docker build</code> 命令最后有一个 <code>.</code>, 表示当前目录, 而 <code>Dockerfile</code> 就在当前目录, 因此不少初学者以为这个路径是在指定Dockerfile所在的路径, 但这么理解其实是不准确的。<br>这是在指定<code>上下文路径</code>, 那么什么是上下文呢?</p><ol><li><p>首先我们要理解 <code>docker build</code> 的工作原理</p><ul><li><p>Docker 在运行时分为<code>Docker引擎</code>(也就是服务端守护进程)和<code>客户端工具</code>;</p></li><li><p>Docker 的引擎提供了一组REST API, 被称为Docker Remote API, 而如docker命令这样的客户端工具, 则是通过这组 API 与 Docker 引擎交互, 从而完成各种功能, 因此, 虽然表面上我们好像是在本机执行各种docker功能, 但实际上, 一切都是使用的远程调用形式在服务端(Docker 引擎)完成。<br>也因为这种C/S设计, 让我们操作远程服务器的 Docker 引擎变得轻而易举。</p></li></ul></li><li><p>当我们进行镜像构建的时候, 并非所有定制都会通过RUN指令完成, <strong>经常会需要将一些主机本地文件复制进镜像</strong>, 比如通过<code>COPY</code>、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像, 其实并非在本地构建, 而是在服务端, 也就是Docker引擎中构建的。那么在这种客户端/服务端的架构中, 如何才能让服务端获得本地文件呢?</p></li><li><p>这就引入了上下文的概念, 当构建的时候, 用户会指定构建镜像上下文的路径, <code>docker build</code> 命令得知这个路径后, 会将路径下的所有内容打包, 然后上传给Docker引擎。这样 Docker 引擎收到这个上下文包后, 展开就会获得构建镜像所需的一切文件。</p></li><li><p>如果在 Dockerfile 中 <code>COPY ./package.json</code> 这么写:</p><ul><li>这并不是要复制你执行 <code>docker build</code> 命令时, 所在的目录下的 package.json, 也不是复制 Dockerfile 所在目录下的 package.json, 而是复制上下文(context)目录下的 package.json</li><li><strong>COPY 这类指令中的源文件的路径都是相对上下文路径的</strong></li></ul></li><li><p>理解构建上下文对于镜像构建是很重要的, 避免犯一些不应该的错误, 比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后, 于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建, 结果发现 <code>docker build</code> 执行后, 在发送一个几十GB的东西, 极为缓慢而且很容易构建失败(因为这种做法是在让 docker build 打包整个硬盘, 这显然是使用错误)。</p></li><li><p>一般来说, 应该将 <code>Dockerfile</code> 置于一个空目录下, 或者项目根目录下。</p><ul><li>如果该目录下没有所需文件, 那么应该把所需文件复制一份过来。</li><li>如果目录下有些东西确实不希望构建时传给 Docker 引擎, 那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>, 该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</li></ul></li><li><p>那么为什么会有人误以为 <code>.</code> 是指定 Dockerfile 所在目录呢?</p><ul><li>这是因为在默认情况下, 如果不额外指定 Dockerfile 的话, 会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。</li><li>这只是默认行为, 实际上Dockerfile的文件名并不要求必须为Dockerfile, 而且并不要求 必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为Dockerfile。</li></ul></li></ol><p>参考 : <a href="https://yeasy.gitbooks.io/docker_practice/content/image/commit.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/image/commit.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用Dockerfile定制镜像&quot;&gt;&lt;a href=&quot;#使用Dockerfile定制镜像&quot; class=&quot;headerlink&quot; title=&quot;使用Dockerfile定制镜像&quot;&gt;&lt;/a&gt;使用Dockerfile定制镜像&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通过之前&lt;
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
</feed>
