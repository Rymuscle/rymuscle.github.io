<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2018-04-21T11:21:42.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>03. 一些注意点</title>
    <link href="http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-03/"/>
    <id>http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-03/</id>
    <published>2018-04-21T07:50:21.000Z</published>
    <updated>2018-04-21T11:21:42.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>类常量</p><ul><li>类常量是公共的</li><li>只能通过<code>类名</code>, 使用 <code>::</code> 静态访问类常量 (也可以使用实例化的对象通过<code>::</code>来访问类常量)</li><li>客户端代码不能对其进行改变</li><li>常量属性使用 <code>const</code> 关键字来声明, 不需要使用 <code>$</code> 符号</li><li>常量属性的值只能包含<strong>基本数据类型</strong>的值, 不能将一个对象指派给常量</li><li>当需要在类的所有实例中都能访问某个属性, 并且属性值无需改变时, 应该使用常量</li></ul></li><li><p>抽象类</p><ul><li>不能实例化抽象类</li><li>抽象类中应该至少包含一个抽象方法 (但也不是强制性的)</li><li>抽象方法使用<code>abstract</code>关键字声明, 不能有具体的内容</li><li>抽象方法不能有消息体<code>{}</code>, 并且需要以<code>;</code>结束</li><li>继承抽象方法的子类必须实现抽象类中的所有抽象方法</li><li>继承抽象方法的子类实现了抽象类中的所有抽象方法之后, 还应该注意: 新实现的这个方法的访问控制权限不能比抽象方法更严格;</li></ul></li><li><p>接口</p><ul><li>接口相对于抽象类, 可能更是彻底的, 一个纯粹的模板;    </li><li>接口只能定义功能, 而不包含实现的内容;</li><li>任何实现了接口的类都需要实现接口中所定义的所有方法, 否则该类必须声明为<code>abstract</code>;</li><li>接口中的所有方法都必须声明为 <code>public</code>(或者不声明权限, 默认就为public)</li><li>接口中的所有方法不能有消息体<code>{}</code>, 并且需要以<code>;</code>结束</li><li>一个类可以同时<strong>继承一个父类</strong>和<strong>实现任意个接口</strong>, <code>extends</code>子句应该在<code>inplements</code> 子句之前;</li><li>一个比较重要的概念是: <strong>实现接口的类接受了它继承的类以及实现的接口的类型</strong>; (对于面向对象来说, 依赖抽象而不依赖具体)</li></ul></li><li><p>final关键字</p></li><li><p>~~未完待续</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;类常量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类常量是公共的&lt;/li&gt;
&lt;li&gt;只能通过&lt;code&gt;类名&lt;/code&gt;, 使用 &lt;code&gt;::&lt;/code&gt; 静态访问类常量 (也可以使用实例化的对象通过&lt;code&gt;::&lt;/code&gt;来访问类常量)&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>02. 延迟静态绑定static关键字</title>
    <link href="http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-02/"/>
    <id>http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-02/</id>
    <published>2018-04-21T07:03:35.000Z</published>
    <updated>2018-04-21T10:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>延迟静态绑定是在PHP5.3引入的;</p></li><li><p><code>static</code>类似于<code>self</code>, 但它指的是调用 包含<code>static</code>的方法 的调用类, 而不是包含<code>static</code>的类;</p></li><li><p>一般 <code>static</code> 和 <code>self</code> 的使用语法有下面两种</p><ul><li><p><code>new static()</code> 与 <code>new self()</code> (用作实例化)</p></li><li><p><code>self::</code> 与 <code>static::</code> (静态方法调用)</p></li></ul></li><li><p>如何理解第2点中的意思</p><ul><li><p>如下, <code>Male</code>与<code>Female</code> 两个类分别继承自 <code>Human</code>, 并且继承了<code>createSelf()</code>方法, 结果却发现, <code>Male</code> 和 <code>Female</code> 调用<code>createSelf()</code>后, 创建的却是 <code>Human</code> 对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Human</div><div class="line">&#123;</div><div class="line">    public function createSelf()</div><div class="line">    &#123;</div><div class="line">        return new self();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Human</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Human</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">var_dump($boy-&gt;createSelf());</div><div class="line">$girl = new Female();</div><div class="line">var_dump($girl-&gt;createSelf());</div></pre></td></tr></table></figure></li><li><p>如果<code>Human</code>是个抽象类, 你甚至无法使用 <code>new self()</code><br><img src="/img/oop/php/static-self.png" width="350/"></p></li></ul></li><li><p>而使用了<code>new static()</code>效果就不一样了</p><ul><li>下面, <code>Male</code>与<code>Female</code> 两个类分别继承自 <code>Human</code>, 并且继承了<code>createSelf()</code>方法, 结果 <code>Male</code> 和 <code>Female</code> 调用<code>createSelf()</code>后, 创建的也都是各自的对象实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">abstract class Huma</div><div class="line">&#123;</div><div class="line">    public function createSelf()</div><div class="line">    &#123;</div><div class="line">        return new static();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Huma</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Huma</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">var_dump($boy-&gt;createSelf());</div><div class="line">$girl = new Female();</div><div class="line">var_dump($girl-&gt;createSelf());</div></pre></td></tr></table></figure></li></ul></li><li><p><code>static</code> 和 <code>self</code> 在调用静态方法时也是一样的</p><ul><li><p>如下结果, 两个类都是 <code>Hello!</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">abstract class Huma</div><div class="line">&#123;</div><div class="line">    public static function createSelf()</div><div class="line">    &#123;</div><div class="line">        self::say();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;Hello!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Male&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Female&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">$boy-&gt;createSelf();</div><div class="line">$girl = new Female();</div><div class="line">$girl-&gt;createSelf();</div></pre></td></tr></table></figure></li><li><p>如果想在父类的<code>公共静态方法</code>中, 调用子类自己重载的<code>静态方法</code>, 那就需要使用 <code>static::</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">abstract class Huma</div><div class="line">&#123;</div><div class="line">    public static function createSelf()</div><div class="line">    &#123;</div><div class="line">        static::say();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;Hello!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Male&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Female&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">$boy-&gt;createSelf(); // I am a Male</div><div class="line">$girl = new Female();</div><div class="line">$girl-&gt;createSelf();   // I am a Female</div></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;延迟静态绑定是在PHP5.3引入的;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;static&lt;/code&gt;类似于&lt;code&gt;self&lt;/code&gt;, 但它指的是调用 包含&lt;code&gt;static&lt;/code&gt;的方法 的调用类, 而不是包含&lt;code&gt;s
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>01. 普通非静态 与 静态</title>
    <link href="http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-01/"/>
    <id>http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-01/</id>
    <published>2018-04-21T06:16:26.000Z</published>
    <updated>2018-04-21T10:51:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对于-属性-来说"><a href="#对于-属性-来说" class="headerlink" title="对于 属性 来说"></a>对于 <code>属性</code> 来说</h2><h3 id="类内部的调用方式"><a href="#类内部的调用方式" class="headerlink" title="类内部的调用方式"></a>类内部的调用方式</h3><ol><li><code>静态属性</code>是<strong>类</strong>的属性</li><li><code>普通属性</code>是<strong>类具体实例化出的对象</strong>的属性</li><li>所以二者是完全不同的, <code>调用方式</code>也非常不同<ul><li>静态属性 <code>self::$静态属性名</code> 、<code>类名::$静态属性名</code></li><li>普通属性 <code>$this-&gt;普通属性名</code></li></ul></li></ol><h3 id="类外部的调用方式"><a href="#类外部的调用方式" class="headerlink" title="类外部的调用方式"></a>类外部的调用方式</h3><ol><li><code>静态属性</code>是<strong>类</strong>的属性</li><li><code>普通属性</code>是<strong>类具体实例化出的对象</strong>的属性</li><li>所以二者是完全不同的, <code>调用方式</code>也非常不同<ul><li>静态属性 <code>类名::$静态属性名</code></li><li>普通属性 <code>实例化对象-&gt;普通属性名</code></li></ul></li></ol><h2 id="对于-方法-来说"><a href="#对于-方法-来说" class="headerlink" title="对于 方法 来说"></a>对于 <code>方法</code> 来说</h2><p>对于方法, 无论 <code>普通</code>还是<code>静态</code>, 它们都是属于类的, 所以理论上, 它们的调用方式 <code>-&gt;/::</code> 是可以互换的, 但事实上, 还是应该严格区分, 否则可能会报 <code>Deprecated...</code>;</p><h3 id="类内部的调用方式-1"><a href="#类内部的调用方式-1" class="headerlink" title="类内部的调用方式"></a>类内部的调用方式</h3><ol><li><code>普通方法</code> 可以使用 <code>$this-&gt;普通方法名()</code> 来进行调用;<ul><li>也可以使用 <code>self::$普通方法名()</code></li></ul></li><li><p><code>静态方法</code> 可以使用 <code>self::$静态方法名()</code> / <code>类名::$静态方法名()</code> 来进行调用;</p><ul><li>也可以使用 <code>$this-&gt;$静态方法名()</code></li></ul></li><li><p><strong>即类内部 <code>普通方法</code> 和 <code>静态方法</code> 的调用方式可以互换</strong>;</p></li></ol><h2 id="类外部的调用方式-1"><a href="#类外部的调用方式-1" class="headerlink" title="类外部的调用方式"></a>类外部的调用方式</h2><ol><li><p><code>普通方法</code> 可以使用 <code>实例化对象-&gt;普通方法名()</code> 来进行调用;</p><ul><li><strong>注意</strong>: 使用 <code>类名::普通方法名()</code> / <code>实例化对象::普通方法名()</code> 都会报 <code>Deprecated:非静态方法不应该按照镜头盖方法的调用方式来使用</code></li></ul></li><li><p><code>静态方法</code> 可以使用 <code>类名::$静态方法名()</code> 来进行调用;</p><ul><li><strong>注意</strong>：静态方法也可以使用 <code>实例化对象-&gt;普通方法名()</code> 来进行调用; (<strong>静态属性不可以</strong>)</li></ul></li></ol><h2 id="静态-非静态方法中的调用权限"><a href="#静态-非静态方法中的调用权限" class="headerlink" title="静态/非静态方法中的调用权限"></a>静态/非静态方法中的调用权限</h2><ol><li>静态方法中只能使用 静态调用方式<code>::</code>来调用 <code>静态属性</code>, <code>静态方法</code>, <code>非静态方法</code>; 不能使用<code>::</code>调用<code>非静态属性</code>;</li><li>非静态普通方法中可以调用 <code>静态/非静态</code> 的 <code>属性/方法</code>;</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>静态属性/方法, 只能通过 <code>::</code> 来访问;</li><li>普通属性只能通过 <code>-&gt;</code> 来访问; </li><li>普通方法能通过 <code>-&gt;/::</code> 来访问; (类外部只能通过<code>-&gt;</code>) </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对于-属性-来说&quot;&gt;&lt;a href=&quot;#对于-属性-来说&quot; class=&quot;headerlink&quot; title=&quot;对于 属性 来说&quot;&gt;&lt;/a&gt;对于 &lt;code&gt;属性&lt;/code&gt; 来说&lt;/h2&gt;&lt;h3 id=&quot;类内部的调用方式&quot;&gt;&lt;a href=&quot;#类内部的调用方式
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://blog.renyimin.com/2018/04/08/2018-04-08-rsa-01/"/>
    <id>http://blog.renyimin.com/2018/04/08/2018-04-08-rsa-01/</id>
    <published>2018-04-08T02:41:16.000Z</published>
    <updated>2018-04-08T05:14:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>加密和解密使用同样的规则(“密钥”);</p><ul><li>这种加密模式有一个最大弱点: 甲方必须把加密规则告诉乙方, 否则乙方无法解密; 这样, <code>保存和传递密钥</code> 就成了最头疼的问题;</li></ul><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li><p>非对称加密算法模式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">乙方生成两把密钥(公钥和私钥): 公钥是公开的, 任何人都可以获得, 私钥则是保密的;</div><div class="line">甲方获取乙方的公钥, 然后用它对信息加密;</div><div class="line">乙方得到加密后的信息, 用私钥解密;</div></pre></td></tr></table></figure></li><li><p><strong>如果公钥加密的信息只有私钥解得开, 那么只要私钥不泄漏, 通信就是安全的</strong>;</p></li><li><p>所谓非对称加密，其实很简单，就是加密和解密需要两把钥匙: 一把公钥和一把私钥;</p><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3></li><li><p>1977年, 三位数学家Rivest、Shamir 和 Adleman 设计了一种算法, 可以实现<code>非对称加密</code>, 这种算法用他们三个人的名字命名, 叫做<code>RSA算法</code>。从那时直到现在, RSA算法一直是最广为使用的”非对称加密算法”。<br> 毫不夸张地说, 只要有计算机网络的地方, 就有RSA算法;</p></li><li><p>这种算法非常可靠, 密钥越长, 它就越难破解。根据已经披露的文献, 目前被破解的最长RSA密钥是768个二进制位, 也就是说, 长度超过768位的密钥, 还无法破解(至少没人公开宣布)。<br> 因此可以认为, <strong>1024位的RSA密钥基本安全, 2048位的密钥极其安全</strong>;</p></li></ol><h3 id="RSA算法的原理"><a href="#RSA算法的原理" class="headerlink" title="RSA算法的原理"></a>RSA算法的原理</h3><p>RSA算法并不难, 只需要一点数论知识就可以理解 (要用到的四个数学概念)</p><p>~~ 未完待续</p><ol><li>互质关系<br> 如果两个正整数, 除了1以外, 没有其他公因子，我们就称这两个数是<code>互质关系</code>(coprime), 比如, 15和32没有公因子, 所以它们是互质关系;<br> 这说明, 不是质数也可以构成互质关系。(质数(prime number)又称素数, 有无限个, 质数定义为在大于1的自然数中, 除了1和它本身以外不再有其他因数)     </li><li>关于互质关系, 不难得到以下结论:<ul><li>任意两个质数构成互质关系, 比如13和61;</li><li>一个数是质数, 另一个数只要不是前者的倍数, 两者就构成互质关系, 比如3和10;</li><li>如果两个数之中, 较大的那个数是质数, 则两者构成互质关系, 比如97和57;</li><li>1和任意一个自然数是都是互质关系，比如1和99;</li><li>p是大于1的整数, 则p和p-1构成互质关系, 比如57和56;</li><li>p是大于1的奇数, 则p和p-2构成互质关系, 比如17和15;</li></ul></li><li></li></ol><p><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对称加密算法&quot;&gt;&lt;a href=&quot;#对称加密算法&quot; class=&quot;headerlink&quot; title=&quot;对称加密算法&quot;&gt;&lt;/a&gt;对称加密算法&lt;/h2&gt;&lt;p&gt;加密和解密使用同样的规则(“密钥”);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这种加密模式有一个最大弱点: 甲方必须把加
      
    
    </summary>
    
      <category term="RSA" scheme="http://blog.renyimin.com/categories/RSA/"/>
    
    
      <category term="RSA" scheme="http://blog.renyimin.com/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>PHP7语法新特性</title>
    <link href="http://blog.renyimin.com/2018/04/04/PHP/2018-04-04-php7new-base/"/>
    <id>http://blog.renyimin.com/2018/04/04/PHP/2018-04-04-php7new-base/</id>
    <published>2018-04-04T01:32:02.000Z</published>
    <updated>2018-04-04T02:30:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="null合并运算符"><a href="#null合并运算符" class="headerlink" title="null合并运算符 ??"></a>null合并运算符 <code>??</code></h3><ol><li><p><code>??</code> : 如果变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数;</p></li><li><p>先回顾一下 <code>isset</code> 用法: 只有 <code>显示声明为null</code> 或者 <code>未声明</code> 的变量, isset的结果为false</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$a = 0;</div><div class="line">$b = 0.0;</div><div class="line">$c = &apos;&apos;;</div><div class="line">$d = &apos;0&apos;;</div><div class="line">$e = &apos;0.0&apos;;</div><div class="line">$f = &apos;null&apos;;</div><div class="line">$g = [];</div><div class="line">$h = [&apos;name&apos; =&gt; &apos;renyimin&apos;, &apos;age&apos; =&gt; null];</div><div class="line">$i = null;</div><div class="line">var_dump(isset($a));    // true</div><div class="line">var_dump(isset($b));    // true</div><div class="line">var_dump(isset($c));    // true</div><div class="line">var_dump(isset($d));    // true</div><div class="line">var_dump(isset($e));    // true</div><div class="line">var_dump(isset($f));    // true</div><div class="line">var_dump(isset($g));    // true</div><div class="line"></div><div class="line">var_dump(isset($h[&apos;age&apos;])); // false</div><div class="line">// 注意: array_key_exists 即使键的值为null, 结果也是true</div><div class="line">var_dump(array_key_exists(&apos;age&apos;, $h));  // true</div><div class="line"></div><div class="line">var_dump(isset($h[&apos;address&apos;])); // false</div><div class="line">// 注意: array_key_exists 即使键的值为null, 结果也是true, 除非键真的不存在</div><div class="line">var_dump(array_key_exists(&apos;address&apos;, $h));  // false</div><div class="line"></div><div class="line">var_dump(isset($h[&apos;address&apos;])); // false</div><div class="line">var_dump(isset($i));    // false</div><div class="line">var_dump(isset($j));    // false</div></pre></td></tr></table></figure></li><li><p><code>??</code> 示例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$a = 0;</div><div class="line">$c = $a ?? 10;  // 相当于 $c = isset($a) ? $a : 10;</div><div class="line">echo $c;</div></pre></td></tr></table></figure></li></ol><p>~~ 未完待续</p><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;null合并运算符&quot;&gt;&lt;a href=&quot;#null合并运算符&quot; class=&quot;headerlink&quot; title=&quot;null合并运算符 ??&quot;&gt;&lt;/a&gt;null合并运算符 &lt;code&gt;??&lt;/code&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;??&lt;/code
      
    
    </summary>
    
      <category term="PHP" scheme="http://blog.renyimin.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.renyimin.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>103. 分区管理</title>
    <link href="http://blog.renyimin.com/2018/03/28/mysql/2018-03-28-mysql-103/"/>
    <id>http://blog.renyimin.com/2018/03/28/mysql/2018-03-28-mysql-103/</id>
    <published>2018-03-28T02:41:26.000Z</published>
    <updated>2018-03-28T02:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h2><p>MySQL5.1 提供了许多修改分区表的方式, 添加、删除、重新定义、合并或拆分已经存在的分区是可能的, 所有这些操作都可以通过使用<code>ALTER TABLE</code>命令的分区扩展来实现; 当然, 也有获得分区表和分区信息的方式;</p><h3 id="drop删除分区及数据"><a href="#drop删除分区及数据" class="headerlink" title="drop删除分区及数据"></a>drop删除分区及数据</h3><ol><li><p><code>mysql&gt; alter table user drop partition p4;</code></p></li><li><p><strong>注意</strong>: </p><ul><li><p>只能对每个分区进行删除, 不能针对每个子分区进行删除操作, 删除分区后子分区连同数据一并被删除;</p></li><li><p>删除分区后, 数据也被删除了;</p></li><li><p><strong><code>drop partition</code>删除分区的语法, 只能用于 <code>range/list</code> 分区</strong> (如果用来删除hash分区或者key分区,则会报错)</p></li><li><p>如果要删除 <code>hash/key</code> 分区, 则直接使用下面remove来移除分区即可, 一般也不直接删除数据;</p></li></ul></li></ol><h3 id="remove移除分区"><a href="#remove移除分区" class="headerlink" title="remove移除分区"></a>remove移除分区</h3><ol><li><p>使用remove移除分区, 注意仅仅是移除分区, <strong>并不会删除数据</strong> (和drop PARTITION不一样, 后者会连同数据一起删除)</p></li><li><p><code>ALTER TABLE tablename REMOVE PARTITIONING;</code> 这样就可以将一个原本分区的数据表变成不分区的表</p><ul><li><p>移除分区前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">0B    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p><code>ALTER TABLE</code>user<code>REMOVE PARTITIONING;</code> 移除分区后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user.MYD</div><div class="line">4.0K    user.MYI</div><div class="line">12K    user.frm</div></pre></td></tr></table></figure></li></ul></li><li><p>注意: 该语法是可以适用于 <code>range/list/key/hash</code> 类型的分区的;</p></li></ol><h3 id="创建不同类型分区"><a href="#创建不同类型分区" class="headerlink" title="创建不同类型分区"></a>创建不同类型分区</h3><h3 id="分区创建索引-整表创建索引"><a href="#分区创建索引-整表创建索引" class="headerlink" title="分区创建索引(整表创建索引)"></a>分区创建索引(整表创建索引)</h3><h3 id="新增分区"><a href="#新增分区" class="headerlink" title="新增分区"></a>新增分区</h3><h3 id="新增不同类型分区"><a href="#新增不同类型分区" class="headerlink" title="新增不同类型分区"></a>新增不同类型分区</h3><h3 id="合并分区"><a href="#合并分区" class="headerlink" title="合并分区"></a>合并分区</h3><ol><li><p>原本分区结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">4.0K    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p>合并 p2, p3这两个分区 </p><ul><li>分区并无子分区<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE tb_sub_ev REORGANIZE PARTITION p2,p3 INTO (</div><div class="line">    PARTITION m_p2_p3 VALUES LESS THAN (2000)</div><div class="line">    ( SUBPARTITION n0,</div><div class="line">        SUBPARTITION n1</div><div class="line">    ) </div><div class="line">);</div></pre></td></tr></table></figure></li></ul></li></ol><h3 id="拆分分区"><a href="#拆分分区" class="headerlink" title="拆分分区"></a>拆分分区</h3><h3 id="重新分区"><a href="#重新分区" class="headerlink" title="重新分区"></a>重新分区</h3><h2 id="每日自动新增分区"><a href="#每日自动新增分区" class="headerlink" title="每日自动新增分区"></a>每日自动新增分区</h2><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分区管理&quot;&gt;&lt;a href=&quot;#分区管理&quot; class=&quot;headerlink&quot; title=&quot;分区管理&quot;&gt;&lt;/a&gt;分区管理&lt;/h2&gt;&lt;p&gt;MySQL5.1 提供了许多修改分区表的方式, 添加、删除、重新定义、合并或拆分已经存在的分区是可能的, 所有这些操作都可以
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>102. 分区键, 主键, 唯一索引关系</title>
    <link href="http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-102/"/>
    <id>http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-102/</id>
    <published>2018-03-27T07:46:51.000Z</published>
    <updated>2018-03-28T02:09:40.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>若表有 <code>primary key</code> 或 <code>unique key</code>, 在对表进行分区时, 需要注意: <code>分区键</code> 必须包含在primary key或unique key列内, 这是为了确保主键的效率, 否则同一主键区的数据一个在Ａ分区, 一个在Ｂ分区, 显然会比较麻烦;<br> 可以说: 在分区表上, 用于分区表达式里的每一个字段都必须是<code>唯一性索引</code>的<code>一部分</code>;</p></li><li><p>如何理解上面的概念?</p></li><li><p>如果表中既有<code>主键</code>, 也有<code>唯一索引</code>: 无论<code>单列键</code>还是<code>多列键</code>分区都会失败</p><ul><li><p>单列唯一索引键分区报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `user` (  </div><div class="line">    `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;,  </div><div class="line">    `name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">    `sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男，1为女&apos;,</div><div class="line">`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,</div><div class="line">    PRIMARY KEY (`id`),</div><div class="line">UNIQUE KEY `age_unique` (`age`)</div><div class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8</div><div class="line">PARTITION BY RANGE COLUMNS (`age`)</div><div class="line">(</div><div class="line">PARTITION p0 VALUES LESS THAN (3),  </div><div class="line">PARTITION p1 VALUES LESS THAN (6),</div><div class="line">PARTITION p2 VALUES LESS THAN (9),  </div><div class="line">PARTITION p3 VALUES LESS THAN (12),  </div><div class="line">PARTITION p4 VALUES LESS THAN (MAXVALUE)</div><div class="line">);</div><div class="line">// 1503 - A PRIMARY KEY must include all columns in the table&apos;s partitioning function, Time: 0.011000s</div></pre></td></tr></table></figure></li><li><p>单列主键分区报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>),</p><pre><code>UNIQUE KEY `age_unique` (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);<br>// 1503 - A UNIQUE INDEX must include all columns in the table’s partitioning function, Time: 0.008000s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 多列(主键和唯一索引键)分区报错</div></pre></td></tr></table></figure><p>// 两列做分区也是失败的, 如下会报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>),</p><pre><code>UNIQUE KEY `age_unique` (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>,<code>age</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3, 10),<br>  PARTITION p1 VALUES LESS THAN (6, 15),<br>  PARTITION p2 VALUES LESS THAN (9, 20),<br>  PARTITION p3 VALUES LESS THAN (12, 25),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);<br>// 1503 - A PRIMARY KEY must include all columns in the table’s partitioning function, Time: 0.012000s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">4. 表中只有`主键`: 分区键属于主键内的键即可 (多列分区, 需要将列与主键一起作为主键才行)</div><div class="line">    - 分区键属于主键内的键即可</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 如果想多列分区, 则需要将多余的列与主键一起作为主键</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>, <code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>,<code>age</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3, 10),<br>  PARTITION p1 VALUES LESS THAN (6, 15),<br>  PARTITION p2 VALUES LESS THAN (9, 20),<br>  PARTITION p3 VALUES LESS THAN (12, 25),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">5. 表中只有`唯一索引`: 分区键属于`唯一索引键`内的键即可 (多列分区, 需要将多个列一起作为唯一索引)</div><div class="line">    - 分区键属于`唯一索引键`内的键即可</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  UNIQUE KEY (<code>id</code>, <code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 多列分区报错(竟然是报主键错): 1503 - A PRIMARY KEY must include all columns in the table&apos;s partitioning function, Time: 0.012000s</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br><code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br><code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br><code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,<br>  <code>age</code> int(2) NOT NULL DEFAULT ‘0’ COMMENT ‘年龄’,<br>UNIQUE KEY id_u (<code>id</code>),<br>  UNIQUE KEY age_u (<code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>, <code>age</code>)<br>(<br>PARTITION p0 VALUES LESS THAN (3,10),<br>PARTITION p1 VALUES LESS THAN (6,15),<br>PARTITION p2 VALUES LESS THAN (9,20),<br>PARTITION p3 VALUES LESS THAN (12,25),<br>PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- **多个唯一索引: 无论单列分区还是多列分区, 都会报错**</div></pre></td></tr></table></figure><p>// 单列分区报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  UNIQUE KEY id_u (<code>id</code>),</p><pre><code>UNIQUE KEY age_u (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);<br>```</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li></ul></li></ol><ul><li>要进行分区, 表中不能同时存在<code>主键</code>和<code>唯一索引键</code>, 也不能存在多个唯一索引键;</li><li>分区的键必须包含在<code>主键</code>内 或者 包含在<code>唯一索引键</code>内;</li><li>本篇只是测试了<code>range</code>这种分区类型, 其实上面的限制对于<code>range/list/hash/key</code>类型的分区都适用;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;若表有 &lt;code&gt;primary key&lt;/code&gt; 或 &lt;code&gt;unique key&lt;/code&gt;, 在对表进行分区时, 需要注意: &lt;code&gt;分区键&lt;/code&gt; 必须包含在primary key或unique key列内, 这是为了确保主键
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>101. 分区,分表,分库</title>
    <link href="http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-101/"/>
    <id>http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-101/</id>
    <published>2018-03-27T03:37:12.000Z</published>
    <updated>2018-03-28T02:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>MySQL是从5.1开始支持分区功能的, 在MySQL中, 数据是以文件的形势存在磁盘上的, 默认放在 ‘/mysql/data/‘ 下(可以通过my.cnf中的datadir来指定)</p></li><li><p>MyISAM引擎中, 一张表主要对应着三个文件: </p><ul><li><code>.frm</code>(与表相关的元数据信息都存放在frm文件, 包括表结构的定义信息等)</li><li><code>.myd</code>(存放表数据)</li><li><code>.myi</code>(存表索引)</li></ul></li><li><p>InnoDB引擎中, 一张表也是对应着三个文件: </p><ul><li><code>.frm</code>(和MyISAM差不多)</li><li><code>.ibd</code>文件和<code>.ibdata</code>文件, 都是存放innodb数据的文件, 之所以用两种文件来存放innodb的数据, 是因为innodb的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据, 还是用独享表空间存放存储数据<br>独享表空间存储方式使用.ibd文件,并且每个表一个ibd文件;<br>共享表空间存储方式使用.ibdata文件，所有表共同使用一个ibdata文件<br>可在mysql的配置文件通过<code>innodb_file_per_table</code>进行配置</li></ul></li><li><p>如果一张表的数据量太大, <code>.ibd</code>, <code>.myd</code>, <code>.myi</code> 之类的文件就会变的很大, 查找数据就会变的很慢, 此时就可以利用mysql的分区功能, 在物理上将这一张表对应的三个文件, 分割成许多个小块, 这样之后, 如果查找一条数据时, 就不用全部查找了, 只要知道这条数据在哪一块, 然后在那一块找即可;<br> 如果表的数据太大, 可能一个磁盘放不下, 此时, 还可以把数据分配到不同的磁盘里面去;</p></li></ol><h2 id="查看当前MySQL版本是否支持分区"><a href="#查看当前MySQL版本是否支持分区" class="headerlink" title="查看当前MySQL版本是否支持分区"></a>查看当前MySQL版本是否支持分区</h2><ol><li><p>对于MySQL5.6以下版本, 如果查询结果显示Empty, 表示不支持分区:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show variables like &apos;%partition%&apos;;</div><div class="line">Empty set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>对于mysql5.6以及以上版本, 需要使用下面的查询命令:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show plugins;</div></pre></td></tr></table></figure><p> 上面的查询方法会显示所有插件, 如果有如下插件的话, 表示支持分区:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| partition                  | ACTIVE   | STORAGE ENGINE     | NULL    | GPL     |</div></pre></td></tr></table></figure></li></ol><h2 id="分区的2种方式"><a href="#分区的2种方式" class="headerlink" title="分区的2种方式"></a>分区的2种方式</h2><h3 id="横向分区"><a href="#横向分区" class="headerlink" title="横向分区"></a>横向分区</h3><p>横向分区: 比如, 有1000W条数据, 分成十份, 前10W条数据放到第一个分区, 第二个10W条数据放到第二个分区, 依此类推; </p><ul><li>也就是把表分成了十份(和使用<code>merge</code>来分表有点像, 取出一条数据的时候, 这条数据包含了表结构中的所有字段);</li><li>横向分区, 并没有改变表的结构;</li></ul><h3 id="纵向分区"><a href="#纵向分区" class="headerlink" title="纵向分区"></a>纵向分区</h3><p>纵向分区: 比如, 在设计用户表的时候, 开始的时候没有考虑好, 把用户的所有信息都放到了一张表里面去, 这样这个表里面就会有比较大的字段, 如个人简介..等, 而这些简介也许不会有好多人去看，所以等到有人要看的时候, 再去查找(分表的时候, 可以把这样的大字段与主表分开来);</p><h2 id="横向分区-1"><a href="#横向分区-1" class="headerlink" title="横向分区"></a>横向分区</h2><p>mysql提供的分区属于第一种 <code>横向分区</code>, 并且细分成很多种方式</p><h3 id="range分区"><a href="#range分区" class="headerlink" title="range分区"></a>range分区</h3><ol><li><p>按照<code>RANGE</code>分区的表是通过如下方式进行分区的, 分区表达式的值位于一个给定的连续区间内的那些行, 会被放到一个分区中</p><ul><li><p>创建表同时进行分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `user` (  </div><div class="line">`id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;,  </div><div class="line">`name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">`sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男，1为女&apos;,  </div><div class="line">PRIMARY KEY (`id`)  </div><div class="line">) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1  </div><div class="line">PARTITION BY RANGE (id) (  </div><div class="line">PARTITION p0 VALUES LESS THAN (3),  </div><div class="line">PARTITION p1 VALUES LESS THAN ( 6 ),</div><div class="line">PARTITION p2 VALUES LESS THAN (9),  </div><div class="line">PARTITION p3 VALUES LESS THAN (12),  </div><div class="line">PARTITION p4 VALUES LESS THAN MAXVALUE  </div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>查看分区效果 (到数据表文件的存放处 <code>$ cd /Library/Application\ Support/appsolute/MAMP\ PRO/db/mysql56/</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">0B    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">0B    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">0B    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">0B    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">0B    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p>插入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">INSERT INTO `test`.`user` (`name` ,`sex`)VALUES (&apos;tank&apos;, &apos;0&apos;)  </div><div class="line">,(&apos;zhang&apos;,1),(&apos;ying&apos;,1),(&apos;张&apos;,1),(&apos;映&apos;,0),(&apos;test1&apos;,1),(&apos;tank2&apos;,1)  </div><div class="line">,(&apos;tank1&apos;,1),(&apos;test2&apos;,1),(&apos;test3&apos;,1),(&apos;test4&apos;,1),(&apos;test5&apos;,1),(&apos;tank3&apos;,1)  </div><div class="line">,(&apos;tank4&apos;,1),(&apos;tank5&apos;,1),(&apos;tank6&apos;,1),(&apos;tank7&apos;,1),(&apos;tank8&apos;,1),(&apos;tank9&apos;,1)  </div><div class="line">,(&apos;tank10&apos;,1),(&apos;tank11&apos;,1),(&apos;tank12&apos;,1),(&apos;tank13&apos;,1),(&apos;tank21&apos;,1),(&apos;tank42&apos;,1);</div></pre></td></tr></table></figure></li><li><p>再次查看分区效果<br>如下可以看到, 文件大小都是4.0K, 从这儿我们可以看出<strong>MyISAM引擎下, 分区的最小区块是4K (InnoDB貌似是96k)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">4.0K    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li></ul></li><li><p>数据测试</p><ul><li><p>初始数据为25条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select count(id) as count from user;</div><div class="line">+-------+</div><div class="line">| count |</div><div class="line">+-------+</div><div class="line">|    25 |</div><div class="line">+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>删除第四个分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; alter table user drop partition p4; </div><div class="line">Query OK, 0 rows affected (0.15 sec)</div><div class="line">Records: 0  Duplicates: 0  Warnings: 0</div></pre></td></tr></table></figure></li><li><p>可以发现, 存放在第四个分区里面的14条数据丢失了, 剩下的3个分区只有11条数据  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select count(id) as count from user; </div><div class="line">+-------+</div><div class="line">| count |</div><div class="line">+-------+</div><div class="line">|    11 |</div><div class="line">+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>查看分区文件, 发现第四个分区确实被删除了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li></ul></li><li><p>小结: 可以发现, 在进行range分区后</p><ul><li>会生成一个 <code>.par</code>文件,用来存储分区信息;</li><li>MyISAM/InnoDB引擎, 原有的 <code>.frm</code> 表结构文件没有被分隔;</li><li>MyISAM引擎, 原有的 <code>.MYD</code>数据文件, <code>.MYI</code>索引文件都被分隔了;</li><li>InnoDB引擎, 原有的 <code>.idb</code>数据文件被分隔了;</li></ul></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li></ul></li></ol><h3 id="List分区"><a href="#List分区" class="headerlink" title="List分区"></a>List分区</h3><ol><li><p>RANGE分区是从属于一个连续区间值的集合, 而LIST分区是基于某列的值从属于一个值列表集中的一个值</p></li><li><p>如果不用主键, 如下list分区可以创建成功，一般情况下, 一张表肯定会有一个主键(所以如果需要用其他键来做分区, 参考下一篇博文<a href="2017/12/17/mysql/2017-12-17-mysql-102/">分区键, 主键, 唯一索引关系</a>)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `list_part` (  </div><div class="line">`id` int(11) NOT NULL COMMENT &apos;用户ID&apos;,  </div><div class="line">`province_id` int(2) NOT NULL DEFAULT 0 COMMENT &apos;省&apos;,  </div><div class="line">`name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">`sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男, 1为女&apos;</div><div class="line">) ENGINE=INNODB DEFAULT CHARSET=utf8</div><div class="line">PARTITION BY LIST (province_id) (  </div><div class="line">PARTITION p0 VALUES IN (1,2,3,4,5,6,7,8),  </div><div class="line">PARTITION p1 VALUES IN (9,10,11,12,16,21),  </div><div class="line">PARTITION p2 VALUES IN (13,14,15,19),  </div><div class="line">PARTITION p3 VALUES IN (17,18,20,22,23,24)</div><div class="line">);</div><div class="line"></div><div class="line">// 创建成功, 会看到分区效果 (InnoDB默认分区最小是96k)</div><div class="line">$ ls |grep list_part |xargs du -sh</div><div class="line">96K    list_part#P#p0.ibd</div><div class="line">96K    list_part#P#p1.ibd</div><div class="line">96K    list_part#P#p2.ibd</div><div class="line">96K    list_part#P#p3.ibd</div><div class="line">12K    list_part.frm</div><div class="line">4.0K    list_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="hash分区"><a href="#hash分区" class="headerlink" title="hash分区"></a>hash分区</h3><ol><li><p>HASH分区主要用来确保数据在预先确定数目的分区中平均分布, 你所要做的只是</p><ul><li>对将要被哈希的列值, 指定一个列值或表达式;</li><li>指定被分区的表将要被分割成的分区数量;</li><li>对HASH分区，使用的用户函数必须返回一个大于0的整数值;</li></ul></li><li><p>创建表同时进行hash分区</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `hash_part` (  </div><div class="line">`id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;评论ID&apos;,  </div><div class="line">`comment` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;评论&apos;,  </div><div class="line">`ip` varchar(25) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;来源IP&apos;,  </div><div class="line">PRIMARY KEY (`id`)  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1  </div><div class="line">PARTITION BY HASH(id)  </div><div class="line">PARTITIONS 3;</div></pre></td></tr></table></figure></li><li><p>查看分区效果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ls |grep hash_part |xargs du -sh</div><div class="line">96K    hash_part#P#p0.ibd</div><div class="line">96K    hash_part#P#p1.ibd</div><div class="line">96K    hash_part#P#p2.ibd</div><div class="line">12K    hash_part.frm</div><div class="line">4.0K    hash_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="key分区"><a href="#key分区" class="headerlink" title="key分区"></a>key分区</h3><ol><li><p>按照KEY进行分区, 类似于按照HASH分区</p><ul><li>HASH分区是使用用户定义的表达式</li><li>而KEY分区的哈希函数是由MySQL服务器提供</li></ul></li><li><p>创建表同时进行key分区</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `key_part` (  </div><div class="line">`news_id` int(11) NOT NULL  COMMENT &apos;新闻ID&apos;,  </div><div class="line">`content` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;新闻内容&apos;,  </div><div class="line">`u_id` varchar(25) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;来源IP&apos;,  </div><div class="line">`create_time` DATE NOT NULL DEFAULT &apos;0000-00-00 00:00:00&apos; COMMENT &apos;时间&apos;  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8  </div><div class="line">PARTITION BY LINEAR HASH(YEAR(create_time))  </div><div class="line">PARTITIONS 3;</div></pre></td></tr></table></figure></li><li><p>查看分区效果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ls |grep key_part |xargs du -sh</div><div class="line">96Kkey_part#P#p0.ibd</div><div class="line">96Kkey_part#P#p1.ibd</div><div class="line">96Kkey_part#P#p2.ibd</div><div class="line">12Kkey_part.frm</div><div class="line">4.0Kkey_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h3><ol><li><p>子分区是分区表中每个分区的再次分割, 对于已经通过<code>RANGE</code>或<code>LIST</code>分区了的表再进行子分区是可能的, 子分区既可以使用<code>HASH</code>分区, 也可以使用<code>KEY</code>分区; 这也被称为复合分区(composite partitioning)</p><ul><li>如果一个分区中创建了子分区, 其他分区也要有子分区</li><li>如果创建了子分区, 每个分区中的<strong>子分区数必须相同</strong></li><li>同一分区内的子分区, 名字不相同, 不同分区内的子分区名子可以相同(5.1.50不适用)</li></ul></li><li><p>创建表同时, 进行子分区操作</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `sub_part` (  </div><div class="line">`news_id` int(11) NOT NULL  COMMENT &apos;新闻ID&apos;,  </div><div class="line">`content` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;新闻内容&apos;,  </div><div class="line">`u_id`  int(11) NOT NULL DEFAULT 0 COMMENT &apos;来源IP&apos;,  </div><div class="line">`create_time` DATE NOT NULL DEFAULT &apos;0000-00-00 00:00:00&apos; COMMENT &apos;时间&apos;  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8  </div><div class="line">PARTITION BY RANGE(YEAR(create_time))  </div><div class="line">SUBPARTITION BY HASH(TO_DAYS(create_time))(  </div><div class="line">    PARTITION p0 VALUES LESS THAN (1990)(</div><div class="line">        SUBPARTITION s0,SUBPARTITION s1,SUBPARTITION s2</div><div class="line">    ),  </div><div class="line">    PARTITION p1 VALUES LESS THAN (2000)(</div><div class="line">        SUBPARTITION s3,SUBPARTITION s4,SUBPARTITION good</div><div class="line">    ),  </div><div class="line">    PARTITION p2 VALUES LESS THAN MAXVALUE(</div><div class="line">        SUBPARTITION tank0,SUBPARTITION tank1,SUBPARTITION tank3</div><div class="line">    )  </div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>查看分区后, 数据表文件结构</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ ls |grep sub_part |xargs du -sh</div><div class="line">96K    sub_part#P#p0#SP#s0.ibd</div><div class="line">96K    sub_part#P#p0#SP#s1.ibd</div><div class="line">96K    sub_part#P#p0#SP#s2.ibd</div><div class="line">96K    sub_part#P#p1#SP#good.ibd</div><div class="line">96K    sub_part#P#p1#SP#s3.ibd</div><div class="line">96K    sub_part#P#p1#SP#s4.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank0.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank1.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank3.ibd</div><div class="line">12K    sub_part.frm</div><div class="line">4.0K    sub_part.par</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;MySQL是从5.1开始支持分区功能的, 在MySQL中, 数据是以文件的形势存在磁盘上的, 默认放在 ‘/mysql/d
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>yield 协程</title>
    <link href="http://blog.renyimin.com/2018/01/13/PHP/2018-01-13-yield/"/>
    <id>http://blog.renyimin.com/2018/01/13/PHP/2018-01-13-yield/</id>
    <published>2018-01-13T05:20:31.000Z</published>
    <updated>2018-04-04T09:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h2 id="迭代生成器"><a href="#迭代生成器" class="headerlink" title="迭代生成器"></a>迭代生成器</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li><p>(迭代)生成器也是一个函数, 返回的是一个<code>迭代器</code>, 而这个<code>迭代器</code>实现了<code>Iterator接口</code>, 所以叫<code>迭代生成器</code>;</p></li><li><p>和普通函数不同, 由于(迭代)生成器返回的是一个迭代器, 所以(迭代)生成器函数中的返回值可以依次返回, 而不是只返回一个单独的值; 或者换句话说, (迭代)生成器使你能更方便的实现了迭代器接口;</p></li><li><p>引用网上常见的示例</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">function xrange($start, $end, $step = 1) &#123;</div><div class="line">    for ($i = $start; $i &lt;= $end; $i += $step) &#123;</div><div class="line">        yield $i;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// var_dump(xrange(1, 1000000));   // object(Generator)[1]</div><div class="line">foreach (xrange(1, 1000000) as $num) &#123;</div><div class="line">    echo $num;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>上面这个 xrange() 函数提供了和PHP的内建函数range()一样的功能, 但是不同的是range()函数返回的是一个包含值从1到100万0的数组; <strong>而xrange()函数返回的是依次输出这些值的一个迭代器, 而不会真正以数组形式返回</strong>;</p><ul><li>这种方法的优点是显而易见的, 它可以让你在处理大数据集合的时候不用一次性的加载到内存中, 甚至你可以处理无限大的数据流;</li><li>当然, 也可以不通过生成器来实现这个功能, 而是可以通过继承Iterator接口实现, 但通过使用生成器实现起来会更方便, 不用再去实现iterator接口中的5个方法了;</li></ul></li></ol><h3 id="生成器内部"><a href="#生成器内部" class="headerlink" title="生成器内部"></a>生成器内部</h3><ol><li><p>要从<code>生成器</code>认识<code>协程</code>, 理解它内部是如何工作是非常重要的: 生成器是一种可中断的函数, 在它里面的<code>yield</code>构成了中断点;<br> 像上面的例子, 调用xrange(1,1000000)的时候, xrange()函数里代码其实并没有真正地运行, 它只是返回了一个迭代器;</p></li><li><p>调用迭代器的方法一次, 其中的代码运行一次, 例如:</p><ul><li>如果你调用生成器返回的迭代器的rewind方法 <code>$range-&gt;rewind()</code>, 那么xrange()里的代码就会运行到控制流第一次出现yield的地方, 而函数内传递给yield语句的返回值, 可以通过$range-&gt;current()获取;</li><li>为了继续执行生成器中yield后的代码, 你就需要调用迭代器的 <code>$range-&gt;next()</code> 方法, 这将再次启动生成器, 直到下一次yield语句出现; 因此, 连续调用next()和current()方法, 你就能从生成器里获得所有的值,直到再没有yield语句出现;</li><li>对xrange()来说, 这种情形出现在$i超过$end时, 在这种情况下, 控制流将到达函数的终点, 因此将不执行任何代码, 一旦这种情况发生, vaild()方法将返回假, 这时迭代结束;</li><li><p>示例1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">function gen() &#123;</div><div class="line">    var_dump(&apos;cat&apos;);</div><div class="line">    yield &apos;t&apos;;</div><div class="line">    var_dump(&apos;dog&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$gen = gen();</div><div class="line">$gen-&gt;rewind();   // 指针会走到第一个yield处, 所以会经过 cat</div><div class="line">var_dump($gen-&gt;current());  // 获取第一个yield处的值</div><div class="line">var_dump(&apos;----------&apos;);</div><div class="line">$gen-&gt;next();  // 会往下走, 走到下一个yield处, 所以会经过 dog</div><div class="line">var_dump($gen-&gt;current());  // 获取下一个yield处的值 (但是后面已经没有yield了, 所以为null)</div><div class="line"></div><div class="line">// 结果:</div><div class="line">string(3) &quot;cat&quot;</div><div class="line">string(1) &quot;t&quot;</div><div class="line">string(10) &quot;----------&quot;</div><div class="line">string(3) &quot;dog&quot;</div><div class="line">NULL</div></pre></td></tr></table></figure></li><li><p>示例2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">function gen() &#123;</div><div class="line">    var_dump(&apos;cat&apos;);</div><div class="line">    yield &apos;t&apos;;</div><div class="line">    var_dump(&apos;dog&apos;);</div><div class="line">    yield &apos;g&apos;;</div><div class="line">    var_dump(&apos;pig&apos;);</div><div class="line">    yield &apos;p&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$gen = gen();</div><div class="line">$gen-&gt;rewind();   // 指针会走到第一个yield处, 所以会经过 cat</div><div class="line">var_dump($gen-&gt;current());  // 获取第一个yield处的值</div><div class="line">var_dump(&apos;----------&apos;);</div><div class="line"></div><div class="line">$gen-&gt;next();  // 会往下走, 走到下一个yield处, 所以会经过 dog</div><div class="line">var_dump($gen-&gt;current());  // 获取下一个yield处的值 (但是后面已经没有yield了, 所以为null)</div><div class="line">var_dump(&apos;----------&apos;);</div><div class="line"></div><div class="line">$gen-&gt;next();  // 会往下走, 走到下一个yield处, 所以会经过 pig</div><div class="line">var_dump($gen-&gt;current());  // 获取下一个yield处的值 (p)</div><div class="line"></div><div class="line">var_dump(&apos;----------&apos;);</div><div class="line">$gen-&gt;next();  // 会往下走, 什么也没有</div><div class="line">var_dump($gen-&gt;current());  // 获取下一个yield处的值 (为null)</div><div class="line"></div><div class="line">// 结果</div><div class="line">string(3) &quot;cat&quot;</div><div class="line">string(1) &quot;t&quot;</div><div class="line">string(10) &quot;----------&quot;</div><div class="line">string(3) &quot;dog&quot;</div><div class="line">string(1) &quot;g&quot;</div><div class="line">string(10) &quot;----------&quot;</div><div class="line">string(3) &quot;pig&quot;</div><div class="line">string(1) &quot;p&quot;</div><div class="line">string(10) &quot;----------&quot;</div><div class="line">NULL</div></pre></td></tr></table></figure></li></ul></li><li><p>上面示例中使用(迭代)生成器时, <code>yield</code> 都只是简单地作为一个<code>语句</code>来使用, 这样只能实现 <strong>生成器到调用者的单向通信</strong>;</p></li></ol><p>迭代器在进行循环(迭代)前, 需要先进行<code>rewind</code>;</p><h3 id="简单理解-协程-Coroutine"><a href="#简单理解-协程-Coroutine" class="headerlink" title="简单理解 协程(Coroutine)"></a>简单理解 <code>协程(Coroutine)</code></h3><ol><li><p>协程的支持是在迭代生成器的基础上, 增加了<strong>调用者可以回送数据给生成器</strong>的功能(调用者发送数据给被调用的生成器函数), <strong>这就把生成器到调用者的单向通信</strong>转变为<strong>两者之间的双向通信</strong>;</p></li><li><p>调用者传递数据给生成器, 是通过迭代器的<code>send()</code>方法实现的; 下面就是一个简单的协程示例, 用来演示这种通信如何运行的</p><ul><li><p>下面例子可以看到在生成器内部, <code>yield</code> 不再是简单的语句, 而是一个可以接收调用者参数并进行赋值的<code>表达式</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">function gen() &#123;</div><div class="line">    var_dump(&apos;cat&apos;);</div><div class="line">    $ret1 = (yield &apos;yield1&apos;);</div><div class="line">    var_dump($ret1 . &apos;dog&apos;);</div><div class="line">    $ret2 = (yield &apos;yield2&apos;);</div><div class="line">    var_dump($ret2 . &apos;pig&apos;);</div><div class="line">&#125;</div><div class="line">$gen = gen();</div><div class="line">$gen-&gt;rewind();     // 指针会走到第一个 yield 处, 所以会经过 cat</div><div class="line">// cat</div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;current());</div><div class="line">// yield1</div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;send(&apos;lala&apos;));   // 如果第一次send之前没有rewind将指针指向第一个yield, 则send会: 自动先进行一次rewind</div><div class="line">                                // 2. 由于指针还在第一个yield处, 此时send传递参数还是传到第一个yield处 (yield &apos;yield1&apos;)</div><div class="line">                                // 3. 执行next 到下一个yield (会经过 $ret.dog )</div><div class="line">                                // 4. 返回next之后的yield值(yield &apos;yield2&apos; )</div><div class="line">// laladog</div><div class="line">// yield2</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;current());      // 到了第二个yield处, 由于没有传递至, 所以可以通过current直接获取 yield &apos;yield2&apos; 传给调用者的 &apos;yield2&apos;</div><div class="line">// yield2</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;send(&apos;haha&apos;));   // 由于指针没变, 还在第二个yield处, 传递了 haha 给生成器</div><div class="line">                                // 然后执行了next 继续往下走, 会经过 var_dump($ret . &apos;pig&apos;);</div><div class="line">                                // 返回next之后的yield值 (已经进行了next, 而之后没有yield了, 所以会返回null)</div><div class="line">// hahapig</div><div class="line">// null</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;current());      // 由于上面已经走了next, 而下面啥都没有了......</div><div class="line">// null</div></pre></td></tr></table></figure></li><li><p>第一次send会默认执行rewind</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">function gen() &#123;</div><div class="line">    var_dump(&apos;cat&apos;);</div><div class="line">    $ret1 = (yield &apos;yield1&apos;);</div><div class="line">    var_dump($ret1 . &apos;dog&apos;);</div><div class="line">    $ret2 = (yield &apos;yield2&apos;);</div><div class="line">    var_dump($ret2 . &apos;pig&apos;);</div><div class="line">&#125;</div><div class="line">$gen = gen();</div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;send(&apos;lala&apos;));   // 如果第一次send之前没有rewind将指针指向第一个yield, 则send会: 自动先进行一次rewind (所以也会经过 cat )</div><div class="line">                                // 2. 由于指针还在第一个yield处, 此时send传递参数还是传到第一个yield处 (yield &apos;yield1&apos;)</div><div class="line">                                // 3. 执行next 到下一个yield (会经过 $ret.dog )</div><div class="line">                                // 4. 返回next之后的yield值(yield &apos;yield2&apos; )</div><div class="line">// cat</div><div class="line">// laladog</div><div class="line">// yield2</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;current());      // 到了第二个yield处, 由于没有传递至, 所以可以通过current直接获取 yield &apos;yield2&apos; 传给调用者的 &apos;yield2&apos;</div><div class="line">// yield2</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;send(&apos;haha&apos;));   // 由于指针没变, 还在第二个yield处, 传递了 haha 给生成器</div><div class="line">                                // 然后执行了next 继续往下走, 会经过 var_dump($ret . &apos;pig&apos;);</div><div class="line">                                // 返回next之后的yield值 (已经进行了next, 而之后没有yield了, 所以会返回null)</div><div class="line">// hahapig</div><div class="line">// null</div><div class="line"></div><div class="line">echo &apos;+++++++++++++++++++&apos;;</div><div class="line">var_dump($gen-&gt;current());      // 由于上面已经走了next, 而下面啥都没有了......</div><div class="line">// null</div><div class="line"></div><div class="line">//function foo() &#123;</div><div class="line">//    $string = yield;</div><div class="line">//    echo $string;</div><div class="line">//    for ($i = 1; $i &lt;= 3; $i++) &#123;</div><div class="line">//        yield $i;</div><div class="line">//    &#125;</div><div class="line">//&#125;</div><div class="line">//</div><div class="line">//$generator = foo();</div><div class="line">//$generator-&gt;send(&apos;Hello world!&apos;);</div><div class="line">//foreach ($generator as $value) echo &quot;$value\n&quot;;</div></pre></td></tr></table></figure></li></ul></li><li><p>更多小例子 (<a href="http://php.net/manual/zh/generator.send.php" target="_blank" rel="external">可参考PHP手册</a>)</p><ul><li><p>可以迭代三次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">function printer() &#123;</div><div class="line">    $i = 3;</div><div class="line">    while ($i&gt;0) &#123;</div><div class="line">        echo 33;</div><div class="line">        $string = yield;</div><div class="line">        echo $string;</div><div class="line">        $i--;</div><div class="line">        echo $i;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$printer = printer();</div><div class="line">$printer-&gt;send(&apos;Hello world!&apos;);</div><div class="line">echo &quot;&lt;br/&gt;++++++++++&lt;br/&gt;&quot;;</div><div class="line">$printer-&gt;send(&apos;haha&apos;);</div><div class="line">echo &quot;&lt;br/&gt;++++++++++&lt;br/&gt;&quot;;</div><div class="line">$printer-&gt;send(&apos;heihei&apos;);</div></pre></td></tr></table></figure></li><li><p>可以一直迭代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">function printer() &#123;</div><div class="line">    while (true) &#123;</div><div class="line">        echo 33;</div><div class="line">        $string = yield;</div><div class="line">        echo $string;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$printer = printer();</div><div class="line">$printer-&gt;send(&apos;Hello world!&apos;);</div><div class="line">echo &quot;&lt;br/&gt;++++++++++&lt;br/&gt;&quot;;</div><div class="line">$printer-&gt;send(&apos;haha&apos;);</div><div class="line">echo &quot;&lt;br/&gt;++++++++++&lt;br/&gt;&quot;;</div><div class="line">$printer-&gt;send(&apos;heihei&apos;);</div><div class="line">echo &quot;&lt;br/&gt;++++++++++&lt;br/&gt;&quot;;</div><div class="line">$printer-&gt;send(&apos;heihei2&apos;);</div></pre></td></tr></table></figure></li></ul></li><li><p>个人感觉重点在于理解调用者发出<code>send()</code>后, <code>send()</code>的执行包括<code>next()</code>及<code>返回</code> (以及, 如果是初次执行send的话, 会隐式执行<code>rewind</code>); </p><ul><li>也可以参考<a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="external">鸟哥博客对send的说明</a><br><img src="/img/PHP/yield-send.png" width="400/"></li></ul></li></ol><h2 id="协程实现任务调度"><a href="#协程实现任务调度" class="headerlink" title="协程实现任务调度"></a>协程实现<code>任务调度</code></h2><ol><li><p>上面的例子比较简单, 可能无法体系会到协程的优点, 接下来可以尝试利用<code>协程</code>去实现<code>多任务调度</code></p><ul><li>要解决的问题是当你想并发地运行多任务(或者”程序”)时, 我们都知道CPU在一个时刻只能运行一个任务(不考虑多核的情况), 因此处理器需要在不同的任务之间进行切换, 而且总是让每个任务<code>运行一小会儿</code>;</li><li>多任务协作这个术语中的<code>协作</code>很好的说明了如何进行这种切换的: 它要求当前正在运行的任务<strong>自动</strong>把控制传回给调度器, 这样就可以运行其他任务了;<br>这与<code>抢占多任务</code>相反, 抢占多任务是这样的: 调度器可以中断运行了一段时间的任务, 不管它喜欢还是不喜欢;<br>协作多任务在Windows的早期版本(windows95)和Mac OS中有使用, 不过它们后来都切换到使用抢先多任务了, <strong>理由相当明确</strong>: 如果你依靠程序自动交出控制的话, <strong>那么一些恶意的程序将很容易占用整个CPU, 不与其他任务共享</strong>;</li></ul></li><li><p>现在你应当明白协程和任务调度之间的关系: </p><ul><li>yield指令提供了任务中断自身的一种方法, 然后把控制交回给任务调度器;</li><li><p>因此协程可以运行多个其他任务, 更进一步来说, <code>yield</code>可以用来在<code>任务</code>和<code>调度器</code>之间进行通信;</p><p>手册中这个例子有空可以稍稍微品味一下: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">function nums() &#123;</div><div class="line">    for ($i = 0; $i &lt; 5; ++$i) &#123;</div><div class="line">        //get a value from the caller</div><div class="line">        $cmd = (yield $i);</div><div class="line"></div><div class="line">        if($cmd == &apos;stop&apos;) return;//exit the function</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$gen = nums();</div><div class="line">foreach($gen as $v)</div><div class="line">&#123;</div><div class="line">    if($v == 3)//we are satisfied</div><div class="line">        $gen-&gt;send(&apos;stop&apos;);</div><div class="line"></div><div class="line">    echo &quot;&#123;$v&#125;\n&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li><li><p>多任务调度的实现</p><ul><li><p>两个使用协程函数的任务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function task1() &#123;</div><div class="line">    for ($i = 1; $i &lt;= 10; ++$i) &#123;</div><div class="line">        echo &quot;This is task 1 iteration $i.\n&quot;;</div><div class="line">        yield;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function task2() &#123;</div><div class="line">    for ($i = 1; $i &lt;= 5; ++$i) &#123;</div><div class="line">        echo &quot;This is task 2 iteration $i.\n&quot;;</div><div class="line">        yield;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Task任务类包装 任务协程函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">/**</div><div class="line"> * 如代码, 一个任务就是用任务ID标记的一个协程(函数).</div><div class="line"> * 使用setSendValue()方法, 你可以指定哪些值将被发送到下次的恢复(在之后你会了解到我们需要这个),</div><div class="line"> * run()函数确实没有做什么, 除了调用send()方法的协同程序</div><div class="line"> * 要理解为什么添加了一个 beforeFirstYieldflag变量</div><div class="line"> */</div><div class="line">class Task &#123;</div><div class="line">    protected $taskId;</div><div class="line">    protected $coroutine;</div><div class="line">    protected $sendValue = null;</div><div class="line">    protected $beforeFirstYield = true;</div><div class="line"></div><div class="line">    public function __construct($taskId, Generator $coroutine) &#123;</div><div class="line">        $this-&gt;taskId = $taskId;</div><div class="line">        $this-&gt;coroutine = $coroutine;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function getTaskId() &#123;</div><div class="line">        return $this-&gt;taskId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//    public function setSendValue($sendValue) &#123;</div><div class="line">//        $this-&gt;sendValue = $sendValue;</div><div class="line">//    &#125;</div><div class="line"></div><div class="line">    public function run() &#123;</div><div class="line">        // 由于send的特性, 会导致先next, 所以下面在设置了一个初始标志beforeFirstYield, 初始时, 先获取了current</div><div class="line">        if ($this-&gt;beforeFirstYield) &#123;</div><div class="line">            $this-&gt;beforeFirstYield = false;</div><div class="line">            return $this-&gt;coroutine-&gt;current();</div><div class="line">        &#125; else &#123;</div><div class="line">            // 注意: 执行send之后会返回next之后的yield值</div><div class="line">            $retval = $this-&gt;coroutine-&gt;send(&apos;目前还没用到双向通信&apos;);</div><div class="line">            return $retval;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function isFinished() &#123;</div><div class="line">        return !$this-&gt;coroutine-&gt;valid();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>实现Scheduler调度器类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Scheduler &#123;</div><div class="line">    protected $maxTaskId = 0;</div><div class="line">    protected $taskMap = []; // taskId =&gt; task</div><div class="line">    protected $taskQueue;</div><div class="line"></div><div class="line">    public function __construct() &#123;</div><div class="line">        $this-&gt;taskQueue = new SplQueue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function newTask(Generator $coroutine) &#123;</div><div class="line">        // 生成任务id</div><div class="line">        $tid = ++$this-&gt;maxTaskId;</div><div class="line">        // 将协程函数封包到Task类中 作为任务</div><div class="line">        $task = new Task($tid, $coroutine);</div><div class="line">        // 放入调度器的任务池中</div><div class="line">        $this-&gt;taskMap[$tid] = $task;</div><div class="line">        // 将任务放入调度器的队列中</div><div class="line">        $this-&gt;schedule($task);</div><div class="line">        return $tid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function schedule(Task $task) &#123;</div><div class="line">        $this-&gt;taskQueue-&gt;enqueue($task);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function run() &#123;</div><div class="line">        while (!$this-&gt;taskQueue-&gt;isEmpty()) &#123;</div><div class="line">            // 从调度器队列中弹出任务, 准备执行</div><div class="line">            $task = $this-&gt;taskQueue-&gt;dequeue();</div><div class="line">            // 执行任务</div><div class="line">            $task-&gt;run();</div><div class="line"></div><div class="line">            // 如果任务执行完毕, 则从调度器的任务池中清除任务</div><div class="line">            if ($task-&gt;isFinished()) &#123;</div><div class="line">                unset($this-&gt;taskMap[$task-&gt;getTaskId()]);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 否则, 再次将弹出的任务放入调度器的任务队列中</div><div class="line">                $this-&gt;schedule($task);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>测试 test.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">require_once &apos;Task.php&apos;;</div><div class="line">require_once &apos;Scheduler.php&apos;;</div><div class="line"></div><div class="line">function task1() &#123;</div><div class="line">    for ($i = 1; $i &lt;= 10; ++$i) &#123;</div><div class="line">        echo &quot;This is task 1 iteration $i.\n&quot;;</div><div class="line">        yield;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function task2() &#123;</div><div class="line">    for ($i = 1; $i &lt;= 5; ++$i) &#123;</div><div class="line">        echo &quot;This is task 2 iteration $i.\n&quot;;</div><div class="line">        yield;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$scheduler = new Scheduler;</div><div class="line">$scheduler-&gt;newTask(task1());</div><div class="line">$scheduler-&gt;newTask(task2());</div><div class="line">$scheduler-&gt;run();</div></pre></td></tr></table></figure></li></ul></li><li><p>当然, 上面是具有两个简单任务(没什么意义的任务)的调度器;</p></li></ol><h2 id="任务和调度器之间的通信"><a href="#任务和调度器之间的通信" class="headerlink" title="任务和调度器之间的通信"></a>任务和调度器之间的通信</h2><ol><li><p>上面可以看到, 调度器已经运行了, 那么我们来看下一个问题: <strong>任务和调度器之间的通信</strong>;</p></li><li><p>接下来将模拟 进程和操作系统进行会话时的方式 – <code>系统调用</code>, 来做任务和调度器之间的通信<br>我们需要<code>系统调用</code>的理由是操作系统与进程相比它处在不同的权限级别上, 因此为了执行特权级别的操作(如杀死另一个进程), 就不得不以某种方式把控制传回给内核, 这样内核就可以执行所说的操作了;<br> 再说一遍, 这种行为在内部是通过使用<code>中断指令</code>来实现的. 过去使用的是通用的int指令, 如今使用的是更特殊并且更快速的syscall/sysenter指令;</p></li><li><p>我们的任务调度系统将反映这种设计: 不是简单地把调度器传递给任务(这样就允许它做它想做的任何事), 我们将通过给yield表达式传递信息来与系统调用通信, 这儿yield即是中断, 也是传递信息给调度器(和从调度器传递出信息)的方法;</p></li><li><p>为了说明系统调用, 我们对可调用的系统调用做一个小小的封装:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure></li></ol><p>~~未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h2&gt;&lt;h2 id=&quot;迭代生成器&quot;&gt;&lt;a href=&quot;#迭代生成器&quot; class=&quot;headerlink&quot; title=&quot;迭代生成器&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="PHP" scheme="http://blog.renyimin.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.renyimin.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>70. 查询性能优化</title>
    <link href="http://blog.renyimin.com/2017/09/27/mysql/2017-09-27-mysql-70/"/>
    <id>http://blog.renyimin.com/2017/09/27/mysql/2017-09-27-mysql-70/</id>
    <published>2017-09-27T12:50:37.000Z</published>
    <updated>2018-03-08T06:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前已经了解了<code>索引优化</code>的相关内容, 它对于高性能是必不可少的, 但还不够, 还需要<code>合理设计查询</code>;</p><ul><li>如果查询写的很糟糕, 即使库表结构再合理, 索引再合适, 也无法实现高性能;</li><li>查询优化, 库表结构优化, 索引优化需要齐头并进, 一个不落;</li></ul><h2 id="慢查询基础"><a href="#慢查询基础" class="headerlink" title="慢查询基础"></a>慢查询基础</h2><h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><ul><li>确认应用程序是否在检索大量超过需要的数据, 你可能访问了太多的行, 也可能是太多的列;<br>比如: 总是返回全部的列; 只展示5条数据,你却查出100条;</li><li>确认<code>MySQL服务器层</code>是否在分析大量超过需要的数据行; (注意: 索引是在存储引擎层, 一旦服务器层分析的数据过多, 可能你的索引不太合适, 没有在存储引擎层过滤掉数据)<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>未完待续~~</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前已经了解了&lt;code&gt;索引优化&lt;/code&gt;的相关内容, 它对于高性能是必不可少的, 但还不够, 还需要&lt;code&gt;合理设计查询&lt;/co
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="查询性能优化" scheme="http://blog.renyimin.com/tags/%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>50. EXPLAIN 分析</title>
    <link href="http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-50/"/>
    <id>http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-50/</id>
    <published>2017-09-25T13:23:08.000Z</published>
    <updated>2018-03-16T06:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `user_info` (</div><div class="line">  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,</div><div class="line">  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">  `age`  INT(11) DEFAULT NULL,</div><div class="line">  PRIMARY KEY (`id`),</div><div class="line">  KEY `name_index` (`name`)</div><div class="line">) ENGINE = InnoDB, DEFAULT CHARSET = utf8;</div><div class="line"></div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);</div><div class="line"></div><div class="line">CREATE TABLE `order_info` (</div><div class="line">  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,</div><div class="line">  `user_id`      BIGINT(20)           DEFAULT NULL,</div><div class="line">  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">  `productor`    VARCHAR(30)          DEFAULT NULL,</div><div class="line">  PRIMARY KEY (`id`),</div><div class="line">  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</div><div class="line">)ENGINE = InnoDB,</div><div class="line">DEFAULT CHARSET = utf8;</div><div class="line"></div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);</div></pre></td></tr></table></figure></code></pre><h2 id="EXPLAIN-输出"><a href="#EXPLAIN-输出" class="headerlink" title="EXPLAIN 输出"></a>EXPLAIN 输出</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from user_info where id = 2;</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref   | rows | Extra |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">|  1 | SIMPLE      | user_info | const | PRIMARY       | PRIMARY | 8       | const |    1 | NULL  |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></code></pre><h2 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h2><ol><li><p>select_type 表示了查询的类型, 它的常用取值有:</p><ul><li><code>SIMPLE</code>, 表示此查询不包含 UNION 查询或子查询 (最常见的查询类别就是 <code>SIMPLE</code> 了)</li><li><code>PRIMARY</code>, 表示此查询是最外层的查询</li><li><code>UNION</code>, 表示此查询是 UNION 的第二或随后的查询</li><li><code>DEPENDENT UNION</code>, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li><code>UNION RESULT</code>, UNION 的结果</li><li><code>SUBQUERY</code>, 子查询中的第一个 SELECT</li><li><code>DEPENDENT SUBQUERY</code>: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li></ul></li><li><p>如果使用了<code>UNION</code>查询, 那么EXPLAIN 输出结果类似如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN ( SELECT * FROM user_info WHERE id IN ( 1, 2, 3 ) ) UNION</div><div class="line">( SELECT * FROM user_info WHERE id IN ( 3, 4, 5 ) );</div><div class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</div><div class="line">| id   | select_type  | table      | type  | possible_keys | key     | key_len | ref  | rows | Extra           |</div><div class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</div><div class="line">|    1 | PRIMARY      | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where     |</div><div class="line">|    2 | UNION        | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where     |</div><div class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | ALL   | NULL          | NULL    | NULL    | NULL | NULL | Using temporary |</div><div class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li></ol><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><ol><li>type 字段比较重要, 它<strong>提供了判断查询是否高效的重要依据依据</strong>; 通过 type 字段, 我们判断此次查询是 <strong>全表扫描</strong> 还是 <strong>索引扫描</strong> 等;</li><li><p>type 常用的取值有:</p><ul><li><p><code>system</code>: 表中只有一条数据, 这个类型是特殊的 <code>const</code> 类型; ??</p></li><li><p><code>const</code>: 针对<strong>主键</strong>或<strong>唯一索引</strong>的<strong>等值查询扫描</strong>, 最多只返回一行数据(const 查询速度非常快, 因为它仅仅读取一次即可)</p></li><li><p><code>eq_ref</code>: 此类型通常出现在多表的join查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果, 并且查询的比较操作通常是 =, <strong>查询效率较高</strong>, 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id;</div><div class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</div><div class="line">| id | select_type | table      | type   | possible_keys             | key                       | key_len | ref                     | rows | Extra                    |</div><div class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | order_info | index  | user_product_detail_index | user_product_detail_index | 254     | NULL                    |    9 | Using where; Using index |</div><div class="line">|  1 | SIMPLE      | user_info  | eq_ref | PRIMARY                   | PRIMARY                   | 8       | test.order_info.user_id |    1 | NULL                     |</div><div class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询, 例如下面这个例子中, 就使用到了 ref 类型的查询:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5;</div><div class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</div><div class="line">| id | select_type | table      | type  | possible_keys             | key                       | key_len | ref   | rows | Extra       |</div><div class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info  | const | PRIMARY                   | PRIMARY                   | 8       | const |    1 | NULL        |</div><div class="line">|  1 | SIMPLE      | order_info | ref   | user_product_detail_index | user_product_detail_index | 9       | const |    1 | Using index |</div><div class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>range: 表示使用<code>索引范围查询</code>, 通过索引字段范围获取表中部分数据记录; 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL (没用到索引), 并且 key_len 字段是此次查询中使用到的索引的最长的那个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT * FROM user_info WHERE id BETWEEN 2 AND 8;</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | range | PRIMARY       | PRIMARY | 8       | NULL |    7 | Using where |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>下面对比, 都使用了范围查询, 但是一个可以使用<strong>索引范围查询</strong>, 另一个不能使用索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name&gt;&apos;nihao&apos;;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra                    |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | user_info | range | name_index    | name_index | 152     | NULL |    1 | Using where; Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age&gt;10;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>另外, 可参考 P185: in语句虽然有时候 type结果也是range (不过, 对于真正的范围查询, 确实是无法使用范围列后面的其他索引了, 但是对于”多个等值条件查询”则没有这个限制)</p></li><li><p>index: 表示<strong>全索引扫描(full index scan)</strong>, 和 ALL 类型类似, 只不过ALL类型是全表扫描, <strong>而 index 类型则仅仅扫描所有的索引, 而不扫描数据</strong><br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据, 即 做的是<strong>覆盖索引</strong>, 当是这种情况时, Extra 字段会显示 <code>Using index</code></p><p>下面的例子中, 查询的 <code>name</code> 字段恰好是一个索引(<strong>做到了覆盖索引</strong>), 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据;<br>因此这样的情况下, type 的值是 <code>index</code>, 并且 Extra 的值是 Using index;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM user_info;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | index | NULL          | name_index | 152     | NULL |   10 | Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>下面不但使用了<code>全索引扫描</code>, 而且使用了<code>where条件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name=&apos;nihao&apos;;</div><div class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                    |</div><div class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using where; Using index |</div><div class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>但是, 如果不使用索引的话, 下面type就是<code>ALL</code>, 表示使用了<code>全表扫描</code>, 并且使用了where条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age=10;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age&gt;10;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name&gt;&apos;nihao&apos;;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra                    |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | user_info | range | name_index    | name_index | 152     | NULL |    1 | Using where; Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一, 通常来说, 我们的查询<strong>不应该出现 ALL 类型的查询</strong>, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难<br>如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</p></li><li></li></ul></li></ol><h2 id="type小结"><a href="#type小结" class="headerlink" title="type小结"></a>type小结</h2><p><strong>type 类型的性能比较</strong> : 通常来说, 不同的 type 类型的性能关系如: <code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code></p><ol><li>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的;</li><li>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快;</li><li>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了;</li></ol><h2 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h2><p>possible_keys 表示 MySQL 在查询时, 能够使用到的索引;<br>注意: 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到;(MySQL 在查询时具体使用了哪些索引, 由 key 字段决定)</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>此字段是 MySQL 在当前查询时所真正使用到的索引</p><h2 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h2><p>rows 也是一个重要的字段, MySQL 查询优化器根据统计信息, <strong>估算SQL要查找到结果集需要到表中扫描读取的数据行数</strong>(上面的例子可以看到, 基本上使用到了索引的话, 真正扫描的行数都很少); 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好</p><h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><p>Explain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ol><li><p><strong>Using filesort</strong>: 当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. </p><ul><li><p>一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</p></li><li><p>比如下面, <code>使用索引扫描做排序</code> 和 <code>不使用索引扫描做排序</code> 的效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM user_info ORDER BY name;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | index | NULL          | name_index | 152     | NULL |   10 | Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; EXPLAIN SELECT name FROM user_info ORDER BY age;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra          |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using filesort |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li></ul></li><li><p><code>Using index</code> 与 <code>Using index condition</code></p><ul><li>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li><li><p>比如下面, 第一个做到了<code>覆盖索引</code>扫描, 后面两个都没做到</p><pre><code>mysql&gt; EXPLAIN SELECT name FROM user_info where name=&apos;haha&apos;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                    |+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using where; Using index |+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+1 row in set (0.00 sec)mysql&gt; EXPLAIN SELECT name,age FROM user_info where name=&apos;haha&apos;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                 |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using index condition |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+1 row in set (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM user_info where name=&apos;haha&apos;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                 |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using index condition |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+1 row in set (0.00 sec)</code></pre></li></ul></li><li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备环境&quot;&gt;&lt;a href=&quot;#准备环境&quot; class=&quot;headerlink&quot; title=&quot;准备环境&quot;&gt;&lt;/a&gt;准备环境&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>49. 索引和锁</title>
    <link href="http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-49/"/>
    <id>http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-49/</id>
    <published>2017-09-25T13:10:40.000Z</published>
    <updated>2018-03-08T02:57:03.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>索引可以让查询锁定更少的行</strong> <blockquote><p>因为InnoDB只有在访问行的时候才会对其加锁, 而索引能够减少InnoDB访问的行数, 从而减少锁的数量;<br>但这只有当InnoDB在存储引擎层就能过滤掉所有不需要的行时才行, 如果索引(处在存储引擎层)无法过滤掉无效的行, 那么在InnoDB检索到数据并发送给服务器层以后, 服务器层才能应用where子句, 这时已经无法避免锁定行了;<br>虽然InnoDB的行锁效率很高, 内存使用也很少, 但是锁定行的时候仍然会带来额外开销;<br>锁定超过需要的行会增加锁争用并减少并发性;</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;strong&gt;索引可以让查询锁定更少的行&lt;/strong&gt; &lt;blockquote&gt;
&lt;p&gt;因为InnoDB只有在访问行的时候才会对其加锁, 而索引能够减少InnoDB访问的行数, 从而减少锁的数量;&lt;br&gt;但这只有当InnoDB在存储引擎层就能过滤掉所有不需
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>48. 冗余和重复索引</title>
    <link href="http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-48/"/>
    <id>http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-48/</id>
    <published>2017-09-25T10:27:40.000Z</published>
    <updated>2018-03-08T02:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><code>重复索引</code> 是指在相同的列上按照相同的顺序创建的相同类型的索引; 应该避免这样的重复索引, 发现后也应该立即删除;</p></li><li><p>MySQL允许在相同的列上创建多个索引, 但是MySQL需要单独维护重复的索引, 并且优化器在优化查询的时候也需要逐个地进行考虑, 这会影响性能;</p></li><li><p><code>冗余索引</code> 和 <code>重复索引</code> 不同, 如果创建了索引(A,B), 在创建索引(A)就是冗余索引, 因为这只是(A,B)索引的前缀索引; <strong>大多数情况下都不需要冗余索引</strong>;</p><ul><li>因此索引(A,B)也可以当做索引(A)来使用</li><li>但是如果再创建索引(B,A), (B) 则都不是冗余索引</li><li>有时候为了让两个查询都变快, 也会需要冗余索引 (P179)</li></ul></li><li>应该尽量扩展已有的索引而不是创建新的索引</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;重复索引&lt;/code&gt; 是指在相同的列上按照相同的顺序创建的相同类型的索引; 应该避免这样的重复索引, 发现后也应该立即删除;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MySQL允许在相同的列上创建多个索引, 但是MySQL需要单独维护重复的索引, 
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>47. 使用索引扫描来做排序</title>
    <link href="http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-47/"/>
    <id>http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-47/</id>
    <published>2017-09-25T10:25:11.000Z</published>
    <updated>2018-03-08T05:38:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>只有<strong>当索引的列顺序 和 ORDER BY 子句的顺序完全一致</strong>, 并且<strong>所有列的排序方向都一样时(要么都是正序, 要么都是倒序)</strong>, MySQL才能够使用索引来对结果做排序;</p></li><li><p>如果查询需要关联多张表, 则只有当 <strong>ORDER BY 子句引用的字段全部为第一个表时</strong>, 才能使用索引做排序;</p></li><li><p>ORDER BY 子句 和 查找型查询的限制是一样的, 需要满足索引的最左前缀的要求, 否则, MySQL都需要亲自去执行排序操作, 而<strong>无法利用索引排序</strong>;</p></li><li><p>有一种情况下, ORDER BY 子句可以不用满足最左前缀的要求, 那就是前导列为常量的时候;<br> 比如一张表的索引是 <code>key(a,b,c)</code> , 而 查询语句是 <code>... where a=100 order by b,c</code>, 即使 order by 不满足最左前缀的要求, 也可以<strong>使用索引做排序</strong>;</p></li><li><p>P177 列出了很多不可以使用索引做排序的查询;</p></li></ol><h2 id="当查询同时有-ORDER-BY-和-LIMIT-子句的时候"><a href="#当查询同时有-ORDER-BY-和-LIMIT-子句的时候" class="headerlink" title="当查询同时有 ORDER BY 和 LIMIT 子句的时候"></a>当查询同时有 ORDER BY 和 LIMIT 子句的时候</h2><ol><li><p>像<code>select &lt;col...&gt; from profiles where sex=&#39;m&#39; order by rating limit 10;</code>这种查询语句, 同时使用了<code>order by</code>和<code>limit</code>, 如果没有索引就会很慢;<br> 即使有索引, 如果用户界面有翻页, 翻页比较靠后时, 也会非常慢, 因为随着偏移量的增加, MySQL需要花费大量的时间来扫描需要丢弃的数据;</p></li><li><p>但是sex的选择性又很低, 如何优化呢?</p></li></ol><ul><li>对于选择性非常低的列, 如果要做排序的话, 可以增加一些特殊的索引来做排序, 例如, 可以创建 (sex, rating)索引</li><li>然后采用 <code>延迟关联</code> , 通过覆盖索引先查询返回需要的主键, 在根据这些主键关联原表获得需要的行;<br><code>select &lt;col...&gt; from profiles INNER JOIN (select &lt;primart key&gt; from profiles where x.sex=&#39;m&#39; order by rating limit 100000, 10) as x using(primary key)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;只有&lt;strong&gt;当索引的列顺序 和 ORDER BY 子句的顺序完全一致&lt;/strong&gt;, 并且&lt;strong&gt;所有
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>46. 覆盖索引</title>
    <link href="http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-46/"/>
    <id>http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-46/</id>
    <published>2017-09-25T09:30:26.000Z</published>
    <updated>2018-03-08T02:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol><li><p>通常, 大家都会根据查询的WHERE条件来创建合适的索引, 不过这只是索引优化的一个方面, <strong>设计优秀的索引应该考虑到整个查询, 而不单单是where条件部分</strong>。</p></li><li><p><strong>覆盖索引</strong></p><ul><li>索引确实是一种查找数据的高效方式, 但是MySQL也可以使用索引就能直接获取列的数据, 这样就不需要再去读取数据行;</li><li>如果叶子节点中已经包含了要查询的数据, 那么就没有必要再回表查询了;</li><li>即, 如果一个索引包含(或者说覆盖)所有需要查询的字段值, 我们就称之为 <code>覆盖索引</code>;</li></ul></li><li><p>覆盖索引是非常有用的工具, 能够极大地提高性能; </p><ul><li>拿InnoDB来说, 覆盖索引就非常有用, 如果你的查询能够做到覆盖你的二级索引列, 那么只需要遍历一次B-Tree(可以直接在二级索引中找到数据), <strong>可以避免对聚簇索引的二次查询</strong>; </li><li>其他更多参考 P171</li></ul></li><li><p><strong>注意:</strong> 覆盖索引<strong>必须要保存索引列的值</strong>, 而 哈希索引, 空间索引 和 全文索引 等都不存储索引列的值; 所以MySQL只能使用B-Tree索引做覆盖索引;</p></li><li><p>如果索引不能覆盖查询所需的全部列, 那就不得不每扫描一次索引记录, 就回表查询一次对应的行, </p></li></ol><h2 id="优化小案例"><a href="#优化小案例" class="headerlink" title="优化小案例"></a>优化小案例</h2><ol><li><p><code>select * ....</code> : 因为查询从表中选择了所有的列, 而一般你不会创建覆盖了所有列的二级索引, 所以这种局域肯定不会用到覆盖索引;</p></li><li><p><code>.... where title LIKE &#39;%ren&#39;</code>: Mysql只能在where条件中做索引的 <code>最左前缀匹配的LIKE比较</code>, 而这里的where条件是以通配符开头的LIKE查询;</p></li><li><p>查看 (P171) 的优化案例 (做表的自关联, 子句使用覆盖索引, 外部不用)<br> 这样虽然无法使用索引覆盖整个查询, 但总算比完全无法利用覆盖索引要好</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通常, 大家都会根据查询的WHERE条件来创建合适的索引, 不过这只是索引优化的一个方面, &lt;strong&gt;设计优秀的索引
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>45. 聚簇索引</title>
    <link href="http://blog.renyimin.com/2017/09/24/mysql/2017-09-24-mysql-45/"/>
    <id>http://blog.renyimin.com/2017/09/24/mysql/2017-09-24-mysql-45/</id>
    <published>2017-09-24T12:10:31.000Z</published>
    <updated>2018-03-07T13:32:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>聚簇索引并不是一种单独的索引类型, 而是一种 <strong>数据存储方式</strong>; </p></li><li><p>因为是存储引擎负责实现索引, 所以不是所有的存储引擎都支持聚簇索引, 这里主要讨论的是 <code>InnoDB引擎的聚簇索引</code>;</p></li><li><p>InnoDB的 <code>聚簇索引</code> 实际上在同一个结构中保存了 <code>B-Tree索引</code> 和 <code>数据行</code></p><ul><li>当表有聚簇索引时, 它的数据行实际上存放在索引的叶子页中(叶子页包含了数据行的 <code>全部列数据</code>)</li><li>因为无法同时把数据行存放在两个不同的地方, 所以一个表只能有一个聚簇索引</li><li>不过<code>覆盖索引</code>, 可以模拟多个聚簇索引的情况</li></ul></li><li><p><strong>InnoDB默认会创建聚簇索引</strong>: InnoDB通过主键来作为聚簇索引, 如果没有定义主键, 则会选择一个唯一的非空索引代替, 如果连非空索引都没有, <strong>InnoDB会隐式定义一个主键来作为聚簇索引</strong>;</p><ul><li>将主键组织到一棵B+树中, 而行数据就储存在叶子节点上，若使用<code>where id = 14</code>这样的条件查找数据;<br><img src="/img/mysql/index/jucusuoyin.png" width="500"></li><li>则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据;</li></ul></li><li><p>InnoDB只聚集 在同一个磁盘页面中的记录, 因此, 如果数据在物理上是相邻的, 那么在索引上就也是相邻的;</p><ul><li>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的;</li><li>但是包含相邻键值的页面可能物理上会相距甚远;</li></ul></li></ol><h2 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h2><ol><li>访问速度更快: 聚簇索引将索引和数据保存在同一个B-Tree中, 因此从聚簇索引中获取数据通常比在非聚簇索引中查询要快;</li><li>使用覆盖索引的查询, 可以直接使用页节点中的<strong>主键值</strong>;</li></ol><h2 id="聚簇索引缺点"><a href="#聚簇索引缺点" class="headerlink" title="聚簇索引缺点"></a>聚簇索引缺点</h2><ol><li>聚簇索引最大限度地提高了I/O密集型应用的性能, 但如果数据全部都放在内存中, 则访问顺序就没那么重要了, 聚簇索引也就没什么优势了;</li><li>插入速度严重依赖于插入顺序, 按照主键的顺序插入是速度最快的方式, 但如果不是按照主键顺序, 在完成操作后最好执行 <code>OPTIMIZE TABLE</code> 命令重新组织一下表;</li><li>更新聚簇索引的代价很高, 因为会强制InnoDB将每个被更新的行移动到新的位置;<br> 基于聚簇索引的表在插入新行, 或者主键被更新导致需要移动行的时候, 可能面临 “页分裂” 问题;<br> 当前主键值要求必须将这一行插入到某个已满的页中时, 存储引擎会将该页分裂成两个页面来容纳该行, 这就是一次页分裂操作。<br> 页分裂操作会导致表占用更多的磁盘空间</li><li>聚簇索引会导致全表扫描变慢, 尤其是行比较稀疏, 或者由于页分裂导致数据存储不连续的时候;</li><li>二级索引(非聚簇索引)可能比想象的要更大, 因为在二级索引的叶子节点包含了引用行的主键列;</li><li><strong>二级索引访问需要两次索引查找, 而不是一次</strong><ul><li>二级索引叶子几点保存的 “行指针” 是行的主键; 这意味着通过二级索引查找行, 存储引擎需要找到二级索引叶子节点获得对应的主键值;</li><li>然后根据这个主键值去聚簇索引中查找对应的行数据;</li><li>这里做了重复工作, 两次 B-Tree 查找, 而不是一次。</li></ul></li></ol><h2 id="InnoDB-和-MyISAM-索引对比"><a href="#InnoDB-和-MyISAM-索引对比" class="headerlink" title="InnoDB 和 MyISAM 索引对比"></a>InnoDB 和 MyISAM 索引对比</h2><ol><li>InnoDB支持聚簇索引, 而MyISAM不支持;</li><li>MyISAM中主键索引和其他索引在索引结构上没有区别; 而InnoDB中 <code>(主键)聚簇索引</code> 和 <code>二级索引(普通索引)</code> 是有区别的;(P167)</li></ol><h2 id="上图总结"><a href="#上图总结" class="headerlink" title="上图总结"></a>上图总结</h2><p><img src="/img/mysql/index/index_duibi.png" width="600"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;聚簇索引并不是一种单独的索引类型, 而是一种 &lt;strong&gt;数据存储方式&lt;/strong&gt;; &lt;/p&gt;
&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>44. 高性能索引策略 -- 多列索引</title>
    <link href="http://blog.renyimin.com/2017/09/24/mysql/2017-09-24-mysql-44/"/>
    <id>http://blog.renyimin.com/2017/09/24/mysql/2017-09-24-mysql-44/</id>
    <published>2017-09-24T09:25:31.000Z</published>
    <updated>2018-03-07T12:23:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>在多个列上建立独立的<code>单列索引</code>, 在大部分情况下并不能提高MySQL的查询性能; </p><ul><li>例如: film_actor 表在 film_id 和 actor_id 上各有一个单列索引, 但是对于下面这个查询WHERE条件, 这两个单列索引都不是好的选择</li><li><code>select film_id, actor_id from actor where actor_id=1 OR film_id=1;</code></li></ul></li><li><p>对于上面的查询</p><ul><li>老版本的MySQL会使用全表扫描;</li><li>而新版本会使用 <code>索引合并策略</code>(参考P158) 来进行优化, 但这更说明了表上的索引建的很糟糕</li></ul></li><li><p>接下来除了 之前已经在<a href="/2017/09/24/mysql/2017-09-24-mysql-41/#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%95%88%E5%BA%94">博文: B-Tree索引</a>中介绍过的多列索引的 <strong>左前缀策略</strong>;<br> 你还需要关注的是创建索引时, <strong>索引列的顺序</strong></p></li></ol><h2 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h2><ol><li><p>在一个多列索引中, 索引列的顺序首先决定了最左前缀策略在查询时是如何进行的; 其次还意味着索引首先按照最左列进行排序, 其次是第二列, 等等; 所以<strong>多列索引的列顺序至关重要</strong>;</p></li><li><p>在不需要考虑排序和分组的时候, <strong>将选择性最高的列放在前面</strong>通常是很好的, 这时候索引的作用只是用于优化where条件的查找。</p></li><li><p>然而, 性能不知是依赖于所有索引列的选择性(整体基数), 也和查询条件的具体值有关, 也就是和值的分布有关;</p></li><li><p>~~未完待续</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在多个列上建立独立的&lt;code&gt;单列索引&lt;/code&gt;, 在大部分情况下并不能提高MySQL的查询性能; &lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>43. 高性能索引策略 - 独立的列, 前缀索引</title>
    <link href="http://blog.renyimin.com/2017/09/24/mysql/2017-09-24-mysql-43/"/>
    <id>http://blog.renyimin.com/2017/09/24/mysql/2017-09-24-mysql-43/</id>
    <published>2017-09-24T09:20:31.000Z</published>
    <updated>2018-03-08T05:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面已经对常见的索引类型及其对应的优缺点有了一定的了解, 接下来要考虑的就是如何 <code>高效正确地选择并使用索引</code></p><h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p>独立的列是指: 在查询条件中, <code>索引列</code> 不能是表达式的一部分, 也不能是函数的参数; (如: <code>select actor_id from actor where actor_id+1=5;</code> 就无法使用索引, 应该始终将索引列单独放在比较符号的一侧, <code>select actor_id from actor where actor_id=4;</code>);</p><h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><ol><li><p>因为B-Tree索引中存储了<code>实际的列值</code>, 所以如果你需要索引的列的内容很长, 就会导致 <code>索引变得大且慢</code>;<br> 对于<code>BLOB</code>, <code>TEXT</code> 或者很长的 <code>VARCHAR</code> 类型的列, 必须使用前缀索引, 因为MySQL不允许索引这些列的完整长度;</p></li><li><p>正常情况下, 不论是创建 <code>单列索引</code> 还是 <code>多列索引</code>, 创建的索引都是以 <code>某个列完整的值</code> 来创建索引, 而 <code>前缀索引</code>则是以 <code>列开始的部分字符</code> 来创建索引, 从而大大节约索引空间, 提高索引效率, 但是这样会降低索引的选择性;</p></li></ol><h2 id="索引选择性"><a href="#索引选择性" class="headerlink" title="索引选择性"></a>索引选择性</h2><ol><li><p><code>索引选择性</code>: 是指不重复的索引值(基数) 和 数据表的记录总数的比值(当然, 唯一索引的所有索引值都不同, 选择性是1, 这是最好的索引选择性, 性能也是最好的); </p></li><li><p>假设一张订单表, 按照 <code>city</code>(城市全名) 来分 和 按照 <code>city</code>(第一个字)来分组 , 那肯定前一种情况分出来的组比较多, 也就是不重复的索引值多;   </p><ul><li><p>如果按照 <code>city</code> 字段的前3个字符来分组的话, 效果如下<br><img src="/img/mysql/index/index_xuanzexing_02.png" width="500"></p></li><li><p>如果按照 <code>city</code> 字段的前7个字符来分组的话, 可以想到, 自然可能会是 <code>分组会更多, 每组的数据会更少</code><br><img src="/img/mysql/index/index_xuanzexing_03.png" width="500"></p></li></ul></li><li><p>分的组越多, 也就是如果以此长度的前缀创建索引的话, 不重复的索引值也就越多, 那么选择性就越高;<br> 选择性越高, 则查询效率越高, 因为MySQL在查找时能够通过索引就过滤掉更多的行, 否则一个索引还是对应了很多的数据行, 那效率还是很低;</p></li><li><p>而我们要做的其实就是让我们的 <code>前缀选择性</code> 接近 <code>完整列的选择性</code></p><ul><li>简单点说, 让 <code>city(n)</code> 接近 <code>city</code> 的选择性;</li><li>计算完整列的选择性<br><img src="/img/mysql/index/index_xuanzexing_04.png" width="500"></li><li>下面给出了同一个查询中计算不同前缀长度的选择性<br><img src="/img/mysql/index/index_xuanzexing_05.png" width="500"></li></ul></li><li><p>前缀索引是一种能使索引更小, 更快的有效办法, 但也有其缺点: </p><ul><li>MySQL无法使用前缀索引做 <code>ORDER BY</code> 和 <code>GROUP BY</code></li><li>有无法使用前缀索引做覆盖扫描</li></ul></li><li>创建前缀索引: <code>alter table city add key(city(7))</code>, 表示以 city 字段的前7个字符 来创建索引;</li></ol><p>参考p189:</p><ul><li>根据传统经验, 不应该在选择性低的裂伤创建索引, 但是如果很过查询都用到该列, 比如一个表中的 <code>gender</code> 列, 考虑到使用的频率, 还是建议在创建不同组合的索引时, 将 (sex) 作为前缀!</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面已经对常见的索引类型及其对应的优缺点有了一定的了解, 接下来要考虑的就是如何 &lt;code&gt;高效正确地选择并使用索引&lt;/code&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>42. 哈希索引</title>
    <link href="http://blog.renyimin.com/2017/09/24/mysql/2017-09-24-mysql-42/"/>
    <id>http://blog.renyimin.com/2017/09/24/mysql/2017-09-24-mysql-42/</id>
    <published>2017-09-24T07:01:31.000Z</published>
    <updated>2018-03-07T10:04:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>哈希索引(hash index)基于哈希表实现, <strong>只有精确匹配索引中所有列的查询才有效</strong>;</p></li><li><p>对于每一行数据, 存储引擎都会对所有的索引列计算一个哈希码(hash code):</p><ul><li>哈希索引将所有的哈希码存储在索引中</li><li><strong>同时在哈希表中保存指向每个数据行的指针</strong></li></ul></li><li><p>在MySQL中, 只有Memory引擎显示支持哈希索引, 这也是Memory引擎表的默认索引类型, Memory引擎也支持B-Tree索引。</p><ul><li>Memory引擎支持 <code>非唯一哈希索引</code>, 也就是同样的索引, 不同的数据可能产生相同的哈希码, 如果出现这种情况, 索引会以<strong>链表</strong>的方式存放多个行指针到同一个哈希条目中</li><li>查找时, 会1. 先在索引中按照哈希码来找到指向数据行的指针, 2. 然后比较数据行的值是否是你查找的行</li></ul></li></ol><h2 id="哈希索引的限制"><a href="#哈希索引的限制" class="headerlink" title="哈希索引的限制"></a>哈希索引的限制</h2><p>因为索引自身只要存储对应的哈希值和行指针, 所以索引的结构十分紧凑, 这也让哈希索引的查找速度非常快, 然而哈希索引也有它的限制:</p><ul><li><p>哈希索引只包含哈希值和行指针, 而不存储字段值, 所以不能使用索引中的值来避免读取行, 不过, 访问内存中的行的速度很快;</p></li><li><p>哈希索引数据并不是按照索引值顺序排序的, 所以无法用于排序;</p></li><li><p>不支持 <code>部分索引列匹配查找</code> , 因为哈希索引始终是使用索引列的全部内容来计算哈希值的;</p></li><li><p>不支持范围查询 (只支持如 <code>=</code>, <code>&lt;&gt;</code>, <code>in</code> 等一些 等值比较)</p></li><li><p>哈希索引数据非常快, 除非有很多哈希冲突 (因为memory引擎支持非唯一索引, 也就是同样的索引, 不同的数据可能产生相同的哈希码)<br><strong>当出现哈希冲突时</strong>, 存储引擎必须遍历 冲突的哈希值 所对应的 <code>链表</code> 中所有的行指针, 逐行到表中进行比较, 直到找到所有符合条件的行;</p></li></ul><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>如果哈希冲突很多的话, 一些索引维护操作的代价也为很高, <strong>如果表中删除一行数据, 存储引擎需要遍历对应哈希值的链表中的每一行, 找到并删除对应行的指针, 冲突越多代价越大</strong>;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;哈希索引(hash index)基于哈希表实现, &lt;strong&gt;只有精确匹配索引中所有列的查询才有效&lt;/strong&gt;;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>41. B-Tree索引</title>
    <link href="http://blog.renyimin.com/2017/09/24/mysql/2017-09-24-mysql-41/"/>
    <id>http://blog.renyimin.com/2017/09/24/mysql/2017-09-24-mysql-41/</id>
    <published>2017-09-24T06:50:19.000Z</published>
    <updated>2018-03-07T11:41:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>当人们谈论索引时, 如果没有特别指明索引类型, 多半说的就是 B-Tree 索引, 它使用 B-Tree 数据结构来存储数据;</p></li><li><p>MySQL的大多数存储引擎都支持这种索引 (Archive引擎不支持)</p></li><li><p><strong>存储引擎以不同的方式使用 <code>B-Tree</code> 索引, 性能也各有优劣</strong>:</p><ul><li>MyISAM使用 <code>前缀压缩技术</code> 使得索引更小</li><li><p>InnoDB则按照原数据格式进行存储</p></li><li><p>MyISAM的索引是通过 <code>数据的物理位置</code> 引用被索引的行<br><code>叶子页中的值</code>指向被索引的行的<code>物理地址</code></p></li><li>InnoDB的索引则是通过 <code>主键</code> 引用被索引的行<br><code>叶子页中的值</code>指向被索引的行的<code>主键</code></li></ul></li><li><p>建立在B-Tree结构(从技术上来说是B+Tree)上的索引<br><img src="/img/mysql/index/b-tree-01.png" width="400"></p></li><li><p><strong>注意</strong>: B-Tree索引中存储了 <code>被索引的列实际的列值</code>, <code>指向数据行的指针</code> (上面的图可能没体现出来, 结合下面多列索引的图找找感觉~~)</p></li><li><p>B-Tree 通常意味着:</p><ul><li>所有的值都是 <strong>按顺序</strong> 存储的;<br>B-Tree对索引列是顺序组织存储的, 所以很适合查找范围数据;</li><li><strong>每一个叶子页到根的距离都是相同的</strong>；</li><li><code>叶子页</code>比较特别, 他们的指针指向的是被索引的数据, 而不是其他的<code>节点页</code>(不同引擎的”指针”类型不同)</li></ul></li><li><p>下图显示了<code>多列索引</code>是如何组织数据存储的</p><ul><li><p>对于下表中的每一行数据, 索引中包含了 last_name, first_name, dob(date of birth, 即出生日期) 列的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE People</div><div class="line">    last_name varchar(50) not null,</div><div class="line">    first_name varchar(50) not null,</div><div class="line">    dob date not null,</div><div class="line">    gender enum(&apos;m&apos;, &apos;f&apos;) not null,</div><div class="line">    key(last_name, first_name, dob)</div><div class="line">);</div></pre></td></tr></table></figure><p><img src="/img/mysql/index/b-tree-02.png" width="400"></p></li><li>注意: 索引对多个列的值进行排序的依据是定义索引时列的顺序 (如上图中, 最后两个条目, 两个人的姓和名都一样, 则根据他们的出生日期来进行排列顺序)</li></ul></li></ol><h2 id="最左前缀效应"><a href="#最左前缀效应" class="headerlink" title="最左前缀效应"></a>最左前缀效应</h2><p>之前提到过 “索引可以包含一个或多个列的值。如果包含多个列, 那么列的顺序也十分重要, <strong>因为MySQL只能高效地使用索引的最左前缀列</strong>“</p><p>拿之前的 <code>People</code> 表来做参考(其创建的索引是 <code>key(last_name, first_name, dob)</code>)</p><ol><li><p>全值匹配 : 指的是如果查询条件和某个索引中的所有列值进行匹配, 这样就可以利用到上面创建的索引;</p><ul><li>比如, 查找 ‘姓为Allen,名为Cuba,出生日期为1960-01-01’ 的人时</li><li>并且指的注意的是, <strong>如果你的查询条件做到了全值匹配, 那么即使你查询条件的顺序不是依照左前缀原则, MySQL也会做优化</strong>;</li></ul></li><li><p>匹配最左前缀: 比如, 查找 ‘姓为Allen’ 的人, 即使用索引的第一列, 这样就可以利用到上面创建的索引;</p></li><li><p>匹配最左前缀列的前缀: 可以用来匹配索引中第一列的值的开头部分, 比如, 查找 姓以’J’开头 的人, 这样就可以利用到上面创建的索引;</p></li><li><p>匹配最左前缀范围值: 查找 ‘姓在Allen和Barrymore’ 之间的人, 这样就可以利用到上面创建的索引</p></li><li><p>精确匹配第一列 并 范围匹配第二列: 查找 ‘姓为Allen并且名字以K开头’ 的人, 这样就可以利用到上面创建的索引</p></li><li><p><strong>只用访问索引的查询</strong> : 这种查询只需要访问索引, 而无需访问数据行; 后面会单独讨论这种 <code>覆盖索引</code> 的优化。<br> <strong>B-Tree索引中存储了实际的列值, 所以某些查询(说的是<code>覆盖索引</code>)可能只使用索引就能够完成查询工作了</strong></p></li></ol><h2 id="B-tree索引的限制"><a href="#B-tree索引的限制" class="headerlink" title="B-tree索引的限制"></a>B-tree索引的限制</h2><ol><li><p>如果查询时, 查询条件不是按照索引的最左列开始写, 则无法使用索引;</p><ul><li>上面例子中, 索引就无法用于 ‘查找名字为Bill的人’, 也无法查找 ‘生日为1960-01-01的人’, 因为这两列都不是最左数据列。</li><li>也无法用于查找 ‘姓以某个字母结尾的人’ (<strong><code>你建索引时指定的列顺序</code>, <code>列的值内容</code> 都要符合最左前缀才能利用到索引</strong>)</li></ul></li><li><p>查询条件不能跳过索引中的列</p><ul><li>比如, 查询 ‘姓为Smith 并且 生日为1960-01-01’ 就无法使用到索引</li></ul></li><li><p>如果查询条件中有某个列是范围查询, 则<strong>其右边的所有列都无法使用索引</strong>来优化查找</p><ul><li>比如, <code>where last_name=&#39;Smith&#39; and first_name LIKE &#39;J%&#39; AND dob=&#39;1976-12-23&#39;</code></li><li>这个查询只能使用索引的前两列</li><li>如果范围查询的列的值结果有限, 比如数据表中只有2个人是 ‘名字以J开头’ 的, 那你也别用范围查找了, 直接用多个等于条件来代替就行<br>比如: <code>where last_name=&#39;Smith&#39; and (first_name=&#39;Jack&#39; or first_name=&#39;Jieke&#39; ) AND dob=&#39;1976-12-23&#39;</code></li></ul></li></ol><p>到这里可以看到: <strong>索引列的顺序是非常重要的! 在优化性能的时候, 可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求</strong>;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当人们谈论索引时, 如果没有特别指明索引类型, 多半说的就是 B-Tree 索引, 它使用 B-Tree 数据结构来存储数
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
</feed>
