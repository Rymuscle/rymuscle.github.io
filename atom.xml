<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2019-04-25T09:11:24.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>05. MySQL5.7 源码编译安装</title>
    <link href="http://blog.renyimin.com/2019/04/25/MySQL/2018-10-14-mysql-05/"/>
    <id>http://blog.renyimin.com/2019/04/25/MySQL/2018-10-14-mysql-05/</id>
    <published>2019-04-25T09:11:24.000Z</published>
    <updated>2019-04-25T09:11:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><ol><li><p><a href="https://dev.mysql.com/downloads/mysql/5.7.html#downloads" target="_blank" rel="noopener">mysql5.7.25</a> 源码下载<br> <img src="/img/mysql/install/install-01.png" width="450"></p></li><li><p>因为 mysql5.7系列要求安装<a href="https://www.boost.org/users/history/" target="_blank" rel="noopener">boost_1_59_0</a>, 这里我们选择包含boost的版本<br> (相对于前者, 它内部已经准备好了boost, 不用你再去下载对应的boost版本)<br> <img src="/img/mysql/install/install-02.png" width="500"></p></li></ol><h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><ol><li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/source-installation.html" target="_blank" rel="noopener">参考</a></p><ul><li>cmake: mysql使用cmake跨平台工具预编译源码, 用于设置mysql的编译参数 (如: 安装目录、数据存放目录、字符编码、排序规则等, 安装最新版本即可)</li><li>make3.75 : mysql源代码是由C和C++语言编写, 在linux下使用make对源码进行编译和构建, 要求必须安装 make 3.75或以上版本 (yum默认都是安装最新版的软件)</li><li>gcc4.4.6 : GCC是Linux下的C语言编译工具, mysql源码编译完全由C和C++编写, 要求必须安装GCC4.4.6或以上版本</li><li>Boost1.59.0 : mysql源码中用到了C++的Boost库, 要求必须安装boost1.59.0或以上版本</li><li>bison2.1 : Linux下C/C++语法分析器</li><li>ncurses : 字符终端处理库</li></ul></li><li><p>所以在安装前, 需先安装相关的依赖库</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ ncurses ncurses-devel bison libgcrypt perl make cmake</span><br></pre></td></tr></table></figure></li></ol><h2 id="编译、安装"><a href="#编译、安装" class="headerlink" title="编译、安装"></a>编译、安装</h2><ol><li><p>相比之前的Mysql编译选项, CMake编译选项现在都是大写的, <a href="https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html#option_cmake_cmake_install_prefix" target="_blank" rel="noopener">参考</a></p></li><li><p>在编译时通常会设置的编译选项如下: (可参考 <a href="https://lnmp.org/download.html" target="_blank" rel="noopener">lnmp1.6</a> 中的MySQL5.7编译脚本)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cmake </span><br><span class="line">-DCMAKE_INSTALL_PREFIX=/usr/local/mysql         // 指定MySQL程序的安装目录, 默认 /usr/local/mysql</span><br><span class="line">-DSYSCONFDIR=/usr/local/mysql/etc               // 初始化参数文件my.cnf的目录, 貌似没有默认值, 需要指定</span><br><span class="line">-DWITH_MYISAM_STORAGE_ENGINE=1                  // 指定静态编译到mysql的存储引擎, InnoDB, MyISAM, MERGE, MEMORY和CSV引擎是必需的（始终编译到服务器中）, 无需显式安装。</span><br><span class="line">-DWITH_INNOBASE_STORAGE_ENGINE=1                // 指定静态编译到mysql的存储引擎, InnoDB, MyISAM, MERGE, MEMORY和CSV引擎是必需的（始终编译到服务器中）, 无需显式安装。</span><br><span class="line">-DWITH_PARTITION_STORAGE_ENGINE=1               // 指定静态编译到mysql的存储引擎, InnoDB, MyISAM, MERGE, MEMORY和CSV引擎是必需的（始终编译到服务器中）, 无需显式安装。</span><br><span class="line">-DWITH_FEDERATED_STORAGE_ENGINE=1               // 指定静态编译到mysql的存储引擎, InnoDB, MyISAM, MERGE, MEMORY和CSV引擎是必需的（始终编译到服务器中）, 无需显式安装。</span><br><span class="line">-DEXTRA_CHARSETS=all                            // 默认就是all</span><br><span class="line">-DDEFAULT_CHARSET=utf8mb4                       // 指定服务器默认字符集, 默认 latin1</span><br><span class="line">-DDEFAULT_COLLATION=utf8mb4_general_ci          // 指定服务器默认的校对规则, 默认 latin1_general_ci</span><br><span class="line">-DWITH_EMBEDDED_SERVER=1    </span><br><span class="line">-DENABLED_LOCAL_INFILE=1                        // 指定是否允许本地执行 LOAD DATA INFILE, 默认OFF</span><br><span class="line">-DWITH_BOOST=/usr/local/src/mysql-5.7.25/boost  // 不用指定 -DENABLE_DOWNLOADS=1</span><br><span class="line"></span><br><span class="line"># 以下选项, lnmp1.6 并没有指定</span><br><span class="line">-DWITH_ARCHIVE_STORAGE_ENGINE=1 </span><br><span class="line">-DWITH_BLACKHOLE_STORAGE_ENGINE=1 </span><br><span class="line">-DWITH_MEMORY_STORAGE_ENGINE=1 </span><br><span class="line">-DMYSQL_TCP_PORT                        // 指定服务器默认的端口号, 默认 3306</span><br><span class="line">-DMYSQL_DATADIR=/usr/local/mysql/data   // 数据文件目录 (这个没有默认值)</span><br><span class="line">-MYSQL_UNIX_ADDR                        // socket文件路径, 默认 /tmp/mysql.sock</span><br><span class="line">-DENABLE_DOWNLOADS=1                    // 是否要下载可选的文件。例如, 启用此选项（设置为1）, cmake将下载谷歌所使用的测试套件运行单元测试。</span><br><span class="line">-DMYSQL_USER=mysql                      // 官网没找到该选项</span><br><span class="line">-DDOWNLOAD_BOOST                        // 不用指定, 因为本次选择的是 mysql-boost 版本的, 所以不用下载boost, 而且下载过程很容易被墙而下载失败</span><br></pre></td></tr></table></figure></li><li><p>编译安装</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DSYSCONFDIR=/usr/local/mysql/etc -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DWITH_FEDERATED_STORAGE_ENGINE=1 -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8mb4 -DDEFAULT_COLLATION=utf8mb4_general_ci -DWITH_EMBEDDED_SERVER=1 -DENABLED_LOCAL_INFILE=1 -DWITH_BOOST=/usr/local/src/mysql-5.7.25/boost -DMYSQL_DATADIR=/usr/local/mysql/data</span><br><span class="line">make    // 花费时间可能会比较长</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>已经生成 /usr/local/mysql</li></ul></li></ol><h2 id="my-cnf"><a href="#my-cnf" class="headerlink" title="my.cnf"></a>my.cnf</h2><ol><li><p>首先, 在编译时, 我们通过 <code>-DSYSCONFDIR</code> 指定的 my.cnf 的路径是在 /usr/local/mysql/etc 下, 但是编译完成后, /usr/local/mysql/ 下并没有 etc 目录<br> 这个选项只是指定将来 my.cnf 的位置, 不会帮我们创建目录和文件 (包括之前在编译时通过 -DMYSQL_DATADIR=/usr/local/mysql/data 指定的mysql的数据目录, 都是需要自己创建)</p></li><li><p>另外, mysql5.7.18之后, 貌似已经不在解压包的support-files目录中提供my-default.cnf文件, <a href="https://dev.mysql.com/doc/refman/5.7/en/binary-installation.html" target="_blank" rel="noopener">参考</a></p></li><li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/option-files.html" target="_blank" rel="noopener">参考</a>, 在Unix和类Unix系统上, MySQL程序按照指定的顺序从下表中显示的文件中读取启动选项（首先列出的文件首先读取, 后面读取的文件优先）<br> (你会发现在centos7-minimal系统的/etc下默认就有my.cnf文件)</p></li><li><p>自己准备 my.cnf 文件</p><ul><li>Mysql参数优化对于新手来讲, 是比较难懂的东西, 其实这个参数优化, 是个很复杂的东西, 对于不同的网站, 及其在线量, 访问量, 帖子数量, 网络情况, 以及机器硬件配置都有关系, 优化不可能一次性完成, 需要不断的观察以及调试, 才有可能得到最佳效果</li><li>下面是个my.cnf示例: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">[client]                                            # 客户端设置，即客户端默认的连接参数</span><br><span class="line">default-character-set = utf8mb4                 </span><br><span class="line">port = 3306                                         # 默认连接端口</span><br><span class="line">socket = /usr/local/mysql/mysql.sock                # 用于本地连接的socket套接字 (注意client的socket要和mysqld是一样的，因为客户端和服务端通信靠的就是这个文件，肯定要一致)</span><br><span class="line"></span><br><span class="line">[mysql]                                             # 服务端基本设置</span><br><span class="line">#auto-rehash                                        # MySQL开启命令自动补全功能, mysql命令行工具自带这个功能, 但是默认是禁用的, 想启用其实很简单, 打开配置文件找到 no-auto-rehash, 用符号 # 将其注释, 另外增加auto-rehash即可</span><br><span class="line">                                                    # 亲测, 感觉不咋实用</span><br><span class="line">[mysqld]</span><br><span class="line">user=mysql                                          # ?? mysqld程序在启动后将在给定UNIX/Linux账户下执行 mysqld必须从root账户启动才能在启动后切换到另一个账户下执行; mysqld_safe脚本将默认使用–user=mysql选项来启动mysqld程序</span><br><span class="line">socket = /usr/local/mysql/mysql.sock                # 为MySQL客户端程序和服务器之间的本地通讯指定一个套接字文件 (编译时未指定socket位置, 就用默认的位置)</span><br><span class="line">port=3306                                           # MySQL监听端口</span><br><span class="line">basedir=/usr/local/mysql                            # 指定了安装 MySQL 的安装路径, 填写全路径可以解决相对路径所造成的问题</span><br><span class="line">datadir=/usr/local/mysql/data                       # 数据文件存放的目录</span><br><span class="line">tmpdir = /usr/local/mysql/tmp                       # ?? MySQL存放临时文件的目录</span><br><span class="line">symbolic-links=0                                    # ?? 是否支持符号链接, 即数据库或表可以存储在my.cnf中指定datadir之外的分区或目录, 为0不开启</span><br><span class="line">log-error=/usr/local/mysql/logs/mysql.log           # 错误日志位置</span><br><span class="line">pid-file=/usr/local/mysql/mysqld.pid</span><br><span class="line"></span><br><span class="line">skip-name-resolve                                   # ?? 禁用主机名解析 (待答疑)</span><br><span class="line">default-storage-engine = InnoDB                     # 默认的数据库引擎</span><br><span class="line"></span><br><span class="line">innodb-file-per-table=1                             # ??</span><br><span class="line">innodb_force_recovery = 1                           # ??</span><br><span class="line">group_concat_max_len = 10240                        # ??</span><br><span class="line">#sql_mode = &apos;PIPES_AS_CONCAT,ANSI_QUOTES,IGNORE_SPACE,NO_KEY_OPTIONS,NO_TABLE_OPTIONS,NO_FIELD_OPTIONS,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;</span><br><span class="line">sql_mode = NO_ENGINE_SUBSTITUTION,NO_AUTO_CREATE_USER   # sql_mode, 定义了mysql应该支持的sql语法，数据校验等</span><br><span class="line">                                                        # NO_AUTO_CREATE_USER: 禁止GRANT创建密码为空的用户</span><br><span class="line">                                                        # NO_ENGINE_SUBSTITUTION: 如果需要的存储引擎被禁用或未编译, 可以防止自动替换存储引擎</span><br><span class="line">expire_logs_days = 7                                # ??</span><br><span class="line">memlock                                             # ??</span><br><span class="line"></span><br><span class="line">### 字符集配置</span><br><span class="line">character-set-client-handshake = FALSE</span><br><span class="line">character-set-server = utf8mb4</span><br><span class="line">collation-server = utf8mb4_unicode_ci</span><br><span class="line">init_connect=&apos;SET NAMES utf8mb4&apos;                    # ??</span><br><span class="line"></span><br><span class="line">### GTID</span><br><span class="line">server_id = 330759                                  # ?? 服务端ID，用来高可用时做区分</span><br><span class="line">binlog_format = row                                 # ?? 为保证 GTID 复制的稳定, 行级日志</span><br><span class="line"></span><br><span class="line">binlog_rows_query_log_events=1                      # 在row模式下, 开启该参数, 将把sql语句打印到binlog日志里面, 默认是0(off), 虽然将语句放入了binlog,但不会执行这个sql,就相当于注释一样.但对于dba来说,在查看binlog的时候,很有用处.</span><br><span class="line">binlog_row_image=&apos;minimal&apos;                          # 默认为full, 在binlog为row格式下, full将记录update前后所有字段的值, minimal时, 只记录更改字段的值和where字段的值, noblob时, 记录除了blob和text的所有字段的值, 如果update的blob或text字段,也只记录该字段更改后的值,更改前的不记录;</span><br><span class="line">                                                    # 大家都知道row格式下的binlog增长速度太快, 对存储空间, 主从传输都是一个不小的压力.因为每个event记录了所有更改数据前后的值,不管数据是否有改动都会记录.binlog_row_image的引入就大大减少了binlog记录的数据.在结合binlog_rows_query_log_events,对于dba日常维护binlog是完全没有压力的,而且节省了硬盘空间开销,减小I/O,减少了主从传输压力;</span><br><span class="line"></span><br><span class="line">gtid_mode = on                                      # ?? 开启 gtid 功能</span><br><span class="line"># 保障 GTID 事务安全</span><br><span class="line"># 当启用 enforce_gtid_consistency 功能时</span><br><span class="line"># MySQL只允许能够保障事务安全, 并且能够被日志记录的SQL语句被执行</span><br><span class="line"># 像create table ... select 和 create temporarytable语句</span><br><span class="line"># 以及同时更新事务表和非事务表的SQL语句或事务都不允许执行</span><br><span class="line">enforce-gtid-consistency = true </span><br><span class="line"></span><br><span class="line"># 以下两条配置为主从切换, 数据库高可用的必须配置</span><br><span class="line"></span><br><span class="line">log_bin = mysql57-bin                               # 开启 binlog 日志功能</span><br><span class="line">log-slave-updates = on                              # ?? 开启从库更新 binlog 日志</span><br><span class="line">skip_slave_start=1                                  # ?? slave复制进程不随mysql启动而启动</span><br><span class="line"></span><br><span class="line">### 慢查询日志</span><br><span class="line">slow_query_log = 1                                  # 打开慢查询日志功能</span><br><span class="line">long_query_time = 2                                 # 超过2秒的查询记录下来</span><br><span class="line">log_queries_not_using_indexes = 0                   # 记录下没有使用索引的查询</span><br><span class="line">slow_query_log_file =/usr/local/mysql/logs/slow.log # 慢查询日志文件</span><br><span class="line">#log=/data/logs/mysql57/all.log</span><br><span class="line"></span><br><span class="line">### 自动修复</span><br><span class="line"></span><br><span class="line">relay_log_info_repository = TABLE                   # 记录 relay.info 到数据表中</span><br><span class="line">master_info_repository = TABLE                      # 记录 master.info 到数据表中 </span><br><span class="line">relay_log_recovery = on                             # 启用 relaylog 的自动修复功能</span><br><span class="line">relay_log_purge = 1                                 # 在 SQL 线程执行完一个 relaylog 后自动删除</span><br><span class="line"></span><br><span class="line">### 数据安全性配置</span><br><span class="line">log_bin_trust_function_creators = on                # wei关闭 master 创建 function 的功能</span><br><span class="line">sync_binlog = 1                                     # 每执行一个事务都强制写入磁盘</span><br><span class="line">explicit_defaults_for_timestamp=true                # 设置 timestamp 的列值为 null, 不会被设置为 current timestamp</span><br><span class="line">                                                    # timestamp 列如果没有显式定义为 not null, 则支持null属性</span><br><span class="line">### 优化配置</span><br><span class="line">ft_min_word_len = 1                                 # 优化中文全文模糊索引</span><br><span class="line">lower_case_table_names = 1                          # 默认库名表名保存为小写, 不区分大小写</span><br><span class="line">max_allowed_packet = 256M                           # 单条记录写入最大的大小限制, 过小可能会导致写入(导入)数据失败</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#rpl_semi_sync_master_enabled = 1                   # ?? 半同步复制开启</span><br><span class="line">#rpl_semi_sync_slave_enabled = 1                    </span><br><span class="line"></span><br><span class="line">#rpl_semi_sync_master_timeout = 1000                # ?? 半同步复制超时时间设置</span><br><span class="line">#rpl_semi_sync_master_wait_point = AFTER_SYNC       # ?? 复制模式(保持系统默认)</span><br><span class="line"></span><br><span class="line">#rpl_semi_sync_master_wait_slave_count = 1          # 多线程复制</span><br><span class="line">                                                    # ?? 后端只要有一台收到日志并写入 relaylog 就算成功</span><br><span class="line">slave_parallel_type = logical_clock                 # ?? 在MySQL5.7版本后可以利用逻辑时钟方式分配SQL多线程</span><br><span class="line">slave_parallel_workers = 4                          # ?? 并行的SQL线程数量, 此参数只有设置 1&lt;N 的情况下才会才起N个线程进行SQL重做</span><br><span class="line">                                                    # ?? 经过测试对比发现, 如果主库的连接线程为M, 只有M &lt; N的情况下, 备库的延迟才可以完全避免</span><br><span class="line"></span><br><span class="line">### 连接数限制</span><br><span class="line">max_connections = 1500                              </span><br><span class="line">max_connect_errors = 200                            # 验证密码超过20次拒绝连接</span><br><span class="line"></span><br><span class="line"># back_log值指出在mysql暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中</span><br><span class="line"># 也就是说, 如果MySql的连接数达到max_connections时, 新来的请求将会被存在堆栈中</span><br><span class="line"># 以等待某一连接释放资源, 该堆栈的数量即back_log, 如果等待连接的数量超过back_log</span><br><span class="line"># 将不被授予连接资源</span><br><span class="line">back_log = 500</span><br><span class="line"></span><br><span class="line">open_files_limit = 65535                            # 服务器关闭交互式连接前等待活动的秒数</span><br><span class="line">interactive_timeout = 3600                          # 服务器关闭非交互连接之前等待活动的秒数</span><br><span class="line">wait_timeout = 3600</span><br><span class="line"></span><br><span class="line">### 内存分配</span><br><span class="line"># 指定表高速缓存的大小。每当MySQL访问一个表时, 如果在表缓冲区中还有空间</span><br><span class="line"># 该表就被打开并放入其中, 这样可以更快地访问表内容</span><br><span class="line">table_open_cache = 1024                            </span><br><span class="line">binlog_cache_size = 4M                              # 为每个session 分配的内存, 在事务过程中用来存储二进制日志的缓存</span><br><span class="line"></span><br><span class="line">tmp_table_size = 128M                               # 在内存的临时表最大大小</span><br><span class="line"></span><br><span class="line"># 创建内存表的最大大小(保持系统默认, 不允许创建过大的内存表)</span><br><span class="line"># 如果有需求当做缓存来用, 可以适当调大此值</span><br><span class="line">max_heap_table_size = 16M</span><br><span class="line"># 顺序读, 读入缓冲区大小设置</span><br><span class="line"># 全表扫描次数多的话, 可以调大此值</span><br><span class="line">read_buffer_size = 1M</span><br><span class="line"># 随机读, 读入缓冲区大小设置</span><br><span class="line">read_rnd_buffer_size = 8M</span><br><span class="line"># 高并发的情况下, 需要减小此值到64K-128K</span><br><span class="line">sort_buffer_size = 1M</span><br><span class="line"># 每个查询最大的缓存大小是1M, 最大缓存64M 数据</span><br><span class="line">query_cache_size = 64M</span><br><span class="line">query_cache_limit = 1M</span><br><span class="line"># 提到 join 的效率</span><br><span class="line">join_buffer_size = 16M</span><br><span class="line"># 线程连接重复利用</span><br><span class="line">thread_cache_size = 64</span><br><span class="line"></span><br><span class="line">### InnoDB 优化</span><br><span class="line">## 内存利用方面的设置</span><br><span class="line"># 数据缓冲区</span><br><span class="line">innodb_buffer_pool_size=2G</span><br><span class="line">## 日志方面设置</span><br><span class="line"># 事务日志大小</span><br><span class="line">innodb_log_file_size = 256M</span><br><span class="line"># 日志缓冲区大小</span><br><span class="line">innodb_log_buffer_size = 4M</span><br><span class="line"># 事务在内存中的缓冲</span><br><span class="line">innodb_log_buffer_size = 3M</span><br><span class="line"># 主库保持系统默认, 事务立即写入磁盘, 不会丢失任何一个事务</span><br><span class="line">innodb_flush_log_at_trx_commit = 1</span><br><span class="line"># mysql 的数据文件设置, 初始100, 以10M 自动扩展</span><br><span class="line">#innodb_data_file_path = ibdata1:100M:autoextend</span><br><span class="line"># 为提高性能, MySQL可以以循环方式将日志文件写到多个文件</span><br><span class="line">innodb_log_files_in_group = 3</span><br><span class="line"></span><br><span class="line">##其他设置</span><br><span class="line"># 如果库里的表特别多的情况, 请增加此值</span><br><span class="line">#innodb_open_files = 800</span><br><span class="line"># 为每个 InnoDB 表分配单独的表空间</span><br><span class="line">innodb_file_per_table = 1</span><br><span class="line"># InnoDB 使用后台线程处理数据页上写 I/O（输入）请求的数量</span><br><span class="line">innodb_write_io_threads = 8</span><br><span class="line"># InnoDB 使用后台线程处理数据页上读 I/O（输出）请求的数量</span><br><span class="line">innodb_read_io_threads = 8</span><br><span class="line"># 启用单独的线程来回收无用的数据</span><br><span class="line">innodb_purge_threads = 1</span><br><span class="line"># 脏数据刷入磁盘(先保持系统默认, swap 过多使用时, 调小此值, 调小后, 与磁盘交互增多, 性能降低)</span><br><span class="line">innodb_max_dirty_pages_pct = 90 </span><br><span class="line"># 事务等待获取资源等待的最长时间</span><br><span class="line">innodb_lock_wait_timeout = 120  </span><br><span class="line"># 开启 InnoDB 严格检查模式, 不警告, 直接报错 1开启 0关闭</span><br><span class="line">innodb_strict_mode=1    </span><br><span class="line"># 允许列索引最大达到3072</span><br><span class="line">innodb_large_prefix = on</span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line"># 开启快速导出</span><br><span class="line">quick</span><br><span class="line">default-character-set = utf8mb4</span><br><span class="line">max_allowed_packet = 256M</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># include all files from the config directory</span><br><span class="line">#</span><br><span class="line">!includedir /etc/my.cnf.d</span><br></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://www.cnblogs.com/pengineer/p/4845218.html" target="_blank" rel="noopener">https://www.cnblogs.com/pengineer/p/4845218.html</a></p></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>貌似开启 skip-name-resolve模式 后, 启动mysqld的话, 会报警告  (貌似是因为初始数据库的时候, 会默认有一个 root | localhost 用户生成, 有该模式不支持反向dns, 但是默认却使用了localhost，所以会有警告)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select user,host from user;</span><br><span class="line">+---------------+-----------+</span><br><span class="line">| user          | host      |</span><br><span class="line">+---------------+-----------+</span><br><span class="line">| mysql.session | localhost |</span><br><span class="line">| mysql.sys     | localhost |</span><br><span class="line">| root          | localhost |</span><br><span class="line">+---------------+-----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p> 参考: <a href="http://blog.itpub.net/14184018/viewspace-1061224/" target="_blank" rel="noopener">http://blog.itpub.net/14184018/viewspace-1061224/</a></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2019-03-29T09:21:02.228170Z 0 [Note] Server hostname (bind-address): &apos;*&apos;; port: 3306</span><br><span class="line">2019-03-29T09:21:02.228201Z 0 [Note] IPv6 is available.</span><br><span class="line">2019-03-29T09:21:02.228211Z 0 [Note]   - &apos;::&apos; resolves to &apos;::&apos;;</span><br><span class="line">2019-03-29T09:21:02.228223Z 0 [Note] Server socket created on IP: &apos;::&apos;.</span><br><span class="line">2019-03-29T09:21:02.231618Z 0 [Warning] &apos;user&apos; entry &apos;mysql.session@localhost&apos; ignored in --skip-name-resolve mode.</span><br><span class="line">2019-03-29T09:21:02.231654Z 0 [Warning] &apos;user&apos; entry &apos;mysql.sys@localhost&apos; ignored in --skip-name-resolve mode.</span><br><span class="line">2019-03-29T09:21:02.231665Z 0 [Warning] &apos;user&apos; entry &apos;lant@localhost&apos; ignored in --skip-name-resolve mode.</span><br><span class="line">2019-03-29T09:21:02.231671Z 0 [Warning] &apos;user&apos; entry &apos;lant1@localhost&apos; ignored in --skip-name-resolve mode.</span><br><span class="line">2019-03-29T09:21:02.231695Z 0 [Warning] &apos;db&apos; entry &apos;performance_schema mysql.session@localhost&apos; ignored in --skip-name-resolve mode.</span><br><span class="line">2019-03-29T09:21:02.231699Z 0 [Warning] &apos;db&apos; entry &apos;sys mysql.sys@localhost&apos; ignored in --skip-name-resolve mode.</span><br><span class="line">2019-03-29T09:21:02.231717Z 0 [Warning] &apos;proxies_priv&apos; entry &apos;@ root@localhost&apos; ignored in --skip-name-resolve mode.</span><br><span class="line">2019-03-29T09:21:02.232858Z 0 [Warning] &apos;tables_priv&apos; entry &apos;user mysql.session@localhost&apos; ignored in --skip-name-resolve mode.</span><br><span class="line">2019-03-29T09:21:02.232897Z 0 [Warning] &apos;tables_priv&apos; entry &apos;sys_config mysql.sys@localhost&apos; ignored in --skip-name-resolve mode.</span><br><span class="line">2019-03-29T09:21:02.242378Z 0 [Note] Event Scheduler: Loaded 0 events</span><br><span class="line">2019-03-29T09:21:02.242750Z 0 [Note] /usr/local/mysql/bin/mysqld: ready for connections.</span><br></pre></td></tr></table></figure></li></ol><h2 id="编码相关"><a href="#编码相关" class="headerlink" title="编码相关"></a>编码相关</h2><p><a href="https://blog.csdn.net/javandroid/article/details/81235387" target="_blank" rel="noopener">https://blog.csdn.net/javandroid/article/details/81235387</a></p><h2 id="运行用户"><a href="#运行用户" class="headerlink" title="运行用户"></a>运行用户</h2><ol><li><p>(-M: 不要自动建立用户的登入目录; -s: 指定用户登入后所使用的shell; -g: 指定用户所属的起始群组 )</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd mysql</span><br><span class="line">useradd -s /sbin/nologin -M -g mysql mysql</span><br></pre></td></tr></table></figure></li><li><p>创建所需目录</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/mysql/</span><br><span class="line">mkdir logs tmp data</span><br></pre></td></tr></table></figure></li></ol><ol><li>设置目录相关权限 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R mysql:mysql /usr/local/mysql/</span><br></pre></td></tr></table></figure></li></ol><h2 id="root密码忘记"><a href="#root密码忘记" class="headerlink" title="root密码忘记"></a>root密码忘记</h2><ol><li><code>mysqld --skip-grant-tables &amp;</code></li><li><code>mysql -uroot -p</code> 直接回车即可<h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2></li><li><p>环境变量设置</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;PATH=/usr/local/mysql/bin:/usr/local/mysql/lib:$PATH&apos; &gt;&gt; /etc/profile // 设置环境变量, 并开机运行</span><br><span class="line">echo &apos;export PATH&apos; &gt;&gt; /etc/profile  //把PATH设为全局变量</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>此时就可以全局使用/usr/local/mysql/bin下的命令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@lant mysql]# mysqld --help</span><br><span class="line">2019-03-28T04:11:28.230733Z 0 [ERROR] mysqld: option &apos;--init_connect&apos; requires an argument</span><br><span class="line">mysqld  Ver 5.7.25 for Linux on x86_64 (Source distribution)</span><br><span class="line">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Starts the MySQL database server.</span><br><span class="line"></span><br><span class="line">Usage: mysqld [OPTIONS]</span><br><span class="line"></span><br><span class="line">For more help options (several pages), use mysqld --verbose --help.</span><br><span class="line">2019-03-28T04:11:28.231753Z 0 [ERROR] Aborting</span><br><span class="line"></span><br><span class="line">[root@lant mysql]#</span><br></pre></td></tr></table></figure></li></ol><h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><ol><li>会自动在/usr/local/mysql下生成data目录, 并且是mysql用户身份 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data</span><br></pre></td></tr></table></figure></li></ol><h2 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h2><ol><li><p>将mysql添加到systemctl系统服务</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/src/mysql-5.7.23/scripts/systemd/mysqld.service.in /usr/lib/systemd/system/mysqld.service</span><br><span class="line">cd /usr/lib/systemd/system/</span><br><span class="line">vi mysqld.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=MySQL Server</span><br><span class="line">Documentation=man:mysqld(8)</span><br><span class="line">Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html</span><br><span class="line">After=network.target</span><br><span class="line">After=syslog.target</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=mysql</span><br><span class="line">Group=mysql</span><br><span class="line"></span><br><span class="line">Type=forking</span><br><span class="line"></span><br><span class="line">PIDFile=/usr/local/mysql/mysqld.pid</span><br><span class="line"></span><br><span class="line"># Disable service start and stop timeout logic of systemd for mysqld service.</span><br><span class="line">TimeoutSec=0</span><br><span class="line"></span><br><span class="line"># Execute pre and post scripts as root</span><br><span class="line">PermissionsStartOnly=true</span><br><span class="line"></span><br><span class="line"># Needed to create system tables // 这里没找到这个脚本, 就先注释掉了</span><br><span class="line">#ExecStartPre=/usr/local/mysql/bin/mysqld_pre_systemd</span><br><span class="line"></span><br><span class="line"># Start main service</span><br><span class="line">ExecStart=/usr/local/mysql/bin/mysqld --daemonize --pid-file=/usr/local/mysql/mysqld.pid $MYSQLD_OPTS</span><br><span class="line"></span><br><span class="line"># Use this to switch malloc implementation</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/mysql</span><br><span class="line"></span><br><span class="line"># Sets open_files_limit</span><br><span class="line">LimitNOFILE = 5000</span><br><span class="line"></span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">RestartPreventExitStatus=1</span><br><span class="line"></span><br><span class="line">PrivateTmp=false</span><br></pre></td></tr></table></figure></li><li><p>然后设置开机自动启动:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start mysqld</span><br><span class="line">netstat -anpt | grep 3306</span><br><span class="line">systemctl enable mysqld</span><br><span class="line"></span><br><span class="line">[root@lant mysql]# ps aux |grep mysql</span><br><span class="line">mysql     2833  0.1  9.8 1768144 179708 ?      Sl   02:40   0:00 /usr/local/mysql/bin/mysqld --daemonize --pid-file=/usr/local/mysql/mysqld.pid</span><br><span class="line">root      2867  0.0  0.0 112704   972 pts/0    S+   02:43   0:00 grep --color=auto mysql</span><br><span class="line">[root@lant mysql]#</span><br></pre></td></tr></table></figure></li></ol><h2 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h2><ol><li><p>默认没有密码, 所以直接设置新密码后即可登录</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root -p password &quot;renyimin&quot;;</span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure></li><li><p>外部客户端连接?</p></li></ol><p>最后更新时间 2018/08/16</p><p>安装存储引擎 : <a href="https://www.cnblogs.com/wt645631686/p/8086682.html" target="_blank" rel="noopener">https://www.cnblogs.com/wt645631686/p/8086682.html</a></p><h2 id="编译过程中的问题"><a href="#编译过程中的问题" class="headerlink" title="编译过程中的问题"></a>编译过程中的问题</h2><ol><li>CMAKE 编译参数指定后, 是否在启动 mysql 时, 还可以动态修改配置?</li><li>CMAKE 编译参数未指定的话, 是否在启动mysql时, 还可以动态修改配置?<ul><li>存储引擎是以插件形式存在的, 如果编译时没有将某个存储引擎编译进来, 后续应该就不能用了<br><a href="https://www.cnblogs.com/hllnj2008/p/4043778.html" target="_blank" rel="noopener">https://www.cnblogs.com/hllnj2008/p/4043778.html</a></li><li>如果忘记编译进某个存储引擎 <a href="https://help.aliyun.com/knowledge_detail/41107.html?spm=5176.11065259.1996646101.searchclickresult.35c13f8dXRN0Rx" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/41107.html?spm=5176.11065259.1996646101.searchclickresult.35c13f8dXRN0Rx</a></li></ul></li></ol><p>3</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码下载&quot;&gt;&lt;a href=&quot;#源码下载&quot; class=&quot;headerlink&quot; title=&quot;源码下载&quot;&gt;&lt;/a&gt;源码下载&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/downloads/mysql/5.7.ht
      
    
    </summary>
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/categories/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/tags/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>60. EXPLAIN -- Extra</title>
    <link href="http://blog.renyimin.com/2019/04/15/MySQL/2019-04-15-mysql-60/"/>
    <id>http://blog.renyimin.com/2019/04/15/MySQL/2019-04-15-mysql-60/</id>
    <published>2019-04-15T08:53:49.000Z</published>
    <updated>2019-04-17T08:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-extra-information" target="_blank" rel="noopener">Extra</a>列包含有关MySQL如何解析查询的其他信息, 该列显示的是不在其他列显示的额外信息; 此字段能够给出让我们深入理解执行计划进一步的细节信息, 比如是否使用ICP, MRR等</p><h2 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a>Using filesort</h2><ol><li><p>当 SQL 中包含 ORDER BY, 而且无法利用索引完成排序操作的时候, MySQL Query Optimizer 不得不选择相应的排序算法来实现; 数据较少时从内存排序, 否则从磁盘排序; Explain不会显示的告诉客户端用哪种排序</p></li><li><p>官方解释: “MySQL需要额外的一次传递, 以找出如何按排序顺序检索行, 通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序, 并按排序顺序检索行”</p></li><li><p>示例: 使用的排序字段并没有为其创建索引</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select `name` from t3 where id in (1,2) order by name;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------+</span><br><span class="line">|  1 | SIMPLE      | t3    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    2 |   100.00 | Using where; Using filesort |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><h2 id="Using-index-主键-覆盖索引"><a href="#Using-index-主键-覆盖索引" class="headerlink" title="Using index 主键-覆盖索引"></a>Using index 主键-覆盖索引</h2><ol><li><p>直接在主键索引上完成查询和所有数据的获取, 一般是只获取主键ID  (<strong>主键 覆盖索引</strong>)</p></li><li><p>示例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select id from explain_goods where id=1;</span><br><span class="line">+----+-------------+---------------+-------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">| id | select_type | table         | type  | possible_keys | key     | key_len | ref   | rows | Extra       |</span><br><span class="line">+----+-------------+---------------+-------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | const | PRIMARY       | PRIMARY | 4       | const |    1 | Using index |</span><br><span class="line">+----+-------------+---------------+-------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>示例: 如果使用的是主键, 但是select的字段列表不止主键id, Extra 为 NULL</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select id,goods_name from explain_goods where id=1;</span><br><span class="line">+----+-------------+---------------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">| id | select_type | table         | type  | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+----+-------------+---------------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  |</span><br><span class="line">+----+-------------+---------------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; explain select * from explain_goods where id=1;</span><br><span class="line">+----+-------------+---------------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">| id | select_type | table         | type  | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+----+-------------+---------------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  |</span><br><span class="line">+----+-------------+---------------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>小结: where条件使用了主键索引, 且 select 只有主键</p></li></ol><h2 id="Using-where-Using-index-二级索引-覆盖索引"><a href="#Using-where-Using-index-二级索引-覆盖索引" class="headerlink" title="Using where; Using index 二级索引-覆盖索引"></a>Using where; Using index 二级索引-覆盖索引</h2><ol><li><p>直接在二级索引(覆盖索引)上获取全部数据 </p></li><li><p>示例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select id from explain_goods where goods_name=&quot;华为&quot;;</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+--------------------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key       | key_len | ref   | rows | Extra                    |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | ref  | idx_goods     | idx_goods | 302     | const |    1 | Using where; Using index |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+--------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; explain select id,goods_name from explain_goods where goods_name=&quot;华为&quot;;</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+--------------------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key       | key_len | ref   | rows | Extra                    |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | ref  | idx_goods     | idx_goods | 302     | const |    1 | Using where; Using index |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+--------------------------+</span><br></pre></td></tr></table></figure></li><li><p>小结: where条件用到了二级索引, 并且 select 做到覆盖索引</p></li></ol><h2 id="Using-index-condition-二级索引-非覆盖索引"><a href="#Using-index-condition-二级索引-非覆盖索引" class="headerlink" title="Using index condition 二级索引-非覆盖索引"></a>Using index condition 二级索引-非覆盖索引</h2><ol><li><p>where条件用到了二级索引, 但无法提供所有select字段: </p><ul><li>先在二级索引上使用索引查找到主键ID, 然后在主键索引上通过主键ID进行查找</li><li>这里之所以需要去主键索引上查, 是因为 select 需要的数据, 二级索引不能完全提供</li></ul></li><li><p>示例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from explain_goods where goods_name=&quot;华为&quot;;</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+-----------------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key       | key_len | ref   | rows | Extra                 |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | ref  | idx_goods     | idx_goods | 302     | const |    1 | Using index condition |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; explain select id,goods_name,goods_status from explain_goods where goods_name=&quot;华为&quot;;</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+-----------------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key       | key_len | ref   | rows | Extra                 |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | ref  | idx_goods     | idx_goods | 302     | const |    1 | Using index condition |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>小结: where条件用到了二级索引, 只不过 select 未做到覆盖索引</p></li><li><p>注意: 如果是范围查找, 优化器会在索引存在的情况下，通过符合 RANGE 范围的条数和总数的比例来选择是使用索引还是进行全表遍历</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 正常情况下</span><br><span class="line">mysql&gt; explain select stock,goods_status from explain_goods where stock&gt;1;</span><br><span class="line">+----+-------------+---------------+-------+---------------+-----------+---------+------+------+-----------------------+</span><br><span class="line">| id | select_type | table         | type  | possible_keys | key       | key_len | ref  | rows | Extra                 |</span><br><span class="line">+----+-------------+---------------+-------+---------------+-----------+---------+------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | range | idx_stock     | idx_stock | 4       | NULL |    2 | Using index condition |</span><br><span class="line">+----+-------------+---------------+-------+---------------+-----------+---------+------+------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">// 而如下一张实战的表, `car_id varchar(45)` 为单列普通索引, 表数据量比较大, mysql优化器最终变成了全表扫描  (全表扫描, 参考 type 列)</span><br><span class="line">mysql&gt; explain select * from cm_bid_history where car_id&gt;&quot;1000&quot;;</span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">| id | select_type | table          | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">|  1 | SIMPLE      | cm_bid_history | ALL  | car_id        | NULL | NULL    | NULL | 141048 | Using where |</span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>注意: 二级索引貌似为 字符类型  时, 才会是上述结果, 如果为int, Extra 可能会是 null</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  explain select stock,goods_name from explain_goods where stock=&quot;1&quot;;</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+-----------------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key       | key_len | ref   | rows | Extra                 |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | ref  | idx_stock     | idx_stock | 33      | const |    1 | Using index condition |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;  explain select stock,goods_name from explain_goods where stock=1;</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+-------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key       | key_len | ref   | rows | Extra |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | ref  | idx_stock     | idx_stock | 4       | const |    1 | NULL  |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><h2 id="Using-index-condition-Using-where"><a href="#Using-index-condition-Using-where" class="headerlink" title="Using index condition; Using where"></a>Using index condition; Using where</h2><ol><li><p>where 条件有二级索引, 也有 非索引字段时</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from explain_goods where goods_name=&quot;华为&quot; and stock=1;</span><br><span class="line"></span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+------------------------------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key       | key_len | ref   | rows | Extra                              |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | ref  | idx_goods     | idx_goods | 302     | const |    1 | Using index condition; Using where |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; explain select id from explain_goods where goods_name=&quot;华为&quot; and stock=1;</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+------------------------------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key       | key_len | ref   | rows | Extra                              |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | ref  | idx_goods     | idx_goods | 302     | const |    1 | Using index condition; Using where |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>小结: where 条件有二级索引, 也有 非索引字段时, 和覆盖不覆盖没有关系</p></li></ol><h2 id="Using-where-未用到索引"><a href="#Using-where-未用到索引" class="headerlink" title="Using where 未用到索引"></a>Using where 未用到索引</h2><ol><li><p>普通where条件, 无索引 (全表扫描, 参考 type 列)</p></li><li><p>示例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  explain select * from explain_goods where stock=1;</span><br><span class="line"></span><br><span class="line">+----+-------------+---------------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+---------------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using where |</span><br><span class="line">+----+-------------+---------------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;  explain select * from explain_goods where goods_status=1;</span><br><span class="line"></span><br><span class="line">+----+-------------+---------------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+---------------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using where |</span><br><span class="line">+----+-------------+---------------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><p>…<br>…<br>…<br>…</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><h2 id="const-row-not-found"><a href="#const-row-not-found" class="headerlink" title="const row not found"></a>const row not found</h2><ol><li>For a query such as SELECT … FROM tbl_name, the table was empty (类似于select … from tbl_name, 而表记录为空)</li></ol><h3 id="no-matching-row-in-const-table"><a href="#no-matching-row-in-const-table" class="headerlink" title="no matching row in const table"></a>no matching row in const table</h3><ol><li>表为空或者表中根据唯一键查询时没有匹配的行</li><li><p>示例: MySQL 5.7.25</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 where id= 1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | no matching row in const table |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>示例: MySQL 5.6.35</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select `name` from t1 where id = 12;</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-----------------------------------------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                                               |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-----------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | Impossible WHERE noticed after reading const tables |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-----------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>问题参考: <a href="https://segmentfault.com/q/1010000004197413" target="_blank" rel="noopener">https://segmentfault.com/q/1010000004197413</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-extra-information&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Extra&lt;/a&gt;列
      
    
    </summary>
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/categories/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/tags/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>57. EXPLAIN -- key_len 检测多列索引的使用情况</title>
    <link href="http://blog.renyimin.com/2019/04/15/MySQL/2019-04-15-mysql-57/"/>
    <id>http://blog.renyimin.com/2019/04/15/MySQL/2019-04-15-mysql-57/</id>
    <published>2019-04-15T05:13:36.000Z</published>
    <updated>2019-04-15T05:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>key_len表示索引使用的字节数，根据这个值可以判断索引的使用情况, 特别是在组合索引的时候, 判断该索引有多少部分被使用到非常重要 </p></li><li><p>在不损失精确性的情况下, 长度越短越好</p></li><li><p>在计算key_len时，下面是一些需要考虑的点: <a href="https://www.cnblogs.com/lukexwang/articles/7060950.html" target="_blank" rel="noopener">参考</a></p><ul><li>索引字段的附加信息: 可以分为变长和定长数据类型讨论, 当索引字段为定长数据类型时, 如 char, int, datetime 需要有是否为空的标记, 这个标记占用1个字节 (对于not null的字段来说,则不需要这1字节);</li><li>对于变长数据类型,比如varchar,除了是否为空的标记外,还需要有长度信息,需要占用 1-2 个字节</li><li>对于 char、varchar、blob、text 等字符集来说, key len的长度还和字符集有关, latin1一个字符占用1个字节, gbk一个字符占用2个字节, utf8一个字符占用3个字节</li></ul></li><li><p>注意: key_len只指示了where中用于条件过滤时被选中的索引列，是不包含order by/group by这一部分被选中的索引列的<br>例如, 有个联合索引idx(c1,c2,c3), 3列均是int not null, 那么下面的SQL执行计划中, key_len的值是8而不是12:<br><code>select ... from tb where c1=? and c2=? order by c1;</code></p></li><li><p>示例表结构</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `explain_goods` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `goods_number` varchar(50) NOT NULL,</span><br><span class="line">  `goods_name` varchar(100) NOT NULL,</span><br><span class="line">  `goods_weight` int(11) NOT NULL,</span><br><span class="line">  `goods_brand` varchar(50) NOT NULL,</span><br><span class="line">  `goods_desc` text NOT NULL,</span><br><span class="line">  `stock` int(11) NOT NULL,</span><br><span class="line">  `goods_status` tinyint(1) NOT NULL,</span><br><span class="line">  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `idx_goods_number` (`goods_number`) USING BTREE,</span><br><span class="line">  KEY `idx_goods` (`goods_name`,`goods_brand`,`goods_weight`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `explain_goods` VALUES (1, &apos;xs335671&apos;, &apos;华为plus&apos;, 11, &apos;荣耀&apos;, &apos;国产最强&apos;, 110, 1, &apos;2019-04-15 13:16:11&apos;, &apos;2019-04-15 13:16:37&apos;);</span><br><span class="line">INSERT INTO `explain_goods` VALUES (2, &apos;cxf77890&apos;, &apos;华为Meta20&apos;, 13, &apos;Meta&apos;, &apos;相机莱卡&apos;, 76, 1, &apos;2019-04-15 13:17:15&apos;, &apos;2019-04-15 13:17:15&apos;);</span><br></pre></td></tr></table></figure></li><li><p>示例1, 多列索引中的三个字段都被使用到时:</p><ul><li><code>goods_name varchar(100) NOT NULL</code> : 100 <em> 3(utf8) = 300字节  2个字节(长度, 貌似无论varchar(M)的M是多少, 此处都是按照2个字节来计算长度, 而且一个varchar字段此处最大是 3</em>255+2=767)</li><li><code>goods_brand varchar(50) NOT NULL</code>: 50 <em> 3(utf8) = 150 字节   2个字节(长度, 貌似无论varchar(M)的M是多少, 此处都是按照2个字节来计算长度, 而且一个varchar字段此处最大是 3</em>255+2=767 )  </li><li><p><code>goods_weight int(11) NOT NULL</code>: 4个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from explain_goods where goods_name = &quot;华为Plus&quot; and goods_brand=&quot;荣耀&quot; and goods_weight=3;</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------------------+------+-----------------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key       | key_len | ref               | rows | Extra                 |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------------------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | ref  | idx_goods     | idx_goods | 458     | const,const,const |    1 | Using index condition |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------------------+------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>当使用到其中两列: 少了一个 “<code>goods_weight</code> int(11) NOT NULL”, 非空 int 列, 也就少了4个字节 (458-4=454) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from explain_goods where goods_name = &quot;华为Plus&quot; and goods_brand=&quot;荣耀&quot;;</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------------+------+-----------------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key       | key_len | ref         | rows | Extra                 |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | ref  | idx_goods     | idx_goods | 454     | const,const |    1 | Using index condition |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------------+------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>当使用到其中一列: 又少了一个 “<code>goods_brand</code> varchar(50) NOT NULL,”, 非空 varchar 列, 也就少了 50*3+2 = 152 个字节 (454-152) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from explain_goods where goods_name = &quot;华为Plus&quot;;</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+-----------------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key       | key_len | ref   | rows | Extra                 |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | ref  | idx_goods     | idx_goods | 302     | const |    1 | Using index condition |</span><br><span class="line">+----+-------------+---------------+------+---------------+-----------+---------+-------+------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如下: 当多列索引中某一列使用了范围查询, 则右边的列无法使用索引优化 </p><ul><li><p>少了 <code>goods_weight int(11) NOT NULL</code> 的 4个字节  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from explain_goods where goods_name = &quot;华为Plus&quot; and goods_brand&gt;&quot;荣耀&quot; and goods_weight=3;</span><br><span class="line">+----+-------------+---------------+-------+---------------+-----------+---------+------+------+-----------------------+</span><br><span class="line">| id | select_type | table         | type  | possible_keys | key       | key_len | ref  | rows | Extra                 |</span><br><span class="line">+----+-------------+---------------+-------+---------------+-----------+---------+------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | range | idx_goods     | idx_goods | 454     | NULL |    1 | Using index condition |</span><br><span class="line">+----+-------------+---------------+-------+---------------+-----------+---------+------+------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>少了 <code>goods_brand varchar(50) NOT NULL</code> 152 + <code>goods_weight int(11) NOT NULL</code> 的 4 = 156个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from explain_goods where goods_name &gt; &quot;华为Plus&quot; and goods_brand=&quot;荣耀&quot; and goods_weight=3;</span><br><span class="line">+----+-------------+---------------+-------+---------------+-----------+---------+------+------+-----------------------+</span><br><span class="line">| id | select_type | table         | type  | possible_keys | key       | key_len | ref  | rows | Extra                 |</span><br><span class="line">+----+-------------+---------------+-------+---------------+-----------+---------+------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | range | idx_goods     | idx_goods | 302     | NULL |    1 | Using index condition |</span><br><span class="line">+----+-------------+---------------+-------+---------------+-----------+---------+------+------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>不是最左前缀匹配, 不会使用索引:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 最左前缀：</span><br><span class="line">mysql&gt; explain select * from explain_goods where goods_name like &quot;华为Plus%&quot; and goods_brand=&quot;荣耀&quot; and goods_weight=3;</span><br><span class="line">+----+-------------+---------------+-------+---------------+-----------+---------+------+------+-----------------------+</span><br><span class="line">| id | select_type | table         | type  | possible_keys | key       | key_len | ref  | rows | Extra                 |</span><br><span class="line">+----+-------------+---------------+-------+---------------+-----------+---------+------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | range | idx_goods     | idx_goods | 458     | NULL |    1 | Using index condition |</span><br><span class="line">+----+-------------+---------------+-------+---------------+-----------+---------+------+------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">// 非最左前缀, 未使用索引:</span><br><span class="line">mysql&gt; explain select * from explain_goods where goods_name like &quot;%华为Plus&quot; and goods_brand=&quot;荣耀&quot; and goods_weight=3;</span><br><span class="line">+----+-------------+---------------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+---------------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | ALL  | NULL          | NULL | NULL    | NULL |    1 | Using where |</span><br><span class="line">+----+-------------+---------------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;key_len表示索引使用的字节数，根据这个值可以判断索引的使用情况, 特别是在组合索引的时候, 判断该索引有多少部分被使用到非常重要 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在不损失精确性的情况下, 长度越短越好&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在计算ke
      
    
    </summary>
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/categories/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/tags/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>55. EXPLAIN -- type 列</title>
    <link href="http://blog.renyimin.com/2019/04/13/MySQL/2019-04-13-mysql-55/"/>
    <id>http://blog.renyimin.com/2019/04/13/MySQL/2019-04-13-mysql-55/</id>
    <published>2019-04-13T11:31:21.000Z</published>
    <updated>2019-04-15T05:11:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="type-列介绍"><a href="#type-列介绍" class="headerlink" title="type 列介绍"></a><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-join-types" target="_blank" rel="noopener">type 列介绍</a></h2><p>这一列描述了MySQL是如何查找表中的行的, 下面的类型从最优到最差:</p><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><ol><li><p><code>system</code> 其实是 <code>const</code> 的特例, 当表只有一行记录(等于系统表)时会出现 (业务上几乎不会出现只有一条记录的表, 所以这种情况并不多见) </p></li><li><p>system 貌似只能用于 MyISAM 和 Memory, InnoDB 模拟不出来</p><ul><li><p>MyISAM: t2表只有一条id为1, name 为Lant2的记录 (如下两条查询, 不管用没用到索引, 由于只有一条记录, 所以 type 就是 system)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain SELECT * from t2 where id=1;</span><br><span class="line">+----+-------------+-------+--------+---------------+------+---------+------+------+-------+</span><br><span class="line">| id | select_type | table | type   | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+----+-------------+-------+--------+---------------+------+---------+------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | t2    | system | PRIMARY       | NULL | NULL    | NULL |    1 | NULL  |</span><br><span class="line">+----+-------------+-------+--------+---------------+------+---------+------+------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; explain SELECT * from t2 where name=&quot;Lant2&quot;;</span><br><span class="line">+----+-------------+-------+--------+---------------+------+---------+------+------+-------+</span><br><span class="line">| id | select_type | table | type   | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+----+-------------+-------+--------+---------------+------+---------+------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | t2    | system | NULL          | NULL | NULL    | NULL |    1 | NULL  |</span><br><span class="line">+----+-------------+-------+--------+---------------+------+---------+------+------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>InnoDB示例: t2表只有一条id为1的记录, 查询不仅使用了主键索引, 查询的内容还做到了覆盖索引, 但发现 type列 结果是 <code>const</code>, 而不是 <code>system</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain SELECT id from t2 where id=1;</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra       |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t2    | const | PRIMARY       | PRIMARY | 4       | const |    1 | Using index |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ol><li><p>const 表示通过索引一次就找到了, 用于 primary key 或者 unique 索引, 因为<strong>只匹配一行数据</strong>, 所以很快 (MyISAM和InnoDB使用主键或唯一索引在where条件, 都可以模拟出来)</p></li><li><p>示例: (注意, 覆盖索引和非覆盖索引的Extra可不同)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain SELECT id from t1 where id=1;</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra       |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | const | PRIMARY       | PRIMARY | 4       | const |    1 | Using index |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; explain SELECT * from t1 where id=1;</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | t1    | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h3><ol><li><p>读取本表表中和 关联表 表中的每行组合成的一行, 除 了 system 和 const 类型之外, 这是最好的联接类型。当连接使用索引的所有部分时, 索引是 主键 或 唯一非NULL索引 时, 将使用该值<br> (InnoDB 和 MyISAM 略有不同)</p></li><li><p>InnoDB示例: 当使用主键或唯一索引, 并且查询的内容是覆盖索引, 会出现 eq_ref: </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain SELECT t1.id,t3.id FROM t1 join t3 on t1.id=t3.id;</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------------+</span><br><span class="line">| id | select_type | table | type   | possible_keys | key     | key_len | ref        | rows | Extra       |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | index  | PRIMARY       | PRIMARY | 4       | NULL       |    3 | Using index |</span><br><span class="line">|  1 | SIMPLE      | t3    | eq_ref | PRIMARY       | PRIMARY | 4       | test.t1.id |    1 | Using index |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>InnoDB示例: 当使用主键或唯一索引, 但查询的内容没有做到覆盖索引时, 就不会出现 eq_ref, 如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 可以看到 t3 使用了 index, 而 t1 使用了 ALL 全表扫描</span><br><span class="line">mysql&gt; explain SELECT t1.id,t3.id,t1.name FROM t1,t3 where t3.id=t1.id;</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra                                              |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+----------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t3    | index | PRIMARY       | PRIMARY | 4       | NULL |    3 | Using index                                        |</span><br><span class="line">|  1 | SIMPLE      | t1    | ALL   | PRIMARY       | NULL    | NULL    | NULL |    3 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+----------------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">// 如下的话, 则都是全表扫描</span><br><span class="line">mysql&gt; explain SELECT * FROM t1,t3 where t3.id=t1.id;</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                                              |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+----------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | ALL  | PRIMARY       | NULL | NULL    | NULL |    3 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | t3    | ALL  | PRIMARY       | NULL | NULL    | NULL |    3 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+----------------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>InnoDB示例: 需要注意的是, 当 InnoDB 数据量比较多的情况下, 有时即使没有做到覆盖所有, 也会出现 eq_ref</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// cm_bid_history 表中有10万数据</span><br><span class="line">explain SELECT * FROM cm_bid_history a join cm_bid_history as b on a.id=b.id;</span><br></pre></td></tr></table></figure></li><li><p>MyISAM示例 : 只要像官网说的那样, 用到了 主键 或唯一索引, 就会出现 eq_ref</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain SELECT * FROM t1,t3 where t3.id=t1.id;</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------+</span><br><span class="line">| id | select_type | table | type   | possible_keys | key     | key_len | ref        | rows | Extra |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | t1    | ALL    | PRIMARY       | NULL    | NULL    | NULL       |    3 | NULL  |</span><br><span class="line">|  1 | SIMPLE      | t3    | eq_ref | PRIMARY       | PRIMARY | 4       | test.t1.id |    1 | NULL  |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ol><li><p>这是一种索引访问, 它可能会找到多个符合条件的行, 因此它是查找和扫描的混合体; 此类索引访问只有当使用 非唯一性索引 或者 唯一性索引的非唯一性前缀 时才会发生;</p></li><li><p>不像 eq_ref 那样要求连接顺序, 也没有主键和唯一索引的要求, 只要使用相等条件检索时就可能出现, 常见于辅助索引的等值查找, 或者多列主键、唯一索引中, 使用第一个列之外的列作为等值查找也会出现, 总之, 返回数据不唯一的等值查找就可能出现</p></li><li><p>如 <code>explain select num from goods where num=11;</code> (num列是个普通索引)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select num from goods where num=11;</span><br><span class="line">+----+-------------+-------+------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key     | key_len | ref   | rows | Extra       |</span><br><span class="line">+----+-------------+-------+------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | goods | ref  | idx_num       | idx_num | 5       | const |    1 | Using index |</span><br><span class="line">+----+-------------+-------+------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><ol><li>ref_ro_null 是ref之上的一个变体, 与ref方法类似, 只是增加了null值的比较, 实际用的不多 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select id,num from goods where num=11 or num is null;</span><br><span class="line">+----+-------------+-------+-------------+---------------+---------+---------+-------+------+-----------------------+</span><br><span class="line">| id | select_type | table | type        | possible_keys | key     | key_len | ref   | rows | Extra                 |</span><br><span class="line">+----+-------------+-------+-------------+---------------+---------+---------+-------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | goods | ref_or_null | idx_num       | idx_num | 5       | const |    2 | Using index condition |</span><br><span class="line">+----+-------------+-------+-------------+---------------+---------+---------+-------+------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><ol><li><p>范围扫描是一个有限制的<strong>索引扫描</strong>, 它开始于索引里的某一点, 返回匹配这个值域的行; 这比全索引扫描好一些, 因为它用不着遍历全部索引; </p></li><li><p>显而易见的范围扫描是where子句里带有 <code>BETWEEN</code> 或 <code>&gt;</code>、<code>&lt;</code>、<code>in</code> 等的查询</p></li><li><p>MyISAM <code>in()</code> 示例: (goods设置了num做BTree索引)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select id,num from goods where num in (10,11);</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+-----------------------+</span><br><span class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra                 |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | goods | range | idx_num       | idx_num | 5       | NULL |    3 | Using index condition |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>MyISAM <code>or</code> 示例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select id,num from goods where num=10 or num=11;</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+-----------------------+</span><br><span class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra                 |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | goods | range | idx_num       | idx_num | 5       | NULL |    3 | Using index condition |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>: 当MySQL使用索引 用 in() 和 or 去查找一系列值时, 虽然都会显示为范围扫描, 但这两者其实是相当不同的访问类型, 在性能上有重要的差异</p></li><li><p>…</p></li></ol><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><ol><li><p>Full Index Scan, 和全表扫描一样, 不过index只遍历索引树, 通常比ALL快 (虽说都是读全表, 但是index是从索引中读取的, 而all是从硬盘中读取的)</p></li><li><p>如果在Extra列中看到 “Using index”, 说明MySQL正在使用覆盖索引, 它只扫描索引的数据, 比按索引次序全表扫描的开销要少很多;</p></li><li><p>示例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// InnoDB</span><br><span class="line">mysql&gt; explain select id from cm_bid_history;</span><br><span class="line">+----+-------------+----------------+-------+---------------+---------+---------+------+--------+-------------+</span><br><span class="line">| id | select_type | table          | type  | possible_keys | key     | key_len | ref  | rows   | Extra       |</span><br><span class="line">+----+-------------+----------------+-------+---------------+---------+---------+------+--------+-------------+</span><br><span class="line">|  1 | SIMPLE      | cm_bid_history | index | NULL          | deleted | 1       | NULL | 142485 | Using index |</span><br><span class="line">+----+-------------+----------------+-------+---------------+---------+---------+------+--------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">// MyISAM</span><br><span class="line">mysql&gt; explain select id from cm_bid_history_copy1;</span><br><span class="line">+----+-------------+----------------------+-------+---------------+---------+---------+------+--------+-------------+</span><br><span class="line">| id | select_type | table                | type  | possible_keys | key     | key_len | ref  | rows   | Extra       |</span><br><span class="line">+----+-------------+----------------------+-------+---------------+---------+---------+------+--------+-------------+</span><br><span class="line">|  1 | SIMPLE      | cm_bid_history_copy1 | index | NULL          | PRIMARY | 4       | NULL | 142267 | Using index |</span><br><span class="line">+----+-------------+----------------------+-------+---------------+---------+---------+------+--------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>…</p></li></ol><h3 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h3><ol><li><p>全表扫描, 通常意味着Mysql必须扫描整张表, 从头到尾去找到需要的行 (也有例外, 例如在查询里使用了LIMIT, 或者在 Extra 列中显示 “Using distinct/not exists”)</p></li><li><p>示例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// InnoDB</span><br><span class="line">mysql&gt; explain select * from cm_bid_history;</span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+--------+-------+</span><br><span class="line">| id | select_type | table          | type | possible_keys | key  | key_len | ref  | rows   | Extra |</span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+--------+-------+</span><br><span class="line">|  1 | SIMPLE      | cm_bid_history | ALL  | NULL          | NULL | NULL    | NULL | 142485 | NULL  |</span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+--------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">// MyISAM</span><br><span class="line">mysql&gt; explain select * from cm_bid_history_copy1;</span><br><span class="line">+----+-------------+----------------------+------+---------------+------+---------+------+--------+-------+</span><br><span class="line">| id | select_type | table                | type | possible_keys | key  | key_len | ref  | rows   | Extra |</span><br><span class="line">+----+-------------+----------------------+------+---------------+------+---------+------+--------+-------+</span><br><span class="line">|  1 | SIMPLE      | cm_bid_history_copy1 | ALL  | NULL          | NULL | NULL    | NULL | 142267 | NULL  |</span><br><span class="line">+----+-------------+----------------------+------+---------------+------+---------+------+--------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><h3 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h3><p>NULL是最好的, 不用访问索引或表, 直接获得数据<br>…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;type-列介绍&quot;&gt;&lt;a href=&quot;#type-列介绍&quot; class=&quot;headerlink&quot; title=&quot;type 列介绍&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/explain-outpu
      
    
    </summary>
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/categories/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/tags/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>54. EXPLAIN -- select_type 列</title>
    <link href="http://blog.renyimin.com/2019/04/11/MySQL/2019-04-11-mysql-54/"/>
    <id>http://blog.renyimin.com/2019/04/11/MySQL/2019-04-11-mysql-54/</id>
    <published>2019-04-11T03:21:53.000Z</published>
    <updated>2019-04-15T03:59:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="select-type列介绍"><a href="#select-type列介绍" class="headerlink" title="select_type列介绍"></a><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_select_type" target="_blank" rel="noopener">select_type列介绍</a></h2><ol><li><p>这一列显示了对应行是简单还是复杂SELECT, 如果是复杂SELECT, 则是三种复杂类型中的一种 </p><blockquote><p>上一篇已经介绍过: MySQL将select查询分为 简单 和 复杂 两种类型; 复杂类型又可以分成三大类: 简单子查询、所谓的派生表(在FROM子句中的子查询), 以及UNION查询 (DERIVED:派生, 衍生)</p></blockquote></li><li><p>select_type 列的常见值有:</p><ul><li><code>SIMPLE</code>: 简单的select查询, 意味着查询中不包含 <code>UNION</code> 或 子查询            (比较常见: 参考<a href="/2019/04/10/MySQL/2019-04-10-mysql-53/#简单查询">EXPLAIN — id 列 简单查询示例</a>)</li><li><code>PRIMARY</code>: 如果查询有任何复杂的子部分, 则最外层的查询会被标记为 PRIMARY       (参考<a href="/2019/04/10/MySQL/2019-04-10-mysql-53/#简单子查询">EXPLAIN — id 列 简单子查询示例</a>)</li><li><code>SUBQUERY</code>: 在SELECT或WHERE列表中包含的子查询 (注意不是 FORM的子句)         (参考<a href="/2019/04/10/MySQL/2019-04-10-mysql-53/#简单子查询">EXPLAIN — id 列 简单子查询示例</a>)</li><li><code>DERIVED</code>: 在FROM列表中包含的子查询被标记为DERIVED(衍生), MySQL会把结果放在临时表里     (参考<a href="/2019/04/10/MySQL/2019-04-10-mysql-53/#派生表-FROM子句中的子查询">EXPLAIN — id 列 派生表示例</a>)</li><li><code>UNION</code>: 若第二个select出现在 UNION 之后, 则被标记为 UNION; 若UNION包含在FROM子句的子查询中, 外层SELECT将被标记为 DERIVED;     (参考<a href="/2019/04/10/MySQL/2019-04-10-mysql-53/#UNION查询">EXPLAIN — id 列 派生表示例</a>)</li><li><p><code>UNION RESULT</code>: 用来从 UNION 的匿名临时表检索结果的SELECT被标记为 UNION RESULT           (参考<a href="/2019/04/10/MySQL/2019-04-10-mysql-53/#UNION查询">EXPLAIN — id 列 UNION查询示例</a>)</p></li><li><p>除了上面的值, <code>SUBQUERY</code> 和 <code>UNION</code> 还可以被标记为 <code>DEPENDENT</code> 和 <code>UNCACHEABLE</code><br><code>DEPENDENT</code> 意味着SELECT依赖于外层查询中发现的数据<br><code>UNCACHEABLE</code> 意味着SELECT中的某些特性组织结果被缓存与一个 Item_cache 中</p></li></ul></li><li><p><code>DEPENDENT SUBQUERY</code>: 参考P224关联子查询的优化</p></li><li><code>UNCACHEABLE SUBQUERY</code></li><li><code>DEPENDENT UNION</code></li><li><code>UNCACHEABLE UNION</code></li></ol><h2 id="测试表准备"><a href="#测试表准备" class="headerlink" title="测试表准备"></a>测试表准备</h2><p>为了后面的测试工作, 接下来简单创建几张测试表 (表本身没有业务意义, 只是为了做测试)</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>接下来将会用几个示例来演示id列几种值的效果, 对于EXPLAIN结果, 我们先只关注 select_type 这一列</p><h3 id="DEPENDENT-SUBQUERY"><a href="#DEPENDENT-SUBQUERY" class="headerlink" title="DEPENDENT SUBQUERY"></a>DEPENDENT SUBQUERY</h3><ol><li><p>参考 P224 关联子查询的优化</p><blockquote><p>P223: MySQL5.6之前, 在子查询方面比较糟糕<br> 如果是 <code>select * from a where a.id in (1,2,3)</code>, 速度不会慢<br> 但是如果写为  <code>select * from a where a.id in (select id from b where b.id in (1,2,3))</code>, mysql不会将 <code>select id from b where b.id in (1,2,3)</code> 这个内容查询出来, 放到in里<br> 如果用explain分析, 则会看到 DEPENDENT SUBQUERY, mysql会将外层的结果先查询出来, 然后逐条执行子查询, 如果外层结果集很大, 这个就会很慢(可以参考下高性能mysql的查询性能优化章节, 有详细描述)</p></blockquote></li><li><p>一般出现这种情况, 是需要进行优化的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;version&quot;;</span><br><span class="line">+---------------+--------+</span><br><span class="line">| Variable_name | Value  |</span><br><span class="line">+---------------+--------+</span><br><span class="line">| version       | 5.5.62 |</span><br><span class="line">+---------------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; EXPLAIN SELECT customer_id FROM explain_order WHERE id = ( SELECT goods_id FROM explain_goods WHERE goods_number = &quot;693822310030&quot;);</span><br><span class="line">+----+--------------------+---------------+------+---------------+------+---------+------+------+-----------------------------------------------------+</span><br><span class="line">| id | select_type        | table         | type | possible_keys | key  | key_len | ref  | rows | Extra                                               |</span><br><span class="line">+----+--------------------+---------------+------+---------------+------+---------+------+------+-----------------------------------------------------+</span><br><span class="line">|  1 | PRIMARY            | explain_order | ALL  | NULL          | NULL | NULL    | NULL |    1 | Using where                                         |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | NULL          | NULL | NULL          | NULL | NULL    | NULL | NULL | Impossible WHERE noticed after reading const tables |</span><br><span class="line">+----+--------------------+---------------+------+---------------+------+---------+------+------+-----------------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN SELECT customer_id FROM explain_order WHERE id in ( SELECT goods_id FROM explain_goods WHERE goods_number = &quot;693822310030&quot;);</span><br><span class="line">+----+--------------------+---------------+------+---------------+------+---------+------+------+-----------------------------------------------------+</span><br><span class="line">| id | select_type        | table         | type | possible_keys | key  | key_len | ref  | rows | Extra                                               |</span><br><span class="line">+----+--------------------+---------------+------+---------------+------+---------+------+------+-----------------------------------------------------+</span><br><span class="line">|  1 | PRIMARY            | explain_order | ALL  | NULL          | NULL | NULL    | NULL |    1 | Using where                                         |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | NULL          | NULL | NULL          | NULL | NULL    | NULL | NULL | Impossible WHERE noticed after reading const tables |</span><br><span class="line">+----+--------------------+---------------+------+---------------+------+---------+------+------+-----------------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>不过, 在 5.6+版本, 已经对上面的子查询做了很大的改进, 一般不会再出现 <code>DEPENDENT SUBQUERY</code> (但不是一定不出现, 如果出现需要进一步分析), 而是 <code>SUBQUERY</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;select-type列介绍&quot;&gt;&lt;a href=&quot;#select-type列介绍&quot; class=&quot;headerlink&quot; title=&quot;select_type列介绍&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.
      
    
    </summary>
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/categories/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/tags/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.renyimin.com/2019/04/10/MySQL/50-bak/"/>
    <id>http://blog.renyimin.com/2019/04/10/MySQL/50-bak/</id>
    <published>2019-04-10T08:15:46.000Z</published>
    <updated>2019-04-10T08:15:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bak"><a href="#bak" class="headerlink" title="bak"></a>bak</h2><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user_info` (</span><br><span class="line">  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `age`  INT(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `name_index` (`name`)</span><br><span class="line">) ENGINE = InnoDB, DEFAULT CHARSET = utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);</span><br><span class="line"></span><br><span class="line">CREATE TABLE `order_info` (</span><br><span class="line">  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `user_id`      BIGINT(20)           DEFAULT NULL,</span><br><span class="line">  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `productor`    VARCHAR(30)          DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br><span class="line">)ENGINE = InnoDB,</span><br><span class="line">DEFAULT CHARSET = utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);</span><br></pre></td></tr></table></figure></code></pre><h2 id="EXPLAIN-输出"><a href="#EXPLAIN-输出" class="headerlink" title="EXPLAIN 输出"></a>EXPLAIN 输出</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2;</span><br><span class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | user_info | const | PRIMARY       | PRIMARY | 8       | const |    1 | NULL  |</span><br><span class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></code></pre><h2 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h2><ol><li><p>select_type 表示了查询的类型, 它的常用取值有:</p><ul><li><code>SIMPLE</code>, 表示此查询不包含 UNION 查询或子查询 (最常见的查询类别就是 <code>SIMPLE</code> 了)</li><li><code>PRIMARY</code>, 表示此查询是最外层的查询</li><li><code>UNION</code>, 表示此查询是 UNION 的第二或随后的查询</li><li><code>DEPENDENT UNION</code>, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li><code>UNION RESULT</code>, UNION 的结果</li><li><code>SUBQUERY</code>, 子查询中的第一个 SELECT</li><li><code>DEPENDENT SUBQUERY</code>: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li></ul></li><li><p>如果使用了<code>UNION</code>查询, 那么EXPLAIN 输出结果类似如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN ( SELECT * FROM user_info WHERE id IN ( 1, 2, 3 ) ) UNION</span><br><span class="line">( SELECT * FROM user_info WHERE id IN ( 3, 4, 5 ) );</span><br><span class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</span><br><span class="line">| id   | select_type  | table      | type  | possible_keys | key     | key_len | ref  | rows | Extra           |</span><br><span class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</span><br><span class="line">|    1 | PRIMARY      | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where     |</span><br><span class="line">|    2 | UNION        | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where     |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | ALL   | NULL          | NULL    | NULL    | NULL | NULL | Using temporary |</span><br><span class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><ol><li>type 字段比较重要, 它<strong>提供了判断查询是否高效的重要依据依据</strong>; 通过 type 字段, 我们判断此次查询是 <strong>全表扫描</strong> 还是 <strong>索引扫描</strong> 等;</li><li><p>type 常用的取值有:</p><ul><li><p><code>system</code>: 表中只有一条数据, 这个类型是特殊的 <code>const</code> 类型; ??</p></li><li><p><code>const</code>: 针对<strong>主键</strong>或<strong>唯一索引</strong>的<strong>等值查询扫描</strong>, 最多只返回一行数据(const 查询速度非常快, 因为它仅仅读取一次即可)</p></li><li><p><code>eq_ref</code>: 此类型通常出现在多表的join查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果, 并且查询的比较操作通常是 =, <strong>查询效率较高</strong>, 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id;</span><br><span class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</span><br><span class="line">| id | select_type | table      | type   | possible_keys             | key                       | key_len | ref                     | rows | Extra                    |</span><br><span class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | order_info | index  | user_product_detail_index | user_product_detail_index | 254     | NULL                    |    9 | Using where; Using index |</span><br><span class="line">|  1 | SIMPLE      | user_info  | eq_ref | PRIMARY                   | PRIMARY                   | 8       | test.order_info.user_id |    1 | NULL                     |</span><br><span class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询, 例如下面这个例子中, 就使用到了 ref 类型的查询:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5;</span><br><span class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</span><br><span class="line">| id | select_type | table      | type  | possible_keys             | key                       | key_len | ref   | rows | Extra       |</span><br><span class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | user_info  | const | PRIMARY                   | PRIMARY                   | 8       | const |    1 | NULL        |</span><br><span class="line">|  1 | SIMPLE      | order_info | ref   | user_product_detail_index | user_product_detail_index | 9       | const |    1 | Using index |</span><br><span class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>range: 表示使用<code>索引范围查询</code>, 通过索引字段范围获取表中部分数据记录; 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL (没用到索引), 并且 key_len 字段是此次查询中使用到的索引的最长的那个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM user_info WHERE id BETWEEN 2 AND 8;</span><br><span class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | user_info | range | PRIMARY       | PRIMARY | 8       | NULL |    7 | Using where |</span><br><span class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>下面对比, 都使用了范围查询, 但是一个可以使用<strong>索引范围查询</strong>, 另一个不能使用索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name&gt;&apos;nihao&apos;;</span><br><span class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</span><br><span class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra                    |</span><br><span class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | user_info | range | name_index    | name_index | 152     | NULL |    1 | Using where; Using index |</span><br><span class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age&gt;10;</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>另外, 可参考 P185: in语句虽然有时候 type结果也是range (不过, 对于真正的范围查询, 确实是无法使用范围列后面的其他索引了, 但是对于”多个等值条件查询”则没有这个限制)</p></li><li><p>index: 表示<strong>全索引扫描(full index scan)</strong>, 和 ALL 类型类似, 只不过ALL类型是全表扫描, <strong>而 index 类型则仅仅扫描所有的索引, 而不扫描数据</strong><br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据, 即 做的是<strong>覆盖索引</strong>, 当是这种情况时, Extra 字段会显示 <code>Using index</code></p><p>下面的例子中, 查询的 <code>name</code> 字段恰好是一个索引(<strong>做到了覆盖索引</strong>), 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据;<br>因此这样的情况下, type 的值是 <code>index</code>, 并且 Extra 的值是 Using index;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT name FROM user_info;</span><br><span class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | user_info | index | NULL          | name_index | 152     | NULL |   10 | Using index |</span><br><span class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>下面不但使用了<code>全索引扫描</code>, 而且使用了<code>where条件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name=&apos;nihao&apos;;</span><br><span class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</span><br><span class="line">| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                    |</span><br><span class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using where; Using index |</span><br><span class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>但是, 如果不使用索引的话, 下面type就是<code>ALL</code>, 表示使用了<code>全表扫描</code>, 并且使用了where条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age=10;</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age&gt;10;</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name&gt;&apos;nihao&apos;;</span><br><span class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</span><br><span class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra                    |</span><br><span class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | user_info | range | name_index    | name_index | 152     | NULL |    1 | Using where; Using index |</span><br><span class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一, 通常来说, 我们的查询<strong>不应该出现 ALL 类型的查询</strong>, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难<br>如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</p></li><li></li></ul></li></ol><h2 id="type小结"><a href="#type小结" class="headerlink" title="type小结"></a>type小结</h2><p><strong>type 类型的性能比较</strong> : 通常来说, 不同的 type 类型的性能关系如: <code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code></p><ol><li>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的;</li><li>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快;</li><li>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了;</li></ol><h2 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h2><p>possible_keys 表示 MySQL 在查询时, 能够使用到的索引;<br>注意: 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到;(MySQL 在查询时具体使用了哪些索引, 由 key 字段决定)</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>此字段是 MySQL 在当前查询时所真正使用到的索引</p><h2 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h2><p>rows 也是一个重要的字段, MySQL 查询优化器根据统计信息, <strong>估算SQL要查找到结果集需要到表中扫描读取的数据行数</strong>(上面的例子可以看到, 基本上使用到了索引的话, 真正扫描的行数都很少); 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好</p><h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><p>Explain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ol><li><p><strong>Using filesort</strong>: 当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. </p><ul><li><p>一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</p></li><li><p>比如下面, <code>使用索引扫描做排序</code> 和 <code>不使用索引扫描做排序</code> 的效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT name FROM user_info ORDER BY name;</span><br><span class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | user_info | index | NULL          | name_index | 152     | NULL |   10 | Using index |</span><br><span class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; EXPLAIN SELECT name FROM user_info ORDER BY age;</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</span><br><span class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra          |</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</span><br><span class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using filesort |</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Using index</code> 与 <code>Using index condition</code></p><ul><li>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li><li><p>比如下面, 第一个做到了<code>覆盖索引</code>扫描, 后面两个都没做到</p><pre><code>mysql&gt; EXPLAIN SELECT name FROM user_info where name=&#39;haha&#39;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                    |+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using where; Using index |+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+1 row in set (0.00 sec)mysql&gt; EXPLAIN SELECT name,age FROM user_info where name=&#39;haha&#39;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                 |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using index condition |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+1 row in set (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM user_info where name=&#39;haha&#39;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                 |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using index condition |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+1 row in set (0.00 sec)</code></pre></li></ul></li><li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;bak&quot;&gt;&lt;a href=&quot;#bak&quot; class=&quot;headerlink&quot; title=&quot;bak&quot;&gt;&lt;/a&gt;bak&lt;/h2&gt;&lt;h2 id=&quot;准备环境&quot;&gt;&lt;a href=&quot;#准备环境&quot; class=&quot;headerlink&quot; title=&quot;准备环境&quot;&gt;&lt;/a&gt;准备环
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>53. EXPLAIN -- id 列</title>
    <link href="http://blog.renyimin.com/2019/04/10/MySQL/2019-04-10-mysql-53/"/>
    <id>http://blog.renyimin.com/2019/04/10/MySQL/2019-04-10-mysql-53/</id>
    <published>2019-04-10T06:03:18.000Z</published>
    <updated>2019-04-15T03:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="id-列介绍"><a href="#id-列介绍" class="headerlink" title="id 列介绍"></a><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_id" target="_blank" rel="noopener">id 列介绍</a></h2><ol><li><p>EXPLAIN 的执行结果会返回一行或多行信息, 显示出执行计划中的的每一部分和执行顺序, 简单点说, 就是会显示出查询中执行表及其顺序, id列就是表示查询中 ‘表’ 的执行顺序 (‘表’的意思在这里比较广义, 可以是一个子查询, 一个UNION结果等等;)</p></li><li><p>如果查询是两个表的联接, 那么输出中将有两行, 别名表会单算为一个表 (如果把一个表与自己联接, 输出中也会有两行); </p></li><li><p>MySQL将select查询分为 简单 和 复杂 两种类型; 复杂类型又可以分成三大类: 简单子查询、所谓的派生表(在FROM子句中的子查询), 以及UNION查询 (DERIVED:派生, 衍生)</p></li><li><p>id列一般会有如下几种值:</p><ul><li>简单查询: id 编号相同, 执行顺序由上至下</li><li>简单子查询: id的序号会递增, id值越大优先级越高, 越先被执行</li><li>派生表(FROM子句中的子查询): id 有相同的, 也有不同的, 相同的id可以认为是同一组, 从上往下顺序执行; id值大的, 优先级越高</li><li>UNION查询: id 为null, 当引用其他查询结果做union时, 该值为null, 且table列的值为 union(m,n), 意思是把id为m和n的查询结果做union</li></ul></li></ol><h2 id="测试表准备"><a href="#测试表准备" class="headerlink" title="测试表准备"></a>测试表准备</h2><p>为了后面的测试工作, 接下来简单创建几张测试表 (表本身没有业务意义, 只是为了做测试)</p><ol><li><p>t1表</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t1` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></li><li><p>t2表</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t2` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></li><li><p>t3表</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t3` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>接下来将会用几个示例来演示id列几种值的效果, 对于EXPLAIN结果, 我们先只关注 id 这一列</p><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><ol><li>并行的表查询, id都是1 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id and t1.id=t3.id and t1.name=&quot;test&quot;;</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+--------------------+------+-------------+</span><br><span class="line">| id | select_type | table | type   | possible_keys | key     | key_len | ref                | rows | Extra       |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+--------------------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | ALL    | PRIMARY       | NULL    | NULL    | NULL               |    1 | Using where |</span><br><span class="line">|  1 | SIMPLE      | t2    | eq_ref | PRIMARY       | PRIMARY | 4       | explain_test.t1.id |    1 | NULL        |</span><br><span class="line">|  1 | SIMPLE      | t3    | eq_ref | PRIMARY       | PRIMARY | 4       | explain_test.t1.id |    1 | NULL        |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+--------------------+------+-------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><h3 id="简单子查询"><a href="#简单子查询" class="headerlink" title="简单子查询"></a>简单子查询</h3><ol><li>id会递增 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM t1 WHERE id=(SELECT id FROM t2 WHERE id = (SELECT id FROM t3 WHERE name=&quot;Lant3&quot;));</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-----------------------------------------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                                               |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-----------------------------------------------------+</span><br><span class="line">|  1 | PRIMARY     | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | Impossible WHERE noticed after reading const tables |</span><br><span class="line">|  2 | SUBQUERY    | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | no matching row in const table                      |</span><br><span class="line">|  3 | SUBQUERY    | t3    | ALL  | NULL          | NULL | NULL    | NULL |    1 | Using where                                         |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-----------------------------------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><h3 id="in-非简单子查询"><a href="#in-非简单子查询" class="headerlink" title="in 非简单子查询??"></a>in 非简单子查询??</h3><ol><li>注意, 这里只是把上面语句的 <code>=</code> 改为 <code>in</code>, 却发现 id 没有递增  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM t1 WHERE id in (SELECT id FROM t2 WHERE id in (SELECT id FROM t3 WHERE name=&quot;Lant3&quot;));</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+--------------------+------+-------------+</span><br><span class="line">| id | select_type | table | type   | possible_keys | key     | key_len | ref                | rows | Extra       |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+--------------------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | ALL    | PRIMARY       | NULL    | NULL    | NULL               |    1 | NULL        |</span><br><span class="line">|  1 | SIMPLE      | t2    | eq_ref | PRIMARY       | PRIMARY | 4       | explain_test.t1.id |    1 | Using index |</span><br><span class="line">|  1 | SIMPLE      | t3    | eq_ref | PRIMARY       | PRIMARY | 4       | explain_test.t1.id |    1 | Using where |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+--------------------+------+-------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><h3 id="派生表-FROM子句中的子查询"><a href="#派生表-FROM子句中的子查询" class="headerlink" title="派生表(FROM子句中的子查询)"></a>派生表(FROM子句中的子查询)</h3><ol><li>下面 <code>&lt;derived2&gt;</code> 和 <code>t2</code> 都是1, 是因为 t2 和 <derived2> 是并行的一组, 而 <code>&lt;derived2&gt;</code>(derived是衍生的意思, 2是t2这一行的id值) 是衍生临时表 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM (SELECT * FROM t2 WHERE name = &quot;test&quot;) as tmp2, t1 where t1.id=tmp2.id;</span><br><span class="line">+----+-------------+------------+------+---------------+-------------+---------+--------------------+------+-------------+</span><br><span class="line">| id | select_type | table      | type | possible_keys | key         | key_len | ref                | rows | Extra       |</span><br><span class="line">+----+-------------+------------+------+---------------+-------------+---------+--------------------+------+-------------+</span><br><span class="line">|  1 | PRIMARY     | t1         | ALL  | PRIMARY       | NULL        | NULL    | NULL               |    1 | NULL        |</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | ref  | &lt;auto_key0&gt;   | &lt;auto_key0&gt; | 4       | explain_test.t1.id |    2 | NULL        |</span><br><span class="line">|  2 | DERIVED     | t2         | ALL  | NULL          | NULL        | NULL    | NULL               |    1 | Using where |</span><br><span class="line">+----+-------------+------------+------+---------------+-------------+---------+--------------------+------+-------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></derived2></li></ol><h3 id="UNION查询"><a href="#UNION查询" class="headerlink" title="UNION查询"></a>UNION查询</h3><ol><li>id 为null <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select 1 union all select 1;</span><br><span class="line">+------+--------------+------------+------+---------------+------+---------+------+------+-----------------+</span><br><span class="line">| id   | select_type  | table      | type | possible_keys | key  | key_len | ref  | rows | Extra           |</span><br><span class="line">+------+--------------+------------+------+---------------+------+---------+------+------+-----------------+</span><br><span class="line">|    1 | PRIMARY      | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | No tables used  |</span><br><span class="line">|    2 | UNION        | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | No tables used  |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | ALL  | NULL          | NULL | NULL    | NULL | NULL | Using temporary |</span><br><span class="line">+------+--------------+------------+------+---------------+------+---------+------+------+-----------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li>in 非简单子查询??  (通过 explain extended + show warnings 分析, mysql的优化语句为 join 结构)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;id-列介绍&quot;&gt;&lt;a href=&quot;#id-列介绍&quot; class=&quot;headerlink&quot; title=&quot;id 列介绍&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/explain-output.html
      
    
    </summary>
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/categories/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/tags/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>52. EXPLAIN</title>
    <link href="http://blog.renyimin.com/2019/04/10/MySQL/2019-04-10-mysql-52/"/>
    <id>http://blog.renyimin.com/2019/04/10/MySQL/2019-04-10-mysql-52/</id>
    <published>2019-04-10T05:20:29.000Z</published>
    <updated>2019-04-17T06:53:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>MySQL中的 <code>explain</code> 命令, 其主要功能是用来分析 select 语句的运行效果, 例如它可以获取select语句使用的索引情况、排序情况等等 </p><p>语法: <code>EXPLAIN [EXTENDED] SELECT select_options</code> </p><p>EXPLAIN 只能解释select查询, 并不会对存储程序调用和INSERT、UPDATE、DELETE或其他语句做解释</p><p>EXPLAIN 结果的表头如下<br>MySQL 5.6.35<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+--------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+------+-------+</span><br></pre></td></tr></table></figure></p><p>MySQL 5.7.25 (多了两列)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+--------+------------+-------+---------------+-----+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+--------+------------+-------+---------------+-----+---------+------+------+----------+-------+</span><br></pre></td></tr></table></figure></p><h2 id="测试准备"><a href="#测试准备" class="headerlink" title="测试准备"></a>测试准备</h2><ol><li><p>几张简陋的测试表</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t1` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `t2` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `t3` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></li><li><p>几张简陋的测试表</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `explain_customer`;</span><br><span class="line">CREATE TABLE `explain_customer` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `customer_name` varchar(20) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `customer_age` tinyint(3) NOT NULL DEFAULT &apos;0&apos;,</span><br><span class="line">  `gender` tinyint(1) NOT NULL DEFAULT &apos;0&apos;,</span><br><span class="line">  `identity_card_type` tinyint(1) NOT NULL DEFAULT &apos;0&apos;,</span><br><span class="line">  `identity_card_no` varchar(20) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `customer_phone` varchar(20) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `customer_level` tinyint(1) NOT NULL DEFAULT &apos;0&apos;,</span><br><span class="line">  `customer_email` varchar(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `status` int(11) NOT NULL DEFAULT &apos;0&apos;,</span><br><span class="line">  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `idx_unique_identity_card_no` (`identity_card_no`) USING BTREE COMMENT &apos;身份证号唯一&apos;,</span><br><span class="line">  UNIQUE KEY `idx_unique_phone` (`customer_phone`) USING BTREE COMMENT &apos;手机号唯一&apos;,</span><br><span class="line">  KEY `idx_unique_custome` (`customer_name`,`gender`,`customer_level`) USING BTREE COMMENT &apos;cms常用查询条件&apos;</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `explain_goods` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `goods_number` varchar(50) NOT NULL,</span><br><span class="line">  `goods_name` varchar(100) NOT NULL,</span><br><span class="line">  `goods_weight` int(11) NOT NULL,</span><br><span class="line">  `goods_brand` varchar(50) NOT NULL,</span><br><span class="line">  `stock` int(11) NOT NULL,</span><br><span class="line">  `goods_status` tinyint(1) NOT NULL,</span><br><span class="line">  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `idx_goods_number` (`goods_number`) USING BTREE,</span><br><span class="line">  KEY `idx_goods` (`goods_name`,`goods_brand`,`goods_weight`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `explain_order` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `customer_id` int(11) NOT NULL,</span><br><span class="line">  `seller_id` int(11) NOT NULL,</span><br><span class="line">  `goods_id` int(11) NOT NULL,</span><br><span class="line">  `order_number` varchar(50) NOT NULL,</span><br><span class="line">  `order_status` tinyint(1) NOT NULL DEFAULT &apos;0&apos;,</span><br><span class="line">  `pay_status` tinyint(1) NOT NULL DEFAULT &apos;0&apos;,</span><br><span class="line">  `seller_status` tinyint(1) NOT NULL COMMENT &apos;卖家备货状态&apos;,</span><br><span class="line">  `delivery_type` tinyint(1) NOT NULL COMMENT &apos;配送类型&apos;,</span><br><span class="line">  `delivery_id` int(11) NOT NULL COMMENT &apos;配送方id&apos;,</span><br><span class="line">  `order_amount` decimal(12,2) NOT NULL,</span><br><span class="line">  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `idx_order_number` (`order_number`) USING BTREE,</span><br><span class="line">  KEY `idx_ocreated_at` (`created_at`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></li></ol><h2 id="EXPLAIN-EXTENDED"><a href="#EXPLAIN-EXTENDED" class="headerlink" title="EXPLAIN EXTENDED"></a>EXPLAIN EXTENDED</h2><p>其实除了 explain 以外, 其变种 <code>explain extended</code> 命令也非常有用, 它能够在原本explain的基础上额外的提供一些查询优化的信息, 这些信息可以通过mysql的 <code>show warnings</code> 命令得到, 执行分为两步:</p><ul><li><code>explain extended 你的SQL;</code></li><li><code>show warnings;</code></li></ul><p>EXPLAIN EXTENDED 命令的表头如下:</p><ul><li><p>MySQL 5.6.35  (多了 filtered 列)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------+---------------+-----+---------+------+------+----------+--------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref  | rows | filtered | Extra  |</span><br><span class="line">+----+-------------+-------+------+---------------+-----+---------+------+------+----------+---------+</span><br></pre></td></tr></table></figure></li><li><p>MySQL 5.7.25 (相对 EXPLAIN 来说, 表头没有变化)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+--------+---------------+-----+---------+-----+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key | key_len | ref | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+-----+---------+-----+------+----------+-------+</span><br></pre></td></tr></table></figure></li></ul><p><strong>从 explain extend 的输出中, 你可以看到sql的执行方式, 对于分析sql还是很有帮助的</strong></p><p>explain extended 除了能够告诉我们mysql的查询优化能做什么, 同时也能告诉我们mysql的查询优化做不了什么</p><ul><li>比如 mysql的查询优化器不能将 id&gt;5 和 id&gt;6 这两个查询条件优化合并成一个 id&gt;6 (<a href="https://www.percona.com/blog/2006/07/24/extended-explain/" target="_blank" rel="noopener">参考</a>)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN EXTENDED SELECT * FROM t1 WHERE id &gt; 5 AND id &gt; 6;</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | range | PRIMARY       | PRIMARY | 4       | NULL |    1 |   100.00 | Using where |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; show warnings;</span><br><span class="line">+-------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Level | Code | Message                                                                                                                                                                                        |</span><br><span class="line">+-------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Note  | 1003 | /* select#1 */ select `explain_test`.`t1`.`id` AS `id`,`explain_test`.`t1`.`name` AS `name` from `explain_test`.`t1` where ((`explain_test`.`t1`.`id` &gt; 5) and (`explain_test`.`t1`.`id` &gt; 6)) |</span><br><span class="line">+-------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>: 从 <code>EXPLAIN extended</code> + <code>show warnings</code> 得到 优化以后 的查询语句可能还不是最终优化执行的sql, 或者说explain extended看到的信息还不足以说明mysql最终对查询语句优化的结果<br>    (?? <a href="https://www.jianshu.com/p/7656b114e783" target="_blank" rel="noopener">https://www.jianshu.com/p/7656b114e783</a>)</p><h2 id="EXPLAIN-EXTENDED-示例"><a href="#EXPLAIN-EXTENDED-示例" class="headerlink" title="EXPLAIN EXTENDED 示例"></a>EXPLAIN EXTENDED 示例</h2><p>如下在一个 简单的子查询中, 使用 <code>=</code> 和 使用 <code>in</code> 的结果截然不同</p><ol><li><p>使用 <code>=</code> 时, 可以看到, 3条执行记录的id是递增的, 是有两个子句的执行, 最后才执行了外层的查询 (表中无数据)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 当表中没有数据时</span><br><span class="line">mysql&gt; EXPLAIN extended SELECT * FROM t1 WHERE id = (SELECT id FROM t2 WHERE id = (SELECT id FROM t3 WHERE name=&quot;Lant3&quot;));</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+</span><br><span class="line">|  1 | PRIMARY     | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | no matching row in const table |</span><br><span class="line">|  2 | SUBQUERY    | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | no matching row in const table |</span><br><span class="line">|  3 | SUBQUERY    | t3    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using where                    |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+</span><br><span class="line">3 rows in set, 2 warnings (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show warnings;</span><br><span class="line">+---------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Level   | Code | Message                                                                                                                                                                                                                                                                 |</span><br><span class="line">+---------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Warning | 1681 | &apos;EXTENDED&apos; is deprecated and will be removed in a future release.                                                                                                                                                                                                       |</span><br><span class="line">| Note    | 1003 | /* select#1 */ select NULL AS `id`,NULL AS `name` from `test`.`t1` where multiple equal((/* select#2 */ select NULL from `test`.`t2` where multiple equal((/* select#3 */ select `test`.`t3`.`id` from `test`.`t3` where (`test`.`t3`.`name` = &apos;Lant3&apos;)), NULL)), NULL) |</span><br><span class="line">+---------+------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>而在使用 <code>in</code> 时, 可以看到, <code>id</code> 列的值都是1, 即为并行执行的, 使用 <code>show warnings</code> 查看后发现, MySQL将语句优化成了 join 结构</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN extended SELECT * FROM t1 WHERE id in (SELECT id FROM t2 WHERE id in (SELECT id FROM t3 WHERE name=&quot;Lant3&quot;));</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref        | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL       |    1 |   100.00 | NULL        |</span><br><span class="line">|  1 | SIMPLE      | t2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | test.t1.id |    1 |   100.00 | Using index |</span><br><span class="line">|  1 | SIMPLE      | t3    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | test.t1.id |    1 |   100.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------------+</span><br><span class="line">3 rows in set, 2 warnings (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show warnings;</span><br><span class="line">+---------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Level   | Code | Message                                                                                                                                                                                                                                                   |</span><br><span class="line">+---------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Warning | 1681 | &apos;EXTENDED&apos; is deprecated and will be removed in a future release.                                                                                                                                                                                         |</span><br><span class="line">| Note    | 1003 | /* select#1 */ select `test`.`t1`.`id` AS `id`,`test`.`t1`.`name` AS `name` from `test`.`t3` join `test`.`t2` join `test`.`t1` where ((`test`.`t2`.`id` = `test`.`t1`.`id`) and (`test`.`t3`.`id` = `test`.`t1`.`id`) and (`test`.`t3`.`name` = &apos;Lant3&apos;)) |</span><br><span class="line">+---------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><h2 id="EXPLAIN-PARTITIONS"><a href="#EXPLAIN-PARTITIONS" class="headerlink" title="EXPLAIN PARTITIONS"></a>EXPLAIN PARTITIONS</h2><h2 id="EXPLAIN-结果列说明"><a href="#EXPLAIN-结果列说明" class="headerlink" title="EXPLAIN 结果列说明"></a>EXPLAIN 结果列说明</h2><h3 id="跳转到-id-列"><a href="#跳转到-id-列" class="headerlink" title="跳转到 id 列"></a>跳转到 <a href="/2019/04/10/MySQL/2019-04-10-mysql-53/">id 列</a></h3><h3 id="跳转到-select-type列"><a href="#跳转到-select-type列" class="headerlink" title="跳转到 select_type列"></a>跳转到 <a href="/2019/04/11/MySQL/2019-04-11-mysql-54/">select_type列</a></h3><h3 id="table-列"><a href="#table-列" class="headerlink" title="table 列"></a><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_table" target="_blank" rel="noopener">table 列</a></h3><ol><li><p>显示这一行显示了对应行正在访问哪个表, 在通常情况下, 它相当明了: 它就是那个表, 或是该表的别名(如果sql中定义了别名)</p></li><li><p>当FROM子句中有子查询或者有UNION时, table列会变得复杂得多, 在这些场景下, 确实没有一个 “表” 可以参考到, 因为 MySQL 创建的匿名临时表仅在查询执行过程中存在</p><ul><li>当在FROM子句中有子查询时, table列是 <derivedn> 的形式, 其中 N 是子查询的id </derivedn></li><li>当有 UNION 时, UNION RESULT 的table列包含一个参与UNION的 id 列表 (<union n,m=""> )</union></li></ul></li></ol><h3 id="跳转到-type-列"><a href="#跳转到-type-列" class="headerlink" title="跳转到 type 列"></a>跳转到 <a href="/2019/04/13/MySQL/2019-04-13-mysql-55/">type 列</a></h3><ol><li>这一列显示了 MySQL 是决定如何查找表中的行, 下面是最重要的访问方法, 依次从最差到最优</li></ol><h2 id="possible-keys-key"><a href="#possible-keys-key" class="headerlink" title="possible_keys, key"></a>possible_keys, key</h2><ol><li>possible_keys: 显示可能应用在这张表中的索引, 一个或多个; 查询涉及到的字段上若存在索引, 则该索引将被列出, 但不一定被查询实际使用 </li><li>key : 实际使用的索引, 如果为NULL, 表示没有使用索引; 如果查询中使用了覆盖索引, 则该索引仅出现在key列表中</li></ol><h2 id="跳转到-key-len"><a href="#跳转到-key-len" class="headerlink" title="跳转到 key_len"></a>跳转到 <a href="/2019/04/15/MySQL/2019-04-15-mysql-57/">key_len</a></h2><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol><li><p>显示索引的哪一列被使用了, 如果可能的话, 是一个常数 (哪些列或常量被用于查找索引列上的值) </p></li><li><p>示例</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain SELECT t1.id,t3.id FROM t1 join t3 on t1.id=t3.id;</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------------+</span><br><span class="line">| id | select_type | table | type   | possible_keys | key     | key_len | ref        | rows | Extra       |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | index  | PRIMARY       | PRIMARY | 4       | NULL       |    3 | Using index |</span><br><span class="line">|  1 | SIMPLE      | t3    | eq_ref | PRIMARY       | PRIMARY | 4       | test.t1.id |    1 | Using index |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>示例</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain SELECT * from t1 where id=1;</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | t1    | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><h2 id="rows"><a href="#rows" class="headerlink" title="rows"></a><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_rows" target="_blank" rel="noopener">rows</a></h2><ol><li>根据表统计信息及索引选用情况, 大致估算出找到所需的记录所需要读取的行数, 这是MySQL认为它要检查的行数, 而不是结果集里的行数; </li><li>对于InnoDB表, 此数字是估计值, 可能并不总是准确的</li><li>…</li></ol><h2 id="跳转到-Extra-列"><a href="#跳转到-Extra-列" class="headerlink" title="跳转到 Extra 列"></a>跳转到 <a href="/2019/04/15/MySQL/2019-04-15-mysql-60/">Extra 列</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Explain&quot;&gt;&lt;a href=&quot;#Explain&quot; class=&quot;headerlink&quot; title=&quot;Explain&quot;&gt;&lt;/a&gt;Explain&lt;/h2&gt;&lt;p&gt;MySQL中的 &lt;code&gt;explain&lt;/code&gt; 命令, 其主要功能是用来分析 select
      
    
    </summary>
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/categories/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/tags/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>01. 第一章 MySQL 体系结构和存储引擎 概述</title>
    <link href="http://blog.renyimin.com/2019/04/03/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/2019-04-03-01/"/>
    <id>http://blog.renyimin.com/2019/04/03/mysql技术内幕/2019-04-03-01/</id>
    <published>2019-04-03T07:48:16.000Z</published>
    <updated>2019-04-08T10:01:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p><code>数据库</code> 和 <code>实例</code> 两个术语区分</p><ul><li>从概念上讲, 数据库是文件的集合, 是依照某种数据模型组织起来并存放于二级存储器中的数据集合</li><li>而数据库实例是程序, 是位于用户与操作系统之间的一层数据管理软件, 用户对数据库数据的任何操作, 包括数据库定义、数据查询、数据维护、数据库运行控制等都是在数据库实例下进行的</li><li>应用程序只有通过 数据库实例 才能和 数据库打交道</li></ul></li><li><p>MySQL是单进程多线程架构的数据库, MySQL数据库实例在系统上的表现就是一个进程;</p></li><li><p>当启动MySQL实例时, MySQL数据会去读取配置文件, 根据配置文件的参数来启动数据库实例; 而且MySQL数据库可以没有配置文件, 在这种情况下, MySQL会按照编译时的默认参数设置启动实例</p><ul><li><p>命令 <code>mysql --help | grep my.cnf</code> 可以查看当MySQL数据库实例启动时, 会在哪些位置查找配置文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@lant ~]# mysql --help | grep my.cnf</span><br><span class="line">order of preference, my.cnf, $MYSQL_TCP_PORT,</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf</span><br><span class="line">// (书中的是 `/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf`)</span><br><span class="line">[root@lant ~]#</span><br></pre></td></tr></table></figure></li><li><p>上述便是MySQL数据库读取配置文件的顺序, 所以如果多个配置文件中有相同的参数, 则以最后一个配置文件中的参数为准;</p></li><li>Linux下, 配置文件一般放在 /etc/my.cnf (Windows平台下, 配置文件的后缀可能是 .cnf, 也可能是 .ini)</li></ul></li></ol><h2 id="MySQL体系结构概述"><a href="#MySQL体系结构概述" class="headerlink" title="MySQL体系结构概述"></a>MySQL体系结构概述</h2><ol><li><p>MySQL的数据库体系结构图:<br> <img src="/img/mysql/技术内幕/01/MySQLServer.png"></p></li><li><p>上图可以发现, MySQL由以下几部分组成:</p><ul><li>连接池组件</li><li>管理服务和工具组件</li><li>SQL接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓冲(Cache)组件</li><li><strong>插件式</strong>存储引擎</li><li>物理文件</li></ul></li><li><p>MySQL数据库区别于其他数据库的最重要一个特点就是其 <strong>插件式</strong>的表存储引擎; 需要注意的是: <strong>存储引擎是基于表的而不是基于数据库的</strong> (每个存储引擎都有各自的特点, 同一个库中, 可以根据具体应用的特点, 使用不同的存储引擎表)</p></li></ol><h2 id="MySQL存储引擎-概述"><a href="#MySQL存储引擎-概述" class="headerlink" title="MySQL存储引擎 概述"></a>MySQL存储引擎 概述</h2><ol><li><p>由于MySQL数据库的开源特性, 存储引擎可以分为 MySQL官方存储引擎 和 第三方存储引擎 (大名鼎鼎的InnoDB存储引擎最早是第三方存储引擎, 后被Oracle收购, 其应用极其广泛, 甚至是MySQL数据库 OLTP 应用中使用最广泛的存储引擎)</p></li><li><p>可以通过 <code>SHOW ENGINES;</code> 来查看当前使用的MySQL数据库所支持的存储引擎;</p></li></ol><h3 id="InnoDB-存储引擎"><a href="#InnoDB-存储引擎" class="headerlink" title="InnoDB 存储引擎"></a>InnoDB 存储引擎</h3><ol><li><p>从MySQL5.5.8版本开始, InnoDB是默认的存储引擎; (从MySQL4.1开始, 可以将InnoDB存储引擎的表单独放到一个独立的ibd文件中)</p></li><li><p>其特点是: </p><ul><li>行锁设计</li><li>支持外键</li><li>支持全文索引 (MySQL5.6版本开始支持InnoDB引擎的全文索引, 语法层面上大多数兼容之前MyISAM的全文索引模式 )</li><li>使用 next-key locking 避免幻读(phantom)的产生</li><li>InnoDB引擎采用的是聚簇(clustered)方式, 因此每张表的存储都是按主键顺序进行存放, 如果没有显示地在表定义时指定主键, InnoDB存储引擎会为每一行生成一个<code>6字节的ROWID</code>, 并以此为主键;</li></ul></li></ol><h3 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h3><ol><li><p>在MySQL5.5.8之前, MyISAM是默认的存储引擎(除Windows版本外), 该存储引擎不支持事务, 是 表锁设计, 不支持外键, 支持全文索引 </p></li><li><p>MyISAM存储引擎的表由 <code>.frm</code>, <code>.MYD</code> 和 <code>.MYI</code> 组成</p><ul><li><code>.frm</code> 表结构文件</li><li><code>.MYD</code> 表数据文件</li><li><code>.MYI</code> 表索引文件</li></ul></li><li><p>在MySQL5.0之前, MyISAM默认支持的表达小为4GB, 如果需要支持大于4GB的MyISAM表时, 则需要定制 <code>MAX_ROWS</code> 和 <code>AVG_ROW_LENGTH</code> 属性; 从MySQL5.0版本开始, MyISAM 默认支持256TB的单标数据, 这足够满足一般应用需求</p></li><li><p>注意: 对于MyISAM存储引擎表, MySQL数据库只缓存其索引文件, 数据文件的缓存交由操作系统本身来完成</p></li></ol><h2 id="其他存储引擎"><a href="#其他存储引擎" class="headerlink" title="其他存储引擎"></a>其他存储引擎</h2><ol><li>NDB 存储引擎</li><li>MEMORY 存储引擎</li><li>ARCHIVE 存储引擎</li><li>FEDERATED 存储引擎</li><li>BLACKHOLE 存储引擎</li><li>Maria 存储引擎</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;数据库&lt;/code&gt; 和 &lt;code&gt;实例&lt;/code&gt; 两个术语区分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从概念上讲,
      
    
    </summary>
    
      <category term="MySQL技术内幕 InnoDB存储引擎" scheme="http://blog.renyimin.com/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="MySQL技术内幕 InnoDB存储引擎" scheme="http://blog.renyimin.com/tags/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>32. InnoDB 存储引擎</title>
    <link href="http://blog.renyimin.com/2019/04/02/MySQL/2019-03-07-mysql-32/"/>
    <id>http://blog.renyimin.com/2019/04/02/MySQL/2019-03-07-mysql-32/</id>
    <published>2019-04-02T11:31:07.000Z</published>
    <updated>2019-04-22T11:18:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>InnoDB存储引擎是事务安全的MySQL存储引擎, 该存储引是第一个完整支持ACID事务的MySQL存储引擎(BDB不算, 已弃用), 通常来说, 它是 在线事务处理(OLTP)应用 中, 核心表的首选存储引擎; (注意: 存储引擎是基于表的而不是基于数据库的, 也就是同一个库中, 你可以创建并使用不同存储引擎的表)</p></li><li><p>从MySQL5.5.8版本开始, InnoDB是默认的存储引擎(之前的版本InnoDB仅在Windows下座位默认的存储引擎); (从MySQL4.1开始, 可以将InnoDB存储引擎的表单独放到一个独立的ibd文件中)</p></li><li><p>InnoDB其特点是 行锁设计, 支持MVCC, 支持外键, 提供一致性非锁定读, 同时被设计用来最有效地利用以及使用内存和CPU；</p></li><li><p>另外, 从MySQL5.1版本时, MySQL数据库允许存储引擎以插件的方式动态进行加载;</p></li><li><p>查看当前MySQL数据库的InnoDB版本</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%innodb_version%&quot;;</span><br><span class="line">+----------------+--------+</span><br><span class="line">| Variable_name  | Value  |</span><br><span class="line">+----------------+--------+</span><br><span class="line">| innodb_version | 5.7.25 |</span><br><span class="line">+----------------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><h2 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h2><ol><li><p>从逻辑存储结构来看, InnoDB存储引擎下的数据都被逻辑地放在一个空间中, 称为 <code>表空间 (tablespace)</code>; 表空间是InnoDB存储引擎逻辑结构的最高层, 所有的数据都存放在表空间中, 默认, InnoDB存储引擎只有一个共享表空间ibdata1, 即所有数据都存放在这个表空间内;<br> 如果用户启用了参数 <code>innodb_file_per_table</code>, 则每张表内的数据可以单独放到一个表空间内;<br> 不过需要注意的是, 每张表的表空间年内存放的只是数据, 索引, 和插入缓冲Bitmap页, 其他类的数据, 如 回滚(undo)信息, 插入缓冲索引页, 系统事务信息, 二次写缓冲(Double write buffer)等还是存放在原来的共享表空间内;</p></li><li><p>表空间是InnoDB存储引擎逻辑结构的最高层, 它由 <code>段(segment)</code>, <code>区(extent)</code>, <code>页(page)</code>(一些文档中也称为<code>块(block)</code>) 组成; InnoDB存储引擎的逻辑存储结构大致如下:<br> <img src="/img/mysql/InnoDB/innodb-01.png" width="450/"></p></li></ol><h3 id="段-segment"><a href="#段-segment" class="headerlink" title="段(segment)"></a>段(segment)</h3><ol><li><p>上图中显示了 tablespace由segment组成, segment 由 extend 组成, extend由page组成, page由row组成; 常见的段有 数据段, 索引段, 回滚段等; 在InnoDB存储引擎中, 对段的管理都是由引擎自身所完成的, DBA不能也没有必要对其进行控制;</p></li><li><p>前面已经介绍过了InnoDB存储引擎表是索引组织的(index organized), 因此数据即索引, 索引即数据</p><ul><li>数据段: B+树的叶节点</li><li>索引段: B+树的非叶节点</li><li>回滚段: 即 rollback segment, 管理undo log segment</li></ul></li></ol><h3 id="区-extend"><a href="#区-extend" class="headerlink" title="区(extend)"></a>区(extend)</h3><ol><li><p>区是由连续的页组成, 在任何情况下, 每个区的大小都为1M, 为了保证区中页的连续性, InnoDB一次从磁盘申请4~5个区, 默认情况下, Innodb中, 页大小为16K, 即一个区中有64个连续的页;</p></li><li><p>…</p></li></ol><h3 id="页-Page"><a href="#页-Page" class="headerlink" title="页(Page)"></a>页(Page)</h3><ol><li>页是InnoDB磁盘管理的最小单位, 默认每个页的大小为16KB;</li><li>在InnoDB存储引擎中, 常见的页类型有:<ul><li>数据页(B-Tree Node)</li><li>undo页(undo Log Page)</li><li>系统页(System Page)</li><li>事务数据页(Transaction system Page)</li><li>插入缓冲位图页(Insert Buffer Bitmap)</li><li>插入缓冲空闲列表页 (Insert Buffer Free List)</li><li>未压缩的二进制大对象页 (Uncompressed BLOB Page)</li><li>压缩的二进制大对象页 (compressed BLOB Page)</li></ul></li></ol><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><ol><li></li><li></li></ol><h2 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h2><ol><li><p>InnoDB存储引擎是多线程的模型, 因此其后台有多个不同的后台线程, 负责处理不同的任务</p><ul><li>Master Thread: 是一个非常核心的后台线程, 主要负责将缓冲池中的数据异步刷新到磁盘, 保证数据的一致性, 包括脏页的刷新、合并插入缓冲(INSERT BUFFER)、UNDO页的回收等, 后面会详细介绍; </li><li><p>IO Thread:  InnoDB存储引擎中大量使用了AIO(Async IO)来处理写IO请求, 这样可以极大提高数据库的性能<br>而 IO Thread 的工作主要是负责这些IO请求的回调(call back)处理</p><p>可以通过 <code>SHOW ENGINE INNODB STATUS</code> 来观察InnoDB中的 IO Thread:</p><p>可以看到 IO Thread 0 为 insert buffer thread, IO Thread 1 为 log thread; 之后就是根据参数 <code>innodb_read_io_threads</code> 及 <code>innodb_write_io_threads</code> 来设置的读写线程, 并且读线程的ID总是小于写线程;<br>从InnoDB 1.X 开始, read thread 和 write thread 分别增大到了4个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;innodb%io_threads&quot;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_read_io_threads</span><br><span class="line">        Value: 4</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: innodb_write_io_threads</span><br><span class="line">        Value: 4</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></li><li><p>Pure Thread<br>事务被提价后, 其所使用的undolog可能不再需要,  </p></li></ul></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;InnoDB存储引擎是事务安全的MySQL存储引擎, 该存储引是第一个完整支持ACID事务的MySQL存储引擎(BDB不算
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>10. char(M) 和 varchar(M)</title>
    <link href="http://blog.renyimin.com/2019/03/30/MySQL/2017-08-23-mysql-10/"/>
    <id>http://blog.renyimin.com/2019/03/30/MySQL/2017-08-23-mysql-10/</id>
    <published>2019-03-30T10:51:28.000Z</published>
    <updated>2019-03-30T09:07:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="char-M"><a href="#char-M" class="headerlink" title="char(M)"></a>char(M)</h2><ol><li><p>char(M) 中的 <code>M</code> 用于指定该字段可存储的 <strong>字符(注意不是字节)</strong> 的最大个数<br> M 最大可以设置到 255 , 即 char(M) 最大可以存储 255个字符</p></li><li><p>注意: 在任何字符集下, M的最大值都是 255, why?</p><ul><li>因为不管在什么字符集下, 对于char(M), MySQL都会首先给该字段的分配 M*3(utf8) 个字节, 那这个字段的所有数据占用的空间都是定长的字节数了</li><li>所以char(M)的存储空间就是这么定长的, 并且你永远不可能超过MySQL分配给 char(M) 的字节数, 因为在这之前你已经被M所限制的字符个数限制住了</li></ul></li></ol><h2 id="varchar-M"><a href="#varchar-M" class="headerlink" title="varchar(M)"></a>varchar(M)</h2><ol><li><p>varchar(M) 中的 <code>M</code> 也是用于指定该字段可存储的 <strong>字符(注意不是字节)</strong> 的最大个数</p></li><li><p>不过 varchar(M) 中的 <code>M</code> <strong>和 字符编码有关</strong>, 由于 varchar最大长度是65535个<strong>字节</strong>, 所以:</p><ul><li>在utf-8编码下, M值不应该超过 21845  (因为M超过255后, 会有两个字节用于记录M的大小, 所以虽然M的最大值为 21845, 但实际能存储的最大字符数为: <code>65535-2</code> / <code>3</code> = <code>21844</code> )</li><li>在GBK编码下, M值也不应该超过 32767   (最大有效字符能存储, …. <code>65535-2</code> / <code>2</code> = <code>32766</code>)</li><li>在utfbbm4编码下, M值也不应该超过 16383   (最大有效字符能存储, … <code>65535-2</code> / <code>4</code> = <code>16383</code>)</li></ul></li><li><p>另外, 由于varchar(M)是不定长的, 因此, 每次在读取数据的时候需要知道这个数据有多少个字符, 这样才能算出总字节, 从而完整地把varchar(M)字段的数据读出来, 所以varchar事实上还会提供一个值来记录每个数据的字符长度, 这个值会占用 1-2 个字节的空间<br> 为什么该值是 1-2 个字节, 不是固定的字节? 因为1个字节可以表示的最大数值255, 而如果varchar(M)的M指定的字符数超过了255, 一个字节就不够了, 那MySQL就需要两个字节来记录字符的长度 </p></li></ol><h2 id="varchar-坑来了"><a href="#varchar-坑来了" class="headerlink" title="varchar 坑来了"></a>varchar 坑来了</h2><ol><li><p>表中只要有字段没有设置为 <code>not null</code> 属性, 每行记录就会浪费一个字节来记录null字段(具体也不知道为什么要记录), 只有所有的字段都为not null的时候, 才不会浪费一个字节来记录null</p></li><li><p>表中一旦有了varchar(M)字段之后, 表中的每行记录都自动有了每行记录的总长度, 也是65535个字节, 所以, varchar(M)的M一般不可能达到最大值</p></li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ol><li><p>如下, 你觉着如下的varchar(M), M最大可设置为多少?<br> <img src="/img/mysql/data_type/varchar_01.png" width="500/"></p></li><li><p>推算:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表中一旦有了varchar(M)字段之后, 表中的每行记录都自动有了每行记录的总长度, 也是65535个字节</span><br><span class="line">65535(行记录的总字节数) - 4*3(3个int字段) - 10*3+1(varchar(10)字段, 1个字节记录长度) = 65492</span><br><span class="line">65492/3 = 21830.67</span><br><span class="line">所以最大可以设置为21830</span><br></pre></td></tr></table></figure></li><li><p>设置为 varchar(21831) 报错, 设置 varchar(21830) 就ok了<br> <img src="/img/mysql/data_type/varchar_02.png" width="500/"></p></li><li><p>由于表中只要有字段没有设置为 <code>not null</code> 属性, 每行记录就会浪费一个字节来记录null字段, 此时如果设置一个字段为null, 会发现又不够了<br> <img src="/img/mysql/data_type/varchar_05.png" width="500/"></p></li></ol><h2 id="text-可忽略"><a href="#text-可忽略" class="headerlink" title="text (可忽略)"></a>text (可忽略)</h2><ol><li>每个BLOB和TEXT列, 账户只占其中的5至9个字节, BLOB和TEXT类型需要 1、2、3或者4个字节来记录列值的长度，取决于该类型的最大可能的长度</li><li>varchar(21830) —&gt; varchar(21826) 少了4个utf8字符, 即12字节：<br><img src="/img/mysql/data_type/varchar_03.png" width="500/"></li><li>再增一个text字段, varchar(21826) —&gt; varchar(21823) 少了3个utf8字符, 即9字节:<br> <img src="/img/mysql/data_type/varchar_04.png" width="500/"></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在建表选择字段时, 当使用varchar(M)的M值较大时, 需要注意以上内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;char-M&quot;&gt;&lt;a href=&quot;#char-M&quot; class=&quot;headerlink&quot; title=&quot;char(M)&quot;&gt;&lt;/a&gt;char(M)&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;char(M) 中的 &lt;code&gt;M&lt;/code&gt; 用于指定该字段可存储的 &lt;stro
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>100. GUID 的生成</title>
    <link href="http://blog.renyimin.com/2019/03/27/MySQL/2019-03-27-guid/"/>
    <id>http://blog.renyimin.com/2019/03/27/MySQL/2019-03-27-guid/</id>
    <published>2019-03-27T06:29:01.000Z</published>
    <updated>2019-03-27T08:34:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/ilanni/p/4080504.html" target="_blank" rel="noopener">binlog</a>相关</p><h2 id="全局GID的应用场景"><a href="#全局GID的应用场景" class="headerlink" title="全局GID的应用场景"></a>全局GID的应用场景</h2><ol><li></li><li></li><li></li><li></li><li>…等等…</li></ol><p>为什么分布式系统需要用到ID生成系统?<br><a href="https://www.jianshu.com/p/6ff45e309e65" target="_blank" rel="noopener">https://www.jianshu.com/p/6ff45e309e65</a><br><a href="https://blog.csdn.net/linzhiqiang0316/article/details/80425437" target="_blank" rel="noopener">https://blog.csdn.net/linzhiqiang0316/article/details/80425437</a></p><ol><li>在复杂分布式系统中, 往往需要对大量的数据和消息进行唯一标识<br> 如在美团点评的金融、支付、餐饮、酒店、猫眼电影等产品的系统中, 数据日渐增长, 对数据库的分库分表后需要有一个唯一ID来标识一条数据或消息, 数据库的自增ID显然不能满足需求；特别一点的如订单、骑手、优惠券也都需要有唯一ID做标识。此时一个能够生成全局唯一ID的系统是非常必要的。<br> 概括下来, 业务系统对ID号的要求有哪些呢？</li></ol><p>链接：<a href="https://www.jianshu.com/p/9d7ebe37215e" target="_blank" rel="noopener">https://www.jianshu.com/p/9d7ebe37215e</a><br><a href="http://www.sohu.com/a/211681078_467759" target="_blank" rel="noopener">http://www.sohu.com/a/211681078_467759</a></p><h2 id="GUID-与-UUID"><a href="#GUID-与-UUID" class="headerlink" title="GUID 与 UUID"></a>GUID 与 UUID</h2><ol><li></li><li></li><li></li></ol><p><a href="http://cenalulu.github.io/mysql/guid-generate/" target="_blank" rel="noopener">http://cenalulu.github.io/mysql/guid-generate/</a><br><a href="http://www.jianshu.com/p/9d7ebe37215e" target="_blank" rel="noopener">http://www.jianshu.com/p/9d7ebe37215e</a><br><a href="https://blog.csdn.net/xyznol/article/details/81262868" target="_blank" rel="noopener">https://blog.csdn.net/xyznol/article/details/81262868</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ilanni/p/4080504.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;binlog&lt;/a&gt;相关&lt;/p&gt;
&lt;h2 id=&quot;全局GID的应用场景&quot;&gt;&lt;a href=&quot;#全局G
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>50. MyISAM InnoDB 区别</title>
    <link href="http://blog.renyimin.com/2019/03/16/MySQL/2019-03-16-mysql-50/"/>
    <id>http://blog.renyimin.com/2019/03/16/MySQL/2019-03-16-mysql-50/</id>
    <published>2019-03-16T08:30:56.000Z</published>
    <updated>2019-04-25T07:11:38.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>InnoDB支持事务, MyISAM不支持, 对于InnoDB每一条SQL语言都默认封装成事务, 自动提交, 这样会影响速度, 所以最好把多条SQL语言放在begin和commit之间, 组成一个事务;</p></li><li><p>InnoDB支持外键, 而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败;</p></li><li><p>InnoDB是聚集索引, 数据文件是和索引绑在一起的, 必须要有主键, 通过主键索引效率很高。但是辅助索引需要两次查询, 先查询到主键, 然后再通过主键查询到数据。因此, 主键不应该过大, 因为主键太大, 其他索引也都会很大。而MyISAM是非聚集索引, 数据文件是分离的, 索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p></li><li><p>InnoDB不保存表的具体行数, 执行 <code>select count(*) from table</code> 时需要全表扫描。而MyISAM用一个变量保存了整个表的行数, 执行上述语句时只需要读出该变量即可, 速度很快;</p></li><li><p>Innodb不支持全文索引, 而MyISAM支持全文索引, 查询效率上MyISAM要高;</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;InnoDB支持事务, MyISAM不支持, 对于InnoDB每一条SQL语言都默认封装成事务, 自动提交, 这样会影响速度, 所以最好把多条SQL语言放在begin和commit之间, 组成一个事务;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;InnoDB支持外
      
    
    </summary>
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/categories/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/tags/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>35. The Binary Log 基础</title>
    <link href="http://blog.renyimin.com/2019/03/13/MySQL/2019-03-13-mysql-35/"/>
    <id>http://blog.renyimin.com/2019/03/13/MySQL/2019-03-13-mysql-35/</id>
    <published>2019-03-13T14:48:49.000Z</published>
    <updated>2019-04-03T03:34:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>MySQL的二进制日志 binlog 可以说是MySQL最重要的日志了, 它记录了对MySQL数据库执行更改的所有操作(同时, 还包括了更新操作的时间和其他信息;), 但是不包括 SELECT 和 SHOW 这类操作(这类操作对数据库本身并没有修改);</p></li><li><p>但是, binlog默认并没有开启, 所以直接运行 <code>show master status\G;</code> 会是如下结果:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status\G;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p> 开启 binlog 会影响性能, 但是性能的损失十分有限, 官方测试表明, 开启binlog会使性能下降1%, 但考虑到它带来的强大功能, 这些性能损失是绝对可以且应该被接受的;</p></li></ol><ol><li><p>binlog 主要有以下几种作用:</p><ul><li>数据恢复: 某些数据的恢复需要binlog (例如, 在一个数据库全备文件回复后, 用户可以通过二进制日志进行 point-int-time 的恢复)</li><li>复制: 原理与恢复类似, 通过复制和执行二进制日志使一台远程的MySQL服务器(一般称为slave或standby)与一台MySQL服务器(一般称为master或primary)进行实时同步;</li><li>审计: 用户可以通过二进制日志中的信息来进行审计, 判断是否对数据库进行注入攻击;</li></ul></li><li><p>查看binlog的相关配置项, 可以执行: (注意, 貌似在my.cnf中配置项的命名是<code>-</code>,<code>_</code>分隔单词都行, 而如下查到的是<code>_</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &quot;%binlog%&quot;\G; </span><br><span class="line">// 可以看到, 默认 binlog 是关闭状态</span><br></pre></td></tr></table></figure></li><li><p>如下是常用的两个用来查看binlog状态的命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">             File: mysql57-bin.000005</span><br><span class="line">         Position: 1865</span><br><span class="line">     Binlog_Do_DB:</span><br><span class="line"> Binlog_Ignore_DB:</span><br><span class="line">Executed_Gtid_Set:</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt; show binlog events in &apos;mysql57-bin.000005&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">   Log_name: mysql57-bin.000005</span><br><span class="line">        Pos: 4</span><br><span class="line"> Event_type: Format_desc</span><br><span class="line">  Server_id: 100</span><br><span class="line">End_log_pos: 123</span><br><span class="line">       Info: Server ver: 5.7.25-log, Binlog ver: 4</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><h2 id="查看-binlog-相关配置选项"><a href="#查看-binlog-相关配置选项" class="headerlink" title="查看 binlog 相关配置选项"></a>查看 binlog 相关配置选项</h2><ol><li><p><code>log-bin[=name]</code> : 如果不指定name, 则默认二进制文件名为主机名, 后缀名为二进制日志的序列号, 所在路径为数据库所在目录(datadir)</p><ul><li><p>要开启 binlog, 可以简单配置如下两项即可开启 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server_id = 100</span><br><span class="line">log_bin=mysql57-bin</span><br></pre></td></tr></table></figure></li><li><p>生成的 binlog 文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@lant mysql]# pwd</span><br><span class="line">/var/lib/mysql</span><br><span class="line">[root@lant mysql]# ls</span><br><span class="line">auto.cnf         ibtmp1              mysql.sock</span><br><span class="line">ca-key.pem       mysql               mysql.sock.lock</span><br><span class="line">ca.pem           mysql57-bin.000001  performance_schema</span><br><span class="line">client-cert.pem  private_key.pem     client-key.pem     </span><br><span class="line">public_key.pem   ib_buffer_pool      server-cert.pem</span><br><span class="line">ibdata1          server-key.pem      ib_logfile0      </span><br><span class="line">sys              ib_logfile1         mysql57-bin.index   </span><br><span class="line">test</span><br><span class="line">[root@lant mysql]#</span><br></pre></td></tr></table></figure></li><li><p>mysql57-bin.index 为二进制的索引文件, 用来存储过往产生的二进制日志序号, 一般不建议修改该文件;</p></li><li>开启后 <code>show master status\G;</code> 即可看到效果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>binlog_rows_query_log_events</code>, <code>binlog_row_image</code>: </p><ul><li><p>注意, MySQL默认是不会把你 执行的修改sql语句 记录到binlog中的, mysql 5.6.2 引入了两个参数 <code>binlog_rows_query_log_events</code> 和 <code>binlog_row_image</code>, 对于使用 <code>row</code> 格式的binlog, 个人觉得很有用<br><code>binlog-format=STATEMENT</code> 当设置为该配置时, 即使update的更新为0, 也会记录该语句; 而如果设置为Row, 则如果update更新为0, 不会记录;</p></li><li><p><code>binlog_rows_query_log_events=1</code>(默认是0(off)), 开启该参数后, 会把你执行的修改相关的sql语句打印到binlog日志里面 (如果日志格式为 <code>STATEMENT</code>, 即便你的修改语句影响行数为0, 也会被记录)<br>对于dba来说, 在查看binlog的时候,很有用处</p></li><li><p><code>binlog_row_image=&#39;minimal</code><br>默认为full, 在binlog为row格式下, full将记录update前后所有字段的值<br>minimal时,只记录更改字段的值和where字段的值<br>noblob时,记录除了blob和text的所有字段的值,如果update的blob或text字段,也只记录该字段更改后的值,更改前的不记录;</p></li><li><p>binlog_row_image的引入就大大减少了binlog记录的数据, 再结合 binlog_rows_query_log_events, 对于dba日常维护binlog是完全没有压力的, 而且节省了硬盘空间开销, 减小I/O, 减少了主从传输压力;</p></li><li><p>开启 binlog_rows_query_log_events 后: 有些更新操作, 本身并没有导致数据库发生变化, 但仍然可能会写入二进制日志 (当配置了 <code>binlog-format=STATEMENT</code> 时, 即便 update/delete 影响行数为0时, binlog也会记录该sql语句)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    mysql&gt; show variables like &apos;binlog_rows_query_log_events&apos;;</span><br><span class="line">    +------------------------------+-------+</span><br><span class="line">    | Variable_name                | Value |</span><br><span class="line">    +------------------------------+-------+</span><br><span class="line">    | binlog_rows_query_log_events | ON    |</span><br><span class="line">    +------------------------------+-------+</span><br><span class="line">    1 row in set (0.01 sec)</span><br><span class="line">    ```  </span><br><span class="line"></span><br><span class="line">3. 什么时候会生成新的 binlog 文件? 于binlog文件的生成规则, 大概有如下三种情况:</span><br></pre></td></tr></table></figure></li><li><p>每重启一次, 便会重新生成一个binlog文件;</p></li><li><p>还有一种情况就是运行了 <code>FLUSH LOGS</code> 命令也会重建一个;</p></li><li><p>还有一种情况就是当这个binlog文件的大小到了设定的值后, 就会重新生成一个新的(<code>max_binlog_size</code>: binlog日志每达到设定大小后, 会使用新的bin log日志, 从MySQL5.0开始的默认值是1G<br>mysql&gt; show global variables like “%max_binlog_size%”\G;<br><strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong><br>Variable_name: max_binlog_size</p><pre><code>  Value: 1073741824</code></pre><p>1 row in set (0.00 sec)</p><p>ERROR:<br>No query specified</p><p>mysql&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. `binlog_cache_size` : 当使用事务时, 所有未提交的二进制日志会被记录到一个缓存中区, 等该事务提交时, 直接将缓冲中的二进制日志写入binlog中, 而该缓冲的大小由 `binlog_cache_size` 决定, 默认大小为32k</span><br><span class="line">    - 此外, binlog_cache_size 是基于会话(session)的, 即, 当一个线程开始一个事务时, MySQL会自动分配一个大小为 binlog_cache_size 的缓存, 因此该值的设置需要相当小心, 不能设置过大;</span><br><span class="line">    - 当一个事务的记录大于设定的 binlog_cache_size 时, MySQL会把缓存中的日志写入一个临时文件中, 因此该值又不能设置的太小</span><br><span class="line">    </span><br><span class="line">5. `binlog_cache_use`, `binlog_cache_disk_use`： 通过 `show global status` 命令可以查看 `binlog_cache_use`, `binlog_cache_disk_use` 的状态, 可以判断当前 binlog_cache_size 的设置是否合适</span><br><span class="line">    - `binlog_cache_use` 记录了使用缓冲写二进制日志的次数</span><br><span class="line">    - `binlog_cache_disk_use` 记录了使用临时文件写二进制日志的次数 (如果该值为0, 表示当前binlog_cache_size设置的缓冲大小对于当前系统完全够用, 暂时没有必要增加binlog_cache_size的值)</span><br><span class="line">    </span><br><span class="line">6. `sync_binlog=[N]` : 默认情况下, 二进制日志并不是在每次写的时候都会同步到磁盘(可以理解为缓冲写), 因此, 当数据库所在操作系统发生宕机时, 可能会有最后一部分数据没有写入二进制日志文件中, 这就会给 恢复 和 复制 带来问题</span><br><span class="line">    - 参数 `sync_binlog=[N]` 表示每写缓冲多少次就同步到磁盘, 如果N设置为1, 表示采用同步写磁盘的方式来写二进制日志, 这时写操作不使用操作系统的缓冲来写二进制日志</span><br><span class="line">    - Mysql中默认 `sync_binlog=0`, 即不作任何强制性的磁盘刷新指令, 这时性能是最好的, 但风险也是最大的, 一旦系统绷Crash, 在文件系统缓存中的所有Binlog信息都会丢失 (发现MySQL5.7默认该值是1)</span><br><span class="line">    如果使用InnoDB存储引擎进行复制, 并且想得到最大的高可用性, 建议将该值设置为ON, 不过该值设置为ON, 确实会对数据库的IO带来一定的影响;</span><br><span class="line"></span><br><span class="line">7. `innodb_support_xa`: 但是, 即便是 sync_binlog 设置为1, 还是会有一种情况导致问题的发生</span><br><span class="line">    - 当使用InnoDB存储引擎时, 在一个事务发出COMMIT动作之前, 由于sync_binlog为1, 因此会将二进制日志立即写入磁盘</span><br><span class="line">    - 如果这时已经写入了二进制日志, 但是提交还没有发生, 突然宕机, 那么下次MySQL启动时, 由于commit操作并没有发生, 所以这个事务会被回滚掉; 但是二进制日志已经记录了该事物信息, 不能被回滚;</span><br><span class="line">    这个问题可以通过将参数 `innodb_support_xa` 设置为1来解决</span><br><span class="line">    - innodb_support_xa 可以开关InnoDB的xa两段式事务提交, 可参考[此文](http://blog.itpub.net/15498/viewspace-2153760/)</span><br><span class="line"></span><br><span class="line">8. `binlog-do-db` 和 `binlog-ignore-db` 表示需要写入或忽略写入哪些库的日志, 默认为空, 表示需要同步所有库的日志到二进制日志</span><br><span class="line">    如果当前数据库是复制中的slave角色, 则它不会将从master取得并执行的二进制日志写入自己的二进制日志文件中去, 如果要写入, 需要设置 `log-slave-update`, 如果需要搭建 `master=&gt;slave=&gt;slave` 架构的复制, 则必须设置该参数;</span><br><span class="line"> </span><br><span class="line">9. `binlog_format` 参数十分重要, 是MySQL5.1引入的, 可以设置如下几个值:</span><br><span class="line">    - `STATEMENT` : STATEMENT和之前的MySQL版本一样, 二进制日志记录的是日志的逻辑SQL语句</span><br><span class="line">    </span><br><span class="line">    - `ROW` : 在ROW下, 二进制日志记录的不再是简单的SQL语句, 而是记录表的 行更改情况 </span><br><span class="line">    **从MySQL5.1开始, 如果设置了binlog_format为ROW, 则可以将InnoDB的事务隔离级别设置为 READ COMMITTED, 以获得更高的并发性!**</span><br><span class="line">    </span><br><span class="line">    - `MIXED` : MySQL默认会再用satement格式进行二进制日志文件的记录, 但是在一些情况下会使用ROW格式, 可能的情况有:</span><br><span class="line">    表的存储引擎为NDB, 这时对表的DML操作都会以ROW格式记录</span><br><span class="line">    使用了UUID(), USER(), CURRENT_USER(), FOUND_ROWS(), ROW_COUNT() 等不确定函数</span><br><span class="line">    使用了 INSERT DELAY语句</span><br><span class="line">    使用了用户自定义函数(UDF)</span><br><span class="line">    使用了临时表</span><br><span class="line"></span><br><span class="line">## binlog与redo log</span><br><span class="line">1. 在MySQL中, 二进制日志 binlog 是server层的, 主要用来做主从复制和即时点恢复时使用的, 而事务日志 redo-log 是InnoDB存储引擎层的, 用来保证事务安全; </span><br><span class="line"></span><br><span class="line">2. 那binlog和redo-log之间有什么关系? 为什么MySQL有binlog了还有redo-log?</span><br><span class="line">    因为MySQL体系结构的原因, MySQL是多存储引擎的, 不管使用那种存储引擎, 都会有binlog, 而不一定有redo log; 简单的说，binlog是MySQL Server层的, redo log是InnoDB层的</span><br><span class="line"></span><br><span class="line">3. 事务提交先写 binlog 还是 redo log? 如何保证这两部分的日志做到顺序一致性?</span><br><span class="line">3. MySQL Binary log在MySQL 5.1版本后推出主要用于主备复制的搭建, 回顾下MySQL在开启/关闭Binary Log功能的情况下是如何工作的:</span><br><span class="line">    - 首先看一下什么是CrashSafe？CrashSafe指MySQL服务器宕机重启后，能够保证：</span><br><span class="line">    - MySQL没有开启Binary log的情况下？</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">   – 所有已经提交的事务的数据仍然存在。</span><br><span class="line">   </span><br><span class="line">   – 所有没有提交的事务的数据自动回滚。</span><br><span class="line">   </span><br><span class="line">   Innodb通过Redo Log和Undo Log可以保证以上两点。为了保证严格的CrashSafe，必须要在每个事务提交的时候，将Redo Log写入硬件存储。这样做会牺牲一些性能，但是可靠性最好。为了平衡两者，InnoDB提供了一个 `innodb_flush_log_at_trx_commit` 系统变量，用户可以根据应用的需求自行调整。</span><br><span class="line">   </span><br><span class="line">   innodb_flush_log_at_trx_commit = 0|1|2</span><br><span class="line">   </span><br><span class="line">   0 – 每N秒将Redo Log Buffer的记录写入Redo Log文件，并且将文件刷入硬件存储1次。N由innodb_flush_log_at_timeout控制。</span><br><span class="line">   </span><br><span class="line">   1 – 每个事务提交时，将记录从Redo Log Buffer写入Redo Log文件，并且将文件刷入硬件存储。</span><br><span class="line">   </span><br><span class="line">   2 – 每个事务提交时，仅将记录从Redo Log Buffer写入Redo Log文件。Redo Log何时刷入硬件存储由操作系统和innodb_flush_log_at_timeout决定。这个选项可以保证在MySQL宕机，而操作系统正常工作时，数据的完整性。</span><br><span class="line">   </span><br><span class="line">   通过redo日志将所有已经在存储引擎内部提交的事务应用redo log恢复，所有已经prepare但是没有commit的transactions将会应用undo log做rollback。然后客户端连接时就能看到已经提交的数据存在数据库内，未提交被回滚地数据需要重新执行。</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">2. </span><br><span class="line">3. </span><br><span class="line">1. https://blog.csdn.net/zbszhangbosen/article/details/9132833</span><br><span class="line"></span><br><span class="line">## </span><br><span class="line">https://www.cnblogs.com/danhuangpai/p/9456990.html</span><br><span class="line"></span><br><span class="line">1. MySQL的二进制日志 binlog 可以说是MySQL最重要的日志了, 它记录了所有的DDL和DML(除了数据查询语句)语句, 以事件形式记录, 还包含语句所执行的消耗的时间, MySQL的二进制日志是事务安全型的。</span><br><span class="line">   </span><br><span class="line">       一般来说开启二进制日志大概会有1%的性能损耗(参见MySQL官方中文手册 5.1.24版)。二进制有两个最重要的使用场景: </span><br><span class="line">       其一：MySQL Replication在Master端开启binlog, Mster把它的二进制日志传递给slaves来达到master-slave数据一致的目的。 </span><br><span class="line">       其二：自然就是数据恢复了, 通过使用mysqlbinlog工具来使恢复数据。</span><br><span class="line">       </span><br><span class="line">       二进制日志包括两类文件：二进制日志索引文件（文件名后缀为.index）用于记录所有的二进制文件, 二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML(除了数据查询语句)语句事件。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">https://www.cnblogs.com/kevingrace/p/6065088.html</span><br><span class="line"></span><br><span class="line">1. binlog 默认是关闭的</span><br></pre></td></tr></table></figure><p>mysql&gt; show global variables like “%log_bin%”;<br>+————————————————-+———-+<br>| Variable_name                   | Value |<br>+————————————————-+———-+<br>| log_bin                         | OFF   |<br>| log_bin_basename                |       |<br>| log_bin_index                   |       |<br>| log_bin_trust_function_creators | OFF   |<br>| log_bin_use_v1_row_events       | OFF   |<br>+————————————————-+———-+<br>5 rows in set (0.01 sec)<br>```</p></li></ul></li></ol><p><a href="https://blog.csdn.net/a375015762/article/details/80152964" target="_blank" rel="noopener">https://blog.csdn.net/a375015762/article/details/80152964</a></p><h2 id="binlog-打开瞧瞧"><a href="#binlog-打开瞧瞧" class="headerlink" title="binlog 打开瞧瞧"></a>binlog 打开瞧瞧</h2><h2 id="binlog-实现闪回"><a href="#binlog-实现闪回" class="headerlink" title="binlog 实现闪回"></a>binlog 实现闪回</h2><p><a href="https://blog.51cto.com/lisea/1949859" target="_blank" rel="noopener">https://blog.51cto.com/lisea/1949859</a><br><a href="http://www.17bianji.com/lsqh/39027.html" target="_blank" rel="noopener">http://www.17bianji.com/lsqh/39027.html</a></p><h2 id="binlog-解析工具"><a href="#binlog-解析工具" class="headerlink" title="binlog 解析工具"></a>binlog 解析工具</h2><h2 id="binlog-可视化"><a href="#binlog-可视化" class="headerlink" title="binlog 可视化"></a>binlog 可视化</h2><p>binlog日志文件的格式为二进制, 不能像错误日志文件, 慢查询日志文件那样用 cat, head, tail 等命令来查看, 要查看二进制日志文件的内容, 必须通过MySQL提供的工具 mysqlbinlog</p><p><a href="https://blog.csdn.net/enmotech/article/details/80175420" target="_blank" rel="noopener">https://blog.csdn.net/enmotech/article/details/80175420</a><br><a href="https://yq.aliyun.com/articles/338423" target="_blank" rel="noopener">https://yq.aliyun.com/articles/338423</a></p><h2 id="阿里-canal"><a href="#阿里-canal" class="headerlink" title="阿里 canal"></a>阿里 canal</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;MySQL的二进制日志 binlog 可以说是MySQL最重要的日志了, 它记录了对MySQL数据库执行更改的所有操作(同
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>33. 事务, redolog, undolog</title>
    <link href="http://blog.renyimin.com/2019/03/10/MySQL/2019-03-10-mysql-33/"/>
    <id>http://blog.renyimin.com/2019/03/10/MySQL/2019-03-10-mysql-33/</id>
    <published>2019-03-10T14:48:49.000Z</published>
    <updated>2019-04-08T13:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html</a></p><h2 id="redo-概述"><a href="#redo-概述" class="headerlink" title="redo 概述"></a>redo 概述</h2><ol><li><p>redo log 也叫重做日志, 用来实现事务的持久性, 即 ACID 中的 D, 其由两部分组成:</p><ul><li>一是 <code>内存中的 重做日志缓冲(redo log buffer)</code>, 其是易失的</li><li>二是 <code>重做日志文件(redo log file)</code>, 其是持久的</li></ul></li><li><p>InnoDB存储引擎通过 Force Log at Commit 机制实现事务的持久性, 即当事务提交(COMMIT)时, 必须先将该事务的所有日志写入到磁盘上的 <code>重做日志文件</code> 进行持久化<br> 注意: 这里的重做日志, 不是特指 redo log, 这里说的重做日志是包含了 redo log, undo log 两部分</p></li><li><p>为了确保事务在提交时, 其所有日志都能写入到 重做日志文件 中, 在每次将 log buffer 中的日志写入日志文件的过程中都会调用一次操作系统的 <code>fsync</code> 操作(即 fsync系统调用)<br> 在 InnoDB存储引擎的配置中参数 <code>innodb_flush_method</code> 通常设置为 <code>O_DIRECT</code>, 这也是官方文档所推荐的设置值。DBA或开发人员 知道该参数是文件打开的一个标识，启用后文件的写入将绕过操作系统缓存, 直接写文件。其在InnoDB存储引擎中的表现为对于写入到数据表空间将绕过操作 系统缓存。这样设置通常不会有更好的性能，但是数据库已经有自己的缓存系统，这样的设置可以确定数据库系统对于内存的使用。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global variables like &quot;%innodb_flush_method%&quot;;</span><br><span class="line">+---------------------+-------+</span><br><span class="line">| Variable_name       | Value |</span><br><span class="line">+---------------------+-------+</span><br><span class="line">| innodb_flush_method |       |</span><br><span class="line">+---------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><ul><li>也就是说, 从 redo log buffer 将日志刷到磁盘的 redo log file 的过程大致如下:<br><img src="/img/mysql/技术内幕/01/redo01.png"></li></ul></li><li><p>MySQL 支持用户自定义在commit事务时, 如何将 log buffer 中的日志刷到 磁盘的 log file 中, 参数 <code>innodb_flush_log_at_trx_commit</code> 就是用来控制重做日志刷新到磁盘的策略</p><ul><li><p>innodb_flush_log_at_trx_commit 有3种值: 0, 1, 2 (默认为1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%innodb_flush_log_at_trx_commit%&quot;;</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">| Variable_name                  | Value |</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">| innodb_flush_log_at_trx_commit | 1     |</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p>当设置为1时, 事务每次提交都会将log buffer中的日志写入os buffer并调用fsync()刷到log file on disk中, 这种方式即使系统崩溃也不会丢失任何数据, 但是因为每次提交都写入磁盘, IO的性能较差</p></li><li>当设置为0时, 事务提交时不会将log buffer中日志写入到os buffer, 而是每秒写入os buffer并调用fsync()写入到log file on disk中, 也就是说设置为0时, 是(大约)每秒刷新写入到磁盘中的, 当系统崩溃, 会丢失1秒钟的数据</li><li>当设置为2时, 每次提交都仅写入到os buffer, 然后是每秒调用fsync()将os buffer中的日志写入到log file on disk, 在这个设置下, 当 MySQL数据库发生宕机而操作系统不发生宕机时, 并不会导致事务的丢失而当操作系统宕机时, 重启数据库后会丢失未从文件系统缓存刷新到重做日志文件那部分事务</li></ul></li><li><p>innodb_flush_log_at_trx_commit 策略大致如下:<br> <img src="/img/mysql/技术内幕/01/redo02.png"><br> 注意, 有一个变量 <code>innodb_flush_log_at_timeout</code> 的值为1秒, 该变量表示的是刷日志的频率</p></li><li><p><strong>注意:</strong> 在主从复制结构中, 要保证事务的持久性和一致性, 需要对日志相关变量设置为如下:</p><ul><li>如果启用了二进制日志, 则设置 <code>sync_binlog=1</code>, 即每提交一次事务同步写到磁盘中</li><li>总是设置 <code>innodb_flush_log_at_trx_commit=1</code>, 即每提交一次事务都写到磁盘中</li><li>上述两项变量的设置保证了 每次提交事务都写入 二进制日志 和 事务日志, 并在提交时将它们刷新到磁盘中</li></ul></li></ol><h2 id="log-block"><a href="#log-block" class="headerlink" title="log block"></a>log block</h2><ol><li>Innodb存储引擎中, redo log 是以 块 为单位进行存储的, 每个块占512字节, 这称为 redo log block, 所以不管是log buffer中还是os buffer中以及redo log file on disk中, 都是这样以512字节的块存储的;</li></ol><pre><code>每个redo log block由3部分组成：日志块头、日志块尾和日志主体。其中日志块头占用12字节，日志块尾占用8字节，所以每个redo log block的日志主体部分只有512-12-8=492字节</code></pre><h3 id="redo-与-binlog"><a href="#redo-与-binlog" class="headerlink" title="redo 与 binlog"></a>redo 与 binlog</h3><ol><li><h2 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h2></li><li><p>redolog 记录了事务的行为, 可以很好地通过其对页进行 “重做” 操作, 但是事务有时还需要进行回滚操作, 这时就需要 undo; 因此在对数据库进行修改时, InnoDB存储引擎不但会产生redo, 还会产生一定量的 undo<br> 这样, 如果用户执行的事务由于某种原因失败了, 或者用户执行了 ROLLBACK 语句请求回滚, 就可以利用这些 undo 信息将数据回滚到修改之前的样子;  </p></li><li><p>redo存放在重做日志文件中, 与redo不同, undo存放在数据库内部的一个特殊段(segment)中, 这个段称为 undo 段 (undo segment)</p><ul><li>undo段位于共享表空间内</li><li>用户通常对undo有这样的误解:<br>undo用于将数据库物理地恢复到执行语句或事务之前的样子, 但事实并非如此<br>undo是逻辑日志, 因此只是将数据库逻辑地恢复到原来的样子, 所有修改都被逻辑地取消了, 但是数据结构和页本身在回滚之后可能大不相同; 这是因为在多用户并发系统中, 可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如, 一个事务在修改当前一个页中某几条记录, 同时还有别的事务在对同一个页中另几条记录进行修改, 因此,不能将一个页回滚到事务开始的样子, 因为这样会影响其他事务正在进行的工作;<br>例如, 用户执行了一个INSERT10W条记录的事务, 这个事务会导致分配一个新的段, 即表空间会增大, 在用户执行 ROLLBACK时, 会将插入的事务进行回滚, 但是表空间的大小并不会因此而收缩, 因此, 当 InnoDB存储引擎回滚时, 它实际上做的是与先前相反的工作, 对于每个INSERT, InnoDB存储引擎会完成一个DELETE; 对于每个DELETE, InnoDB存储引擎会执行一个 INSERT; 对于每个UPDATE, InnoDB存储引擎会执行一个相反的UPDATE, 将修改前的行放回去;<br>除了回滚操作, undo的另一个作用是MVCC, 即在 InnoDB存储引擎中MVCC的实现是通过undo来完成, 当用户读取一行记录时, 若该记录已经被其他事务占用, 当前事务可以通过undo读取之前的行版本信息, 以此实现非锁定读取<br>最后也是最为重要的一点是, undo log会产生redo log, 也就是undo log的产生会伴随着 redo log的产生, 这是因为undo log也需要持久性的保护</li></ul></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/f-ck
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>46. 高性能索引 -- 覆盖索引</title>
    <link href="http://blog.renyimin.com/2019/03/09/MySQL/2019-03-09-mysql-46/"/>
    <id>http://blog.renyimin.com/2019/03/09/MySQL/2019-03-09-mysql-46/</id>
    <published>2019-03-09T03:12:09.000Z</published>
    <updated>2019-04-25T09:06:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>如果一个索引包含(或者说覆盖)所有需要查询的字段的值, 我们就称该索引为 “覆盖索引”; （其实覆盖索引是针对二级索引的, 聚簇索引的查找已经算是回表了）</p></li><li><p>覆盖索引对于InnoDB表特别有用, InnoDB的二级索引在叶子节点中保存了行的主键值, 但如果二级索引能够做到覆盖索引(即除了主键还保存了你所需要查询的列值), 那么只需要遍历一次B-Tree(可以直接在二级索引中找到数据), 可以避免 回表 对主键索引的二次查询; (其他更多参考 P171)<br> 如果索引不能覆盖查询所需的全部列, 那就不得不每扫描一次索引记录, 就回表查询一次对应的行    </p></li><li><p><code>select * ....</code> : 因为查询从表中选择了所有的列, 而一般你不会创建覆盖了所有列的二级索引, 所以这种局域肯定不会用到覆盖索引;</p></li><li></li></ol><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li><p>既然InnoDB表有聚簇索引, 那么即便你的二级索引做不到覆盖索引, 要做二次扫描, 由于聚簇索引的叶子节点中包含了所有的数据行字段值, 那么最终也不会导致扫表啊, 为什么会扫表?</p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果一个索引包含(或者说覆盖)所有需要查询的字段的值, 我们就称该索引为 “覆盖索引”; （其实覆盖索引是针对二级索引的,
      
    
    </summary>
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/categories/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/tags/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>45. 高性能索引 -- 聚簇索引</title>
    <link href="http://blog.renyimin.com/2019/03/05/MySQL/2019-03-05-mysql-45/"/>
    <id>http://blog.renyimin.com/2019/03/05/MySQL/2019-03-05-mysql-45/</id>
    <published>2019-03-05T12:07:57.000Z</published>
    <updated>2019-04-25T08:49:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="“索引组织表”-第一篇"><a href="#“索引组织表”-第一篇" class="headerlink" title="“索引组织表” 第一篇"></a>“索引组织表” 第一篇</h2><ol><li><p><strong>重点</strong>: InnoDB存储引擎的表是 <code>索引组织表</code>, 即 <strong>表中的数据本身就是按照主键顺序存放, 聚集索引就是按照每张表的主键构造一颗 B+Tree</strong>, 同时叶子结点存放的即为表的行纪录数据(聚集索引的叶子结点也称为数据页); 聚集索引的这个特性也决定了索引组织表中数据也是索引的一部分, 和 B+Tree 数据结构一样, 每个数据页之间都通过一个双向链表来进行链接;</p></li><li><p>从 表存储文件 看 “索引组织表”</p><ul><li><p>对于 InnoDB 表, 可以通过 <code>innodb_file_per_table</code> 选项 开启 独立表空间, 此时用户不用将所有数据都存放于默认的表空间(<code>ibdataX</code>文件)中, 而是会产生单独的 <code>.ibd</code> 独立表空间文件<br><strong>可以看到</strong>: 这些独立的表空间文件中存储了 innodb表的数据、索引 等信息  (而InnoDB的数据本身就是按照B+Tree组织的, 所以说该文件中其实包含了 <code>数据+聚簇索引</code> 和 <code>二级索引</code>)</p></li><li><p>但是对于 MyISAM 来说, 其数据表文件分为 <code>.frm</code>(存储表的结构), <code>.MYD</code>(存储数据), <code>.MYI</code>(存储索引)<br>可以明显的看到, MyISAM 的数据和索引是分开存储的 (其 主键索引 和 普通索引 的索引策略没有本质区别)</p></li></ul></li><li><p>小结:</p><ul><li>InnoDB是聚集索引, 数据文件是和索引绑在一起的, 聚集索引就是按照每张表的主键构造一颗 B+Tree, 因此通过主键索引效率很高; 但是辅助索引需要两次查询, 先通过二级索引查询到主键, 然后再通过主键查询到数据;</li><li>而MyISAM是非聚集索引, 数据文件和索引是分离的; </li></ul></li></ol><h2 id="“索引组织表”-第二篇"><a href="#“索引组织表”-第二篇" class="headerlink" title="“索引组织表” 第二篇"></a>“索引组织表” 第二篇</h2><ol><li><p>InnoDB存储引擎表中, 每张表都有个主键(Primary Key), 因为 <strong>表中的数据本身就是按照主键顺序存放, 聚集索引就是按照每张表的主键构造一颗 B+Tree</strong>, 所以如果在创建表时没有显示地定义主键, 则InnoDB存储引擎会按如下方式选择或创建主键:</p><ul><li>首先判断表中是否有 非空的唯一索引(unique not null), 如果有, 则该列即为主键</li><li>如果不符合上述条件, InnoDB存储引擎会自动创建一个6字节大小的指针 (<code>_rowid</code>)</li><li>当表中有多个非空唯一索引时, InnoDB存储引擎会选择建表时第一个定义的非空索引为主键 (这里要注意的是, 主键的选择根据的是<strong>定义索引的顺序</strong>, 而不是建表时列的顺序)</li></ul></li><li><p>例: 下面创建一张表t, 有a,b,c,d 4个列, b,c,d上都有唯一索引, 不同的是b列允许为NULL, 由于没有显示地定义主键, 因此会选择非空的唯一索引为主键, 并且顺序是第一个定义的索引, 即 字段 d  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t (</span><br><span class="line">   -&gt;        a int not null,</span><br><span class="line">   -&gt;        b int null,</span><br><span class="line">   -&gt;        c int not null,</span><br><span class="line">   -&gt;        d int not null,</span><br><span class="line">   -&gt;        UNIQUE KEY(b),</span><br><span class="line">   -&gt;        UNIQUE KEY(d),</span><br><span class="line">   -&gt;        UNIQUE KEY(c)</span><br><span class="line">   -&gt;    );</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">// 插入几条测试数据</span><br><span class="line">mysql&gt; insert into t select 1,2,3,4;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t select 5,6,7,8;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t select 9,10,11,12;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">// _rowid 可以显示表的主键, 因此通过下面的查询语句可以找到表t的主键 (可以看到是d列的值, d被选为主键了)</span><br><span class="line">mysql&gt; select a,b,c,d,_rowid FROM t;</span><br><span class="line">+---+------+----+----+--------+</span><br><span class="line">| a | b    | c  | d  | _rowid |</span><br><span class="line">+---+------+----+----+--------+</span><br><span class="line">| 1 |    2 |  3 |  4 |      4 |</span><br><span class="line">| 5 |    6 |  7 |  8 |      8 |</span><br><span class="line">| 9 |   10 | 11 | 12 |     12 |</span><br><span class="line">+---+------+----+----+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p><code>_rowid</code> 可以显示表的主键, 但是只能用于查看<strong>单个列为主键</strong>的情况, 对于多列组成的主键就无能为力了:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table a (</span><br><span class="line">    -&gt;         a INT,</span><br><span class="line">    -&gt;         b INT,</span><br><span class="line">    -&gt;         PRIMARY KEY(a,b)</span><br><span class="line">    -&gt;     );</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into a select 1,2;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into a select 3,4;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select a,_rowid FROM a;</span><br><span class="line">ERROR 1054 (42S22): Unknown column &apos;_rowid&apos; in &apos;field list&apos;</span><br></pre></td></tr></table></figure></li></ol><h2 id="MyISAM-与-InnoDB-索引对比"><a href="#MyISAM-与-InnoDB-索引对比" class="headerlink" title="MyISAM 与 InnoDB 索引对比"></a>MyISAM 与 InnoDB 索引对比</h2><ol><li><p>主键索引+覆盖索引</p><ul><li>MyISAM 从 主键索引 找到B+Tree中对应的叶子节点 找到数据的物理行指针, 然后寻址找到数据</li><li>InnoDB 从 聚簇索引 找到B+Tree中对应的叶子节点 直接就找到了数据</li><li>看上去 InnoDB是直接找到了数据, 而 MyISAM 还需要寻址, 但其实 MyISAM 还是要快一些 ???</li></ul></li><li><p>普通索引+覆盖索引</p><ul><li>MyISAM 从普通索引中就可以取到具体数据 </li><li>而InnoDB 从二级索引中就可以取到数据的</li><li>看起来是一样快的</li></ul></li><li><p>如果索引生效, 但没做到覆盖索引:</p><ul><li>MyISAM 从普通索引中 就可以取到具体数据的物理行位置, 然后通过 <code>物理行号</code> 再回表, 到具体数据行 </li><li>而InnoDB 需要两次索引扫描, 先从二级索引中可以取到数据的主键, 然后 通过 <code>主键</code> 在聚簇索引上找到具体数据行</li></ul></li><li><p>如果索引未生效, 走全表扫描</p><ul><li>MyISAM 的数据分布比较简单, 按照数据的插入顺序存储在磁盘上, 扫表比较快</li><li>InnoDB 表的数据本身就是聚集的, 也就是说, 表本身就是聚集索引, 全表扫描, 扫的就是当然就是聚集索引本身<blockquote><p>正常情况下, 我们可以定义一个代理键作为主键, 这种主键的数据应该和应用无关, 最简单的方法是使用 AUTO_INCREMENT 自增列, 这样可以保证数据行是按顺序写入的<br>最好避免随机的(不连续且值的分布范围非常大)的聚簇索引, 特别是对于I/O密集型的应用, 这样会导致聚簇索引的插入变得完全随机, 这是最坏情况, 数据没有任何聚集特性</p></blockquote></li><li>做全表扫描时, InnoDB 会按主键顺序扫描页面和行, 如果主键页表没有碎片(存储主键和行的页表), 全表扫描是相当快, 因为读取顺序接近物理存储顺序, 但如果主键碎片化变大, 随机性高, 则性能会下降;</li></ul></li><li><p>执行 <code>select count(*) from table</code> 时需要全表扫描</p><ul><li>InnoDB不保存表的具体行数</li><li>而MyISAM用一个变量保存了整个表的行数, 执行上述语句时只需要读出该变量即可, 速度很快</li></ul></li></ol><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><ol><li><p>在MySQL中, InnoDB使用的是聚簇索引, 将主键组织到一棵B+树中, 而行数据就储存在叶子节点上, 若使用 “where id = 14” 这样的条件查找主键, 即做到了 <code>主键 覆盖索引</code>, 则按照B+树的检索算法即可查找到对应的叶节点, 之后获得行数据; 若对Name普通索引列进行条件搜索, 则需要两个步骤: 第一步在辅助索引B+树中检索Name, 到达其叶子节点获取对应的主键; 第二步使用主键在主索引B+树种再执行一次B+树检索操作, 最终到达叶子节点即可获取整行数据</p></li><li><p>MyISM使用的是非聚簇索引, 非聚簇索引的两棵B+树看上去没什么不同, 节点的结构完全一致。表数据存储在独立的地方, 这两颗B+树的叶子节点都使用一个 <code>地址</code> 指向真正的表数据, 对于表数据来说, 这两个键没有任何差别, 由于索引树是独立的, 通过辅助键检索无需访问主键的索引树;</p></li><li><p>下图这张抽象图描述了两者保存数据和索引的区别<br> <img src="/img/mysql/index/cluster_vs_second_index.png" width="600"></p></li></ol><ol><li><p><strong>聚簇索引的特点</strong>:</p><ul><li>一个表只能有一个聚簇索引 (不过覆盖索引可以模拟多个聚簇索引的情况)</li><li>有一点和MyISAM不同的是: InnoDB 聚簇索引的每一个叶子节点中都包含了主键值, 事务ID, 用于事务和MVCC的回滚指针 以及 表中剩余的所有列; 而 MyISAM 索引的叶子节点只有你创建索引时选择的列的值(也可以做到覆盖索引) </li><li>还有一点和MyISAM不同的是: InnoDB的 二级(辅助)索引 和 聚簇索引 有很大的不同, InnoDB 二级(辅助)索引 的叶子节点中存储的 不是物理 <code>行指针</code>, 而是主键值, 通过该主键值指向聚簇索引中的主键<br>而对 MyISAM 存储引擎来说, 其 主键索引 和 二级(辅助)索引 在结构上没有什么不同</li></ul></li><li><p>一些缺点:</p><ul><li>二级索引(非聚簇索引) 可能会比想象的要稍大一些, 因为在二级索引的叶子节点包含了引用行的主键列</li><li>更新聚簇索引列的代价很高, 因为会强制Innodb将每个被更新的行移动到新的位置</li><li>基于聚簇索引的表在插入新行, 或者逐渐被更新导致需要移动行时, 可能面临 “页分裂” 的问题, 页分裂会导致表占用更多的磁盘空间</li><li></li><li>… 参考 P163</li></ul></li><li><p><strong>小结</strong>: 所以, MyISAM 用索引检索数据时, 无论是使用的 <code>主键索引</code> 还是 <code>普通索引</code>, 只会访问一次索引即可拿到叶子节点的物理行指针; 而InnoDB在使用 <code>二级(非聚簇)索引</code> 时, 需要访问可能两次索引查找, 而不是一次, 除非你做到了<strong>覆盖索引</strong> 或者 你用到了主键索引;</p></li><li><p>另外需要知道的是: 在MySQL目前内建的存储引擎中, 不支持 手动选择一个列作为聚簇索引 (InnoDB 如果没有定义主键, MySQL 会隐式定义一个主键来作为聚簇索引) </p></li><li><p>覆盖索引可以模拟多个聚簇索引的情况??</p></li><li><p>聚簇索引可能对性能有帮助, 但也可能导致严重的性能问题 (尤其是将表的存储引擎从InnoDB改成其他引擎, 或者反过来时, 需要仔细考虑聚簇索引) ??</p></li></ol><h2 id="在InnoDB中按主键顺序插入行"><a href="#在InnoDB中按主键顺序插入行" class="headerlink" title="在InnoDB中按主键顺序插入行"></a>在InnoDB中按主键顺序插入行</h2><p>… 未完待续</p><p>参考:<br><a href="http://blog.haohtml.com/archives/17372" target="_blank" rel="noopener">http://blog.haohtml.com/archives/17372</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;“索引组织表”-第一篇&quot;&gt;&lt;a href=&quot;#“索引组织表”-第一篇&quot; class=&quot;headerlink&quot; title=&quot;“索引组织表” 第一篇&quot;&gt;&lt;/a&gt;“索引组织表” 第一篇&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;重点&lt;/strong&gt;: Inno
      
    
    </summary>
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/categories/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/tags/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>44. 高性能索引 -- 多列索引</title>
    <link href="http://blog.renyimin.com/2019/03/05/MySQL/2019-03-05-mysql-44/"/>
    <id>http://blog.renyimin.com/2019/03/05/MySQL/2019-03-05-mysql-44/</id>
    <published>2019-03-05T06:12:31.000Z</published>
    <updated>2019-04-22T12:10:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="合并索引-技术"><a href="#合并索引-技术" class="headerlink" title="合并索引 技术"></a>合并索引 技术</h2><ol><li><p>首先, 你需要了解的是 “为多个列各自创建独立的索引 在大部分情况下并不能提高MySQL的性能”</p><blockquote><p>尽管MySQL5.0+引入了一种叫 “索引合并”(index merge) 的技术, 在一定程度上可以使用表上的多个单列索引来定位指定的行</p></blockquote></li><li><p>示例: explain_goods 创建了 stock, goods_weight 两个独立索引</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 当表中有数据时, 确实使用了 索引合并 技术</span><br><span class="line">mysql&gt; explain select id from explain_goods where goods_weight=10 or stock=11; </span><br><span class="line">+----+-------------+---------------+-------------+----------------------------+----------------------------+---------+------+------+------------------------------------------------------+</span><br><span class="line">| id | select_type | table         | type        | possible_keys              | key                        | key_len | ref  | rows | Extra                                                |</span><br><span class="line">+----+-------------+---------------+-------------+----------------------------+----------------------------+---------+------+------+------------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods | index_merge | idx_stock,idx_goods_weight | idx_goods_weight,idx_stock | 4,4     | NULL |    2 | Using union(idx_goods_weight,idx_stock); Using where |</span><br><span class="line">+----+-------------+---------------+-------------+----------------------------+----------------------------+---------+------+------+------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">// 注意一个例外情况: 当表中没有数据时, 发现MySQL优化器走了全表扫描</span><br><span class="line">mysql&gt; explain select id from explain_goods_copy1 where goods_weight=10 or stock=11; </span><br><span class="line">+----+-------------+---------------------+------+----------------------------+------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table               | type | possible_keys              | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+---------------------+------+----------------------------+------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | explain_goods_copy1 | ALL  | idx_stock,idx_goods_weight | NULL | NULL    | NULL |    1 | Using where |</span><br><span class="line">+----+-------------+---------------------+------+----------------------------+------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>这种算法有三个变种: <code>or条件的联合</code>, <code>and条件的相交</code>, <code>组合前两种情况的联合及相交</code></p></li></ol><h2 id="多列索引的顺序"><a href="#多列索引的顺序" class="headerlink" title="多列索引的顺序"></a>多列索引的顺序</h2><ol><li>本节适用于 B-Tree 索引</li><li>多列 B-Tree 索引的顺序至关重要<br> 当不需要考虑排序和分组时, 通常将选择性最高的列放在前面 (这样设计索引, 能够最快地过滤出处需要的行, 对于在where条件中只使用了索引部分前缀列的查询来说选择性也更好)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;合并索引-技术&quot;&gt;&lt;a href=&quot;#合并索引-技术&quot; class=&quot;headerlink&quot; title=&quot;合并索引 技术&quot;&gt;&lt;/a&gt;合并索引 技术&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先, 你需要了解的是 “为多个列各自创建独立的索引 在大部分情况下并不能提高My
      
    
    </summary>
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/categories/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/tags/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>43. 高性能索引 -- 前缀索引 &amp; 索引选择性</title>
    <link href="http://blog.renyimin.com/2019/03/03/MySQL/2019-03-03-mysql-43/"/>
    <id>http://blog.renyimin.com/2019/03/03/MySQL/2019-03-03-mysql-43/</id>
    <published>2019-03-03T12:07:57.000Z</published>
    <updated>2019-04-22T12:08:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么时候要用前缀索引"><a href="#什么时候要用前缀索引" class="headerlink" title="什么时候要用前缀索引?"></a>什么时候要用前缀索引?</h2><ol><li><p>有时候需要为某个很长的字符列创建索引, 这会让索引变得大且慢, 一个策略是前面提到过的模拟哈希索引, 但有时候这样却不那么合适 </p></li><li><p>其实对于很长的字符列, 如果要创建索引, 我们可以尝试为该列开始的部分字符创建索引, 这样就可以大大节约索引空间, 从而提高索引效率, 但可能会降低索引的选择性;</p><blockquote><p>什么是索引的选择性?<br> 索引的选择性是指 不重复的索引值的数量 和 数据表的记录总数(n) 的比值 (范围从 1/n 到 1之间)<br> 索引的选择性越高, 则查询效率越高; 因为选择性高的索引可以让MySQL在查找时过滤更多的行, 唯一索引的选择性是1, 这是最好的索引选择性, 性能也是最好的;</p></blockquote></li><li><p>一般情况下, 某个列的前缀索引的选择性都是比较高的, 足以满足查询性能, 对于 BLOB, TEXT 或 很长的 VARCHAR 类型的列, 必须使用前缀索引, 因为MySQL不允许索引这些列的完整长度;</p></li><li><p>要注意的是: 我们要选择足够长的前缀字符, 以保证较高的选择性, 但同时又不能太长(以便于节约空间)</p></li></ol><h2 id="如何选择合适的前缀长度"><a href="#如何选择合适的前缀长度" class="headerlink" title="如何选择合适的前缀长度?"></a>如何选择合适的前缀长度?</h2><ol><li><p>那么 当你为一个 较长的字符列 创建索引时, 如何决定前缀的合适长度呢? (我们的目的是选择足够长的前缀, 从而提高前缀索引的选择性, 提高查询性能) </p></li><li><p>准备一张简单的城市表, 里面存放了美国的一些地方名</p></li></ol><h3 id="前缀长度-—-统计观察"><a href="#前缀长度-—-统计观察" class="headerlink" title="前缀长度 — 统计观察"></a>前缀长度 — 统计观察</h3><ol><li><p>尝试 根据各城市名分组 根据各组统计的次数 倒序排名: 可以看到, 完整列的选择性也并非是1, 我们可以选择合适的前缀, 让选择性逐渐接近完整列的</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) as cnt, city_name from test_city group by city_name order by cnt desc limit 10;</span><br><span class="line">+-----+-----------+</span><br><span class="line">| cnt | city_name |</span><br><span class="line">+-----+-----------+</span><br><span class="line">|   4 | SantaRosa |</span><br><span class="line">|   3 | Auburn    |</span><br><span class="line">|   3 | Norfolk   |</span><br><span class="line">|   3 | Roanoke   |</span><br><span class="line">|   3 | Richfield |</span><br><span class="line">|   3 | Olympia   |</span><br><span class="line">|   3 | Danville  |</span><br><span class="line">|   3 | Arlington |</span><br><span class="line">|   3 | Provo     |</span><br><span class="line">|   3 | Plano     |</span><br><span class="line">+-----+-----------+</span><br><span class="line">10 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p>尝试取长度为3的前缀, 继续上述统计:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) as cnt, left(city_name, 3) as pref from test_city group by pref order by cnt desc limit 10;</span><br><span class="line">+-----+------+</span><br><span class="line">| cnt | pref |</span><br><span class="line">+-----+------+</span><br><span class="line">|  19 | New  |</span><br><span class="line">|  17 | Nor  |</span><br><span class="line">|  16 | For  |</span><br><span class="line">|  16 | San  |</span><br><span class="line">|  13 | Cha  |</span><br><span class="line">|  11 | Sal  |</span><br><span class="line">|  10 | Roc  |</span><br><span class="line">|   9 | Gra  |</span><br><span class="line">|   9 | Ken  |</span><br><span class="line">|   9 | Bel  |</span><br><span class="line">+-----+------+</span><br><span class="line">10 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p>尝试增加前缀长度, 让前缀选择性接近完整列的选择性</p></li></ol><h3 id="前缀长度-—-选择性计算"><a href="#前缀长度-—-选择性计算" class="headerlink" title="前缀长度 — 选择性计算"></a>前缀长度 — 选择性计算</h3><ol><li>计算合适前缀长度的另外一个方法就是计算完整列的选择性, 并使前缀的选择性接近于完整列的选择性</li><li><p>下面显示了如何计算完整列的选择性:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(DISTINCT city_name ) / COUNT( * ) FROM test_city;</span><br><span class="line">+-----------------------------------------+</span><br><span class="line">| COUNT(DISTINCT city_name ) / COUNT( * ) |</span><br><span class="line">+-----------------------------------------+</span><br><span class="line">| 0.4821                                  |</span><br><span class="line">+-----------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>上面看来, 对 city_name 这列来说, 完整列的选择性是 0.4821, 不算高, 但如果要对该列建索引, 那么选择的前缀要保证选择性能接近 0.4821 即可</p></li><li><p>下面给出了如何在同一个查询中计算不同前缀长度的选择性:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT</span><br><span class="line">COUNT( DISTINCT city_name ) / COUNT( * )  as t0,</span><br><span class="line">COUNT( DISTINCT left(city_name, 4) ) / COUNT( * )  as t1,</span><br><span class="line">COUNT( DISTINCT left(city_name, 5) ) / COUNT( * )  as t2,</span><br><span class="line">COUNT( DISTINCT left(city_name, 6) ) / COUNT( * )  as t3,</span><br><span class="line">COUNT( DISTINCT left(city_name, 7) ) / COUNT( * )  as t4,</span><br><span class="line">COUNT( DISTINCT left(city_name, 8) ) / COUNT( * )  as t5,</span><br><span class="line">COUNT( DISTINCT left(city_name, 9) ) / COUNT( * )  as t6,</span><br><span class="line">COUNT( DISTINCT left(city_name, 10) ) / COUNT( * )  as t7,</span><br><span class="line">COUNT( DISTINCT left(city_name, 11) ) / COUNT( * )  as t8</span><br><span class="line">FROM</span><br><span class="line">test_city;</span><br><span class="line"></span><br><span class="line">+--------+--------+--------+--------+--------+--------+--------+--------+--------+</span><br><span class="line">| t0     | t1     | t2     | t3     | t4     | t5     | t6     | t7     | t8     |</span><br><span class="line">+--------+--------+--------+--------+--------+--------+--------+--------+--------+</span><br><span class="line">| 0.4821 | 0.4055 | 0.4351 | 0.4597 | 0.4729 | 0.4760 | 0.4791 | 0.4811 | 0.4811 |</span><br><span class="line">+--------+--------+--------+--------+--------+--------+--------+--------+--------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p> 可以看到, 前缀长度到达 10 的时候, 选择性的提升已经很小了, 因此 10 可以算是一个差不多合理的长度了</p></li><li><p><strong>注意</strong>: 前缀索引是一种能似索引更小, 更快的有效办法, 但也有其缺点: </p><ul><li>MySQL无法使用前缀索引做 ORDER BY 和 GROUP BY </li><li>也无法使用前缀索引做覆盖索引</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么时候要用前缀索引&quot;&gt;&lt;a href=&quot;#什么时候要用前缀索引&quot; class=&quot;headerlink&quot; title=&quot;什么时候要用前缀索引?&quot;&gt;&lt;/a&gt;什么时候要用前缀索引?&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;有时候需要为某个很长的字符列创建索引, 这会让索引变得
      
    
    </summary>
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/categories/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/tags/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>42. 高性能索引 -- 独立的列</title>
    <link href="http://blog.renyimin.com/2019/03/03/MySQL/2019-03-03-mysql-42/"/>
    <id>http://blog.renyimin.com/2019/03/03/MySQL/2019-03-03-mysql-42/</id>
    <published>2019-03-03T11:05:16.000Z</published>
    <updated>2019-04-22T12:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇非常简单</p><ol><li><p><code>独立的列</code> 是指索引列不能是表达式的一部分, 也不能是函数的参数;</p></li><li><p>示例: 很容易看出 where 中的表达式其实等价于 actor_id=4, 但MySQL却无法自动解析这个方程式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select actor_id FROM actor where actor_id+1=5;</span><br></pre></td></tr></table></figure><p> (就像 <a href="/2019/04/10/MySQL/2019-04-10-mysql-52/#EXPLAIN-EXTENDED">mysql的查询优化器不能将 id&gt;5 和 id&gt;6 这两个查询条件优化合并成一个 id&gt;6 一样</a>, MySQL优化器有时候没有我们想的那么自然, 但的确非常有用)</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇非常简单&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;独立的列&lt;/code&gt; 是指索引列不能是表达式的一部分, 也不能是函数的参数;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;示例: 很容易看出 where 中的表达式其实等价于 actor_id=4, 但MySQL却无法自动解
      
    
    </summary>
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/categories/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
    
      <category term="《高性能MySQL》" scheme="http://blog.renyimin.com/tags/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/"/>
    
  </entry>
  
</feed>
