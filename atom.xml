<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2017-09-19T04:52:28.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Laravel-install-01</title>
    <link href="http://blog.renyimin.com/2016/04/15/Laravel-install-01/"/>
    <id>http://blog.renyimin.com/2016/04/15/Laravel-install-01/</id>
    <published>2016-04-15T08:34:13.000Z</published>
    <updated>2017-09-19T04:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="通过Composer下载安装"><a href="#通过Composer下载安装" class="headerlink" title="通过Composer下载安装"></a>通过Composer下载安装</h4><p>可以在终端中通过Composer的==create-project==命令来创建一个新的Laravel项目:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">composer create-project laravel/laravel [项目目录名] [项目版本号] --prefer-dist</div><div class="line"></div><div class="line">如果不写laravel下载下来后放置项目的目录名, 则默认为laravel;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">比如要下载Laravel的LTS版本(目前是Laravel5.1), 操作如下:</div><div class="line"></div><div class="line">composer create-project laravel/laravel vip 5.1.33 --prefer-dist</div><div class="line"></div><div class="line">或者</div><div class="line"></div><div class="line">composer create-project laravel/laravel vip 5.1.* --prefer-dist</div></pre></td></tr></table></figure><h4 id="应用Key的设置"><a href="#应用Key的设置" class="headerlink" title="应用Key的设置"></a>应用Key的设置</h4><p>如果你是通过Composer或者Laravel安装器安装的话, 该key的值已经通过key:generate命令生成好了;</p><p>(通常, 该字符串应该是32位长, 该key被配置在.env环境文件中(APP_KEY), 如果你还没有将.env.example文件重命名为.env, 现在立即这样做;如果应用key没有被设置, 用户sessions和其它加密数据将会有安全隐患!)</p><p>如果你不是通过composer安装的laravel, 生成key的方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">先创建一个.env文件</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">然后生成应用key:</div><div class="line"></div><div class="line">bogon:laravel renyimin$ php artisan key:generate</div><div class="line">Application key [7a7rsPOdMubimWYQRddpxEiTRuoQMScE] set successfully.</div><div class="line">bogon:laravel renyimin$</div></pre></td></tr></table></figure><p>你如果是使用Composer安装的话, 可以看到:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-06c8fbb330d8f53f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-740d1978831266b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><h4 id="nginx的设置"><a href="#nginx的设置" class="headerlink" title="nginx的设置:"></a>nginx的设置:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$uri $uri/ /index.php?$query_string</div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-2045d4084f87333c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">项目根目录配置到: 项目目录的 public 目录下;</div></pre></td></tr></table></figure><h4 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功:"></a>安装成功:</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-1d49b5e644607509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;通过Composer下载安装&quot;&gt;&lt;a href=&quot;#通过Composer下载安装&quot; class=&quot;headerlink&quot; title=&quot;通过Composer下载安装&quot;&gt;&lt;/a&gt;通过Composer下载安装&lt;/h4&gt;&lt;p&gt;可以在终端中通过Composer的==cre
      
    
    </summary>
    
      <category term="PHP框架" scheme="http://blog.renyimin.com/categories/PHP%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Laravel" scheme="http://blog.renyimin.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Client Credentials Grant.</title>
    <link href="http://blog.renyimin.com/2016/03/24/OAuth-Client-Credentials-Grant/"/>
    <id>http://blog.renyimin.com/2016/03/24/OAuth-Client-Credentials-Grant/</id>
    <published>2016-03-24T13:07:01.000Z</published>
    <updated>2017-09-22T03:51:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="客户端模式（Client-Credentials-Grant）"><a href="#客户端模式（Client-Credentials-Grant）" class="headerlink" title="客户端模式（Client Credentials Grant）"></a>客户端模式（Client Credentials Grant）</h2><p>指客户端以自己的名义, 而不是以用户的名义, 向”服务提供商”进行认证;</p><p>严格地说, 客户端模式并不属于OAuth框架所要解决的问题;</p><p>在这种模式中, 用户直接向客户端注册, 客户端以自己的名义要求”服务提供商”提供服务, 其实不存在授权问题;</p><h2 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h2><p>1.客户端向认证服务器进行身份认证, 并要求一个访问令牌 ;<br>2.认证服务器确认无误后, 向客户端提供访问令牌 ;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;客户端模式（Client-Credentials-Grant）&quot;&gt;&lt;a href=&quot;#客户端模式（Client-Credentials-Grant）&quot; class=&quot;headerlink&quot; title=&quot;客户端模式（Client Credentials Grant
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>Password Credentials Grant</title>
    <link href="http://blog.renyimin.com/2016/03/23/OAuth-Password-Credentials-Grant/"/>
    <id>http://blog.renyimin.com/2016/03/23/OAuth-Password-Credentials-Grant/</id>
    <published>2016-03-23T04:45:07.000Z</published>
    <updated>2017-09-22T04:39:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="密码模式-Resource-Owner-Password-Credentials-Grant"><a href="#密码模式-Resource-Owner-Password-Credentials-Grant" class="headerlink" title="密码模式(Resource Owner Password Credentials Grant)"></a>密码模式(Resource Owner Password Credentials Grant)</h2><p>用户向客户端提供自己的用户名和密码,客户端使用这些信息, 向”服务商提供商”索要授权;</p><p>在这种模式中, 用户必须把自己的密码给客户端, 但是客户端不得储存密码 ;</p><p>这通常用在用户对客户端高度信任的情况下, 比如客户端是操作系统的一部分, 或者由一个著名公司出品; </p><p>而认证服务器只有在其他授权模式无法执行的情况下, 才能考虑使用这种模式;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;密码模式-Resource-Owner-Password-Credentials-Grant&quot;&gt;&lt;a href=&quot;#密码模式-Resource-Owner-Password-Credentials-Grant&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>OAuth-implicit-grant</title>
    <link href="http://blog.renyimin.com/2016/03/22/OAuth-Implicit-grant/"/>
    <id>http://blog.renyimin.com/2016/03/22/OAuth-Implicit-grant/</id>
    <published>2016-03-22T12:11:19.000Z</published>
    <updated>2017-09-22T04:27:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简化模式-隐式授权-implicit-grant-type"><a href="#简化模式-隐式授权-implicit-grant-type" class="headerlink" title="简化模式/隐式授权(implicit grant type)"></a>简化模式/隐式授权(implicit grant type)</h2><p>不通过第三方应用程序的服务器, 直接在浏览器中向认证服务器申请令牌, 跳过了”授权码”这个步骤, 因此得名; 所有步骤在浏览器中完成, 令牌对访问者是可见的, 且客户端不需要认证;</p><h2 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h2><p>1.客户端将用户导向认证服务器 ;</p><p>2.用户决定是否给于客户端授权 ;</p><p>3.假设用户给予授权, 认证服务器将用户导向客户端指定的”重定向URI”, 并在URI的Hash部分包含了访问令牌 ;</p><p>4.浏览器向资源服务器发出请求, 其中不包括上一步收到的Hash值 ;</p><p>5.资源服务器返回一个网页, 其中包含的代码可以获取Hash值中的令牌 ;</p><p>6.浏览器执行上一步获得的脚本, 提取出令牌 ;</p><p>7.浏览器将令牌发给客户端 ;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简化模式-隐式授权-implicit-grant-type&quot;&gt;&lt;a href=&quot;#简化模式-隐式授权-implicit-grant-type&quot; class=&quot;headerlink&quot; title=&quot;简化模式/隐式授权(implicit grant type)&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>03-授权码模式分析</title>
    <link href="http://blog.renyimin.com/2016/03/22/OAuth-authorization-code03/"/>
    <id>http://blog.renyimin.com/2016/03/22/OAuth-authorization-code03/</id>
    <published>2016-03-22T11:11:10.000Z</published>
    <updated>2017-09-22T07:55:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="各步骤的参数研究"><a href="#各步骤的参数研究" class="headerlink" title="各步骤的参数研究"></a>各步骤的参数研究</h2><h3 id="客户端将用户导向授权页"><a href="#客户端将用户导向授权页" class="headerlink" title="客户端将用户导向授权页"></a>客户端将用户导向授权页</h3><p>应该传递的参数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">response_type: 表示授权类型, 必选项, 此处由于采用的是授权码模式, 所以值固定为 <span class="string">"code"</span></div><div class="line">client_id: 表示客户端的ID, 必选项</div><div class="line">redirect_uri: 表示重定向URI, 可选项</div><div class="line">scope: 表示申请的权限范围, 可选项</div><div class="line">state: 表示客户端的当前状态, 可以指定任意值, 认证服务器会原封不动地返回这个值</div></pre></td></tr></table></figure></p><h5 id="新浪"><a href="#新浪" class="headerlink" title="新浪"></a><a href="http://open.weibo.com/wiki/Oauth2/authorize" target="_blank" rel="external">新浪</a></h5><p><img src="/img/oauth/oauth_sina.png" width="500" height="560" alt="sina" align="center"></p><h5 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a><a href="http://wiki.connect.qq.com/%E4%BD%BF%E7%94%A8authorization_code%E8%8E%B7%E5%8F%96access_token" target="_blank" rel="external">QQ</a></h5><p><img src="/img/oauth/oauth_qq.png" width="500" height="560" alt="qq" align="center"></p><h5 id="微信"><a href="#微信" class="headerlink" title="微信"></a><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信</a></h5><p><img src="/img/oauth/oauth_wechat.png" width="500" height="560" alt="wechat" align="center"></p><h5 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a><a href="https://developer.github.com/apps/building-integrations/setting-up-and-registering-oauth-apps/about-authorization-options-for-oauth-apps/" target="_blank" rel="external">GitHub</a></h5><p><img src="/img/oauth/oauth_github.png" width="500" height="560" alt="github" align="center"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>各平台对比来看, 如果你要自己设计一个OAuth认证服务器的话, 你的授权码模式下, 授权页API的参数应该至少有如下:</p><h4 id="response-type"><a href="#response-type" class="headerlink" title="response_type"></a>response_type</h4><p>表示授权类型, 必选项, 此处由于采用的是授权码模式, 所以值固定为 “code”<br>你的认证服务器可能还有其他的OAuth授权模式, 所以需要此参数来加以区分</p><h4 id="client-id"><a href="#client-id" class="headerlink" title="client_id"></a>client_id</h4><p>表示客户端的ID, 必选项<br>客户端在你的Oauth服务器注册时生成的client_id</p><h4 id="redirect-uri"><a href="#redirect-uri" class="headerlink" title="redirect_uri"></a>redirect_uri</h4><p>表示重定向URI, 必选项<br>客户端在你的OAuth服务器注册时设定的回调地址, 一般客户端自己的服务器中会首先校验一下<br>可以在认证服务端做redirect_uri校验, 以防篡改, 很多认证服务器在做校验的时候, 都是简单校验顶级域名是否正确即可(其实这样即可)</p><h5 id="简书新浪授权传递错误-redirect-uri"><a href="#简书新浪授权传递错误-redirect-uri" class="headerlink" title="简书新浪授权传递错误 redirect_uri"></a>简书新浪授权传递错误 <code>redirect_uri</code></h5><p><img src="/img/oauth/jianshu_sina_err01.png" width="400" height="220" alt="github" align="center"></p><h5 id="简书qq授权传递错误-redirect-uri"><a href="#简书qq授权传递错误-redirect-uri" class="headerlink" title="简书qq授权传递错误 redirect_uri"></a>简书qq授权传递错误 <code>redirect_uri</code></h5><p><img src="/img/oauth/jianshu_qq_err01.png" width="320" height="240" alt="github" align="center"></p><h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><p>表示申请的权限范围, 必选项<br>前提是你已经在认证服务方申请了开放哪些权限, 然后可以使用这个参数来在授权页中罗列出来<br>(不建议罗列太多, 用户会有顾虑)</p><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>一个不可估量的随机字符串, 它用于防止跨站点请求伪造攻击, 认证服务器会原封不动地返回这个值</p><h5 id="知乎的state"><a href="#知乎的state" class="headerlink" title="知乎的state"></a>知乎的state</h5><p>首先知乎作为第三方网站, 对自己生成的也是对state做了校验<br>给了一个新的弹框用来进行授权, 但是如果用户复制出弹框中的url, 之后再修改state并刷新页面, 授权后发现:<br><img src="/img/oauth/zhihu_auth_qq_01.png" width="420" height="100" alt="github" align="center"></p><h5 id="简书的state"><a href="#简书的state" class="headerlink" title="简书的state"></a>简书的state</h5><p>简书也对自己生成的state做校验了, 如果你改动授权页中的state, 你会发现登录失败并跳到登录页</p><h3 id="认证服务器返回"><a href="#认证服务器返回" class="headerlink" title="认证服务器返回"></a>认证服务器返回</h3><h4 id="state-1"><a href="#state-1" class="headerlink" title="state"></a>state</h4><p>原样返回之前客户端生成并传递过来的state</p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>为了防止code被篡改:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">可以设置有时效性, 比如QQ的code会在十分钟后过期, 这样即使攻击者给受害者的链接中是自己的code, 让受害者在十分钟内就点击的难度也会增大</div><div class="line"></div><div class="line">其实最好是code一旦申请过token_access之后, 认证服务器就应该立马做上标记, 以便不能被二次使用</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;各步骤的参数研究&quot;&gt;&lt;a href=&quot;#各步骤的参数研究&quot; class=&quot;headerlink&quot; title=&quot;各步骤的参数研究&quot;&gt;&lt;/a&gt;各步骤的参数研究&lt;/h2&gt;&lt;h3 id=&quot;客户端将用户导向授权页&quot;&gt;&lt;a href=&quot;#客户端将用户导向授权页&quot; class
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>02-针对OAuth2的CSRF攻击</title>
    <link href="http://blog.renyimin.com/2016/03/20/OAuth-authorization-code02/"/>
    <id>http://blog.renyimin.com/2016/03/20/OAuth-authorization-code02/</id>
    <published>2016-03-20T14:03:21.000Z</published>
    <updated>2017-09-22T10:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="针对OAuth2的CSRF攻击例子"><a href="#针对OAuth2的CSRF攻击例子" class="headerlink" title="针对OAuth2的CSRF攻击例子"></a>针对OAuth2的CSRF攻击例子</h2><p>针对OAuth2的CSRF攻击的例子, 假设有如下几个角色:<br>1.受害者 <code>张三</code> ;<br>2.攻击者 <code>李四</code> ;<br>3.还有一个第三方Web应用 <code>Tonr网站</code>, 它集成了第三方社交账号登录并且允许用户将社交账号和 <code>Tonr网站</code> 中的账号进行绑定 ;<br>4.此外还有一个OAuth2服务提供平台 <code>Sparklr网站</code> ;</p><h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><p>1.攻击者<code>李四</code>登录<code>Tonr网站</code> 并且选择绑定自己的<code>Sparklr网站</code>账号;</p><p>2.<code>Tonr网站</code> 将<code>李四</code>重定向到<code>Sparklr网站</code>, 由于他之前已经登录过<code>Sparklr网站</code>, 所以<code>Sparklr网站</code>直接向他显示 “是否授权<code>Tonr网站</code>访问” 的页面;</p><p>3.<code>李四</code>在点击”同意授权”之后, 截获<code>Sparklr网站</code>服务器返回的含有<code>Authorization Code</code>参数的HTTP响应;</p><p>4.<code>李四</code>精心构造一个Web页面, 它会触发<code>Tonr网站</code> 向<code>Sparklr网站</code>发起<strong>令牌申请</strong>的请求, 而这个请求中的Authorization Code参数正是上一步截获到的code;</p><p>5.<code>李四</code>将这个Web页面放到互联网上, 等待或者诱骗受害者<code>张三</code>来访问;</p><p>6.(<code>张三</code>之前登录了<code>Tonr网站</code> , 只是没有把自己的账号和其他社交账号绑定起来) 在 <code>张三</code> 访问了 <code>李四</code> 准备的这个Web页面后, 令牌申请流程在 <code>张三</code> 的浏览器里被顺利触发, <code>Tonr网站</code> 从<code>Sparklr网站</code>那里获取到access_token, 但是这个token以及通过它进一步获取到的用户信息却都是攻击者<code>李四</code>的;</p><p>7.<code>Tonr网站</code> 将 <code>李四</code> 的 <code>Sparklr网站</code> 账号同 <code>张三</code> 的 <code>Tonr网站</code> 账号关联绑定起来, 从此以后, <code>李四</code>就可以用自己的<code>Sparklr网站</code>账号通过OAuth登录到 <code>张三</code> 在 <code>Tonr网站</code> 中的账号, 堂而皇之的冒充<code>张三</code>的身份执行各种操作;</p><p><strong><em>这一切发生得太快, 可能你还没看清楚<code>李四</code>怎么就登录到<code>张三</code>的账号里去了, 下面让我们从几个不同的角度来看看这当中发生了什么？</em></strong></p><h2 id="下面从不同角色的视角来分析这个漏洞"><a href="#下面从不同角色的视角来分析这个漏洞" class="headerlink" title="下面从不同角色的视角来分析这个漏洞"></a>下面从不同角色的视角来分析这个漏洞</h2><h3 id="受害者张三-Resource-Owner-视角"><a href="#受害者张三-Resource-Owner-视角" class="headerlink" title="受害者张三(Resource Owner)视角"></a>受害者<code>张三</code>(Resource Owner)视角</h3><p>受害者 <code>张三</code> 访问了一个Web页面, 然后, 就没有然后了, 他在<code>Tonr网站</code> 上的账号就和攻击者<code>李四</code>在<code>Sparklr网站</code>上的账号绑定到了一起, 伪造的请求是经过精心构造的, 令牌申请这一过程在受害者<code>张三</code>的浏览器里是非常隐蔽的被触发的, 换句话讲就是, 他根本不知道这背后发生了什么;</p><h3 id="Tonr网站-Client-视角"><a href="#Tonr网站-Client-视角" class="headerlink" title="Tonr网站 (Client)视角"></a><code>Tonr网站</code> (Client)视角</h3><p>从 <code>Tonr网站</code> 来看, 它收到的所有请求看上去都是正常的, 比如客户端在申请令牌的时候, 它收到了一个HTTP请求, 其代表着当前用户<code>张三</code>在 <code>Sparklr网站</code> 上已经做了”同意授权”操作, 其内容可能会如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /bindingCallback?code=AUTHORIZATION_CODE</div></pre></td></tr></table></figure></p><p>不过需要注意的是, URL里的code不是当前受害者<code>张三</code>的Authorization Code, 而是攻击者<code>李四</code>的; 当 <code>Tonr网站</code> 收到这样的请求时, 它以为<code>张三</code>已经同意授权(但实际上这个请求是<code>李四</code>伪造的), 于是就发起后续的令牌申请请求, 用收到的Authorization Code向在 <code>Sparklr网站</code> 换取access_token, 只不过最后拿到的是攻击者<code>李四</code>的 access_token; 最后, <code>Tonr网站</code> 把攻击者<code>李四</code>的access_token和当前受害者<code>张三</code>在 <code>Tonr网站</code> 上的账号进行关联绑定;</p><h3 id="Sparklr网站-OAuth2服务提供者-视角"><a href="#Sparklr网站-OAuth2服务提供者-视角" class="headerlink" title="Sparklr网站 (OAuth2服务提供者)视角"></a><code>Sparklr网站</code> (OAuth2服务提供者)视角</h3><p><code>Sparklr网站</code> 也是一脸茫然的样子, 因为在它看来, 自己收到的授权请求以及后续的令牌申请请求都是正常的, 或者说它无法得知接收到的这些请求之间的关联关系, 而且也无法区别出这些请求到底是来自<code>张三</code>本人, 还是由<code>李四</code>伪造出来的;</p><p>因此只要自己收到的参数是正确有效的, 那就提供正常的认证服务, 仅此而已;</p><h3 id="攻击者李四视角"><a href="#攻击者李四视角" class="headerlink" title="攻击者李四视角"></a>攻击者<code>李四</code>视角</h3><p><code>李四</code>伪造了一个用户授权成功的请求, 并且将其中的Authorization Code参数替换成了自己提前获取到的code, 这样, 当受害者 <code>张三</code> 的浏览器被欺骗从而发起令牌申请求时, 实际上是在 和 <code>李四</code>在 <code>Sparklr网站</code> 上的账号做绑定;</p><p>攻击完成后, <code>李四</code> 在 <code>Tonr网站</code> 上可以通过自己在 <code>Sparklr网站</code> 的账号进行登录, 而且登录进入的是 <code>张三</code> 在 <code>Tonr网站</code> 上的账号, 而 <code>张三</code> 通过自己在 <code>Tonr网站</code> 上的账号登录进去之后, 看到的是 <code>李四</code> 在 <code>Sparklr网站</code> 上的部分账户信息;</p><h3 id="上帝视角"><a href="#上帝视角" class="headerlink" title="上帝视角"></a>上帝视角</h3><p>从整体上来看,这次攻击的时序图应该是下面这个样子的<br><img src="/img/oauth/yihuajiemu_mawei.png" width="500" height="480" alt="sina" align="center"></p><h2 id="分析漏洞"><a href="#分析漏洞" class="headerlink" title="分析漏洞"></a>分析漏洞</h2><h3 id="回顾图1"><a href="#回顾图1" class="headerlink" title="回顾图1"></a>回顾图1</h3><p><img src="/img/oauth/authorization_code.png" width="535" height="500" alt="qq" align="center"></p><h3 id="分析漏洞的本质"><a href="#分析漏洞的本质" class="headerlink" title="分析漏洞的本质"></a>分析漏洞的本质</h3><p>这个问题的关键点在于, OAuth2的认证流程是分为好几步来完成的, 在的图1中的第4步, 第三方应用在收到一个GET请求时, 除了能知道当前用户的cookie, 以及URL中的Authorization Code之外, 难以分辨出这个请求到底是用户本人的意愿, 还是攻击者利用用户的身份伪造出来的请求;</p><p>于是乎, 攻击者就能使用移花接木的手段, 提前准备一个含有自己的Authorization Code的请求, 并让受害者的浏览器来接着完成后续的令牌申请流程;</p><h3 id="漏洞被攻击者使用还需要具备的前提条件"><a href="#漏洞被攻击者使用还需要具备的前提条件" class="headerlink" title="漏洞被攻击者使用还需要具备的前提条件"></a>漏洞被攻击者使用还需要具备的前提条件</h3><p>尽管这个攻击既巧妙又隐蔽, 但是要成功进行这样的CSRF攻击也是需要满足一定前提条件的:</p><p>首先, 在攻击过程中, 受害者 <code>张三</code> 在 <code>Tonr网站</code> 上的用户会话(User Session)必须是有效的, 也就是说, <code>张三</code>在受到攻击前已经登录了 <code>Tonr网站</code> ;  ？？？？</p><p>其次, 整个攻击必须在短时间内完成, 因为OAuth2提供者颁发的Authorization Code有效期很短, <strong>OAuth2官方推荐的时间是不大于10分钟</strong>, 而一旦Authorization Code过期那么后续的攻击也就不能进行下去了;</p><p>最后, 一个Authorization Code只能被使用一次, 如果OAuth2提供者收到重复的Authorization Code, 它会拒绝当前的令牌申请请求, 不止如此, 根据OAuth2官方推荐, 它还可以把和这个已经使用过的Authorization Code相关联的access_token全部撤销掉, 进一步降低安全风险;</p><h3 id="防御办法"><a href="#防御办法" class="headerlink" title="防御办法"></a>防御办法</h3><p>要防止这样的攻击其实很容易, 作为第三方应用的开发者, 只需在OAuth认证过程中加入state参数, 并验证它的参数值即可;</p><p>具体细节如下:</p><p>在将用户重定向到OAuth2的Authorization Endpoint去的时候, 为用户生成一个随机的字符串, 并作为state参数加入到URL中;</p><p>在收到OAuth2服务提供者返回的Authorization Code请求的时候, 验证接收到的state参数值, 如果是正确合法的请求, 那么此时接受到的参数值应该和上一步提到的为该用户生成的state参数值完全一致, 否则就是异常请求;</p><p>state参数值需要具备下面几个特性:<br>1.不可预测性: 足够的随机, 使得攻击者难以猜到正确的参数值 ;<br>如果你每次生成的state都被放在一起, 比如一个库/缓存中存在很多state;<br>那么问题就是攻击者还是可以拿着自己的code在加上一个state, 来构造一个链接欺骗用户来点击;<br>假设state正好就在你的库/缓存中;<br>所以应该让state和具体的用户关联起来, 虽然用户还没有登录, 但是也可以让state放到session中 ;<br>然后攻击者要猜测出来一个state的话, 即便是已经生成过了, 但是也得正好攻击的是这个用户;</p><p>2.关联性: state参数值可以和当前用户会话(user session)相互关联的 ;<br>比如简书, 每次你点击QQ登录之后, 会跳转到授权页面(url中带了简书服务器生成的state)<br>此时你还会发现简书的cookie中总会多出一个_maleskine_session, 并且值是很长的一大串类似hash加密传, 可以猜测这个值就是state;</p><p>3.唯一性: 每个用户, 甚至每次请求生成的state参数值都是唯一的 ;</p><p>4.时效性: state参数一旦被使用则立即失效 ;<br>```</p><blockquote><p><a href="http://insights.thoughtworkers.org/attack-aim-at-oauth2/" target="_blank" rel="external">摘自 马伟 移花接木</a><br><a href="http://blog.sina.com.cn/s/blog_56b798f801018jyb.html" target="_blank" rel="external">参考 state参数漏洞</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;针对OAuth2的CSRF攻击例子&quot;&gt;&lt;a href=&quot;#针对OAuth2的CSRF攻击例子&quot; class=&quot;headerlink&quot; title=&quot;针对OAuth2的CSRF攻击例子&quot;&gt;&lt;/a&gt;针对OAuth2的CSRF攻击例子&lt;/h2&gt;&lt;p&gt;针对OAuth2的C
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>01-授权码模式简介</title>
    <link href="http://blog.renyimin.com/2016/03/19/OAuth-authorization-code01/"/>
    <id>http://blog.renyimin.com/2016/03/19/OAuth-authorization-code01/</id>
    <published>2016-03-19T12:27:36.000Z</published>
    <updated>2017-09-22T07:44:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="授权码模式简介"><a href="#授权码模式简介" class="headerlink" title="授权码模式简介"></a>授权码模式简介</h2><p><strong>授权码模式(authorization code)是功能最完整、流程最严密的授权模式, 它的特点就是通过 <code>客户端的后台服务器</code> 与 <code>&quot;服务提供商&quot;的认证服务器</code> 进行互动 ;</strong> </p><h2 id="授权码模式运行过程"><a href="#授权码模式运行过程" class="headerlink" title="授权码模式运行过程"></a>授权码模式运行过程</h2><h3 id="运行图"><a href="#运行图" class="headerlink" title="运行图"></a>运行图</h3><p><img src="/img/oauth/authorization_code.png" width="535" height="500" alt="qq" align="center"></p><h3 id="运行步骤"><a href="#运行步骤" class="headerlink" title="运行步骤"></a>运行步骤</h3><p>1.用户(RO)通过浏览器(UA)在客户端(Client)中触发操作(比方说新浪微博登录/QQ登录), Client之后将用户导向<code>认证服务器</code>的授权页面：<br><img src="/img/oauth/weixin_oauth.png" width="352" height="189" alt="sina" align="center"><br><img src="/img/oauth/qq_oauth.png" width="360" height="200" alt="qq" align="center"></p><p>2.假设用户在授权页面给予客户端授权(authorization grant), 认证服务器会生成一个授权码code, 并带着这个code重新导向客户端配置并传递的 <code>redirect_url</code> ;</p><p>3.客户端的回调接口收到授权码, 然后在客户端的服务器中使用授权码去直接向认证服务器申请令牌 ;</p><p>4.认证服务器对客户端进行认证以后, 确认无误, 同意发放令牌(access_token) ;</p><p>5.客户端使用令牌，向资源服务器申请获取资源 ;</p><p>6.资源服务器确认令牌无误, 同意向客户端开放资源 ;</p><h2 id="授权码模式图中的三个阶段"><a href="#授权码模式图中的三个阶段" class="headerlink" title="授权码模式图中的三个阶段"></a>授权码模式图中的三个阶段</h2><p>这里, 我们又把OAuth2的整个认证过程大致分为三个阶段(分几个阶段, 几部步骤都是次要的, 重要的是能够理解整个过程):</p><h3 id="向用户取得授权许可"><a href="#向用户取得授权许可" class="headerlink" title="向用户取得授权许可"></a>向用户取得授权许可</h3><p>对应图中的第1、2、3步;</p><h3 id="申请访问令牌"><a href="#申请访问令牌" class="headerlink" title="申请访问令牌"></a>申请访问令牌</h3><p>access_token令牌的申请<br>对应图中的第4、5步;</p><h3 id="使用令牌获取用户数据"><a href="#使用令牌获取用户数据" class="headerlink" title="使用令牌获取用户数据"></a>使用令牌获取用户数据</h3><p>这一过程中涉及了不少敏感参数和数据, 例如client_secret相当于是第三方应用自己的密码, access_token某种程度上来讲就是用户的session id, 由于这些参数以及数据极其特殊, 我们当然得确保它们的安全性, HTTPS加密传输以及安全存储是必不可少的防护手段, <strong>不过仅仅做到这些是远远不够的, 因为其实在这个流程里存在一个弱点， 容易被攻击者利用进行CSRF攻击, 稍后讲解 ; </strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;授权码模式简介&quot;&gt;&lt;a href=&quot;#授权码模式简介&quot; class=&quot;headerlink&quot; title=&quot;授权码模式简介&quot;&gt;&lt;/a&gt;授权码模式简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;授权码模式(authorization code)是功能最完整、流程最严密的授权模式
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>01-OAuth简介</title>
    <link href="http://blog.renyimin.com/2016/03/19/OAuth/"/>
    <id>http://blog.renyimin.com/2016/03/19/OAuth/</id>
    <published>2016-03-19T03:05:00.000Z</published>
    <updated>2017-10-16T03:24:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是OAuth"><a href="#什么是OAuth" class="headerlink" title="什么是OAuth"></a>什么是OAuth</h2><p>开放式授权 Open Authorization</p><p>1.OAuth是一个关于授权(authorization)的开放网络标准, 在全世界得到广泛应用, 目前的版本是2.0版;</p><p>2.与以往的授权方式不同之处是, OAuth的授权 <strong><em>不会使第三方触及到用户的帐号信息(如用户名与密码)</em></strong> , 即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权, 因此 OAuth 是安全的, OAuth 是 <code>Open Authorization(开放授权)</code> 的简写;</p><h2 id="OAuth协议版本"><a href="#OAuth协议版本" class="headerlink" title="OAuth协议版本"></a>OAuth协议版本</h2><h3 id="1-0版本-2007-12"><a href="#1-0版本-2007-12" class="headerlink" title="1.0版本: 2007.12"></a>1.0版本: 2007.12</h3><p>有过安全漏洞, 比较复杂不易用</p><h3 id="2-0版本-2010年初"><a href="#2-0版本-2010年初" class="headerlink" title="2.0版本: 2010年初"></a>2.0版本: 2010年初</h3><h2 id="OAuth的应用场景"><a href="#OAuth的应用场景" class="headerlink" title="OAuth的应用场景"></a>OAuth的应用场景</h2><h3 id="各个站点随处可见的-QQ-微信-微博-登录"><a href="#各个站点随处可见的-QQ-微信-微博-登录" class="headerlink" title="各个站点随处可见的 QQ,微信,微博 登录"></a>各个站点随处可见的 <code>QQ</code>,<code>微信</code>,<code>微博</code> 登录</h3><p>比如你要做一个站点, 常规做法就需要建立一套用户注册登录体系, 而网民很反感, 因为他们可能有很多站点的用户名密码, 不太想再多一个账号了, 但大家几乎都有 QQ , 微信, 人人, 豆瓣 等互联网大佬的帐号; 那我们为何不用 QQ 帐号登录后, 授权给本网站呢？<br>可行, 不过先要确定好相互之间(网站和QQ之间)认证的规范, 这个规范有很多, 也可以自己写, 但业界比较通用 OAuth ;</p><h3 id="有些站点干脆就是需要使用其他站点的用户资料"><a href="#有些站点干脆就是需要使用其他站点的用户资料" class="headerlink" title="有些站点干脆就是需要使用其他站点的用户资料"></a>有些站点干脆就是需要使用其他站点的用户资料</h3><p>比如, 用户想在 “云冲印”网站上冲印自己Google账户上的照片, 首先”云冲印”网站得读取到用户储存在Google上的照片, 那么用户就需要授予”云冲印”网站自己Google账户的部分权限; (至少也得给予云冲印网站能够读取用户Google账户中照片的权限吧)</p><h2 id="传统授权的弊端"><a href="#传统授权的弊端" class="headerlink" title="传统授权的弊端"></a>传统授权的弊端</h2><p>传统所谓的”授权”做法, 最<code>简单</code> <code>直接</code> <code>暴力</code> 的就是用户直接将自己的Google账号和密码提供给”云冲印”网站, 这样后者就可以读取用户的照片了;</p><p>但这种做法有以下几个严重缺点:</p><h3 id="哪怕有一个Client有隐患"><a href="#哪怕有一个Client有隐患" class="headerlink" title="哪怕有一个Client有隐患"></a>哪怕有一个Client有隐患</h3><p>第三方网站, 为了后续的服务, 会保存用户的 Google/QQ/新浪微博/微信 账号和密码, 这样很不安全, 如果第三方网站都这样做的话, 难免有些第三方平台会由于自己的安全问题而导致用户 Google/QQ/新浪微博/微信 账户和密码的泄露, 这样将导致所有被密码保护的用户大量信息泄露 ;</p><h3 id="用户无法设定Client的权利范围"><a href="#用户无法设定Client的权利范围" class="headerlink" title="用户无法设定Client的权利范围"></a>用户无法设定Client的权利范围</h3><p>第三方网站拥有了获取用户 Google/QQ/新浪微博/微信 所有资料的权力, 用户没法限制 第三方网站 获得授权的范围和有效期 ;</p><h3 id="用户想收回Client权利不太方便"><a href="#用户想收回Client权利不太方便" class="headerlink" title="用户想收回Client权利不太方便"></a>用户想收回Client权利不太方便</h3><p>用户只有修改密码, 才能收回赋予 第三方网站 的权力, 否则 第三方网站 将会永久拥有用户 Google/QQ/新浪微博/微信 上的权利, 但是这样做, 会使得其他所有获得用户授权的第三方应用程序全部失效；</p><p>或者, 一些良心第三方可以设置 用户账号 和 Google/QQ/新浪微博/微信 账号的绑定和解绑, 但不一定所有第三方都会给你做, 如果不做解绑的话, 你还真只有前一种方法能够收回权利;</p><h2 id="OAuth应运而生"><a href="#OAuth应运而生" class="headerlink" title="OAuth应运而生"></a>OAuth应运而生</h2><h3 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h3><p>在详细讲解OAuth 2.0之前, 需要了解几个专用名词:</p><h4 id="Third-party-application"><a href="#Third-party-application" class="headerlink" title="Third-party application"></a>Third-party application</h4><p>第三方应用程序, 本文中又称”客户端”, 即上一节例子中的”云冲印” ;</p><h4 id="Owner"><a href="#Owner" class="headerlink" title="Owner"></a>Owner</h4><p>资源所有者, 用户自己 ;</p><h4 id="Authorization-server"><a href="#Authorization-server" class="headerlink" title="Authorization server"></a>Authorization server</h4><p>认证服务器, 即服务提供商专门用来处理认证的服务器 ;<br>(如QQ, google, 人人, 微信等都有自己的认证服务器)</p><h4 id="Resource-server"><a href="#Resource-server" class="headerlink" title="Resource server"></a>Resource server</h4><p>资源服务器, 即服务提供商存放用户生成的资源的服务器 (当然, 它与认证服务器, 可以是同一台服务器,也可以是不同的服务器)</p><h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User Agent"></a>User Agent</h4><p>用户代理, 本文中就是指浏览器 ;</p><h3 id="OAuth-2-0的运行流程"><a href="#OAuth-2-0的运行流程" class="headerlink" title="OAuth 2.0的运行流程"></a>OAuth 2.0的运行流程</h3><h4 id="运行流程图"><a href="#运行流程图" class="headerlink" title="运行流程图"></a>运行流程图</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/oauth/oauth2-01.png" alt="OAuth 2.0的运行流程图" title="">                </div>                <div class="image-caption">OAuth 2.0的运行流程图</div>            </figure><h4 id="运行流程图解"><a href="#运行流程图解" class="headerlink" title="运行流程图解"></a>运行流程图解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">（A）用户打开客户端以后，客户端要求用户给予授权。</div><div class="line">（B）用户同意给予客户端授权。</div><div class="line">（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</div><div class="line">（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</div><div class="line">（E）客户端使用令牌，向资源服务器申请获取资源。</div><div class="line">（F）资源服务器确认令牌无误，同意向客户端开放资源</div></pre></td></tr></table></figure><p>不难看出来, 上面六个步骤之中, B是关键, 即用户怎样才能给于客户端授权; </p><p>有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源;</p><h2 id="引出客户端的授权模式"><a href="#引出客户端的授权模式" class="headerlink" title="引出客户端的授权模式"></a>引出客户端的授权模式</h2><p>客户端必须得到用户的授权(authorization grant), 才能获得令牌(access token), OAuth 2.0定义了四种授权方式:</p><h3 id="授权码模式（authorization-code"><a href="#授权码模式（authorization-code" class="headerlink" title="授权码模式（authorization code)"></a>授权码模式（authorization code)</h3><h3 id="简化模式（implicit）"><a href="#简化模式（implicit）" class="headerlink" title="简化模式（implicit）"></a>简化模式（implicit）</h3><h3 id="密码模式（resource-owner-password-credentials）"><a href="#密码模式（resource-owner-password-credentials）" class="headerlink" title="密码模式（resource owner password credentials）"></a>密码模式（resource owner password credentials）</h3><h3 id="客户端模式（client-credentials）"><a href="#客户端模式（client-credentials）" class="headerlink" title="客户端模式（client credentials）"></a>客户端模式（client credentials）</h3><p>参考: <a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">阮一峰</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是OAuth&quot;&gt;&lt;a href=&quot;#什么是OAuth&quot; class=&quot;headerlink&quot; title=&quot;什么是OAuth&quot;&gt;&lt;/a&gt;什么是OAuth&lt;/h2&gt;&lt;p&gt;开放式授权 Open Authorization&lt;/p&gt;
&lt;p&gt;1.OAuth是一个关于授权
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>PHP的Closure学习整理</title>
    <link href="http://blog.renyimin.com/2016/03/10/clusore-introduction/"/>
    <id>http://blog.renyimin.com/2016/03/10/clusore-introduction/</id>
    <published>2016-03-10T06:30:15.000Z</published>
    <updated>2017-09-19T04:55:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要是对网上现存的一些资料做了一些简单地整理, 一方面让自己对基础知识加深印象, 一方面便于日后自己随时回顾!</p><h4 id="JavaScript中的闭包"><a href="#JavaScript中的闭包" class="headerlink" title="JavaScript中的闭包"></a>JavaScript中的闭包</h4><p>在了解PHP的闭包之前, 我们可以先简单了解一下JavaScript的闭包是怎样的?</p><h5 id="Js的作用域"><a href="#Js的作用域" class="headerlink" title="Js的作用域"></a>Js的作用域</h5><p>1.要理解闭包，首先必须理解Javascript的 <strong>变量作用域</strong> ;</p><p>2.变量的作用域无非就是两种: <strong>全局变量</strong> 和 <strong>局部变量</strong> ;</p><p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量:<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var n=999;</div><div class="line">function f1()&#123;</div><div class="line">    alert(n);</div><div class="line">&#125;</div><div class="line">f1(); // 999</div></pre></td></tr></table></figure></p><p>另一方面, 在函数外部自然无法读取函数内的局部变量:<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function f1()&#123;</div><div class="line">    var n=999;  //这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</div><div class="line">&#125;</div><div class="line">alert(n); // error</div></pre></td></tr></table></figure></p><h5 id="如何从外部读取局部变量？"><a href="#如何从外部读取局部变量？" class="headerlink" title="如何从外部读取局部变量？"></a>如何从外部读取局部变量？</h5><p>出于种种原因, 我们有时候需要得到函数内的局部变量, 但是, 前面已经说过了, 正常情况下，这是办不到的, 只有通过变通方法才能实现;</p><p>于是, 我们可以在函数的内部, 再定义一个函数:<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function f1()&#123;</div><div class="line">    var n = 999;</div><div class="line">    function f2()&#123;</div><div class="line">        alert(n); // 999</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在上面的代码中, 函数f2就被包括在函数f1内部, 这时, f1内部的所有局部变量, 对f2都是可见的;<br>但是反过来就不行, f2内部的局部变量, 对f1就是不可见的; </p><p>这就是Javascript语言特有的”链式作用域”结构(chain scope), 子对象会一级一级地向上寻找所有父对象的变量; 所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function f1(a)&#123;</div><div class="line">    var n = &apos;局部变量&apos;;</div><div class="line">    function f2(c)&#123;</div><div class="line">       console.log(n);</div><div class="line">       console.log(a);</div><div class="line">       console.log(c);</div><div class="line">    &#125;</div><div class="line">    return f2;</div><div class="line">&#125;</div><div class="line">var result = f1(&apos;传递给函数的参数,也成了一个局部值&apos;);</div><div class="line">result(&apos;传递给闭包的参数1&apos;);</div><div class="line">console.log(&apos;&apos;);</div><div class="line">result(&apos;传递给闭包的参数2&apos;);</div><div class="line">//结果: </div><div class="line">局部变量    //可以看到我们就从外部取到了函数内部的局部变量</div><div class="line">传递给函数的参数,也成了一个局部值</div><div class="line">传递给闭包的参数1</div><div class="line"></div><div class="line">局部变量    //可以看到我们就从外部取到了函数内部的局部变量</div><div class="line">传递给函数的参数,也成了一个局部值</div><div class="line">传递给闭包的参数2</div></pre></td></tr></table></figure></p><h5 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h5><p>上一节代码中的f2函数, 就是闭包;</p><p>各种专业文献上对 “闭包”（closure）定义非常抽象，很难看懂;</p><p>我的理解是，闭包就是能够读取其他函数内部变量的函数;</p><p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量, 因此可以把闭包简单理解成 <strong>“定义在一个函数内部的函数”</strong> ;</p><p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁;</p><h5 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h5><p>1.闭包可以用在许多地方, 它的最大用处有两个:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">一个是前面提到的可以读取函数内部的变量; </div><div class="line">另一个就是让这些变量的值始终保持在内存中;</div></pre></td></tr></table></figure></p><p>2.怎么来理解上面的话呢？</p><p>之前的代码中, result 这个变量其实就是闭包函数f2, 它一共运行了两次;</p><p>而函数f1中的局部变量一直保存在内存中, 并没有在f1调用后被自动清除;</p><p><strong>原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后被垃圾回收机制（garbage collection）回收;</strong></p><h5 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h5><p>1.由于闭包会使得函数中的变量都被保存在内存中, 内存消耗很大, 所以不能滥用闭包, 否则会造成网页的性能问题, 在IE中可能导致内存泄露, 解决方法是, 在退出函数之前, 将不使用的局部变量全部删除;</p><p>2.闭包会在父函数外部改变父函数内部变量的值; 所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method）, 把内部变量当作它的私有属性（private value）, 这时一定要小心, 不要随便改变父函数内部变量的值;</p><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line">var object = &#123;</div><div class="line">    name : &quot;My Object&quot;,</div><div class="line">    getNameFunc : function()&#123;</div><div class="line">        return function()&#123;</div><div class="line">            return this.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">console.log(object.getNameFunc()());     // The Window</div></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line">var object = &#123;</div><div class="line">    name : &quot;My Object&quot;,</div><div class="line">    getNameFunc : function()&#123;</div><div class="line">        var that = this;</div><div class="line">        return function()&#123;</div><div class="line">            return that.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">console.log(object.getNameFunc()());    // My Object</div></pre></td></tr></table></figure><p>以上参考<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">阮一峰的博客</a>, 阮一峰大哥真的写的很好了, 本人这里只是过一遍, 然后稍微简化了一点点, 修改了一点列子, 便于自己理解;</p><h4 id="PHP的闭包"><a href="#PHP的闭包" class="headerlink" title="PHP的闭包"></a>PHP的闭包</h4><p>1.PHP的<code>闭包</code> 和 <code>匿名函数</code> 是在PHP5.3.0中引入, 这两个特性非常有用, 每个PHP开发者都应该掌握;</p><p>2.闭包是指在创建时, <strong>封装周围状态的函数</strong>, 即便闭包所在的环境不存在了, 闭包中封装的状态依然存在, 这个概念如果你看了之前的JavaScript相关闭包的概念, 应该理解起来不是太难;</p><p>3.匿名函数是没有名称的的函数, 匿名函数可以赋值给变量, 还能像其他任何PHP变量那样传递, 不过匿名函数仍是函数, 因此可以调用, 还可以传入参数, 匿名函数特别适合作为函数或方法的回调;</p><p>4.理论上讲, 闭包和匿名函数是不同的概念, 不过, PHP将其视为相同的概念, 所以一般在PHP中说闭包就是匿名函数, 说匿名函数也是指闭包;</p><p>5.PHP闭包和匿名函数使用的句法虽然和普通函数相同, 但是需要注意的是, 闭包和匿名函数其实是<strong>伪装成函数的对象</strong>, 如果审查PHP闭包或匿名函数, 会发现阀门是Closure类的实例; 闭包和字符串或证书一样, 也是<strong>一等值类型</strong> ;</p><h5 id="创建闭包"><a href="#创建闭包" class="headerlink" title="创建闭包"></a>创建闭包</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$closure = <span class="function"><span class="keyword">function</span> <span class="params">($name)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sprintf(<span class="string">'Hello %s'</span>, $name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var_dump($closure); <span class="comment">//object(Closure)#1 (1) &#123; ["parameter"]=&gt; array(1) &#123; ["$name"]=&gt; string(10) "" &#125; &#125;</span></div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;br/&gt;'</span>;</div><div class="line"><span class="keyword">echo</span> $closure(<span class="string">'Josh'</span>);  <span class="comment">//Hello Josh</span></div></pre></td></tr></table></figure><p>闭包对象的创建就这么简单;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">建议: 之所以能调用$closure变量, 是因为这个变量的值是一个闭包, 而且闭包对象实现了__invoke()魔术方法;</div><div class="line">只要变量名后面有(), PHP就会查找并调用__invoke()方法;</div></pre></td></tr></table></figure><p>通常情况下, 我们会把PHP的闭包对象当做函数和方法的回调来使用; 很多PHP的函数都会用到回调函数, 例如 array_map()和preg_replace_callback();<br>这是使用PHP匿名函数的绝佳时机! 记住, 闭包和其他值一样, 可以作为参数出传入其他PHP函数;</p><h5 id="PHP中闭包的-附加状态"><a href="#PHP中闭包的-附加状态" class="headerlink" title="PHP中闭包的 附加状态"></a>PHP中闭包的 <code>附加状态</code></h5><p>1.之前我们说的 array_map()和preg_replace_callback() 对闭包的使用, 主要是把匿名函数当做回调来使用;<br><strong>下面我们讨论的是如何为PHP闭包附加并封装状态;</strong></p><p><strong>2</strong>.JavaScript开发者可能对PHP的闭包感到奇怪, 因为通过之前对JavaScript中闭包的了解, <strong>它的闭包会自动封装应用的状态</strong>; 而PHP的闭包不会像真正的JS闭包那样自动封装应用的状态;<br><strong>在PHP中, 我们必须手动调用闭包对象的 <code>use关键字</code> , 或者闭包对象的 <code>bindTo()方法</code> 来把状态附加到PHP闭包上;</strong></p><h5 id="use关键字"><a href="#use关键字" class="headerlink" title="use关键字"></a>use关键字</h5><p>使用use关键字附加闭包状态比较常见, 我们先看这种方式;</p><p>使用use关键字把变量附加到闭包上时, 附加的变量会记住附加时赋给它的值:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enclosePerson</span><span class="params">($name)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">($doCommand)</span> <span class="title">use</span> <span class="params">($name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sprintf(<span class="string">'%s, %s'</span>, $name, $doCommand);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$clay = enclosePerson(<span class="string">'Clay'</span>);</div><div class="line"></div><div class="line"><span class="keyword">echo</span> $clay(<span class="string">'get me sweet tea!'</span>);</div></pre></td></tr></table></figure></p><p>在例子中, 具名函数enclosePerson()有个名为$name参数, 这个函数返回一个闭包对象, 而且这个闭包对象封装了$name参数;<br>即便返回的闭包对象已经跳出了enclosePerson()函数的作用域, 闭包对象也会记住$name参数的值, 因为$name变量仍在闭包中;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">使用<span class="keyword">use</span>关键字可以把多个参数传入闭包, 此时要像<span class="title">php</span>函数或方法的参数一样, 使用都好分割多个参数;</div></pre></td></tr></table></figure><h5 id="Closure对象的bindTo-方法"><a href="#Closure对象的bindTo-方法" class="headerlink" title="Closure对象的bindTo()方法"></a>Closure对象的bindTo()方法</h5><p>1.别忘了, php闭包是个对象(Closure对象), 与任何其他PHP对象类似, 每个闭包都可以使用$this关键字获取闭包的内部状态; </p><p>虽然闭包对象的默认状态没什么用, 只不过是有一个__invoke魔术方法和bindTo()方法而已; 但是bindTo()方法为闭包增加了一些有趣的潜力, 我们可以使用这个方法把closure对象内部的状态绑定到其他对象上;</p><p>2.<strong>bindTo()方法的第二个参数很重要, 其作用是指定绑定闭包的那个对象所属的PHP类; 因此, 闭包可以访问绑定闭包的对象中受保护和似有的成员变量;</strong></p><p>3.其实如果经常看一些php框架源码, 你会发现, PHP框架经常使用bindTo()方法把 <code>路由URL所映射的匿名回调函数</code> 绑定到 <code>应用对象上</code>, 这么做可以在这个匿名函数中使用$this关键字引用重要的应用对象:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">protected</span> $routes = [];</div><div class="line">    <span class="keyword">protected</span> $responseStatus = <span class="string">'200 OK'</span>;</div><div class="line">    <span class="keyword">protected</span> $responseContentType = <span class="string">'text/html'</span>;</div><div class="line">    <span class="keyword">protected</span> $responseBody = <span class="string">'Hello world'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addRoute</span><span class="params">($routePath, $routeCallback)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;routes[$routePath] = $routeCallback-&gt;bindTo(<span class="keyword">$this</span>, <span class="keyword">__CLASS__</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">($currentPath)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">foreach</span>(<span class="keyword">$this</span>-&gt;routes <span class="keyword">as</span> $routePath =&gt; $callBack)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> ($routePath === $currentPath) &#123;</div><div class="line">                $callBack();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        header(<span class="string">'HTTP/1.1 '</span> . <span class="keyword">$this</span>-&gt;responseStatus);</div><div class="line">        header(<span class="string">'Content-type: '</span> . <span class="keyword">$this</span>-&gt;responseContentType);</div><div class="line">        header(<span class="string">'Content-length: '</span> . mb_strlen(<span class="keyword">$this</span>-&gt;responseBody));</div><div class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;responseBody;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$app = <span class="keyword">new</span> App();</div><div class="line">$app-&gt;addRoute(<span class="string">'/user/getName'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;responseContentType = <span class="string">'application/json;charset=utf8'</span>;</div><div class="line">    <span class="keyword">$this</span>-&gt;responseBody = <span class="string">'&#123;"name": "renyimin"&#125;'</span>;</div><div class="line">&#125;);</div><div class="line">$app-&gt;dispatch(<span class="string">'/user/getName'</span>);</div><div class="line"></div><div class="line"><span class="comment">//结果返回: &#123;"name": "renyimin"&#125;</span></div></pre></td></tr></table></figure></p><p>上面例子其实就是通过在App应用类中, 使用匿名函数的bindTo()方法将匿名函数绑定到了App对象上, 所以你就可以在绑定路由与其匿名函数的时候, 在匿名函数中来通过$this来调用App对象中的一些受保护的属性, 从而设定本路由的返回信息;</p><blockquote><p>《Modern PHP》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要是对网上现存的一些资料做了一些简单地整理, 一方面让自己对基础知识加深印象, 一方面便于日后自己随时回顾!&lt;/p&gt;
&lt;h4 id=&quot;JavaScript中的闭包&quot;&gt;&lt;a href=&quot;#JavaScript中的闭包&quot; class=&quot;headerlink&quot; title=&quot;J
      
    
    </summary>
    
      <category term="PHP New Features" scheme="http://blog.renyimin.com/categories/PHP-New-Features/"/>
    
      <category term="PHP" scheme="http://blog.renyimin.com/categories/PHP-New-Features/PHP/"/>
    
    
      <category term="Closure(闭包)" scheme="http://blog.renyimin.com/tags/Closure-%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>网络数据通信方式</title>
    <link href="http://blog.renyimin.com/2015/07/10/Data-communication-method01/"/>
    <id>http://blog.renyimin.com/2015/07/10/Data-communication-method01/</id>
    <published>2015-07-10T05:20:16.000Z</published>
    <updated>2017-09-30T03:12:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络中传输的信息都是数字数据, <strong>按照数据在线路上的传输方向</strong>，<code>通信方式</code> 可分为：</p><h2 id="单工通信-Simplex"><a href="#单工通信-Simplex" class="headerlink" title="单工通信(Simplex)"></a>单工通信(Simplex)</h2><h3 id="单向信道-信息流是单方向的"><a href="#单向信道-信息流是单方向的" class="headerlink" title="单向信道,信息流是单方向的"></a>单向信道,信息流是单方向的</h3><p>发送端和接收端的身份是固定的, 发送端只能发送信息, 不能接收信息; 接收端只能接收信息, 不能发送信息 ;</p><h3 id="常见通信"><a href="#常见通信" class="headerlink" title="常见通信"></a>常见通信</h3><p>遥控、遥测, 就是单工通信方式</p><h2 id="半双工通信-Half-Duplex"><a href="#半双工通信-Half-Duplex" class="headerlink" title="半双工通信(Half Duplex)"></a>半双工通信(Half Duplex)</h2><h3 id="双向信道-信息流是双向的"><a href="#双向信道-信息流是双向的" class="headerlink" title="双向信道, 信息流是双向的"></a>双向信道, 信息流是双向的</h3><p>没有固定发送端和接收端, 任何一端都可以发送消息给另一端 ;</p><h3 id="同一时刻只能发送或只能接收数据"><a href="#同一时刻只能发送或只能接收数据" class="headerlink" title="同一时刻只能发送或只能接收数据"></a>同一时刻只能发送或只能接收数据</h3><p>所谓半双工就是指一个时间段内只有一个动作发生 ;</p><h3 id="常见通信-1"><a href="#常见通信-1" class="headerlink" title="常见通信"></a>常见通信</h3><p>对讲机, 微信语音</p><h2 id="全双工通信-Full-Duplex"><a href="#全双工通信-Full-Duplex" class="headerlink" title="全双工通信(Full Duplex)"></a>全双工通信(Full Duplex)</h2><h3 id="双向信道-信息流是双向的-1"><a href="#双向信道-信息流是双向的-1" class="headerlink" title="双向信道, 信息流是双向的"></a>双向信道, 信息流是双向的</h3><p>没有固定发送端和接收端, 任何一端都可以发送消息给另一端 ;</p><h3 id="发送和接收数据可以同时进行"><a href="#发送和接收数据可以同时进行" class="headerlink" title="发送和接收数据可以同时进行"></a>发送和接收数据可以同时进行</h3><p>是指在发送数据的同时也能够接收数据, 可以同时进行 ;<br>(目前的网卡一般都支持全双工)</p><h3 id="常见通信-2"><a href="#常见通信-2" class="headerlink" title="常见通信"></a>常见通信</h3><p>我们平时的打电话通信就是全双工通信，你在说话的同时也能够听到对方的声音 ;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机网络中传输的信息都是数字数据, &lt;strong&gt;按照数据在线路上的传输方向&lt;/strong&gt;，&lt;code&gt;通信方式&lt;/code&gt; 可分为：&lt;/p&gt;
&lt;h2 id=&quot;单工通信-Simplex&quot;&gt;&lt;a href=&quot;#单工通信-Simplex&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="网络" scheme="http://blog.renyimin.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://blog.renyimin.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>polling--&gt;服务推技术--&gt;websocket</title>
    <link href="http://blog.renyimin.com/2015/07/10/websocket01/"/>
    <id>http://blog.renyimin.com/2015/07/10/websocket01/</id>
    <published>2015-07-10T04:40:16.000Z</published>
    <updated>2017-10-16T03:04:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1.传统Web开发下, 我们都是使用http协议在服务器和客户端之间进行通信, 要知道http协议是一种单向的网络协议, 在建立连接之后, 只能是浏览器向服务器发出请求资源后, 服务器才能响应 ; </p><p>注意: <code>服务器是无法主动的推送数据给客户端的</code>, 这也是为了<code>安全</code>起见 ;</p><p>2.既然传统的http请求有上述问题, 那么如下一些现代web开发的场景该如何应对?<br>即时通信系统；<br>即时报价系统；<br>股票的实时行情;</p><p>3.要应对上述应用场景, 目前有很多方案可供选择, 下面将一一介绍;</p><h2 id="传统Ajax短轮训-Polling"><a href="#传统Ajax短轮训-Polling" class="headerlink" title="传统Ajax短轮训(Polling)"></a>传统Ajax短轮训(Polling)</h2><p>1.这种方案主要就是通过浏览器<code>每隔一定时间就去向服务器发送http请求</code>, 服务器受到请求后, 就把最新的数据返回给客户端(浏览器), 浏览器再将数据显示出来 ;</p><p>2.虽然这种方案可以满足需求, 但是却存在很多问题:<br>(1) 可能在一段时间内的多次请求中, 服务器端的数据根本就没有更新过, 这样就导致客户端一直在空转, 这样既浪费了网络带宽, 又浪费了COU的利用率 ;</p><p>(2) 针对第一个问题, 可能有人会觉得, 将客户端请求服务器的时间间隔做适当的调整就可以, 比如调整大一点, 但这样的话, 如果服务器端的数据更新很快的时候, 又不能保证客户端获取数据的实时性 ;</p><h2 id="解决方案-–-服务器推技术"><a href="#解决方案-–-服务器推技术" class="headerlink" title="解决方案 – 服务器推技术"></a>解决方案 – 服务器推技术</h2><h3 id="服务器推技术分两类"><a href="#服务器推技术分两类" class="headerlink" title="服务器推技术分两类"></a>服务器推技术分两类</h3><p>面对上面提到的实时性较高的web应用场景, “服务器推”技术有一些解决方案, 本文将这些解决方案分为两类 :<br>(1)一类需要在浏览器端安装插件,基于套接口传送信息,或是使用 RMI、CORBA 进行远程调用 ;<br>基于客户端套接口的 “服务器推” 技术</p><p>(2)而另一类则无须浏览器安装任何插件、基于 HTTP 长连接 ;<br>Comet </p><h2 id="基于客户端套接口的”服务器推”技术"><a href="#基于客户端套接口的”服务器推”技术" class="headerlink" title="基于客户端套接口的”服务器推”技术"></a>基于客户端套接口的”服务器推”技术</h2><h3 id="Flash-XMLSocket"><a href="#Flash-XMLSocket" class="headerlink" title="Flash XMLSocket"></a>Flash XMLSocket</h3><p>如果你的Web应用的用户可以接受 <code>只有在安装了 Flash 播放器</code> 应用才能正常运行, 那么使用 Flash 的 <code>XMLSocket</code> 就是一个可行的方案:</p><p>这种方案实现的基础是:<br>1.Flash 提供了 XMLSocket 类 ;<br>2.JavaScript 和 Flash 的紧密结合: 在 JavaScript 可以直接调用 Flash 程序提供的接口;</p><p>具体实现方法: 在 HTML 页面中内嵌入一个使用了 XMLSocket 类的 Flash 程序, JavaScript 通过调用此 Flash 程序提供的套接口接口与服务器端的套接口进行通信, JavaScript 在收到服务器端以 XML 格式传送的信息后可以很容易地控制 HTML 页面的内容显示 ;</p><p><strong><em>关于如何去构建充当了 JavaScript 与 Flash XMLSocket 桥梁的 Flash 程序，以及如何在 JavaScript 里调用 Flash 提供的接口，我们可以参考 AFLAX（Asynchronous Flash and XML）项目提供的 Socket Demo 以及 SocketJS（请参见 参考资源）</em></strong></p><p>Javascript 与 Flash 的紧密结合，极大增强了客户端的处理能力。从 Flash 播放器 V7.0.19 开始，已经取消了 XMLSocket 的端口必须大于 1023 的限制。Linux 平台也支持 Flash XMLSocket 方案。但此方案的 <strong>缺点</strong> 在于：<br>(1)客户端必须安装 Flash 播放器；<br>(2)因为 XMLSocket 没有 HTTP 隧道功能，XMLSocket 类不能自动穿过防火墙；<br>(3)因为是使用套接口，需要设置一个通信端口，防火墙、代理服务器也可能对非 HTTP 通道端口进行限制；</p><p>不过这种方案在一些网络聊天室，网络互动游戏中已得到广泛使用。</p><h3 id="Java-Applet-套接口"><a href="#Java-Applet-套接口" class="headerlink" title="Java Applet 套接口"></a>Java Applet 套接口</h3><p>在客户端使用 Java Applet，通过 java.net.Socket 或 java.net.DatagramSocket 或 java.net.MulticastSocket 建立与服务器端的套接口连接, 从而实现”服务器推” ;</p><p>这种方案最大的不足在于 <code>Java applet 在收到服务器端返回的信息后, 无法通过 JavaScript 去更新 HTML 页面的内容</code> ;</p><h2 id="基于HTTP长连接的”服务器推”技术"><a href="#基于HTTP长连接的”服务器推”技术" class="headerlink" title="基于HTTP长连接的”服务器推”技术"></a>基于HTTP长连接的”服务器推”技术</h2><h3 id="Comet-简介"><a href="#Comet-简介" class="headerlink" title="Comet 简介"></a>Comet 简介</h3><p>1.”服务器推” 是一种很早就存在的技术,以前在实现上主要是通过客户端的套接口或是服务器端的远程调用, 因为浏览器技术的发展比较缓慢,没有为”服务器推”的实现提供很好的支持,在纯浏览器的应用中很难有一个完善的方案去实现”服务器推”并用于商业程序; </p><p>2.最近几年, 因为 <code>AJAX 技术的普及</code>, 以及 <code>把 IFrame 嵌在 &quot;htmlfile&quot; 的 ActiveX 组件中可以解决 IE 的加载显示问题</code>，一些受欢迎的应用如 meebo，gmail+gtalk 在实现中使用了这项技术;</p><p>3.Alex Russell(Dojo Toolkit 的项目 Lead)称 <code>基于 HTTP 长连接、无须在浏览器端安装插件的</code> “服务器推”技术为 “Comet”;</p><p>4.目前已经出现了一些成熟的 Comet 应用以及各种开源框架, 一些 Web 服务器如Jetty也在为支持大量并发的长连接进行了很多改进; 关于 Comet 技术最新的发展状况请参考关于 Comet 的 wiki。</p><h3 id="Comet的实现模型有两类"><a href="#Comet的实现模型有两类" class="headerlink" title="Comet的实现模型有两类"></a>Comet的实现模型有两类</h3><p>下面将介绍两种 Comet 应用的实现模型 (都是基于http长连接) :<br>基于 AJAX 的长轮询（long-polling）方式</p><p>基于 Iframe 及 htmlfile 的流(streaming)方式</p><h3 id="基于-AJAX-的长轮询（long-polling）方式"><a href="#基于-AJAX-的长轮询（long-polling）方式" class="headerlink" title="基于 AJAX 的长轮询（long-polling）方式"></a>基于 AJAX 的长轮询（long-polling）方式</h3><p>1.AJAX 的出现使得 JavaScript 可以调用 XMLHttpRequest 对象发出 HTTP 请求，JavaScript 响应处理函数根据服务器返回的信息对 HTML 页面的显示进行更新;</p><p>2.使用 AJAX 实现”服务器推” 与 传统的 AJAX 应用不同之处在于：<br>(1)服务器端会阻塞请求直到有数据传递或超时才返回;<br>(2)客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后,再次发出请求,重新建立连接;<br>(3)当客户端处理接收的数据、重新建立连接时, 服务器端可能有新的数据到达, 这些信息会被服务器端保存直到客户端重新建立连接, 客户端会一次把当前服务器端所有的信息取回;</p><p>3.基于长轮询的服务器推模型如下:<br><img src="/img/websocket/comet_ajax_longpolling.png" width="350" height="280" alt="comet_ajax_longpolling" align="center"></p><p>相对于”短轮询”(poll), 这种长轮询方式也可以称为”拉”(pull);</p><p>这种方案<code>基于 AJAX</code>，具有以下一些优点:<br>请求异步发出;<br>无须安装插件;<br>IE、Mozilla FireFox 都支持 AJAX;</p><h3 id="基于-Iframe-及-htmlfile-的流-streaming-方式"><a href="#基于-Iframe-及-htmlfile-的流-streaming-方式" class="headerlink" title="基于 Iframe 及 htmlfile 的流(streaming)方式"></a>基于 Iframe 及 htmlfile 的流(streaming)方式</h3><p>1.iframe 是很早就存在的一种 HTML 标记, 通过在 HTML 页面里嵌入一个隐蔵帧,然后将这个隐蔵帧的 SRC 属性设为对一个长连接的请求, 服务器端就能源源不断地往客户端输入数据;</p><p>2.基于流方式的服务器推模型<br><img src="/img/websocket/comet_iframe_streaming.png" width="350" height="280" alt="comet_iframe_streaming" align="center"><br>上节提到的 AJAX 方案是在 JavaScript 里处理 XMLHttpRequest 从服务器取回的数据，然后 Javascript 可以很方便的去控制 HTML 页面的显示;</p><p>同样的思路用在 iframe 方案的客户端，iframe 服务器端并不返回直接显示在页面的数据，而是返回对客户端 Javascript 函数的调用，如<code>&lt;script type=&quot;text/javascript&quot;&gt;js_func(&#39;data from server&#39;)&lt;/script&gt;;</code> 服务器端将返回的数据作为客户端 JavaScript 函数的参数传递, 客户端浏览器的 Javascript 引擎在收到服务器返回的 JavaScript 调用时就会去执行代码;</p><p>从图中可以看到,每次数据传送不会关闭连接,连接只会在通信出现错误时或是连接重建时关闭(一些防火墙常被设置为丢弃过长的连接,服务器端可以设置一个超时时间,超时后通知客户端重新建立连接,并关闭原来的连接);</p><p>使用 iframe 请求一个长连接有一个很明显的不足之处:IE、Morzilla Firefox 下端的进度栏都会显示加载没有完成,而且 IE 上方的图标会不停的转动,表示加载正在进行;<br>Google 的天才们使用一个称为“htmlfile”的 ActiveX 解决了在 IE 中的加载显示问题，并将这种方法用到了 gmail+gtalk 产品中。Alex Russell 在 “What else is burried down in the depth’s of Google’s amazing JavaScript?”文章中介绍了这种方法。Zeitoun 网站提供的 comet-iframe.tar.gz，封装了一个基于 iframe 和 htmlfile 的 JavaScript comet 对象，支持 IE、Mozilla Firefox 浏览器，可以作为参考。（请参见 参考资源）</p><h2 id="解决方案-–-WebSocket"><a href="#解决方案-–-WebSocket" class="headerlink" title="解决方案 – WebSocket"></a>解决方案 – WebSocket</h2><p>1.websocket是HTML5中定义的新协议, 它实现了<strong>真正的</strong>长连接, 实现了浏览器与服务器的全双工通信;<br>WebSocket是为解决客户端与服务端实时通信而产生的技术, websocket协议本质上是一个基于tcp的协议，是先通过HTTP/HTTPS协议发起一条特殊的http请求进行握手后, 创建一个用于交换数据的TCP连接, 此后服务端与客户端通过此TCP连接进行实时通信 ;<br>注意:此时不再需要原HTTP协议的参与了 ;</p><p>2.<br><a href="https://www.ibm.com/developerworks/cn/web/wa-lo-comet/#icomments" target="_blank" rel="external">摘自</a><br><a href="http://blog.csdn.net/fhzaitian/article/details/51691946" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;1.传统Web开发下, 我们都是使用http协议在服务器和客户端之间进行通信, 要知道http协议是一种单向的网络协议, 在建立连接之后, 
      
    
    </summary>
    
      <category term="WebSocket" scheme="http://blog.renyimin.com/categories/WebSocket/"/>
    
    
      <category term="WebSocket" scheme="http://blog.renyimin.com/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Ajax请求不能发送 -- WebSocket方案</title>
    <link href="http://blog.renyimin.com/2015/06/07/sameoriginpolicy07-ajax-disabled-websocket/"/>
    <id>http://blog.renyimin.com/2015/06/07/sameoriginpolicy07-ajax-disabled-websocket/</id>
    <published>2015-06-07T02:20:16.000Z</published>
    <updated>2017-09-30T01:44:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信 ;</p><p>下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /chat HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</div><div class="line">Sec-WebSocket-Protocol: chat, superchat</div><div class="line">Sec-WebSocket-Version: 13</div><div class="line">Origin: http://example.com</div></pre></td></tr></table></figure></p><p>上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。<br>正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</div><div class="line">Sec-WebSocket-Protocol: chat</div></pre></td></tr></table></figure></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
      <category term="WebSocket" scheme="http://blog.renyimin.com/categories/CrossDomain/WebSocket/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
      <category term="WebSocket" scheme="http://blog.renyimin.com/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>小结</title>
    <link href="http://blog.renyimin.com/2015/05/30/sameoriginpolicy06-summary/"/>
    <id>http://blog.renyimin.com/2015/05/30/sameoriginpolicy06-summary/</id>
    <published>2015-05-30T13:20:16.000Z</published>
    <updated>2017-09-29T09:22:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jsonp-对比-CORS简单-非简单请求"><a href="#Jsonp-对比-CORS简单-非简单请求" class="headerlink" title="Jsonp 对比 CORS简单/非简单请求"></a>Jsonp 对比 CORS简单/非简单请求</h2><p>都可以方便实现跨域;</p><h3 id="Jsonp"><a href="#Jsonp" class="headerlink" title="Jsonp"></a>Jsonp</h3><p>简单适用, 老式浏览器全部支持, 服务器端改动很小;</p><p>JSONP只能发GET请求;</p><p>JSONP跨子域发送Cookie的话(貌似也就是在跨子域的时候你能发发cookie), 只用设置好<code>cookie的domain属性</code>为顶级域名即可;</p><h3 id="CORS简单请求"><a href="#CORS简单请求" class="headerlink" title="CORS简单请求"></a>CORS简单请求</h3><p>服务端需要设置一些允许选项;</p><p>发送请求为 GET, POST, HEAD ;</p><p>跨子域发送cookie的话(貌似也就是在跨子域的时候你能发发cookie), 不仅需要设置<code>cookie的domain属性</code>, 服务端和客户端都要对<code>Credentials</code> header属性进行设置;</p><p>跨子域的话 服务端 <code>Access-Control-Allow-Origin</code> 不能设置为 * , 否则会提示 :<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Failed to load http:<span class="comment">//test.test.com/index.php?sex=renyimin&amp;age=100: </span></div><div class="line">The value of the <span class="string">'Access-Control-Allow-Origin'</span> header in the response must not be the wildcard <span class="string">'*'</span> when the request<span class="string">'s credentials mode is '</span><span class="keyword">include</span><span class="string">'. </span></div><div class="line"><span class="string">Origin '</span>http:<span class="comment">//www.test.com' is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span></div></pre></td></tr></table></figure></p><h3 id="CORS非简单请求"><a href="#CORS非简单请求" class="headerlink" title="CORS非简单请求"></a>CORS非简单请求</h3><p>服务端需要设置一些允许选项;</p><p>发送其他请求 (PUT) ..</p><p>可以设置自定义header头</p><p>cookie方面和 CORS简单请求一样</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Jsonp-对比-CORS简单-非简单请求&quot;&gt;&lt;a href=&quot;#Jsonp-对比-CORS简单-非简单请求&quot; class=&quot;headerlink&quot; title=&quot;Jsonp 对比 CORS简单/非简单请求&quot;&gt;&lt;/a&gt;Jsonp 对比 CORS简单/非简单请求&lt;/
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>Ajax请求不能发送 -- CORS方案02 (not-so-simple request)</title>
    <link href="http://blog.renyimin.com/2015/05/20/sameoriginpolicy05-ajax-disabled-cors-not-simple/"/>
    <id>http://blog.renyimin.com/2015/05/20/sameoriginpolicy05-ajax-disabled-cors-not-simple/</id>
    <published>2015-05-20T12:10:16.000Z</published>
    <updated>2017-09-29T09:22:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><h3 id="预检请求-preflight-说明"><a href="#预检请求-preflight-说明" class="headerlink" title="预检请求 preflight 说明"></a>预检请求 <code>preflight</code> 说明</h3><ol><li><p>非简单请求是那种对服务器有特殊要求的请求, 比如请求方法是 <code>PUT</code> 或 <code>DELETE</code>, 或者 <code>Content-Type</code> 字段的类型是 <code>application/json</code> ;</p></li><li><p>非简单请求的CORS请求, 会在正式通信之前, 增加一次HTTP查询请求, 称为 <code>&quot;预检&quot;请求(preflight)</code> ;<br> 浏览器先询问服务器, 当前网页所在的域名是否在服务器的许可名单之中, 以及可以使用哪些HTTP动词和头信息字段;<br> 只有得到肯定答复, 浏览器才会发出正式的XMLHttpRequest请求, 否则就报错 ;</p></li><li><p>非简单请求会导致原先的一次请求变成两次, 第一次请求是 <code>预检请求</code> ;</p></li><li><p>“预检”请求用的请求方法是 <code>OPTIONS</code>，表示这个请求是用来<code>询问</code>的，头信息里面，关键字段是Origin，表示请求来自哪个源 ;<br> 即使你的请求方法是 <code>GET</code>, <code>POST</code> 或者 <code>HEAD</code>(只是请求时自定义了一些header首部字段), 你的这个跨域请求也是 <code>非简单请求</code>，此时请求头显示的 ；</p></li></ol><h4 id="非简单请求的例子"><a href="#非简单请求的例子" class="headerlink" title="非简单请求的例子"></a>非简单请求的例子</h4><ol><li><p>www.test.com/index.php<br> 本例子使用 <code>PUT</code> 来进行ajax请求, 满足 <code>非简单请求</code> 的条件 ;<br> 另外, 本例还<code>自定义了请求时的 header 首部字段</code>, 也满足 <code>非简单请求</code> 的条件 ;</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="meta">?&gt;</span></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;Title&lt;/title&gt;</div><div class="line">    &lt;script src=<span class="string">"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=<span class="string">"text/javascript"</span> &gt;</div><div class="line">        $(document).ready(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">            $(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">//序列化name/value</span></div><div class="line">                <span class="keyword">var</span> data = $(<span class="string">"form"</span>).serializeArray();</div><div class="line">                $.ajax(&#123;</div><div class="line">                    <span class="comment">//这里用PUT, 则为 `非简单` 请求</span></div><div class="line">                    type: <span class="string">'PUT'</span>,</div><div class="line">                    url: <span class="string">'http://test.test.com/index.php'</span>,</div><div class="line">                    dataType: <span class="string">'json'</span>,</div><div class="line">                    data: data,</div><div class="line">                    <span class="comment">//或者如果你自定义了一些请求时的 header 首部字段, 那么请求就也是 复杂请求</span></div><div class="line">                    headers: &#123;<span class="string">"custom-header-field"</span> : <span class="string">"test"</span>&#125;,</div><div class="line">                    success: <span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;</div><div class="line">                        console.log(result);</div><div class="line">                    &#125;,</div><div class="line">                    timeout: <span class="number">3000</span></div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form name=<span class="string">"form"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"sex"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"btn"</span> value=<span class="string">"button"</span> /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></li><li><p>test.test.com/index.php</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//服务器允许的 Origin</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.test.com"</span>);</div><div class="line"><span class="comment">//服务器允许的 methods</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Methods: PUT, GET, POST"</span>);</div><div class="line"><span class="comment">//服务器允许设置的头部字段</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Headers: custom-header-field"</span>);</div><div class="line"></div><div class="line">$arguments = file_get_contents(<span class="string">'php://input'</span>);</div><div class="line"><span class="keyword">echo</span> json_encode([<span class="string">'arguments'</span> =&gt; $arguments]);</div></pre></td></tr></table></figure></li><li><p>注意: 像上面例子的复杂跨域请求<br> 必须: 首先和简单请求一样, 服务器端的 <code>Access-Control-Allow-Origin</code> 是必须设置的, 不然首先就跨不了域;</p><p> 必须: 其次, 是使用了 <code>get</code>, <code>post</code>, <code>head</code> 之外方法的 <code>复杂请求</code>, 那么就必须在服务端有对应的 <code>Access-Control-Allow-Method</code>, 否则:<br> <img src="/img/cross-domain/not-simple-error01.png" width="597" height="133" alt="not-simple-error01" align="center"></p><p> 可选: 如果你自定义了 <code>自定义首部字段</code> 的 <code>复杂请求</code>, 那么也要在服务端有对应的 <code>Access-Control-Allow-Headers</code>, 否则:<br> <img src="/img/cross-domain/not-simple-error02.png" width="598" height="150" alt="not-simple-error02" align="center"></p></li><li><p>另外需要关注的是:<br> 如果你设置了自定义的首部字段, 那么即使你的请求类型是get, post, head, 自然也是复杂请求, 此时的HTTP请求方法显示的仍然如下:</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Request Method:OPTIONS</div></pre></td></tr></table></figure></li></ol><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><ol><li><p>上面<code>www.test.com/index.php</code>代码进行ajax请求的时候, HTTP请求的方法是<code>PUT</code>, 所以浏览器会发现, 这是一个非简单请求, 就自动发出一个”预检”请求, 要求服务器确认可以这样请求 ;</p></li><li><p>所以请求应该是包括<code>预检请求</code>和<code>真正的请求</code>两个请求的:<br><img src="/img/cross-domain/2times_request.png" width="600" height="360" alt="2times_request" align="center"></p></li><li><p>下面是这个”预检”请求的HTTP头信息 和 回应信息:<br><img src="/img/cross-domain/preflight01.png" width="700" height="500" alt="preflight01" align="center"></p></li><li><p>可以看到, “预检”请求用的请求方法是OPTIONS, 表示这个请求是用来询问的, 头信息里面, 关键字段是Origin, 表示请求来自哪个源;<br>除了Origin字段，”预检”请求的头信息包括两个特殊字段:<br>(1)<code>Access-Control-Request-Method</code><br>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT ;<br>(2)<code>Access-Control-Request-Headers</code><br>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段, 上例是X-Custom-Header ;</p></li></ol><h4 id="预检响应"><a href="#预检响应" class="headerlink" title="预检响应"></a>预检响应</h4><ol><li><p>从下面预检请求的截图中，可以看到预检请求的回应中, 服务器收到”预检”请求以后, 检查了 <code>Origin</code>、<code>Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code> 字段以后，确认允许跨源请求，就可以做出回应 ;<br> <img src="/img/cross-domain/preflight01.png" width="700" height="500" alt="preflight01" align="center"></p><p> 并且预检请求部分是不会真的发送数据的:<br> <img src="/img/cross-domain/preflight02.png" width="400" height="150" alt="preflight02" align="center"></p></li><li><p>上面的HTTP回应中，关键的是 <code>Access-Control-Allow-Origin</code> 字段，表示 <code>http://www.test.com</code> 可以请求数据, <strong>该字段也可以设为星号</strong>，表示同意任意跨源请求 ;</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http:<span class="comment">//www.test.com</span></div><div class="line">或者</div><div class="line">Access-Control-Allow-Origin: *</div></pre></td></tr></table></figure></li><li><p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段 ; 这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 <code>XMLHttpRequest</code> 对象的 <code>onerror</code> 回调函数捕获;<br> 控制台会打印出如下的报错信息 ;</p><p><img src="/img/cross-domain/no-simple-error01.png" width="650" height="150" alt="no-simple-error01" align="center"></p></li><li><p>服务器还可能回应的其他CORS相关字段如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Methods: GET, POST, PUT</div><div class="line">Access-Control-Allow-Headers: X-Custom-Header</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Max-Age: 1728000</div></pre></td></tr></table></figure><p> （1）Access-Control-Allow-Methods<br> 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。<br> （2）Access-Control-Allow-Headers<br> 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。<br> （3）Access-Control-Allow-Credentials<br> 该字段与简单请求时的含义相同。<br> （4）Access-Control-Max-Age<br> 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p></li><li><p>cookie方面, 其实和CORS简单请求是一样的要求<br> www.test.com/index.php</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">setcookie(<span class="string">'address'</span>, json_encode([<span class="string">'city'</span> =&gt; <span class="string">'yuncheng'</span>, <span class="string">'town'</span> =&gt; <span class="string">'xiaoliang'</span>]), <span class="number">0</span>, <span class="string">'/'</span>, <span class="string">'.test.com'</span>);</div><div class="line"><span class="meta">?&gt;</span></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;Title&lt;/title&gt;</div><div class="line">    &lt;script src=<span class="string">"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=<span class="string">"text/javascript"</span> &gt;</div><div class="line">        $(document).ready(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">            $.ajaxSetup(&#123;crossDomain: <span class="keyword">true</span>, xhrFields: &#123;withCredentials: <span class="keyword">true</span>&#125;&#125;);</div><div class="line">            $(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">//序列化name/value</span></div><div class="line">                <span class="keyword">var</span> data = $(<span class="string">"form"</span>).serializeArray();</div><div class="line">                $.ajax(&#123;</div><div class="line">                    <span class="comment">//这里用PUT, 则为 `非简单` 请求</span></div><div class="line">                    type: <span class="string">'PUT'</span>,</div><div class="line">                    url: <span class="string">'http://test.test.com/index.php'</span>,</div><div class="line">                    dataType: <span class="string">'json'</span>,</div><div class="line">                    data: data,</div><div class="line">                    <span class="comment">//或者如果你自定义了一些请求时的 header 首部字段, 那么请求就也是 复杂请求</span></div><div class="line">                    headers: &#123;<span class="string">"custom-header-field"</span> : <span class="string">"test"</span>&#125;,</div><div class="line">                    success: <span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;</div><div class="line">                        console.log(result);</div><div class="line">                    &#125;,</div><div class="line">                    timeout: <span class="number">3000</span></div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form name=<span class="string">"form"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"sex"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"btn"</span> value=<span class="string">"button"</span> /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></li></ol><pre><code>test.test.com<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//服务器允许的 Origin (如果要发送cookie的话复杂请求也不能为*)</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.test.com"</span>);</div><div class="line"><span class="comment">//服务器允许的 methods</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Methods: PUT, GET, POST"</span>);</div><div class="line"><span class="comment">//服务器允许设置的头部字段</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Headers: custom-header-field"</span>);</div><div class="line"><span class="comment">//要跨子域发cookie, 这个自然不能少</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Credentials: true"</span>);</div><div class="line"></div><div class="line">$arguments = file_get_contents(<span class="string">'php://input'</span>);</div><div class="line">$address = $_COOKIE[<span class="string">'address'</span>];</div><div class="line"><span class="keyword">echo</span> json_encode([<span class="string">'arguments'</span> =&gt; $arguments, <span class="string">'cookie'</span> =&gt; $address]);</div></pre></td></tr></table></figure></code></pre><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">参考 CORS</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;非简单请求&quot;&gt;&lt;a href=&quot;#非简单请求&quot; class=&quot;headerlink&quot; title=&quot;非简单请求&quot;&gt;&lt;/a&gt;非简单请求&lt;/h2&gt;&lt;h3 id=&quot;预检请求-preflight-说明&quot;&gt;&lt;a href=&quot;#预检请求-preflight-说明&quot; class
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>Ajax请求不能发送 -- CORS方案01 (simple request)</title>
    <link href="http://blog.renyimin.com/2015/05/19/sameoriginpolicy04-ajax-disabled-cors-simple/"/>
    <id>http://blog.renyimin.com/2015/05/19/sameoriginpolicy04-ajax-disabled-cors-simple/</id>
    <published>2015-05-19T04:45:07.000Z</published>
    <updated>2017-09-29T09:21:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CORS说明"><a href="#CORS说明" class="headerlink" title="CORS说明"></a>CORS说明</h2><ol><li><p>CORS是一个W3C标准, 全称是 “跨域资源共享 “(Cross-origin resource sharing), 通俗说就是我们所熟知的跨域请求 ;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">众所周知，在以前，跨域可以采用 `代理`、`JSONP` 等方式，而在Modern浏览器面前，这些终将成为过去式，因为有了CORS ;</div><div class="line">CORS在最初接触的时候只大概了解到，通过服务器端设置Access-Control-Allow-Origin响应头，即可使指定来源像访问同源接口一样访问跨域接口，但其实CORS的规范定义远不止这些 ;</div></pre></td></tr></table></figure></li><li><p>它允许 <code>浏览器</code> 向 <code>跨源服务器</code> 发出XMLHttpRequest请求, 从而克服了AJAX只能同源使用的限制 ;</p></li><li><p>CORS需要浏览器和服务器同时支持 (目前, 所有浏览器都支持该功能, IE浏览器不能低于IE10) ;</p></li><li><p>整个CORS通信过程都是浏览器自动完成, 不需要用户参与 ;<br> 对于开发者来说, CORS通信与同源的AJAX通信没有差别, 代码完全一样, 浏览器一旦发现AJAX的请求是跨源的, 就会自动添加一些附加的头信息, 有时还会多出一次附加的请求, 但用户不会有感觉;</p><p> <strong> 因此，其实实现CORS通信的关键是服务器, 只要服务器实现了CORS接口，就可以跨源通信 </strong></p></li></ol><h3 id="CORS的两类请求"><a href="#CORS的两类请求" class="headerlink" title="CORS的两类请求"></a>CORS的两类请求</h3><ol><li><p>浏览器将CORS请求分成两类: 简单请求(simple request) 和 非简单请求(not-so-simple request)</p></li><li><p>以下为<code>非简单请求</code>的情况 :</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">请求以 GET, HEAD 或者 POST 以外的方法发起请求 ;</div><div class="line"></div><div class="line">或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型, 比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求 ;</div><div class="line"></div><div class="line">使用自定义请求头（比如添加诸如 X-PINGOTHER）</div></pre></td></tr></table></figure></li></ol><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><h3 id="先看代码案例"><a href="#先看代码案例" class="headerlink" title="先看代码案例"></a>先看代码案例</h3><ol><li><p>客户端代码<br> www.test.com/index.html : </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">   &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">   &lt;title&gt;Title&lt;/title&gt;</div><div class="line">   &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">   &lt;script type=&quot;text/javascript&quot; &gt;</div><div class="line">       $(document).ready(function()&#123;</div><div class="line">           $(&quot;#btn&quot;).click(function(k) &#123;</div><div class="line">               var data = $(&quot;form&quot;).serializeArray();//序列化name/value</div><div class="line">               $.ajax(&#123;</div><div class="line">                   type: &apos;GET&apos;,  //这里用GET</div><div class="line">                   url: &apos;http://test.test.com/index.php&apos;,</div><div class="line">                   dataType: &apos;json&apos;,  //类型</div><div class="line">                   data: data,</div><div class="line">                   success: function (result) &#123;//返回的json数据</div><div class="line">                       console.log(result); //回调输出</div><div class="line">                   &#125;,</div><div class="line">                   timeout: 3000</div><div class="line">               &#125;);</div><div class="line">           &#125;);</div><div class="line">       &#125;);</div><div class="line">   &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form name=&quot;form&quot;&gt;</div><div class="line">   &lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt;</div><div class="line">   &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;</div><div class="line">   &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></li><li><p>服务端代码<br>test.test.com/index.php : </p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.test.com"</span>);</div><div class="line"><span class="keyword">echo</span> json_encode([<span class="string">'name'</span> =&gt; <span class="string">'lant'</span>, <span class="string">'age'</span> =&gt; <span class="number">100</span>]);</div></pre></td></tr></table></figure></li></ol><h3 id="基本流程分析"><a href="#基本流程分析" class="headerlink" title="基本流程分析"></a>基本流程分析</h3><h4 id="浏览器直接发出CORS请求"><a href="#浏览器直接发出CORS请求" class="headerlink" title="浏览器直接发出CORS请求"></a>浏览器直接发出CORS请求</h4><p>对于简单请求，浏览器直接发出CORS请求, 具体来说, 就是在头信息之中, 自动增加一个Origin字段 ;</p><h4 id="浏览器识别出跨域AJAX简单请求"><a href="#浏览器识别出跨域AJAX简单请求" class="headerlink" title="浏览器识别出跨域AJAX简单请求"></a>浏览器识别出跨域AJAX简单请求</h4><p>浏览器发现这次跨源AJAX请求是简单请求, 就自动在头信息之中, 添加一个Origin字段:<br><img src="/img/cross-domain/ajax-simple-cors.png" width="670" height="420" alt="ajax-simple-cors" align="center"></p><p><strong>上面的头信息中, <code>Origin字段</code> 用来说明本次请求来自哪个源(协议 + 域名 + 端口), 服务器根据这个值, 决定是否同意这次请求 </strong>;</p><h4 id="浏览器添加的Origin源不在服务器设置的许可范围"><a href="#浏览器添加的Origin源不在服务器设置的许可范围" class="headerlink" title="浏览器添加的Origin源不在服务器设置的许可范围"></a>浏览器添加的Origin源不在服务器设置的许可范围</h4><p>如果Origin源, 不在许可范围内, 服务器让然会返回一个正常的HTTP回应, 不过浏览器会发现, 这个回应的头信息并没有包含 <code>Access-Control-Allow-Origin</code> 字段(详见下文), 就知道出错了, 从而抛出一个错误, 被XMLHttpRequest的onerror回调函数捕获; <strong>注意, 这种错误无法通过状态码识别, 因为HTTP回应的状态码有可能是200</strong> ;<br><img src="/img/cross-domain/ajax-simple-cors02.png" width="590" height="260" alt="ajax-simple-cors02" align="center"></p><h4 id="浏览器添加的Origin源在服务器设置的许可范围内"><a href="#浏览器添加的Origin源在服务器设置的许可范围内" class="headerlink" title="浏览器添加的Origin源在服务器设置的许可范围内"></a>浏览器添加的Origin源在服务器设置的许可范围内</h4><ol><li><p>当然, 如果 <code>Origin源在服务器设置的许可范围内</code> , 服务器返回的响应, 就会多出如下个头信息字段(当然也不一定是所有都包含, <strong>具体还得看服务器如何进行设置</strong>) :</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://api.bob.com</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Expose-Headers: FooBar</div><div class="line">Content-Type: text/html; charset=utf-8</div></pre></td></tr></table></figure></li><li><p><strong>重点分析</strong>:<br>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头:<br>(1) <code>Access-Control-Allow-Origin</code><br>服务器要设置ajax请求可以跨域, 该字段是必须的, 它的值要么是请求时Origin字段的值，要么是一个<em>，表示接受任意域名的请求;<br>(2) <code>Access-Control-Allow-Credentials</code><br>该字段可选, 它的值是一个布尔值，表示是否允许发送Cookie, <em>*默认情况下，Cookie不包括在CORS请求之中</em></em>, 设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器;<br>注意, 这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。<br>(3) <code>Access-Control-Expose-Headers</code><br>该字段可选, CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p></li></ol><h4 id="服务器端的具体设置"><a href="#服务器端的具体设置" class="headerlink" title="服务器端的具体设置"></a>服务器端的具体设置</h4><ol><li>服务器在设置的时候, 其实就是通过header函数设置上面的三个选项!</li><li><p>比如之前的例子中, 如果服务器只是简单的为了实现跨域, 直接设置如下选项即可:</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.test1.com"</span>);</div><div class="line"><span class="keyword">echo</span> json_encode([<span class="string">'name'</span> =&gt; <span class="string">'lant'</span>, <span class="string">'age'</span> =&gt; <span class="number">100</span>]);</div></pre></td></tr></table></figure></li></ol><h3 id="withCredentials-属性"><a href="#withCredentials-属性" class="headerlink" title="withCredentials 属性"></a>withCredentials 属性</h3><h4 id="CORS请求默认不发送Cookie和HTTP认证信息-Jsonp是会发送cookie信息的"><a href="#CORS请求默认不发送Cookie和HTTP认证信息-Jsonp是会发送cookie信息的" class="headerlink" title="CORS请求默认不发送Cookie和HTTP认证信息 (Jsonp是会发送cookie信息的)"></a>CORS请求默认不发送<code>Cookie</code>和<code>HTTP认证信息</code> (Jsonp是会发送cookie信息的)</h4><ol><li><p>之前在介绍<code>Access-Control-Allow-Credentials</code>选项的时候提到, CORS请求默认不发送Cookie和HTTP认证信息; 如果要把Cookie发到服务器:</p><p> 一方面要 <strong>服务器同意指定Access-Control-Allow-Credentials字段</strong> :</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Credentials: <span class="keyword">true</span></div><div class="line"><span class="comment">//php中设置如下:</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Credentials: true"</span>);</div></pre></td></tr></table></figure><p> 另一方面, 开发者必须在AJAX请求中打开 <code>withCredentials</code> 属性:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.withCredentials = true;</div><div class="line">//jquery中设置withCredentials的代码如下:</div><div class="line">$.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;);</div></pre></td></tr></table></figure></li><li><p>需要以上两方面都做到才可以</p><p> 否则，即使服务器同意发送Cookie，浏览器也不会发送, 或者，服务器要求设置Cookie，浏览器也不会处理 ;</p><p> 但是, 如果省略 <code>withCredentials</code> 设置, 有的浏览器还是会一起发送Cookie, 这时, 可以显式关闭 <code>withCredentials</code> ;</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.withCredentials = <span class="keyword">false</span>;</div></pre></td></tr></table></figure></li><li><p><strong>需要注意的是</strong>:<br> <strong>如果要发送Cookie, <code>Access-Control-Allow-Origin</code> 就不能设为星号<code>*</code>, 必须指定明确的、与请求网页一致的域名</strong> ; </p><p> <strong>同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传, 其他域名的Cookie并不会上传, 且(跨源)原网页代码中的document.cookie也无法读取服务器域名下的Cookie ;</strong></p></li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>域1中的代码(www.test.com/index.php)：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传, 其他域名的Cookie并不会上传, 且(跨源)原网页代码中的document.cookie也无法读取服务器域名下的Cookie</span></div><div class="line">setcookie(<span class="string">'address'</span>, json_encode([<span class="string">'city'</span> =&gt; <span class="string">'yuncheng'</span>, <span class="string">'town'</span> =&gt; <span class="string">'xiaoliang'</span>]), <span class="number">0</span>, <span class="string">'/'</span>, <span class="string">'.test.com'</span>);</div><div class="line"><span class="meta">?&gt;</span></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;Title&lt;/title&gt;</div><div class="line">    &lt;script src=<span class="string">"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=<span class="string">"text/javascript"</span> &gt;</div><div class="line">        $(document).ready(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">            $.ajaxSetup(&#123;crossDomain: <span class="keyword">true</span>, xhrFields: &#123;withCredentials: <span class="keyword">true</span>&#125;&#125;);</div><div class="line"></div><div class="line">            $(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">(k)</span> </span>&#123;</div><div class="line">                <span class="keyword">var</span> data = $(<span class="string">"form"</span>).serializeArray();<span class="comment">//序列化name/value</span></div><div class="line">                $.ajax(&#123;</div><div class="line">                    type: <span class="string">'GET'</span>,  <span class="comment">//这里用GET</span></div><div class="line">                    url: <span class="string">'http://test.test.com/index.php'</span>,</div><div class="line">                    dataType: <span class="string">'json'</span>,  <span class="comment">//类型</span></div><div class="line">                    data: data,</div><div class="line">                    success: <span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;<span class="comment">//返回的json数据</span></div><div class="line">                        console.log(result); <span class="comment">//回调输出</span></div><div class="line">                    &#125;,</div><div class="line">                    timeout: <span class="number">3000</span></div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form name=<span class="string">"form"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"sex"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"btn"</span> value=<span class="string">"button"</span> /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p><p>域2中的代码(test.test.comindex.php):<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.test.com"</span>);</div><div class="line">header(<span class="string">"Access-Control-Allow-Credentials: true"</span>);</div><div class="line">$address = $_COOKIE[<span class="string">'address'</span>];</div><div class="line"><span class="keyword">echo</span> json_encode([<span class="string">'name'</span> =&gt; <span class="string">'lant'</span>, <span class="string">'age'</span> =&gt; <span class="number">100</span>, <span class="string">'address'</span> =&gt; $address]);</div></pre></td></tr></table></figure></p><p>效果:<br><img src="/img/cross-domain/cors-cookie.png" width="590" height="260" alt="cors-cookie" align="center"></p><h4 id="两个注意"><a href="#两个注意" class="headerlink" title="两个注意"></a>两个注意</h4><ol><li><p>如果域1中在html中设置了 <code>withCredentials</code> 为 true :</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;);</div></pre></td></tr></table></figure><p> 那么在对应的ajax请求的域2中必须设置</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">header(<span class="string">"Access-Control-Allow-Credentials: true"</span>);</div></pre></td></tr></table></figure><p> 否则, 报错如下:<br> <img src="/img/cross-domain/haha-server-withCredentials.png" width="500" height="160" alt="haha-server-withCredentials" align="center"></p></li><li><p>如果两边都不设置 <code>withCredentials</code> 属性的话, 也就是默认请求不带cookie, 那么即使请求方域1中设置了domain属性为 <code>.test.com</code> 的cookie值, 服务方(test.test.com)中也获取不到cookie, 因为域1默认请求就没有带cookie ;</p></li></ol><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">参考 CORS</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CORS说明&quot;&gt;&lt;a href=&quot;#CORS说明&quot; class=&quot;headerlink&quot; title=&quot;CORS说明&quot;&gt;&lt;/a&gt;CORS说明&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;CORS是一个W3C标准, 全称是 “跨域资源共享 “(Cross-origin reso
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>Ajax请求不能发送 -- JSONP方案</title>
    <link href="http://blog.renyimin.com/2015/05/18/sameoriginpolicy03-ajax-disabled-jsonp/"/>
    <id>http://blog.renyimin.com/2015/05/18/sameoriginpolicy03-ajax-disabled-jsonp/</id>
    <published>2015-05-18T11:27:31.000Z</published>
    <updated>2017-09-29T09:21:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><h3 id="说明及注意"><a href="#说明及注意" class="headerlink" title="说明及注意"></a>说明及注意</h3><ol><li><p>JSONP是服务器与客户端 <strong>跨源通信</strong> 的常用方法, 最大特点就是简单适用, 老式浏览器全部支持, 服务器端改造非常小 ;</p></li><li><p>但是，<strong>JSONP只能发GET请求</strong> ;</p></li><li><p><strong>注意:</strong> JSONP跨子域发送Cookie的话, 只用设置好<code>cookie的domain属性</code>为顶级域名即可 ;</p></li></ol><p>ajax使用jsonp跨域的时候是可以轻松像上面这样带上cookie给所跨的域的 ;</p><p>而下一篇介绍的ajax使用cors方案跨域的话, 除了设置了cookie的 <code>document.domain</code> 为两个地址的顶级域名, 却也不能带上cookie, 还需要注意 前端和服务端的 <code>withCredentials</code> 头字段 ;</p><h3 id="jsonp跨域请求案例"><a href="#jsonp跨域请求案例" class="headerlink" title="jsonp跨域请求案例"></a>jsonp跨域请求案例</h3><p>www.test.com/index.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Title&lt;/title&gt;</div><div class="line">    &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot; &gt;</div><div class="line">        $(document).ready(function()&#123;</div><div class="line">            //注意, 此时jsonp是会带上cookie的</div><div class="line">            //当然不设置domain的话, test.test.com自然获取不到cookie</div><div class="line">            document.cookie = &quot;name=value; domain=test.com&quot;;</div><div class="line">            $(&quot;#btn&quot;).click(function() &#123;</div><div class="line">                var data = $(&quot;form&quot;).serializeArray();//序列化name/value</div><div class="line">                $.ajax(&#123;</div><div class="line">                    type: &apos;GET&apos;,  //这里用GET</div><div class="line">                    url: &apos;http://test.test.com/index.php&apos;,</div><div class="line">                    dataType: &apos;jsonp&apos;,  //类型</div><div class="line">                    data: data,</div><div class="line">                    jsonp: &apos;callback&apos;, //jsonp回调参数，必需</div><div class="line">                    async: false,</div><div class="line">                    success: function (result) &#123;//返回的json数据</div><div class="line">                        console.log(result); //回调输出</div><div class="line">                    &#125;,</div><div class="line">                    timeout: 3000</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form name=&quot;form&quot;&gt;</div><div class="line">    &lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt;</div><div class="line">    &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;</div><div class="line">    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p><p>test.test.com/index.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//jsonp回调参数，必需</span></div><div class="line">$callback = <span class="keyword">isset</span>($_GET[<span class="string">'callback'</span>]) ? trim($_GET[<span class="string">'callback'</span>]) : <span class="string">''</span>;</div><div class="line"></div><div class="line">$sex = <span class="keyword">isset</span>($_GET[<span class="string">'sex'</span>]) ? trim($_GET[<span class="string">'sex'</span>]) : <span class="string">''</span>;</div><div class="line">$age = <span class="keyword">isset</span>($_GET[<span class="string">'age'</span>]) ? trim($_GET[<span class="string">'age'</span>]) : <span class="string">''</span>;</div><div class="line"></div><div class="line">$data = [<span class="string">"sex"</span> =&gt; $sex, <span class="string">"age"</span> =&gt; $age];</div><div class="line">$res = json_encode($data); <span class="comment">//json 数据</span></div><div class="line"><span class="comment">// 不能用return</span></div><div class="line"><span class="keyword">echo</span> $callback . <span class="string">'('</span> . $res . <span class="string">')'</span>;  <span class="comment">//返回格式，必需</span></div></pre></td></tr></table></figure></p><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JSONP&quot;&gt;&lt;a href=&quot;#JSONP&quot; class=&quot;headerlink&quot; title=&quot;JSONP&quot;&gt;&lt;/a&gt;JSONP&lt;/h2&gt;&lt;h3 id=&quot;说明及注意&quot;&gt;&lt;a href=&quot;#说明及注意&quot; class=&quot;headerlink&quot; title=&quot;说明及
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>同源策略的限制 -- Ajax请求不能发送</title>
    <link href="http://blog.renyimin.com/2015/05/17/sameoriginpolicy02-ajax-disabled/"/>
    <id>http://blog.renyimin.com/2015/05/17/sameoriginpolicy02-ajax-disabled/</id>
    <published>2015-05-17T14:30:19.000Z</published>
    <updated>2017-09-29T09:21:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同源策略的限制-Ajax请求不能发送"><a href="#同源策略的限制-Ajax请求不能发送" class="headerlink" title="同源策略的限制 - Ajax请求不能发送"></a>同源策略的限制 - Ajax请求不能发送</h2><ol><li><p>同源政策规定, AJAX请求只能发给同源的网址, 否则就报错 ;</p></li><li><p>除了架设服务器代理(浏览器请求同源服务器，再由后者请求外部服务), 有三种方法规避这个限制 :<br> <strong><a href="http://blog.renyimin.com">JSONP</a></strong></p><p> <strong><a href="http://blog.renyimin.com">CORS</a></strong></p><p> <strong><a href="http://blog.renyimin.com">WebSocket</a></strong></p></li></ol><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">参考</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同源策略的限制-Ajax请求不能发送&quot;&gt;&lt;a href=&quot;#同源策略的限制-Ajax请求不能发送&quot; class=&quot;headerlink&quot; title=&quot;同源策略的限制 - Ajax请求不能发送&quot;&gt;&lt;/a&gt;同源策略的限制 - Ajax请求不能发送&lt;/h2&gt;&lt;ol&gt;

      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>同源策略的限制 -- Cookie无法读取</title>
    <link href="http://blog.renyimin.com/2015/05/16/sameoriginpolicy01-cookie-disabled/"/>
    <id>http://blog.renyimin.com/2015/05/16/sameoriginpolicy01-cookie-disabled/</id>
    <published>2015-05-16T05:18:13.000Z</published>
    <updated>2017-09-29T10:15:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>之前学习同源策略基础知识的时候, 了解了同源策略的 <code>三种行为</code> 限制:</p><ol><li><code>Cookie</code>、<code>LocalStorage</code> 和 <code>IndexDB</code> 无法读取</li><li><code>DOM</code> 无法获得 </li><li><code>AJAX</code> 请求不能发送 </li></ol><p>(注意: 这里并不会导致诸如<code>超链接</code>之类的请求被限制, 也就是b网站中的超链接访问a网站是不会被同源策略限制的, 这才会有CSRF攻击 ;)</p><p>本节主要讨论 <code>Cookie无法读取</code> 的相关知识 ;</p><h2 id="Cookie无法读取的例子"><a href="#Cookie无法读取的例子" class="headerlink" title="Cookie无法读取的例子"></a>Cookie无法读取的例子</h2><ol><li><p>要知道, Cookie 是服务器写入浏览器的一小段信息, 只有同源的网页才能共享 ;</p></li><li><p><strong>注意:</strong> 本篇介绍的主要是直接访问不相同的域名(<code>超链接模拟跨域</code> 或者 <code>直接打开另一个网页模拟跨域</code> ) 导致的Cookie无法读取的问题, 不会涉及到 <code>Ajax请求所涉及的cookie传递问题</code>, 这个问题属于同源策略的第三种限制 <code>AJAX请求不能发送</code> ;</p></li><li><p>例子 :<br> A网页是 <code>http://www.test.com/index.html</code>，B网页是 <code>http://test.test.com/index.html</code> :<br> A: www.test.com/index.html (此处是使用js来设置cookie进行测试; 当然, 用服务端代码php测试也是OK的)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Title&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script type=&quot;application/javascript&quot;&gt;</div><div class="line">    document.cookie=&quot;name=value;&quot;;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p> <img src="/img/cross-domain/cookie-disabled-01.png" width="650" height="272" alt="cookie-disabled-01" align="center"></p><p> B: test.test.com/index.html</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script type=&quot;application/javascript&quot;&gt;</div><div class="line">    console.log(document.cookie);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p> // 可以看到, <code>同顶级域名</code> 的域名也获取不到不同二级域名的域锁设置的cookie<br> <img src="/img/cross-domain/cookie-disabled-02.png" width="650" height="272" alt="cookie-disabled-02" align="center"></p><p> //同理, 直接在<code>http://www.test.com/index.html</code>中超链接点击到<code>http://test.test.com/index.html</code>也是获取不到cookie的 ;</p></li></ol><h2 id="合理规避Cookie无法读取的限制"><a href="#合理规避Cookie无法读取的限制" class="headerlink" title="合理规避Cookie无法读取的限制"></a><code>合理</code>规避Cookie无法读取的限制</h2><ol><li>还是那句话, 虽然同源导致的这些限制是必要, 但是有些情况下, 其实我们是需要 <code>合理</code> 规避Cookie无法读取的限制的 ;</li><li>比如: 如果两个网页的顶级域名相同, 只是二级域名不同的话, 浏览器其实是允许你通过设置 <code>document.domain</code> 来共享 Cookie ;</li><li><p>例子:<br> A网页是 <code>http://www.test.com/index.html</code>，B网页是 <code>http://test.test.com/index.html</code>, 那么只要设置相同的 <code>document.domain</code>，两个网页就可以共享Cookie :<br> A: www.test.com/index.html (此处是使用js来设置cookie进行测试; 当然, 用php代码也是OK的)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Title&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script type=&quot;application/javascript&quot;&gt;</div><div class="line">    document.cookie=&quot;name=value; domain=test.com&quot;;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p> <img src="/img/cross-domain/cookie-share.png" width="559" height="272" alt="cookie-share" align="center"></p><p> B: test.test.com/index.html</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script type=&quot;application/javascript&quot;&gt;</div><div class="line">    console.log(document.cookie);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p> <img src="/img/cross-domain/cookie-share02.png" width="300" height="275" alt="cookie-share" align="center"></p></li><li><p>注意, 这种方法只适用于 <code>Cookie</code> 和 <code>iframe 窗口</code>, LocalStorage 和 IndexDB 无法通过这种方法来规避同源政策，而要使用之后会介绍的PostMessage API ;</p></li></ol><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">摘自 阮一峰</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;p&gt;之前学习同源策略基础知识的时候, 了解了同源策略的 &lt;code&gt;三种行为&lt;/code&gt; 限制:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Coo
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的同源策略(Same origin policy)</title>
    <link href="http://blog.renyimin.com/2015/05/15/sameoriginpolicy/"/>
    <id>http://blog.renyimin.com/2015/05/15/sameoriginpolicy/</id>
    <published>2015-05-15T11:58:54.000Z</published>
    <updated>2017-09-29T09:21:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a><code>同源策略</code></h2><p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策；</p><p>最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”，所谓 “同源” 指的是 <strong>“三个相同”</strong> ：<br><strong>1.协议相同</strong><br><code>http://blog.renyimin.com</code> 和 <code>https://blog.renyimin.com</code> 就不是同一个源 ；</p><p><strong>2.域名相同</strong><br><code>http://blog.renyimin.com/test/index.php</code> 和 <code>http://blog.renyimin.com/welcome/index.html</code> 就是同一个源; 但是 <code>http://www.renyimin.com/test/index.php</code> 和 <code>http://blog.renyimin.com/test/index.php</code> 就不是同一个源 ；<br>请注意：localhost和127.0.0.1虽然都指向本机, 但也不是同一个源 ;</p><p><strong>3.端口相同</strong><br><code>http://www.renyimin.com:8080/test/index.php</code> 和 <code>http://www.renyimin.com:80/test/index.php</code> 就不是同一个源 ;</p><p>再举例来说，<code>http://www.example.com/dir/page.html</code> 这个网址，协议是 <code>http://</code>，域名是 <code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略），它的同源情况如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">http:<span class="comment">//www.example.com/dir2/other.html：同源</span></div><div class="line">http:<span class="comment">//example.com/dir/other.html：不同源（域名不同）</span></div><div class="line">http:<span class="comment">//v2.www.example.com/dir/other.html：不同源（域名不同）</span></div><div class="line">http:<span class="comment">//www.example.com:81/dir/other.html：不同源（端口不同）</span></div></pre></td></tr></table></figure></p><h2 id="同源策略目的"><a href="#同源策略目的" class="headerlink" title="同源策略目的"></a>同源策略目的</h2><p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据;</p><p>设想这样一种情况: A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？<br>很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏;</p><p>更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以内置一些A网站的访问路径, 因为这样就可以拿到A网站之前存在用户本地的cookie, 这样就可以冒充用户，为所欲为，因为浏览器同时还规定，提交表单不受同源政策的限制 ;</p><p><strong>由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了 ;</strong></p><h2 id="同源策略的限制范围"><a href="#同源策略的限制范围" class="headerlink" title="同源策略的限制范围"></a>同源策略的限制范围</h2><p>随着互联网的发展, “同源政策”越来越严格, 目前, 如果非同源, 共有三种行为受到限制 :</p><h3 id="Cookie、LocalStorage-和-IndexDB-无法读取"><a href="#Cookie、LocalStorage-和-IndexDB-无法读取" class="headerlink" title="Cookie、LocalStorage 和 IndexDB 无法读取"></a><code>Cookie</code>、<code>LocalStorage</code> 和 <code>IndexDB</code> 无法读取</h3><h3 id="DOM-无法获得"><a href="#DOM-无法获得" class="headerlink" title="DOM 无法获得"></a><code>DOM</code> 无法获得</h3><h3 id="AJAX-请求不能发送"><a href="#AJAX-请求不能发送" class="headerlink" title="AJAX 请求不能发送"></a><code>AJAX</code> 请求不能发送</h3><p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响, 将详细介绍，如何合理规避上面三种限制 ;</p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">参考 阮一峰</a><br>增加了很多例子和额外思考!</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;&lt;code&gt;同源策略&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策；&lt;/p&gt;
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>CSRF (Cross-site request forgery)</title>
    <link href="http://blog.renyimin.com/2015/05/05/safe-csrf01/"/>
    <id>http://blog.renyimin.com/2015/05/05/safe-csrf01/</id>
    <published>2015-05-05T02:20:16.000Z</published>
    <updated>2017-10-16T06:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们知道浏览器的同源策略对用户请求的资源是有一些行为限制的:</p><ol><li><code>Cookie</code>、<code>LocalStorage</code> 和 <code>IndexDB</code> 无法读取</li><li><code>DOM</code> 无法获得 </li><li><code>AJAX</code> 请求不能发送</li></ol><p>但也有一些就是不在同源策略的限制范围之内;</p><h2 id="CSRF-跨站点请求伪造"><a href="#CSRF-跨站点请求伪造" class="headerlink" title="CSRF 跨站点请求伪造"></a>CSRF 跨站点请求伪造</h2><p>CSRF跨站点请求伪造(Cross—Site Request Forgery)跟XSS攻击一样, 存在巨大的危害性, 你可以这样来理解:</p><p>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的;<br>但是却完成了攻击者所期望的一个操作, 比如以你的名义发送邮件、发消息, 盗取你的账号, 添加系统管理员, 甚至于购买商品、虚拟货币转账等;<br>如:</p><pre><code><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Web A为存在CSRF漏洞的网站;</div><div class="line">Web B为攻击者构建的恶意网站;</div><div class="line">User C为Web A网站的合法用户;</div></pre></td></tr></table></figure></code></pre><p>CSRF攻击攻击原理及过程如下:</p><pre><code><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</div><div class="line">在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功, 可以正常发送请求到网站A;</div><div class="line">用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B;</div><div class="line">网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A;</div><div class="line">浏览器在接收到这些攻击性代码后,根据网站B的请求,在用户不知情的情况下携带Cookie信息,向网站A发出请求;</div><div class="line">网站A并不知道该请求其实是由B发起的,所以会根据用户C的Cookie信息以C的权限处理该请求,导致来自网站B的恶意代码被执行。</div></pre></td></tr></table></figure></code></pre><h2 id="CSRF攻击实例"><a href="#CSRF攻击实例" class="headerlink" title="CSRF攻击实例"></a>CSRF攻击实例</h2><p>受害者 <code>maomao</code> 在银行有一笔存款，通过对银行的网站发送请求 <code>http://bank.example/withdraw?account=maomao&amp;amount=1000000&amp;for=gougou</code> 可以使 <code>maomao</code> 把自己的 1000000 的存款转到 <code>gougou</code> 的账号下;</p><p>通常情况下, 该请求发送到网站后, 服务器会先验证该请求是否来自一个合法的 session, 并且该 session 的用户 <code>maomao</code> 已经成功登陆 ;</p><p>黑客 <code>feiying</code> 自己在该银行也有账户, 他知道银行网站中的上述 URL 可以对钱进行转帐操作, 于是 <code>feiying</code> 自己发送一个请求给银行: <code>http://bank.example/withdraw?account=maomao&amp;amount=1000000&amp;for=feiying</code>, 但是这个请求来自 <code>feiying</code> 而非 <code>maomao</code>, 他不能通过安全认证，因此该请求不会起作用 ;</p><p>但是此时，<code>feiying</code> 想到使用 CSRF 的攻击方式, 他先自己做一个网站, 在网站中放入如下代码: <code>src=&quot;http://bank.example/withdraw?account=maomao&amp;amount=1000000&amp;for=feiying&quot;</code>，并且通过广告等诱使 <code>maomao</code> 来访问他的网站, 当 <code>maomao</code> 访问该网站时, 上述 url 就会从 <code>maomao</code> 的浏览器发向银行, 而这个请求会附带 <code>maomao</code> 浏览器中的 cookie 一起发向银行服务器, 大多数情况下，该请求会失败，<strong>因为他要求 maomao 的认证信息</strong>, 但是，如果 maomao 当时恰巧刚访问他的银行后不久, 他的浏览器与银行网站之间的 session 尚未过期, 浏览器的 cookie 之中含有 maomao 的认证信息;</p><p>这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 <code>maomao</code> 的账号转移到 <code>feiying</code> 的账号, 而 <code>maomao</code> 当时毫不知情, 等以后 <code>maomao</code> 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 <code>feiying</code> 则可以拿到钱后逍遥法外;</p><h2 id="CSRF漏洞检测"><a href="#CSRF漏洞检测" class="headerlink" title="CSRF漏洞检测"></a>CSRF漏洞检测</h2><p>检测CSRF漏洞是一项比较繁琐的工作, 最简单的方法就是抓取一个正常请求的数据包, 去掉Referer字段后再重新提交, 如果该提交还有效, 那么基本上可以确定存在CSRF漏洞 ;</p><p>随着对CSRF漏洞研究的不断深入, 不断涌现出一些专门针对CSRF漏洞进行检测的工具, 如<code>CSRFTester</code>, <code>CSRF Request Builder</code>等 ;</p><p>以<code>CSRFTester</code>工具为例，CSRF漏洞检测工具的测试原理如下:<br>使用CSRFTester进行测试时, 首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息, 然后通过在CSRFTester中修改相应的表单等信息, 重新提交, 这相当于一次伪造客户端请求;<br>如果修改后的测试请求成功被网站服务器接受, 则说明存在CSRF漏洞, 当然此款工具也可以被用来进行CSRF攻击;</p><h2 id="防御CSRF攻击"><a href="#防御CSRF攻击" class="headerlink" title="防御CSRF攻击"></a>防御CSRF攻击</h2><p>目前防御 CSRF 攻击主要有三种策略</p><h3 id="验证-HTTP-Referer-字段"><a href="#验证-HTTP-Referer-字段" class="headerlink" title="验证 HTTP Referer 字段"></a>验证 HTTP Referer 字段</h3><p>根据 HTTP 协议, 在 HTTP 头中有一个字段叫 Referer, 它记录了该 HTTP 请求的来源地址;</p><p>在通常情况下, 访问一个安全受限页面的请求来自于同一个网站, 比如需要访问 <a href="http://bank.example/withdraw?account=maomao&amp;amount=1000000&amp;for=gougou" target="_blank" rel="external">http://bank.example/withdraw?account=maomao&amp;amount=1000000&amp;for=gougou</a>, 用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件, 这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL, 通常是以 bank.example 域名开头的地址; </p><p>而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的, 如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求;</p><p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷;</p><p>然而，<strong>这种方法并非万无一失</strong>, Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞, 使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全, 事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值, 如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击 ;<br>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题, 因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中, 因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer, 当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问;</p><h3 id="在请求地址中添加-token-并验证"><a href="#在请求地址中添加-token-并验证" class="headerlink" title="在请求地址中添加 token 并验证"></a>在请求地址中添加 token 并验证</h3><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证;</p><p>要抵御 CSRF, 关键在于<strong>在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中</strong>, 可以在 HTTP 请求中以参数的形式加入一个随机产生的 token, 并在服务器端建立一个拦截器来验证这个 token, 如果请求中没有 token 或者 token 内容不正确, 则认为可能是 CSRF 攻击而拒绝该请求;</p><p>这种方法要比检查 Referer 要安全一些, token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求, 对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url?csrftoken=tokenvalue" target="_blank" rel="external">http://url?csrftoken=tokenvalue</a>, 而对于 POST 请求来说，要在 form 的最后加上 <code>&lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;tokenvalue&quot;/&gt;</code>, 这样就把 token 以参数的形式加入请求了, 但是, 在一个网站中, 可以接受请求的地方非常多, 要对于每一个请求都加上 token 是很麻烦的, 并且很容易漏掉, 通常使用的方法就是在每次页面加载时, 使用 javascript 遍历整个 dom 树, 对于 dom 中所有的 a 和 form 标签后加入 token, 这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token ;</p><p>该方法还有一个缺点是难以保证 token 本身的安全, 特别是在一些论坛之类支持用户自己发表内容的网站, 黑客可以在上面发布自己个人网站的地址, 由于系统也会在这个地址后面加上 token, 黑客可以在自己的网站上得到这个 token, 并马上就可以发动 CSRF 攻击, 为了避免这一点, 系统可以在添加 token 的时候增加一个判断, 如果这个链接是链到自己本站的, 就在后面添加 token, 如果是通向外网则不加;<br><strong>不过，即使这个 csrftoken 不以参数的形式附加在请求之中, 黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击, 这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因 ;</strong></p><h3 id="在-HTTP-头中自定义属性并验证"><a href="#在-HTTP-头中自定义属性并验证" class="headerlink" title="在 HTTP 头中自定义属性并验证"></a>在 HTTP 头中自定义属性并验证</h3><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里;<br>通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中, 这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去;</p><p>然而这种方法的局限性非常大, XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便;<br>另外, 对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的;</p><p><a href="http://blog.csdn.net/stpeace/article/details/53512283" target="_blank" rel="external">原文</a><br><a href="http://blog.csdn.net/qdx411324962/article/details/50235253" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们知道浏览器的同源策略对用户请求的资源是有一些行为限制的:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Cookie&lt;/code&gt;、&lt;code&gt;
      
    
    </summary>
    
      <category term="Safe" scheme="http://blog.renyimin.com/categories/Safe/"/>
    
    
      <category term="Safe" scheme="http://blog.renyimin.com/tags/Safe/"/>
    
  </entry>
  
</feed>
