<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2018-05-24T02:01:42.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux文本处理 - awk</title>
    <link href="http://blog.renyimin.com/2018/05/18/linux/2018-05-18-awk/"/>
    <id>http://blog.renyimin.com/2018/05/18/linux/2018-05-18-awk/</id>
    <published>2018-05-18T02:03:51.000Z</published>
    <updated>2018-05-24T02:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>Awk是一种便于使用且表达能力强的程序设计语言, 没错, 它是一门编程语言, 它拥有数组, 支持<code>if-else</code>控制语句, <code>for/while</code>循环语句, 内置函数等功能; 同时, <strong>它是一个强大的文本分析工具</strong>; </p></li><li><p>之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的Family Name的首字符;</p></li><li><p>awk 命令的执行过程</p><ul><li>awk是逐行处理的, 就是说, 当awk处理一个文本时, 会一行一行进行处理, 处理完当前行, 再处理下一行, awk默认以 “换行符” 为标记来识别每一行, 跟我们人类一样, 每次遇到”回车换行”, 就认为是当前行的结束, 新的一行的开始;</li><li>awk在逐行处理文本时, 会搜索能够匹配程序中任意模式(也就是在awk命令中的’program’中可以有多个模式)的行, 每个模式依次测试每个输入行, 对于匹配到模式的行, 会执行awk命令中模式后面的动作(也许包含多步), 然后读取下一行并继续匹配, 直到所有的输入读取完毕;</li><li>同时, awk会按照用户指定的分割符去分割当前行为多个字段(每个字段分别被标识为 <code>$1</code> 一直到 <code>$NF</code>, <code>$NF</code>为awk中的变量, 表示当前行被分隔出的最大字段数), 如果没有指定分割符, 默认使用空格作为分隔符, 另外, 默认会将空格符和制表符都视为空格, 而且多个连续的空格都视为一个;</li></ul></li><li><p>作为一个PHP开发人员, 在工作中, 不一定要求会写比较复杂的awk语句, 但可能经常会接触到开发, 沙盒, 预发, 线上等各种环境, 此时可以使用awk对一些日志文本做一些分析很方便的分析工作;</p></li></ol><h2 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h2><ol><li><p>基本语法结构为: <code>awk [options] &#39;program&#39; file1 , file2 ...</code>, 其中, <code>&#39;program&#39;</code> 又可以细分为 <code>pattern</code>模式 和 <code>action</code>动作; 也就是说, awk的完整语法其实为 <code>awk [options] &#39;pattern {action}&#39; file1 , file2 ...</code></p></li><li><p><code>pattern</code> : 指的是模式, 用来匹配awk命令所处理的文本中的每一行内容;</p><ul><li><p><strong>注意模式匹配字符串时, 需要使用双引号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ cat awk.log</div><div class="line">renyimin   200 1200W 男</div><div class="line"></div><div class="line">renfumin 500 200W  男</div><div class="line">renjuanfang          1000 900W 女</div><div class="line"></div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ awk &apos;$1==&quot;renyimin&quot; &#123;print $1,$2,$3&#125;&apos; awk.log</div><div class="line">renyimin 200 1200W</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ awk &apos;$1==&apos;renyimin&apos; &#123;print $1,$2,$3&#125;&apos; awk.log</div><div class="line"></div><div class="line"></div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ awk &apos;$1==renyimin &#123;print $1,$2,$3&#125;&apos; awk.log</div><div class="line"></div><div class="line"></div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$</div></pre></td></tr></table></figure></li><li><p>模式可以组合(可以使用括号和逻辑操作符与 <code>&amp;&amp;</code> ， 或 <code>||</code> ， 以及非 <code>!</code> 对模式进行组合)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ awk &apos;$1==&quot;renyimin&quot; &amp;&amp; $2&gt;20 &#123;print $1,$2,$3&#125;&apos; awk.log</div><div class="line">renyimin 200 1200W</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ awk &apos;$1==&quot;renyimin&quot; &amp;&amp; $2&gt;200 &#123;print $1,$2,$3&#125;&apos; awk.log</div></pre></td></tr></table></figure></li><li><p>模式可以使用<code>运算符</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ cat test1.log</div><div class="line">Beth4.000</div><div class="line">Dan3.750</div><div class="line">kathy4.0010</div><div class="line">Mark5.0020</div><div class="line">Mary5.5022</div><div class="line">Susie4.2518</div><div class="line">renyimindeMacBook-Pro:linux renyimin$ awk &apos;$2*$3&gt;50 &#123;print $0&#125;&apos; test1.log</div><div class="line">Mark5.0020</div><div class="line">Mary5.5022</div><div class="line">Susie4.2518</div><div class="line">renyimindeMacBook-Pro:linux renyimin$</div></pre></td></tr></table></figure></li><li><p>也可以使用<code>正则表达式</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ awk &apos;/Susie/ &#123;print $0&#125;&apos; test1.log</div><div class="line">Susie4.2518</div><div class="line">renyimindeMacBook-Pro:linux renyimin$</div></pre></td></tr></table></figure></li></ul></li></ol><ol><li><p><code>action</code> 指的就是动作, awk 擅长文本格式化并将格式化后的文本<strong>输出</strong>, 所以它比较常用的 action 是 <code>print</code> 和 <code>printf</code>;</p></li><li><p>‘模式+动作’ 语句中的 模式 或 动作都可以省略, 但不是两者同时省略;</p><ul><li>有的awk命令有 一个模式 + 动作</li><li>有的awk命令只有一个模式, 没有动作(如果没有动作, 那么模式匹配到的每一行都会被完整打印出来, 相当于动作是<code>{print}</code> 或者 <code>{print $0}</code>)</li><li>有的awk命令只有多个模式, 没有动作(同上) </li><li>有的awk命令可以有多个模式 + 一个动作</li><li>貌似没有 模式+动作, 模式+动作 这种awk命令</li><li>多个模式可以使用括号和逻辑操作符<code>与&amp;&amp;</code>, <code>或||</code>, 以及 <code>非!</code> 对模式进行组合</li></ul></li><li><p><code>option</code> 选项, 可以不用任何选项, 常用选项为</p><ul><li><p><code>-F fs or --field-separator fs</code> : 指定输入文件分隔符(), fs可以是一个字符串或是一个正则表达式 (当然, 也可以使用内置变量, 结合参数 -v,  <code>-v FS=&#39;分隔符&#39;</code> 来指定分隔符)<br><code>-F</code> 还可以使用正则表达式来定制按照某些字符串来做分隔, 字符需要放在 <code>&#39;[]&#39;中</code>, 比如对nginx的access日志使用<code>[</code>或者<code>]</code>来分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ tail -5 c2b_oms.2018-03-30-access.log</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:16:43:17 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[200] byte=[884] elapsed=[2.189] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[7.55]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:17:11:45 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[500] byte=[22005] elapsed=[0.136] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[-]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:17:13:25 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[200] byte=[695] elapsed=[0.115] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[9.50]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:17:14:41 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[500] byte=[22005] elapsed=[0.133] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[-]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:17:14:58 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[500] byte=[22005] elapsed=[0.139] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[-]</div><div class="line">$ tail -5 c2b_oms.2018-03-30-access.log | awk -F &apos;[][]&apos; &apos;&#123;print $8&#125;&apos;</div><div class="line">GET /api/v1/car_dealer/list HTTP/1.1</div><div class="line">GET /api/v1/car_dealer/list HTTP/1.1</div><div class="line">GET /api/v1/car_dealer/list HTTP/1.1</div><div class="line">GET /api/v1/car_dealer/list HTTP/1.1</div><div class="line">GET /api/v1/car_dealer/list HTTP/1.1</div><div class="line">[work@VM_0_206_centos nginx_log]$</div></pre></td></tr></table></figure><p>或者还可以使用 <code>tail -10 c2b_oms.2018-03-30-access.log | awk -F&#39;[\\[\\]]&#39; &#39;{print $2}&#39;</code></p></li><li>可以按照任意一段字符串进行分隔<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[work@VM_0_206_centos nginx_log]$ tail -3 c2b_oms.2018-03-30-access.log</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:11:26:09 +0800] request=[GET /api/v1/car_dealer/list?car_dealer_name_or_phone=18625036504 HTTP/1.1] status=[200] byte=[276] elapsed=[0.005] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[0.61]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:11:28:23 +0800] request=[GET /api/v1/car_dealer/list?car_dealer_name_or_phone=renyimin HTTP/1.1] status=[200] byte=[786] elapsed=[1.312] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[8.27]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:11:29:39 +0800] request=[GET /api/v1/car_dealer/list?car_dealer_name_or_phone1=renyimin HTTP/1.1] status=[200] byte=[786] elapsed=[0.269] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[8.27]</div><div class="line">[work@VM_0_206_centos nginx_log]$ tail -10 c2b_oms.2018-03-30-access.log | awk -F&apos;+0800&apos; &apos;&#123;print $2&#125;&apos;</div><div class="line">] request=[GET /api/v1/car_dealer/list?car_dealer_name_or_phone=18625036504 HTTP/1.1] status=[200] byte=[276] elapsed=[0.005] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[0.61]</div><div class="line">] request=[GET /api/v1/car_dealer/list?car_dealer_name_or_phone=renyimin HTTP/1.1] status=[200] byte=[786] elapsed=[1.312] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[8.27]</div><div class="line">] request=[GET /api/v1/car_dealer/list?car_dealer_name_or_phone1=renyimin HTTP/1.1] status=[200] byte=[786] elapsed=[0.269] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[8.27]</div><div class="line">[work@VM_0_206_centos nginx_log]$</div></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- `-v` 变量赋值选项: 该选项将一个值赋予一个变量, 它会在程序开始之前进行赋值, 下面的例子描述了该选项的使用`-v` : 定义一个变量 (变量可以是awk内置的, 也可以是自定义的)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ awk -v name=Rymuscle &apos;BEGIN&#123;printf &quot;Name = %s\n&quot;, name&#125;&apos;</div><div class="line">Name = Jerry</div><div class="line">$</div></pre></td></tr></table></figure>- 上面介绍了如何设定输入分隔符, 其实还有输出分隔符, 可以使用 `-v OFS=&apos;分隔符&apos;`, 来定义输出分隔符 (注意,在输出时, 各字段间的`逗号`就代表了输出分隔符, 没有逗号则各字段会紧连着)-  `-f scriptfile 或者 --file scriptfile` : 从脚本文件中读取awk命令</code></pre><ol><li>多文件处理, 用到了再补充~~</li></ol><h2 id="内置的一些变量"><a href="#内置的一些变量" class="headerlink" title="内置的一些变量"></a>内置的一些变量</h2><p>下面值列出本人常用的一些awk内置变量<br>变量可以在<code>BEGIN</code>语句块中声明, 也可以在<code>program</code>中声明, 也可以使用参数 <code>-v</code> 声明</p><ol><li><p><code>NF</code>: <strong>行的字段数量</strong>, 你可以在awk命令的program中使用action, 在action中比较常用的是print所需的字段, 此时你可能总是需要通过 $1, $2 这样来指定索要打印的不同字段, 但任何表达式都可以使用在<code>$</code>之后来表达一个字段的序号; 表达式会被求值并用于表示字段序号, 同时, Awk会对当前输入的行有多少个字段进行计数, 并且将当前行的字段数量存储在一个内建的称作 <code>NF</code> 的变量中;<br> 因此, 程序 <code>{ print NF, $1, $NF }</code> 会依次打印出每一行的字段数量, 第一个字段的值, 最后一个字段的值;</p></li><li><p><code>NR</code>: 它会存储当前已经读取了多少行的计数. 我们可以使用 <code>$NR</code> 给结果的每一行加上行号</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ awk &apos;&#123;print NR,$0&#125;&apos; awk.log</div><div class="line">1 renyimin   &quot;200&quot; 1200W 男</div><div class="line">2</div><div class="line">3 renfumin 500 &quot;200W&quot;  男</div><div class="line">4 renjuanfang          1000 900W &quot;女&quot;</div><div class="line">5</div><div class="line">renyimindeMacBook-Pro:linux renyimin$</div></pre></td></tr></table></figure></li><li><p><code>FS</code>: 除了使用 <code>-F</code>参数指定字段分隔符, 也可以通过 -v 设定 <code>FS</code> 内置变量来指定字段分隔符 (或者在<code>BEGIN</code>中指定<code>FS</code>变量)</p></li><li><p><code>OFS</code> : 上面介绍了如何设定输入分隔符, 其实还有输出分隔符, 可以使用 <code>-v OFS=&#39;分隔符&#39;</code>(或者在<code>BEGIN</code>中指定<code>OFS</code>变量), 来定义输出分隔符 (注意,在输出时, 各字段间的<code>逗号</code>就代表了输出分隔符, 没有逗号则各字段会紧连着)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[work@VM_0_206_centos nginx_log]$ tail -3 c2b_oms.2018-03-30-access.log | awk -F&quot;[][]&quot; -v OFS=&apos;---&apos; &apos;&#123;print $2,$3&#125;&apos;</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">[work@VM_0_206_centos nginx_log]$ tail -3 c2b_oms.2018-03-30-access.log | awk -F&quot;[][]&quot; &apos;BEGIN&#123;OFS=&quot;---&quot;&#125; &#123;print $2,$3&#125;&apos;</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">[work@VM_0_206_centos nginx_log]$</div></pre></td></tr></table></figure></li><li><p>另外声明变量也可以直接在 <code>program</code> 中进行</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[work@VM_0_206_centos nginx_log]$ tail -3 c2b_oms.2018-03-30-access.log | awk &apos;FS=&quot;[][]&quot;,OFS=&quot;---&quot; &#123;print $2,$3&#125;&apos;</div><div class="line">http_x_forward=[-]---time=[30/Mar/2018:11:26:09</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">[work@VM_0_206_centos nginx_log]$</div></pre></td></tr></table></figure></li><li><p>其余的, 用到了再补充~~</p></li></ol><h2 id="BEGIN-语句块"><a href="#BEGIN-语句块" class="headerlink" title="BEGIN 语句块"></a>BEGIN 语句块</h2><ol><li><code>BEGIN</code> 语句块的语法: 在awk的program中 <code>BEGIN {awk-commands}</code>: BEGIN语句块在程序开始的使用执行, 它只执行一次, 在这里可以初始化变量或者打印一个开头什么的…</li><li><code>BEGIN</code> 是AWK的关键字, 因此它必须为大写, 注意, 这个语句块是可选的;</li><li>测试:<ul><li>可以使用 <code>print &quot;&quot;</code> 在输出之前先打印一个空行<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ awk &apos;BEGIN &#123;print &quot;&quot;&#125; &#123;print NR,$0&#125;&apos; awk.log</div><div class="line"></div><div class="line">1 renyimin   &quot;200&quot; 1200W 男</div><div class="line">2</div><div class="line">3 renfumin 500 &quot;200W&quot;  男</div><div class="line">4 renjuanfang          1000 900W &quot;女&quot;</div><div class="line">5</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="END-语句块"><a href="#END-语句块" class="headerlink" title="END 语句块"></a>END 语句块</h2><p>END 则用于处理匹配过的最后一个文件的最后一行之后的位置;</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>下面根据nginx的access.log日志来做一些练习 (这个日志还是挺大量的)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wc c2b_bid.2018-04-23-access.log</div><div class="line">   65608  1501442 29580860 c2b_bid.2018-04-23-access.log</div></pre></td></tr></table></figure></p><ol><li><p>统计独立ip的访问量 - 共有多少独立IP访问过本站点</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-bash-4.2$ awk &apos;&#123;print $1&#125;&apos; c2b_bid.2018-04-23-access.log | sort -n | uniq | wc -l</div><div class="line">240</div></pre></td></tr></table></figure><p> 表示共有240个不同ip访问过站点</p></li><li><p>统计独立ip的访问情况 - 每个独立ip的访问次数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bash-4.2$ awk &apos;&#123;print $1&#125;&apos; c2b_bid.2018-04-23-access.log | sort -n | uniq -c</div><div class="line">    190 remote_addr=[100.116.226.0]</div><div class="line">    195 remote_addr=[100.116.226.1]</div><div class="line">    176 remote_addr=[100.116.226.10]</div><div class="line">    176 remote_addr=[100.116.226.100]</div><div class="line">    .....</div><div class="line">    就不全部列出了</div></pre></td></tr></table></figure></li><li><p>统计访问最频繁的前10个ip</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-bash-4.2$ awk &apos;&#123;print $1&#125;&apos; c2b_bid.2018-04-23-access.log | sort -n | uniq -c | sort -rn | head -10</div><div class="line">    407 remote_addr=[100.116.251.123]</div><div class="line">    399 remote_addr=[100.116.251.65]</div><div class="line">    394 remote_addr=[100.116.251.56]</div><div class="line">    390 remote_addr=[100.116.251.97]</div><div class="line">    388 remote_addr=[100.116.251.11]</div><div class="line">    387 remote_addr=[100.116.251.110]</div><div class="line">    384 remote_addr=[100.116.251.98]</div><div class="line">    383 remote_addr=[100.116.251.83]</div><div class="line">    382 remote_addr=[100.116.251.8]</div><div class="line">    381 remote_addr=[100.116.251.40]</div><div class="line">-bash-4.2$</div></pre></td></tr></table></figure></li><li><p>查看访问380次以上的ip</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-bash-4.2$ awk &apos;&#123;print $1&#125;&apos; c2b_bid.2018-04-23-access.log | sort -n | uniq -c | awk &apos;$1 &gt; 380 &#123;print&#125;&apos; | sort -rn</div><div class="line">    407 remote_addr=[100.116.251.123]</div><div class="line">    399 remote_addr=[100.116.251.65]</div><div class="line">    394 remote_addr=[100.116.251.56]</div><div class="line">    390 remote_addr=[100.116.251.97]</div><div class="line">    388 remote_addr=[100.116.251.11]</div><div class="line">    387 remote_addr=[100.116.251.110]</div><div class="line">    384 remote_addr=[100.116.251.98]</div><div class="line">    383 remote_addr=[100.116.251.83]</div><div class="line">    382 remote_addr=[100.116.251.8]</div><div class="line">    381 remote_addr=[100.116.251.40]</div><div class="line">    381 remote_addr=[100.116.251.38]</div><div class="line">    381 remote_addr=[100.116.251.118]</div><div class="line">-bash-4.2$</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Awk是一种便于使用且表达能力强的程序设计语言, 没错, 它是一门编程语言, 它拥有数组, 支持&lt;code&gt;if-else
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://blog.renyimin.com/2018/05/17/linux/2018-05-17-regular/"/>
    <id>http://blog.renyimin.com/2018/05/17/linux/2018-05-17-regular/</id>
    <published>2018-05-17T06:22:31.000Z</published>
    <updated>2018-05-17T06:22:36.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux编辑器</title>
    <link href="http://blog.renyimin.com/2018/05/17/linux/2018-05-17/"/>
    <id>http://blog.renyimin.com/2018/05/17/linux/2018-05-17/</id>
    <published>2018-05-17T06:17:57.000Z</published>
    <updated>2018-05-17T06:21:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><p>光标跳转到某行<br>光标跳转到行首<br>光标跳转到行尾</p><h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><p>复制当前行<br>复制从当前行开始多少行<br>复制指定某几行</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><h3 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h3><p>垂直<br>水平<br>分屏切换焦点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vim&quot;&gt;&lt;a href=&quot;#vim&quot; class=&quot;headerlink&quot; title=&quot;vim&quot;&gt;&lt;/a&gt;vim&lt;/h2&gt;&lt;h3 id=&quot;跳转&quot;&gt;&lt;a href=&quot;#跳转&quot; class=&quot;headerlink&quot; title=&quot;跳转&quot;&gt;&lt;/a&gt;跳转&lt;/h3&gt;&lt;p
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文本处理 - sort, uniq, wc</title>
    <link href="http://blog.renyimin.com/2018/05/16/linux/2018-05-16-other-command/"/>
    <id>http://blog.renyimin.com/2018/05/16/linux/2018-05-16-other-command/</id>
    <published>2018-05-16T07:28:21.000Z</published>
    <updated>2018-05-23T05:27:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><ol><li>Linux <code>sort</code>命令用于将文本文件内容以<code>行</code>为单位进行排序; </li><li><p>语法: <code>sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][--help][--verison][文件]</code><br> <code>sort</code> 命令既可以从特定的文件，也可以从 stdin 中获取输入;</p></li><li><p>选项</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-b：忽略每行前面开始出的空格字符；</div><div class="line">-c：检查文件是否已经按照顺序排序；</div><div class="line">-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符；</div><div class="line">-f：排序时，将小写字母视为大写字母；</div><div class="line">-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；</div><div class="line">-m：将几个排序号的文件进行合并；</div><div class="line">-M：将前面3个字母依照月份的缩写进行排序；</div><div class="line">-n：依照数值的大小排序；</div><div class="line">-o&lt;输出文件&gt;：将排序后的结果存入制定的文件；</div><div class="line">-r：以相反的顺序来排序；</div><div class="line">-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符；</div><div class="line">+&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</div></pre></td></tr></table></figure></li><li><p>目前常用的选项有 <code>-nr</code></p></li></ol><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><ol><li><p><code>uniq</code> 命令用于报告或忽略文件中的重复行，一般与sort命令结合使用; </p><ul><li>之所以要和sort命令结合使用, 是因为<code>uniq</code>命令值只可以删除相邻的重复行;</li><li>如果一文本中有重复却不相邻的行, 单独使用<code>uniq</code>命令则无法删除, 需要结合sort命令;</li></ul></li><li><p>语法: <code>uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--help][--version][输入文件][输出文件]</code></p></li><li><p>选项:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-c或——count：在每列旁边(貌似是左边)显示该行重复出现的次数；</div><div class="line">-d或--repeated：仅显示重复出现的行列；</div><div class="line">-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;：忽略比较指定的栏位；</div><div class="line">-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;：忽略比较指定的字符；</div><div class="line">-u或——unique：仅显示出一次的行列；</div><div class="line">-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;：指定要比较的字符。</div></pre></td></tr></table></figure></li><li><p>目前常用的选项有 <code>-c</code></p></li><li><p>参数介绍</p><ul><li>输入文件: 指定要去除的重复行文件, 如果不指定此项, 则从标准读取数据; </li><li>输出文件: 指定要去除重复行后的内容要写入的输出文件, 如果不指定此选项, 则将内容显示到标准输出设备(显示到终端);</li></ul></li><li><p>实例</p><ul><li>uniq <strong>无法去除不相邻的重复行</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ cat uniq.log</div><div class="line">renyimin is a it man</div><div class="line">he has many article</div><div class="line">renyimin comes from shanxi province</div><div class="line">he has many article</div><div class="line"></div><div class="line">// 可以看到uniq并没有对不相邻的重复行进行去重操作</div><div class="line">renyimindeMacBook-Pro:linux renyimin$ uniq uniq.log</div><div class="line">renyimin is a it man</div><div class="line">he has many article</div><div class="line">renyimin comes from shanxi province</div><div class="line">he has many article</div><div class="line">renyimindeMacBook-Pro:linux renyimin$</div><div class="line">   </div><div class="line">// 如下进行排序后即可</div><div class="line">renyimindeMacBook-Pro:linux renyimin$ sort uniq.log | uniq</div><div class="line">he has many article</div><div class="line">renyimin comes from shanxi province</div><div class="line">renyimin is a it man</div><div class="line">renyimindeMacBook-Pro:linux renyimin$</div></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- `-c` 参数, 对文件相同行进行去重, 并统计每行重复出现的次数 (类似于mysql的groupby分组统计)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ sort uniq.log | uniq -c</div><div class="line">2 he has many article</div><div class="line">1 renyimin comes from shanxi province</div><div class="line">1 renyimin is a it man</div></pre></td></tr></table></figure>- 当然, 还可以继续结合sort来按照重复条数最多的来排序 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ sort uniq.log | uniq -c | sort</div><div class="line">1 renyimin comes from shanxi province</div><div class="line">1 renyimin is a it man</div><div class="line">2 he has many article</div></pre></td></tr></table></figure></code></pre><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><ol><li><p>利用<code>wc</code>指令我们可以计算文件的 行数、Byte数、字数、或是列数, 若不指定文件名称、或是所给予的文件名为”-“, 则wc指令会从标准输入设备读取数据;</p></li><li><p>语法: <code>wc [-clw][--help][--version][文件...]</code></p></li><li><p>选项</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-c或--bytes或--chars 只显示Bytes数</div><div class="line"></div><div class="line">-l或--lines 只显示行数</div><div class="line"></div><div class="line">-w或--words 只显示字数</div><div class="line"></div><div class="line">--help 在线帮助</div><div class="line"></div><div class="line">--version 显示版本信息</div></pre></td></tr></table></figure></li><li><p>目前常用的选项有 <code>-lwc</code> (貌似也是默认的选项, 而且无论选项的顺序是怎样的, 结果总是: “行数, 字数, 字节数, 文件名”)</p></li><li><p>实例</p><ul><li><p>基本用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ cat uniq.log</div><div class="line">renyimin is a it man</div><div class="line">he has many article</div><div class="line">renyimin comes from shanxi province</div><div class="line">he has many article</div><div class="line">renyimindeMacBook-Pro:linux renyimin$ wc uniq.log</div><div class="line">       4      18      97 uniq.log</div><div class="line">renyimindeMacBook-Pro:linux renyimin$</div></pre></td></tr></table></figure></li><li><p>统计多文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ wc -l uniq.log uniq.log</div><div class="line">       4 uniq.log       // 第一个文件行数为4</div><div class="line">       4 uniq.log       // 第二个文件行数为4</div><div class="line">       8 total          // 两个文件总的行数为8</div><div class="line">renyimindeMacBook-Pro:linux renyimin$</div></pre></td></tr></table></figure></li><li><p>结合之前的 <code>uniq</code>, <code>sort</code> 命令, 统计去重后的行数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ cat uniq.log</div><div class="line">renyimin is a it man</div><div class="line">he has many article</div><div class="line">renyimin comes from shanxi province</div><div class="line">he has many article</div><div class="line"></div><div class="line">// 总共有4行</div><div class="line">renyimindeMacBook-Pro:linux renyimin$ sort uniq.log | wc -l</div><div class="line">          4</div><div class="line">// 去重后有3行</div><div class="line">renyimindeMacBook-Pro:linux renyimin$ sort uniq.log | uniq -c | wc -l</div><div class="line">          3</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h2><p>nl命令在linux系统中用来计算文件中行号, nl 可以将输出的文件内容自动的加上行号, 其默认的结果与 <code>cat -n</code> 有点不太一样, nl 可以将行号做比较多的显示设计, 包括位数与是否自动补齐 0 等等的功能<br>1．命令格式 : <code>nl [选项]... [文件]...</code><br>2．命令参数：<br>    -b  ：指定行号指定的方式，主要有两种：<br>    -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>    -b t ：如果有空行，空的那一行不要列出行号(默认值)；<br>    -n  ：列出行号表示的方法，主要有三种：<br>    -n ln ：行号在萤幕的最左方显示；<br>    -n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>    -n rz ：行号在自己栏位的最右方显示，且加 0 ；<br>    -w  ：行号栏位的占用的位数。<br>    -p 在逻辑定界符处不重新开始计算。</p><ol><li>试用 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$ nl -ba Test.class.php</div><div class="line"> 1&lt;?php</div><div class="line"> 2interface Huma</div><div class="line"> 3&#123;</div><div class="line"> 4     public static function say();</div><div class="line"> 5&#125;</div><div class="line"> 6</div><div class="line"> 7class Male implements Huma</div><div class="line"> 8&#123;</div><div class="line"> 9    private static function say()</div><div class="line">10    &#123;</div><div class="line">11        echo &quot;I am a Male&quot;;</div><div class="line">12    &#125;</div><div class="line">13&#125;</div><div class="line">14</div><div class="line">15class Female implements Huma</div><div class="line">16&#123;</div><div class="line">17    public static function say()</div><div class="line">18    &#123;</div><div class="line">19        echo &quot;I am a Female&quot;;</div><div class="line">20    &#125;</div><div class="line">21&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="其他案例"><a href="#其他案例" class="headerlink" title="其他案例"></a>其他案例</h2><ol><li>在多个文件中匹配某个字符串(比如 ‘&lt;?php’), 并列出文件名: <code>grep &#39;&lt;?php&#39; *.php</code></li></ol><p>重点还是多练习….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sort&quot;&gt;&lt;a href=&quot;#sort&quot; class=&quot;headerlink&quot; title=&quot;sort&quot;&gt;&lt;/a&gt;sort&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Linux &lt;code&gt;sort&lt;/code&gt;命令用于将文本文件内容以&lt;code&gt;行&lt;/code&gt;为单位进行排序
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins</title>
    <link href="http://blog.renyimin.com/2018/05/15/Jenkins/2018-05-15-01/"/>
    <id>http://blog.renyimin.com/2018/05/15/Jenkins/2018-05-15-01/</id>
    <published>2018-05-15T10:28:18.000Z</published>
    <updated>2018-05-16T02:28:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jenkins.io/download/" target="_blank" rel="external">下载</a>安装</p><ol><li><p>默认情况下, Jenkins提供了 最新版本 和 长期支持版本(LTS) 可供下载;</p><ul><li><a href="https://hub.docker.com/r/jenkins/jenkins/" target="_blank" rel="external">Docker 拉取</a>Jenkins镜像: <code>docker pull jenkins/jenkins:lts</code></li><li>在本机创建目录 <code>/Users/renyimin/Desktop/jenkins_home</code>, 下面将会以root用户身份将jenkins容器中的jenkins_home目录挂载到宿主机上, 防止容器删除, 数据丢失</li><li><a href="https://github.com/jenkinsci/docker/blob/master/README.md" target="_blank" rel="external">Docker 运行</a>: </li><li>在输出的控制台信息中, 一定要记得记录生成的秘钥串, 稍后会用到, 如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">May 15, 2018 10:55:38 AM jenkins.install.SetupWizard init</div><div class="line">INFO:</div><div class="line"></div><div class="line">*************************************************************</div><div class="line">*************************************************************</div><div class="line">*************************************************************</div><div class="line"></div><div class="line">Jenkins initial setup is required. An admin user has been created and a password generated.</div><div class="line">Please use the following password to proceed to installation:</div><div class="line"></div><div class="line">29b2b48ed7e14cb8bf9f706dde309995</div><div class="line"></div><div class="line">This may also be found at: /var/jenkins_home/secrets/initialAdminPassword</div><div class="line"></div><div class="line">*************************************************************</div><div class="line">*************************************************************</div><div class="line">*************************************************************</div></pre></td></tr></table></figure></li></ul></li><li><p>看到秘钥串生成, 就可以打开浏览器, 输入：<a href="http://127.0.0.1:8080" target="_blank" rel="external">http://127.0.0.1:8080</a> 进入jenkins系统配置界面, 输入刚刚记录的秘钥串 <code>29b2b48ed7e14cb8bf9f706dde309995</code>:<br> <img src="/img/jenkins/install-01.png" width="500/"></p></li><li><p>点继续, 到了选择安装插件的界面, 这里我们选择安装默认常用的插件, 如图:<br> <img src="/img/jenkins/install-02.png" width="500/"><br> <img src="/img/jenkins/install-03.png" width="500/"></p></li><li><p>插件安装完成后, 选择以admin管理员用户继续, 如下:<br> <img src="/img/jenkins/install-04.png" width="500/"></p></li><li><p>然后 开始使用Jenknsi :<br> <img src="/img/jenkins/install-05.png" width="500/"></p></li><li><p>选择 “用户”-&gt;”admin”-&gt;设置”, 把admin管理员账户的密码修改一下, 然后点击保存, 到此Jenkins安装结束;<br> <img src="/img/jenkins/install-06.png" width="500/"></p></li></ol><p>参考:<a href="https://www.cnblogs.com/soar1688/p/6833540.html" target="_blank" rel="external">https://www.cnblogs.com/soar1688/p/6833540.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jenkins.io/download/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载&lt;/a&gt;安装&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;默认情况下, Jenkins提供了 最新版本 和 长期支持版本(LTS) 可供下载;
      
    
    </summary>
    
      <category term="持续集成" scheme="http://blog.renyimin.com/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="持续集成" scheme="http://blog.renyimin.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux文本处理 - grep</title>
    <link href="http://blog.renyimin.com/2018/05/15/linux/2018-05-15-grep/"/>
    <id>http://blog.renyimin.com/2018/05/15/linux/2018-05-15-grep/</id>
    <published>2018-05-15T02:09:02.000Z</published>
    <updated>2018-05-17T06:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;grep&quot;&gt;&lt;a href=&quot;#grep&quot; class=&quot;headerlink&quot; title=&quot;grep&quot;&gt;&lt;/a&gt;grep&lt;/h2&gt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文本处理 - sed</title>
    <link href="http://blog.renyimin.com/2018/05/15/linux/2018-05-15-sed/"/>
    <id>http://blog.renyimin.com/2018/05/15/linux/2018-05-15-sed/</id>
    <published>2018-05-15T02:08:21.000Z</published>
    <updated>2018-05-17T06:42:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sed&quot;&gt;&lt;a href=&quot;#sed&quot; class=&quot;headerlink&quot; title=&quot;sed&quot;&gt;&lt;/a&gt;sed&lt;/h2&gt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IO相关的一些概念</title>
    <link href="http://blog.renyimin.com/2018/05/13/socket/2018-05-13-IO/"/>
    <id>http://blog.renyimin.com/2018/05/13/socket/2018-05-13-IO/</id>
    <published>2018-05-13T03:12:19.000Z</published>
    <updated>2018-05-13T12:02:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>在开始socket编程前, 需要先对 <code>IO</code> 的概念有一定的认识: </p><ul><li>我们通常使用php的fopen打开文件关闭文件读读写写, 这叫<code>本地文件IO</code>; </li><li>而在socket编程中, 本质其实是<code>网络IO</code>;</li></ul><h2 id="同步异步阻塞非阻塞"><a href="#同步异步阻塞非阻塞" class="headerlink" title="同步异步阻塞非阻塞"></a>同步异步阻塞非阻塞</h2><p>之前反正一直搞不清楚同步和阻塞, 异步和非阻塞的概念, 总感觉同步就是阻塞, 异步就是非阻塞的, 总是搞得晕乎乎的, 于是就重新查了些资料进行了梳理, 如有不对欢迎大家指正;</p><h3 id="简单来说"><a href="#简单来说" class="headerlink" title="简单来说"></a>简单来说</h3><p>同步: 同步体现在, 在等待一件事情的处理结果时, 对方是否提供通知服务, 如果对方不提供通知服务, 则为 同步;</p><p>异步: 异步体现在, 在等待一件事情的处理结果时, 对方是否提供通知服务, 如果对方提供通知服务, 则为 异步; </p><ul><li>对于常见的Ajax请求, 前端在ajax请求后通常还会执行一些其他加载操作(非阻塞); 在server端处理完后, 会将数据’通知’到前端页面;</li><li>而对于最近正好在看的RabbitMQ消息队列系统, 虽然本质上来说也是异步的(它是通过分隔了数据的发送和接收来解耦应用, 数据在最终被消费者处理完后也不会通知到生产者, 因为消息系统采用了很多手段如持久化, 重试等来确保消息一定会被执行), 但实质上, 消息会在发送成功后会立即得到响应, 所以单就生产者成功生产消息这一步来说, 其实是同步的;</li></ul><p>阻塞: 阻塞体现在, 在等待一件事情的处理结果时, 你是否还去干点其他的事情, 如果不去, 则为 阻塞;</p><p>非阻塞: 非阻塞体现在, 在等待一件事情的处理结果时, 你是否还去干点其他的事情, 如果去了, 则为 非阻塞;</p><h3 id="结合例子来说"><a href="#结合例子来说" class="headerlink" title="结合例子来说"></a>结合例子来说</h3><p>此处找了一位朋友写的例子, 感觉很不错<br>同步阻塞: 你去 甜在心馒头 店买太极馒头, 阿梅说:”暂时没, 正在蒸呢, <strong>你自己看着点儿</strong>!”, 于是你就站在旁边只等馒头, 此时的你, 是阻塞的, 也是同步的;</p><ul><li>阻塞表现在你除了等馒头，别的什么都不做了;</li><li>同步表现在等馒头的过程中, 阿梅不提供通知服务, 你不得不自己主动检查 ＂馒头出炉＂ 的消息;</li></ul><p>同步非阻塞: 你去甜在心馒头店买太极馒头, 阿梅说:＂暂时没, 正在蒸呢, <strong>你自己看着点儿</strong>!＂, 于是你就站在旁边发发微信, 然后问一句:＂好了没？＂, 然后玩玩QQ游戏, 然后再问一句:＂好了没？＂, 此时的你, 是非阻塞的, 不过却还是同步的;</p><ul><li>非阻塞表现在你除了等馒头, 自己还在干别的事情;</li><li>同步表现在等馒头的过程中, 由于阿梅不提供通知服务, 你不得不自己主动检查 ＂馒头出炉＂ 的消息;</li></ul><p>异步阻塞: 你去甜在心馒头店买太极馒头, 阿梅说:＂暂时没, 正在蒸呢, 蒸好了<strong>我打电话告诉你</strong>!＂, 但你依然站在旁边只等馒头, 此时的你, 是阻塞的, 是异步的;</p><ul><li>阻塞表现在你除了等馒头, 也没去干点别的什么(比如玩玩手机啥的);</li><li>异步表现在等馒头的过程中, 阿梅提供电话通知＂馒头出炉＂的消息, 你只需要等阿梅的电话;</li></ul><p>异步非阻塞: 你去甜在心馒头店买太极馒头, 阿梅说:＂暂时没, 正在蒸呢, 蒸好了<strong>我打电话告诉你</strong>!＂, 于是你就走了, 去买了双新球鞋, 看了看武馆, 总之, 从此不再过问馒头的事情, 一心只等阿梅电话, 此时的你, 是非阻塞的, 是异步的</p><ul><li>非阻塞表现在你除了等馒头, 自己还去干点别的事情;</li><li>异步表现在等馒头的过程中, 阿梅提供电话通知＂馒头出炉＂的消息, 你只需要等阿梅的电话;</li></ul><p><a href="https://www.jianshu.com/p/5d00d25ef18a?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IO&quot;&gt;&lt;a href=&quot;#IO&quot; class=&quot;headerlink&quot; title=&quot;IO&quot;&gt;&lt;/a&gt;IO&lt;/h2&gt;&lt;p&gt;在开始socket编程前, 需要先对 &lt;code&gt;IO&lt;/code&gt; 的概念有一定的认识: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们通常使用php的
      
    
    </summary>
    
      <category term="Socket" scheme="http://blog.renyimin.com/categories/Socket/"/>
    
    
      <category term="Socket" scheme="http://blog.renyimin.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Linux软件安装</title>
    <link href="http://blog.renyimin.com/2018/05/13/linux/2018-05-13-install/"/>
    <id>http://blog.renyimin.com/2018/05/13/linux/2018-05-13-install/</id>
    <published>2018-05-13T03:02:35.000Z</published>
    <updated>2018-05-17T06:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;yum&quot;&gt;&lt;a href=&quot;#yum&quot; class=&quot;headerlink&quot; title=&quot;yum&quot;&gt;&lt;/a&gt;yum&lt;/h2&gt;&lt;h2 id=&quot;rpm&quot;&gt;&lt;a href=&quot;#rpm&quot; class=&quot;headerlink&quot; title=&quot;rpm&quot;&gt;&lt;/a&gt;rpm&lt;/h
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统监控</title>
    <link href="http://blog.renyimin.com/2018/05/10/linux/2018-05-10-system-monitor/"/>
    <id>http://blog.renyimin.com/2018/05/10/linux/2018-05-10-system-monitor/</id>
    <published>2018-05-10T05:20:29.000Z</published>
    <updated>2018-05-17T06:27:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000005621984" target="_blank" rel="external">https://segmentfault.com/a/1190000005621984</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000005621984&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://segmentfault.com/a/1190000005621984&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>PHP-X</title>
    <link href="http://blog.renyimin.com/2018/05/09/PHP/2018-05-09-PHP-X/"/>
    <id>http://blog.renyimin.com/2018/05/09/PHP/2018-05-09-PHP-X/</id>
    <published>2018-05-09T12:29:31.000Z</published>
    <updated>2018-05-09T12:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.swoole.com/wiki/index/prid-15" target="_blank" rel="external">https://wiki.swoole.com/wiki/index/prid-15</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://wiki.swoole.com/wiki/index/prid-15&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://wiki.swoole.com/wiki/index/prid-15&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="PHP" scheme="http://blog.renyimin.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.renyimin.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>01.</title>
    <link href="http://blog.renyimin.com/2018/04/28/oauth/2018-04-28-CAS/"/>
    <id>http://blog.renyimin.com/2018/04/28/oauth/2018-04-28-CAS/</id>
    <published>2018-04-28T13:10:12.000Z</published>
    <updated>2018-05-02T08:07:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Single-Sign-On"><a href="#Single-Sign-On" class="headerlink" title="Single Sign On"></a>Single Sign On</h2><p>单点登录(Single Sign On), 简称为<code>SSO</code>, 是目前比较流行的企业业务整合的解决方案之一;<br>SSO的定义是在多个应用系统中, 用户只需要登录一次就可以访问所有相互信任的应用系统;</p><h2 id="CAS简介"><a href="#CAS简介" class="headerlink" title="CAS简介"></a><a href="https://www.apereo.org/" target="_blank" rel="external">CAS</a>简介</h2><ol><li><a href="https://www.apereo.org/projects/cas" target="_blank" rel="external">CAS</a>由Yale耶鲁大学研发的一款开源的,企业级,SSO单点登录解决方案;</li><li><a href="https://github.com/apereo/cas" target="_blank" rel="external">CAS Github 源码下载</a>, 这里使用的是CAS5.1.9</li><li><a href="https://apereo.github.io/cas/5.1.x/" target="_blank" rel="external">CAS 文档</a><h3 id="CAS系统组件"><a href="#CAS系统组件" class="headerlink" title="CAS系统组件"></a>CAS系统组件</h3>CAS系统架构由 <code>CAS Server</code> 和 <code>CAS Client</code> 两个物理组件构成, 它们通过各种协议进行通信;<h3 id="CAS-Server"><a href="#CAS-Server" class="headerlink" title="CAS Server"></a>CAS Server</h3></li><li>CAS服务器是基于Spring框架构建的Java servlet, 其主要职责是验证用户, 并通过发布和验证票证来对 启用CAS的服务(通常称为CAS客户端)的访问权限 进行授权;<br>服务器在成功登录后, 会向用户授予 <code>票证(TGT)</code>时创建SSO会话;<br>根据用户的请求, 通过使用TGT作为标记的浏览器重定向向服务发出服务票据(ST);<br>ST随后通过反向信道通信在CAS服务器上进行验证。 CAS Protocol文档中详细描述了这些交互;</li></ol><h3 id="CAS-Client"><a href="#CAS-Client" class="headerlink" title="CAS Client"></a>CAS Client</h3><h2 id="CAS-Server搭建"><a href="#CAS-Server搭建" class="headerlink" title="CAS Server搭建"></a>CAS Server搭建</h2><ol><li><code>CAS</code> 可以分为两部分 <code>CAS Server</code> 和 <code>CAS Client</code></li></ol><ul><li><code>CAS Server</code> 用来负责用户的认证工作, 就像是把第一次登录用户的一个标识存在这里, 以便此用户在其他系统登录时验证其需不需要再次登录;</li><li><code>CAS Client</code> 就是我们自己的应用, 需要接入<code>CAS Server</code>端; 当用户访问我们的应用时, 首先需要重定向到CAS Server端进行验证, 要是原来登陆过, 就免去登录, 重定向到下游系统, 否则进行用户名密码登陆操作;</li></ul><ol><li>术语<br>Ticket Granting ticket (TGT): 可以认为是CAS Server根据用户账号和密码生成的一张票, 存在CAS Server端;<br>Ticket-granting cookie (TGC): 其实就是一个cookie, 存放用户身份信息, 由CAS Server发给CAS Client端;<br>Service ticket (ST): 由TGT生成的一次性票据, 用于验证, 只能用一次。相当于server发给client一张票, 然后client拿着这是个票再来找server验证, 看看是不是server签发的;<br>就像是我给了你一张我的照片, 然后你拿照片再来问我, 这个照片是不是你, 没错，就是这么无聊</li></ol><h3 id="TGT-Ticket-Grangting-Ticket"><a href="#TGT-Ticket-Grangting-Ticket" class="headerlink" title="TGT(Ticket Grangting Ticket)"></a>TGT(Ticket Grangting Ticket)</h3><ol><li><code>TGT</code>是<code>CAS</code>为用户签发的登录票据, 拥有了TGT, 用户就可以证明自己在CAS成功登录过;<ul><li>TGT封装了Cookie值以及此Cookie值对应的用户信息;</li><li>用户在CAS认证成功后, CAS生成cookie, 写入浏览器, 同时生成一个TGT对象, 放入自己的缓存;</li><li>TGT对象的ID就是cookie的值</li><li>当HTTP再次请求到来时, 如果传过来的有CAS生成的cookie, 则CAS以此cookie值为key查询缓存中有无TGT, 如果有的话, 则说明用户之前登录过, 如果没有, 则用户需要重新登录;</li></ul></li></ol><p>ST（Service Ticket）<br>ST是CAS为用户签发的访问某一service的票据。用户访问service时，service发现用户没有ST，则要求用户去CAS获取ST。用户向CAS发出获取ST的请求，如果用户的请求中包含cookie，则CAS会以此cookie值为key查询缓存中有无TGT，如果存在TGT，则用此TGT签发一个ST，返回给用户。<br>用户凭借ST去访问service，service拿ST去CAS验证，验证通过后，允许用户访问资源。</p><p>PGT（Proxy Granting Ticket）<br>Proxy Service的代理凭据。用户通过CAS成功登录某一Proxy Service后，CAS生成一个PGT对象，缓存在CAS本地，同时将PGT的值（一个UUID字符串）回传给Proxy Service，并保存在Proxy Service里。Proxy Service拿到PGT后，就可以为Target Service（back-end service）做代理，为其申请PT。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Single-Sign-On&quot;&gt;&lt;a href=&quot;#Single-Sign-On&quot; class=&quot;headerlink&quot; title=&quot;Single Sign On&quot;&gt;&lt;/a&gt;Single Sign On&lt;/h2&gt;&lt;p&gt;单点登录(Single Sign On), 
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>03. 一些注意点</title>
    <link href="http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-03/"/>
    <id>http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-03/</id>
    <published>2018-04-21T07:50:21.000Z</published>
    <updated>2018-04-21T11:21:42.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>类常量</p><ul><li>类常量是公共的</li><li>只能通过<code>类名</code>, 使用 <code>::</code> 静态访问类常量 (也可以使用实例化的对象通过<code>::</code>来访问类常量)</li><li>客户端代码不能对其进行改变</li><li>常量属性使用 <code>const</code> 关键字来声明, 不需要使用 <code>$</code> 符号</li><li>常量属性的值只能包含<strong>基本数据类型</strong>的值, 不能将一个对象指派给常量</li><li>当需要在类的所有实例中都能访问某个属性, 并且属性值无需改变时, 应该使用常量</li></ul></li><li><p>抽象类</p><ul><li>不能实例化抽象类</li><li>抽象类中应该至少包含一个抽象方法 (但也不是强制性的)</li><li>抽象方法使用<code>abstract</code>关键字声明, 不能有具体的内容</li><li>抽象方法不能有消息体<code>{}</code>, 并且需要以<code>;</code>结束</li><li>继承抽象方法的子类必须实现抽象类中的所有抽象方法</li><li>继承抽象方法的子类实现了抽象类中的所有抽象方法之后, 还应该注意: 新实现的这个方法的访问控制权限不能比抽象方法更严格;</li></ul></li><li><p>接口</p><ul><li>接口相对于抽象类, 可能更是彻底的, 一个纯粹的模板;    </li><li>接口只能定义功能, 而不包含实现的内容;</li><li>任何实现了接口的类都需要实现接口中所定义的所有方法, 否则该类必须声明为<code>abstract</code>;</li><li>接口中的所有方法都必须声明为 <code>public</code>(或者不声明权限, 默认就为public)</li><li>接口中的所有方法不能有消息体<code>{}</code>, 并且需要以<code>;</code>结束</li><li>一个类可以同时<strong>继承一个父类</strong>和<strong>实现任意个接口</strong>, <code>extends</code>子句应该在<code>inplements</code> 子句之前;</li><li>一个比较重要的概念是: <strong>实现接口的类接受了它继承的类以及实现的接口的类型</strong>; (对于面向对象来说, 依赖抽象而不依赖具体)</li></ul></li><li><p>final关键字</p></li><li><p>~~未完待续</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;类常量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类常量是公共的&lt;/li&gt;
&lt;li&gt;只能通过&lt;code&gt;类名&lt;/code&gt;, 使用 &lt;code&gt;::&lt;/code&gt; 静态访问类常量 (也可以使用实例化的对象通过&lt;code&gt;::&lt;/code&gt;来访问类常量)&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>02. 延迟静态绑定static关键字</title>
    <link href="http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-02/"/>
    <id>http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-02/</id>
    <published>2018-04-21T07:03:35.000Z</published>
    <updated>2018-05-19T16:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>延迟静态绑定是在PHP5.3引入的;</p></li><li><p><code>static</code> 类似于 <code>self</code>, 但它指的是调用 包含<code>static</code>的方法 的调用类, 而不是包含<code>static</code>的类;</p></li><li><p>一般 <code>static</code> 和 <code>self</code> 的使用语法有下面两种</p><ul><li><p><code>new static()</code> 与 <code>new self()</code> (用作实例化)</p></li><li><p><code>self::</code> 与 <code>static::</code> (静态方法调用)</p></li></ul></li><li><p>如何理解第2点中的意思</p><ul><li><p>如下, <code>Male</code>与<code>Female</code> 两个类分别继承自 <code>Human</code>, 并且继承了<code>createSelf()</code>方法, 结果却发现, <code>Male</code> 和 <code>Female</code> 调用<code>createSelf()</code>后, 创建的却是 <code>Human</code> 对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Human</div><div class="line">&#123;</div><div class="line">    public function createSelf()</div><div class="line">    &#123;</div><div class="line">        return new self();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Human</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Human</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">var_dump($boy-&gt;createSelf());</div><div class="line">$girl = new Female();</div><div class="line">var_dump($girl-&gt;createSelf());</div></pre></td></tr></table></figure></li><li><p>如果<code>Human</code>是个抽象类, 你甚至无法使用 <code>new self()</code><br><img src="/img/oop/php/static-self.png" width="350/"></p></li></ul></li><li><p>而使用了<code>new static()</code>效果就不一样了</p><ul><li>下面, <code>Male</code>与<code>Female</code> 两个类分别继承自 <code>Human</code>, 并且继承了<code>createSelf()</code>方法, 结果 <code>Male</code> 和 <code>Female</code> 调用<code>createSelf()</code>后, 创建的也都是各自的对象实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">abstract class Huma</div><div class="line">&#123;</div><div class="line">    public function createSelf()</div><div class="line">    &#123;</div><div class="line">        return new static();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Huma</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Huma</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">var_dump($boy-&gt;createSelf());</div><div class="line">$girl = new Female();</div><div class="line">var_dump($girl-&gt;createSelf());</div></pre></td></tr></table></figure></li></ul></li><li><p><code>static</code> 和 <code>self</code> 在调用静态方法时也是一样的</p><ul><li><p>如下结果, 两个类都是 <code>Hello!</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">abstract class Huma</div><div class="line">&#123;</div><div class="line">    public static function createSelf()</div><div class="line">    &#123;</div><div class="line">        self::say();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;Hello!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Male&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Female&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">$boy-&gt;createSelf();</div><div class="line">$girl = new Female();</div><div class="line">$girl-&gt;createSelf();</div></pre></td></tr></table></figure></li><li><p>如果想在父类的<code>公共静态方法</code>中, 调用子类自己重载的<code>静态方法</code>, 那就需要使用 <code>static::</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">abstract class Huma</div><div class="line">&#123;</div><div class="line">    public static function createSelf()</div><div class="line">    &#123;</div><div class="line">        static::say();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;Hello!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Male&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Female&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">$boy-&gt;createSelf(); // I am a Male</div><div class="line">$girl = new Female();</div><div class="line">$girl-&gt;createSelf();   // I am a Female</div></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;延迟静态绑定是在PHP5.3引入的;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;static&lt;/code&gt; 类似于 &lt;code&gt;self&lt;/code&gt;, 但它指的是调用 包含&lt;code&gt;static&lt;/code&gt;的方法 的调用类, 而不是包含&lt;code
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>01. 普通非静态 与 静态</title>
    <link href="http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-01/"/>
    <id>http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-01/</id>
    <published>2018-04-21T06:16:26.000Z</published>
    <updated>2018-04-21T10:51:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对于-属性-来说"><a href="#对于-属性-来说" class="headerlink" title="对于 属性 来说"></a>对于 <code>属性</code> 来说</h2><h3 id="类内部的调用方式"><a href="#类内部的调用方式" class="headerlink" title="类内部的调用方式"></a>类内部的调用方式</h3><ol><li><code>静态属性</code>是<strong>类</strong>的属性</li><li><code>普通属性</code>是<strong>类具体实例化出的对象</strong>的属性</li><li>所以二者是完全不同的, <code>调用方式</code>也非常不同<ul><li>静态属性 <code>self::$静态属性名</code> 、<code>类名::$静态属性名</code></li><li>普通属性 <code>$this-&gt;普通属性名</code></li></ul></li></ol><h3 id="类外部的调用方式"><a href="#类外部的调用方式" class="headerlink" title="类外部的调用方式"></a>类外部的调用方式</h3><ol><li><code>静态属性</code>是<strong>类</strong>的属性</li><li><code>普通属性</code>是<strong>类具体实例化出的对象</strong>的属性</li><li>所以二者是完全不同的, <code>调用方式</code>也非常不同<ul><li>静态属性 <code>类名::$静态属性名</code></li><li>普通属性 <code>实例化对象-&gt;普通属性名</code></li></ul></li></ol><h2 id="对于-方法-来说"><a href="#对于-方法-来说" class="headerlink" title="对于 方法 来说"></a>对于 <code>方法</code> 来说</h2><p>对于方法, 无论 <code>普通</code>还是<code>静态</code>, 它们都是属于类的, 所以理论上, 它们的调用方式 <code>-&gt;/::</code> 是可以互换的, 但事实上, 还是应该严格区分, 否则可能会报 <code>Deprecated...</code>;</p><h3 id="类内部的调用方式-1"><a href="#类内部的调用方式-1" class="headerlink" title="类内部的调用方式"></a>类内部的调用方式</h3><ol><li><code>普通方法</code> 可以使用 <code>$this-&gt;普通方法名()</code> 来进行调用;<ul><li>也可以使用 <code>self::$普通方法名()</code></li></ul></li><li><p><code>静态方法</code> 可以使用 <code>self::$静态方法名()</code> / <code>类名::$静态方法名()</code> 来进行调用;</p><ul><li>也可以使用 <code>$this-&gt;$静态方法名()</code></li></ul></li><li><p><strong>即类内部 <code>普通方法</code> 和 <code>静态方法</code> 的调用方式可以互换</strong>;</p></li></ol><h2 id="类外部的调用方式-1"><a href="#类外部的调用方式-1" class="headerlink" title="类外部的调用方式"></a>类外部的调用方式</h2><ol><li><p><code>普通方法</code> 可以使用 <code>实例化对象-&gt;普通方法名()</code> 来进行调用;</p><ul><li><strong>注意</strong>: 使用 <code>类名::普通方法名()</code> / <code>实例化对象::普通方法名()</code> 都会报 <code>Deprecated:非静态方法不应该按照镜头盖方法的调用方式来使用</code></li></ul></li><li><p><code>静态方法</code> 可以使用 <code>类名::$静态方法名()</code> 来进行调用;</p><ul><li><strong>注意</strong>：静态方法也可以使用 <code>实例化对象-&gt;普通方法名()</code> 来进行调用; (<strong>静态属性不可以</strong>)</li></ul></li></ol><h2 id="静态-非静态方法中的调用权限"><a href="#静态-非静态方法中的调用权限" class="headerlink" title="静态/非静态方法中的调用权限"></a>静态/非静态方法中的调用权限</h2><ol><li>静态方法中只能使用 静态调用方式<code>::</code>来调用 <code>静态属性</code>, <code>静态方法</code>, <code>非静态方法</code>; 不能使用<code>::</code>调用<code>非静态属性</code>;</li><li>非静态普通方法中可以调用 <code>静态/非静态</code> 的 <code>属性/方法</code>;</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>静态属性/方法, 只能通过 <code>::</code> 来访问;</li><li>普通属性只能通过 <code>-&gt;</code> 来访问; </li><li>普通方法能通过 <code>-&gt;/::</code> 来访问; (类外部只能通过<code>-&gt;</code>) </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对于-属性-来说&quot;&gt;&lt;a href=&quot;#对于-属性-来说&quot; class=&quot;headerlink&quot; title=&quot;对于 属性 来说&quot;&gt;&lt;/a&gt;对于 &lt;code&gt;属性&lt;/code&gt; 来说&lt;/h2&gt;&lt;h3 id=&quot;类内部的调用方式&quot;&gt;&lt;a href=&quot;#类内部的调用方式
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://blog.renyimin.com/2018/04/08/2018-04-08-rsa-01/"/>
    <id>http://blog.renyimin.com/2018/04/08/2018-04-08-rsa-01/</id>
    <published>2018-04-08T02:41:16.000Z</published>
    <updated>2018-04-08T05:14:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>加密和解密使用同样的规则(“密钥”);</p><ul><li>这种加密模式有一个最大弱点: 甲方必须把加密规则告诉乙方, 否则乙方无法解密; 这样, <code>保存和传递密钥</code> 就成了最头疼的问题;</li></ul><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li><p>非对称加密算法模式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">乙方生成两把密钥(公钥和私钥): 公钥是公开的, 任何人都可以获得, 私钥则是保密的;</div><div class="line">甲方获取乙方的公钥, 然后用它对信息加密;</div><div class="line">乙方得到加密后的信息, 用私钥解密;</div></pre></td></tr></table></figure></li><li><p><strong>如果公钥加密的信息只有私钥解得开, 那么只要私钥不泄漏, 通信就是安全的</strong>;</p></li><li><p>所谓非对称加密，其实很简单，就是加密和解密需要两把钥匙: 一把公钥和一把私钥;</p><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3></li><li><p>1977年, 三位数学家Rivest、Shamir 和 Adleman 设计了一种算法, 可以实现<code>非对称加密</code>, 这种算法用他们三个人的名字命名, 叫做<code>RSA算法</code>。从那时直到现在, RSA算法一直是最广为使用的”非对称加密算法”。<br> 毫不夸张地说, 只要有计算机网络的地方, 就有RSA算法;</p></li><li><p>这种算法非常可靠, 密钥越长, 它就越难破解。根据已经披露的文献, 目前被破解的最长RSA密钥是768个二进制位, 也就是说, 长度超过768位的密钥, 还无法破解(至少没人公开宣布)。<br> 因此可以认为, <strong>1024位的RSA密钥基本安全, 2048位的密钥极其安全</strong>;</p></li></ol><h3 id="RSA算法的原理"><a href="#RSA算法的原理" class="headerlink" title="RSA算法的原理"></a>RSA算法的原理</h3><p>RSA算法并不难, 只需要一点数论知识就可以理解 (要用到的四个数学概念)</p><p>~~ 未完待续</p><ol><li>互质关系<br> 如果两个正整数, 除了1以外, 没有其他公因子，我们就称这两个数是<code>互质关系</code>(coprime), 比如, 15和32没有公因子, 所以它们是互质关系;<br> 这说明, 不是质数也可以构成互质关系。(质数(prime number)又称素数, 有无限个, 质数定义为在大于1的自然数中, 除了1和它本身以外不再有其他因数)     </li><li>关于互质关系, 不难得到以下结论:<ul><li>任意两个质数构成互质关系, 比如13和61;</li><li>一个数是质数, 另一个数只要不是前者的倍数, 两者就构成互质关系, 比如3和10;</li><li>如果两个数之中, 较大的那个数是质数, 则两者构成互质关系, 比如97和57;</li><li>1和任意一个自然数是都是互质关系，比如1和99;</li><li>p是大于1的整数, 则p和p-1构成互质关系, 比如57和56;</li><li>p是大于1的奇数, 则p和p-2构成互质关系, 比如17和15;</li></ul></li><li></li></ol><p><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对称加密算法&quot;&gt;&lt;a href=&quot;#对称加密算法&quot; class=&quot;headerlink&quot; title=&quot;对称加密算法&quot;&gt;&lt;/a&gt;对称加密算法&lt;/h2&gt;&lt;p&gt;加密和解密使用同样的规则(“密钥”);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这种加密模式有一个最大弱点: 甲方必须把加
      
    
    </summary>
    
      <category term="RSA" scheme="http://blog.renyimin.com/categories/RSA/"/>
    
    
      <category term="RSA" scheme="http://blog.renyimin.com/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>PHP7语法新特性</title>
    <link href="http://blog.renyimin.com/2018/04/04/PHP/2018-04-04-php7new-base/"/>
    <id>http://blog.renyimin.com/2018/04/04/PHP/2018-04-04-php7new-base/</id>
    <published>2018-04-04T01:32:02.000Z</published>
    <updated>2018-04-04T02:30:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="null合并运算符"><a href="#null合并运算符" class="headerlink" title="null合并运算符 ??"></a>null合并运算符 <code>??</code></h3><ol><li><p><code>??</code> : 如果变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数;</p></li><li><p>先回顾一下 <code>isset</code> 用法: 只有 <code>显示声明为null</code> 或者 <code>未声明</code> 的变量, isset的结果为false</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$a = 0;</div><div class="line">$b = 0.0;</div><div class="line">$c = &apos;&apos;;</div><div class="line">$d = &apos;0&apos;;</div><div class="line">$e = &apos;0.0&apos;;</div><div class="line">$f = &apos;null&apos;;</div><div class="line">$g = [];</div><div class="line">$h = [&apos;name&apos; =&gt; &apos;renyimin&apos;, &apos;age&apos; =&gt; null];</div><div class="line">$i = null;</div><div class="line">var_dump(isset($a));    // true</div><div class="line">var_dump(isset($b));    // true</div><div class="line">var_dump(isset($c));    // true</div><div class="line">var_dump(isset($d));    // true</div><div class="line">var_dump(isset($e));    // true</div><div class="line">var_dump(isset($f));    // true</div><div class="line">var_dump(isset($g));    // true</div><div class="line"></div><div class="line">var_dump(isset($h[&apos;age&apos;])); // false</div><div class="line">// 注意: array_key_exists 即使键的值为null, 结果也是true</div><div class="line">var_dump(array_key_exists(&apos;age&apos;, $h));  // true</div><div class="line"></div><div class="line">var_dump(isset($h[&apos;address&apos;])); // false</div><div class="line">// 注意: array_key_exists 即使键的值为null, 结果也是true, 除非键真的不存在</div><div class="line">var_dump(array_key_exists(&apos;address&apos;, $h));  // false</div><div class="line"></div><div class="line">var_dump(isset($h[&apos;address&apos;])); // false</div><div class="line">var_dump(isset($i));    // false</div><div class="line">var_dump(isset($j));    // false</div></pre></td></tr></table></figure></li><li><p><code>??</code> 示例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$a = 0;</div><div class="line">$c = $a ?? 10;  // 相当于 $c = isset($a) ? $a : 10;</div><div class="line">echo $c;</div></pre></td></tr></table></figure></li></ol><p>~~ 未完待续</p><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;null合并运算符&quot;&gt;&lt;a href=&quot;#null合并运算符&quot; class=&quot;headerlink&quot; title=&quot;null合并运算符 ??&quot;&gt;&lt;/a&gt;null合并运算符 &lt;code&gt;??&lt;/code&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;??&lt;/code
      
    
    </summary>
    
      <category term="PHP" scheme="http://blog.renyimin.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.renyimin.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>103. 分区管理</title>
    <link href="http://blog.renyimin.com/2018/03/28/mysql/2018-03-28-mysql-103/"/>
    <id>http://blog.renyimin.com/2018/03/28/mysql/2018-03-28-mysql-103/</id>
    <published>2018-03-28T02:41:26.000Z</published>
    <updated>2018-03-28T02:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h2><p>MySQL5.1 提供了许多修改分区表的方式, 添加、删除、重新定义、合并或拆分已经存在的分区是可能的, 所有这些操作都可以通过使用<code>ALTER TABLE</code>命令的分区扩展来实现; 当然, 也有获得分区表和分区信息的方式;</p><h3 id="drop删除分区及数据"><a href="#drop删除分区及数据" class="headerlink" title="drop删除分区及数据"></a>drop删除分区及数据</h3><ol><li><p><code>mysql&gt; alter table user drop partition p4;</code></p></li><li><p><strong>注意</strong>: </p><ul><li><p>只能对每个分区进行删除, 不能针对每个子分区进行删除操作, 删除分区后子分区连同数据一并被删除;</p></li><li><p>删除分区后, 数据也被删除了;</p></li><li><p><strong><code>drop partition</code>删除分区的语法, 只能用于 <code>range/list</code> 分区</strong> (如果用来删除hash分区或者key分区,则会报错)</p></li><li><p>如果要删除 <code>hash/key</code> 分区, 则直接使用下面remove来移除分区即可, 一般也不直接删除数据;</p></li></ul></li></ol><h3 id="remove移除分区"><a href="#remove移除分区" class="headerlink" title="remove移除分区"></a>remove移除分区</h3><ol><li><p>使用remove移除分区, 注意仅仅是移除分区, <strong>并不会删除数据</strong> (和drop PARTITION不一样, 后者会连同数据一起删除)</p></li><li><p><code>ALTER TABLE tablename REMOVE PARTITIONING;</code> 这样就可以将一个原本分区的数据表变成不分区的表</p><ul><li><p>移除分区前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">0B    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p><code>ALTER TABLE</code>user<code>REMOVE PARTITIONING;</code> 移除分区后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user.MYD</div><div class="line">4.0K    user.MYI</div><div class="line">12K    user.frm</div></pre></td></tr></table></figure></li></ul></li><li><p>注意: 该语法是可以适用于 <code>range/list/key/hash</code> 类型的分区的;</p></li></ol><h3 id="创建不同类型分区"><a href="#创建不同类型分区" class="headerlink" title="创建不同类型分区"></a>创建不同类型分区</h3><h3 id="分区创建索引-整表创建索引"><a href="#分区创建索引-整表创建索引" class="headerlink" title="分区创建索引(整表创建索引)"></a>分区创建索引(整表创建索引)</h3><h3 id="新增分区"><a href="#新增分区" class="headerlink" title="新增分区"></a>新增分区</h3><h3 id="新增不同类型分区"><a href="#新增不同类型分区" class="headerlink" title="新增不同类型分区"></a>新增不同类型分区</h3><h3 id="合并分区"><a href="#合并分区" class="headerlink" title="合并分区"></a>合并分区</h3><ol><li><p>原本分区结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">4.0K    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p>合并 p2, p3这两个分区 </p><ul><li>分区并无子分区<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE tb_sub_ev REORGANIZE PARTITION p2,p3 INTO (</div><div class="line">    PARTITION m_p2_p3 VALUES LESS THAN (2000)</div><div class="line">    ( SUBPARTITION n0,</div><div class="line">        SUBPARTITION n1</div><div class="line">    ) </div><div class="line">);</div></pre></td></tr></table></figure></li></ul></li></ol><h3 id="拆分分区"><a href="#拆分分区" class="headerlink" title="拆分分区"></a>拆分分区</h3><h3 id="重新分区"><a href="#重新分区" class="headerlink" title="重新分区"></a>重新分区</h3><h2 id="每日自动新增分区"><a href="#每日自动新增分区" class="headerlink" title="每日自动新增分区"></a>每日自动新增分区</h2><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分区管理&quot;&gt;&lt;a href=&quot;#分区管理&quot; class=&quot;headerlink&quot; title=&quot;分区管理&quot;&gt;&lt;/a&gt;分区管理&lt;/h2&gt;&lt;p&gt;MySQL5.1 提供了许多修改分区表的方式, 添加、删除、重新定义、合并或拆分已经存在的分区是可能的, 所有这些操作都可以
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>102. 分区键, 主键, 唯一索引关系</title>
    <link href="http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-102/"/>
    <id>http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-102/</id>
    <published>2018-03-27T07:46:51.000Z</published>
    <updated>2018-03-28T02:09:40.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>若表有 <code>primary key</code> 或 <code>unique key</code>, 在对表进行分区时, 需要注意: <code>分区键</code> 必须包含在primary key或unique key列内, 这是为了确保主键的效率, 否则同一主键区的数据一个在Ａ分区, 一个在Ｂ分区, 显然会比较麻烦;<br> 可以说: 在分区表上, 用于分区表达式里的每一个字段都必须是<code>唯一性索引</code>的<code>一部分</code>;</p></li><li><p>如何理解上面的概念?</p></li><li><p>如果表中既有<code>主键</code>, 也有<code>唯一索引</code>: 无论<code>单列键</code>还是<code>多列键</code>分区都会失败</p><ul><li><p>单列唯一索引键分区报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `user` (  </div><div class="line">    `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;,  </div><div class="line">    `name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">    `sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男，1为女&apos;,</div><div class="line">`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,</div><div class="line">    PRIMARY KEY (`id`),</div><div class="line">UNIQUE KEY `age_unique` (`age`)</div><div class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8</div><div class="line">PARTITION BY RANGE COLUMNS (`age`)</div><div class="line">(</div><div class="line">PARTITION p0 VALUES LESS THAN (3),  </div><div class="line">PARTITION p1 VALUES LESS THAN (6),</div><div class="line">PARTITION p2 VALUES LESS THAN (9),  </div><div class="line">PARTITION p3 VALUES LESS THAN (12),  </div><div class="line">PARTITION p4 VALUES LESS THAN (MAXVALUE)</div><div class="line">);</div><div class="line">// 1503 - A PRIMARY KEY must include all columns in the table&apos;s partitioning function, Time: 0.011000s</div></pre></td></tr></table></figure></li><li><p>单列主键分区报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>),</p><pre><code>UNIQUE KEY `age_unique` (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);<br>// 1503 - A UNIQUE INDEX must include all columns in the table’s partitioning function, Time: 0.008000s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 多列(主键和唯一索引键)分区报错</div></pre></td></tr></table></figure><p>// 两列做分区也是失败的, 如下会报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>),</p><pre><code>UNIQUE KEY `age_unique` (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>,<code>age</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3, 10),<br>  PARTITION p1 VALUES LESS THAN (6, 15),<br>  PARTITION p2 VALUES LESS THAN (9, 20),<br>  PARTITION p3 VALUES LESS THAN (12, 25),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);<br>// 1503 - A PRIMARY KEY must include all columns in the table’s partitioning function, Time: 0.012000s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">4. 表中只有`主键`: 分区键属于主键内的键即可 (多列分区, 需要将列与主键一起作为主键才行)</div><div class="line">    - 分区键属于主键内的键即可</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 如果想多列分区, 则需要将多余的列与主键一起作为主键</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>, <code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>,<code>age</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3, 10),<br>  PARTITION p1 VALUES LESS THAN (6, 15),<br>  PARTITION p2 VALUES LESS THAN (9, 20),<br>  PARTITION p3 VALUES LESS THAN (12, 25),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">5. 表中只有`唯一索引`: 分区键属于`唯一索引键`内的键即可 (多列分区, 需要将多个列一起作为唯一索引)</div><div class="line">    - 分区键属于`唯一索引键`内的键即可</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  UNIQUE KEY (<code>id</code>, <code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 多列分区报错(竟然是报主键错): 1503 - A PRIMARY KEY must include all columns in the table&apos;s partitioning function, Time: 0.012000s</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br><code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br><code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br><code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,<br>  <code>age</code> int(2) NOT NULL DEFAULT ‘0’ COMMENT ‘年龄’,<br>UNIQUE KEY id_u (<code>id</code>),<br>  UNIQUE KEY age_u (<code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>, <code>age</code>)<br>(<br>PARTITION p0 VALUES LESS THAN (3,10),<br>PARTITION p1 VALUES LESS THAN (6,15),<br>PARTITION p2 VALUES LESS THAN (9,20),<br>PARTITION p3 VALUES LESS THAN (12,25),<br>PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- **多个唯一索引: 无论单列分区还是多列分区, 都会报错**</div></pre></td></tr></table></figure><p>// 单列分区报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  UNIQUE KEY id_u (<code>id</code>),</p><pre><code>UNIQUE KEY age_u (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);<br>```</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li></ul></li></ol><ul><li>要进行分区, 表中不能同时存在<code>主键</code>和<code>唯一索引键</code>, 也不能存在多个唯一索引键;</li><li>分区的键必须包含在<code>主键</code>内 或者 包含在<code>唯一索引键</code>内;</li><li>本篇只是测试了<code>range</code>这种分区类型, 其实上面的限制对于<code>range/list/hash/key</code>类型的分区都适用;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;若表有 &lt;code&gt;primary key&lt;/code&gt; 或 &lt;code&gt;unique key&lt;/code&gt;, 在对表进行分区时, 需要注意: &lt;code&gt;分区键&lt;/code&gt; 必须包含在primary key或unique key列内, 这是为了确保主键
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>101. 分区,分表,分库</title>
    <link href="http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-101/"/>
    <id>http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-101/</id>
    <published>2018-03-27T03:37:12.000Z</published>
    <updated>2018-03-28T02:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>MySQL是从5.1开始支持分区功能的, 在MySQL中, 数据是以文件的形势存在磁盘上的, 默认放在 ‘/mysql/data/‘ 下(可以通过my.cnf中的datadir来指定)</p></li><li><p>MyISAM引擎中, 一张表主要对应着三个文件: </p><ul><li><code>.frm</code>(与表相关的元数据信息都存放在frm文件, 包括表结构的定义信息等)</li><li><code>.myd</code>(存放表数据)</li><li><code>.myi</code>(存表索引)</li></ul></li><li><p>InnoDB引擎中, 一张表也是对应着三个文件: </p><ul><li><code>.frm</code>(和MyISAM差不多)</li><li><code>.ibd</code>文件和<code>.ibdata</code>文件, 都是存放innodb数据的文件, 之所以用两种文件来存放innodb的数据, 是因为innodb的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据, 还是用独享表空间存放存储数据<br>独享表空间存储方式使用.ibd文件,并且每个表一个ibd文件;<br>共享表空间存储方式使用.ibdata文件，所有表共同使用一个ibdata文件<br>可在mysql的配置文件通过<code>innodb_file_per_table</code>进行配置</li></ul></li><li><p>如果一张表的数据量太大, <code>.ibd</code>, <code>.myd</code>, <code>.myi</code> 之类的文件就会变的很大, 查找数据就会变的很慢, 此时就可以利用mysql的分区功能, 在物理上将这一张表对应的三个文件, 分割成许多个小块, 这样之后, 如果查找一条数据时, 就不用全部查找了, 只要知道这条数据在哪一块, 然后在那一块找即可;<br> 如果表的数据太大, 可能一个磁盘放不下, 此时, 还可以把数据分配到不同的磁盘里面去;</p></li></ol><h2 id="查看当前MySQL版本是否支持分区"><a href="#查看当前MySQL版本是否支持分区" class="headerlink" title="查看当前MySQL版本是否支持分区"></a>查看当前MySQL版本是否支持分区</h2><ol><li><p>对于MySQL5.6以下版本, 如果查询结果显示Empty, 表示不支持分区:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show variables like &apos;%partition%&apos;;</div><div class="line">Empty set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>对于mysql5.6以及以上版本, 需要使用下面的查询命令:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show plugins;</div></pre></td></tr></table></figure><p> 上面的查询方法会显示所有插件, 如果有如下插件的话, 表示支持分区:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| partition                  | ACTIVE   | STORAGE ENGINE     | NULL    | GPL     |</div></pre></td></tr></table></figure></li></ol><h2 id="分区的2种方式"><a href="#分区的2种方式" class="headerlink" title="分区的2种方式"></a>分区的2种方式</h2><h3 id="横向分区"><a href="#横向分区" class="headerlink" title="横向分区"></a>横向分区</h3><p>横向分区: 比如, 有1000W条数据, 分成十份, 前10W条数据放到第一个分区, 第二个10W条数据放到第二个分区, 依此类推; </p><ul><li>也就是把表分成了十份(和使用<code>merge</code>来分表有点像, 取出一条数据的时候, 这条数据包含了表结构中的所有字段);</li><li>横向分区, 并没有改变表的结构;</li></ul><h3 id="纵向分区"><a href="#纵向分区" class="headerlink" title="纵向分区"></a>纵向分区</h3><p>纵向分区: 比如, 在设计用户表的时候, 开始的时候没有考虑好, 把用户的所有信息都放到了一张表里面去, 这样这个表里面就会有比较大的字段, 如个人简介..等, 而这些简介也许不会有好多人去看，所以等到有人要看的时候, 再去查找(分表的时候, 可以把这样的大字段与主表分开来);</p><h2 id="横向分区-1"><a href="#横向分区-1" class="headerlink" title="横向分区"></a>横向分区</h2><p>mysql提供的分区属于第一种 <code>横向分区</code>, 并且细分成很多种方式</p><h3 id="range分区"><a href="#range分区" class="headerlink" title="range分区"></a>range分区</h3><ol><li><p>按照<code>RANGE</code>分区的表是通过如下方式进行分区的, 分区表达式的值位于一个给定的连续区间内的那些行, 会被放到一个分区中</p><ul><li><p>创建表同时进行分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `user` (  </div><div class="line">`id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;,  </div><div class="line">`name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">`sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男，1为女&apos;,  </div><div class="line">PRIMARY KEY (`id`)  </div><div class="line">) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1  </div><div class="line">PARTITION BY RANGE (id) (  </div><div class="line">PARTITION p0 VALUES LESS THAN (3),  </div><div class="line">PARTITION p1 VALUES LESS THAN ( 6 ),</div><div class="line">PARTITION p2 VALUES LESS THAN (9),  </div><div class="line">PARTITION p3 VALUES LESS THAN (12),  </div><div class="line">PARTITION p4 VALUES LESS THAN MAXVALUE  </div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>查看分区效果 (到数据表文件的存放处 <code>$ cd /Library/Application\ Support/appsolute/MAMP\ PRO/db/mysql56/</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">0B    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">0B    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">0B    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">0B    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">0B    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p>插入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">INSERT INTO `test`.`user` (`name` ,`sex`)VALUES (&apos;tank&apos;, &apos;0&apos;)  </div><div class="line">,(&apos;zhang&apos;,1),(&apos;ying&apos;,1),(&apos;张&apos;,1),(&apos;映&apos;,0),(&apos;test1&apos;,1),(&apos;tank2&apos;,1)  </div><div class="line">,(&apos;tank1&apos;,1),(&apos;test2&apos;,1),(&apos;test3&apos;,1),(&apos;test4&apos;,1),(&apos;test5&apos;,1),(&apos;tank3&apos;,1)  </div><div class="line">,(&apos;tank4&apos;,1),(&apos;tank5&apos;,1),(&apos;tank6&apos;,1),(&apos;tank7&apos;,1),(&apos;tank8&apos;,1),(&apos;tank9&apos;,1)  </div><div class="line">,(&apos;tank10&apos;,1),(&apos;tank11&apos;,1),(&apos;tank12&apos;,1),(&apos;tank13&apos;,1),(&apos;tank21&apos;,1),(&apos;tank42&apos;,1);</div></pre></td></tr></table></figure></li><li><p>再次查看分区效果<br>如下可以看到, 文件大小都是4.0K, 从这儿我们可以看出<strong>MyISAM引擎下, 分区的最小区块是4K (InnoDB貌似是96k)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">4.0K    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li></ul></li><li><p>数据测试</p><ul><li><p>初始数据为25条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select count(id) as count from user;</div><div class="line">+-------+</div><div class="line">| count |</div><div class="line">+-------+</div><div class="line">|    25 |</div><div class="line">+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>删除第四个分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; alter table user drop partition p4; </div><div class="line">Query OK, 0 rows affected (0.15 sec)</div><div class="line">Records: 0  Duplicates: 0  Warnings: 0</div></pre></td></tr></table></figure></li><li><p>可以发现, 存放在第四个分区里面的14条数据丢失了, 剩下的3个分区只有11条数据  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select count(id) as count from user; </div><div class="line">+-------+</div><div class="line">| count |</div><div class="line">+-------+</div><div class="line">|    11 |</div><div class="line">+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>查看分区文件, 发现第四个分区确实被删除了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li></ul></li><li><p>小结: 可以发现, 在进行range分区后</p><ul><li>会生成一个 <code>.par</code>文件,用来存储分区信息;</li><li>MyISAM/InnoDB引擎, 原有的 <code>.frm</code> 表结构文件没有被分隔;</li><li>MyISAM引擎, 原有的 <code>.MYD</code>数据文件, <code>.MYI</code>索引文件都被分隔了;</li><li>InnoDB引擎, 原有的 <code>.idb</code>数据文件被分隔了;</li></ul></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li></ul></li></ol><h3 id="List分区"><a href="#List分区" class="headerlink" title="List分区"></a>List分区</h3><ol><li><p>RANGE分区是从属于一个连续区间值的集合, 而LIST分区是基于某列的值从属于一个值列表集中的一个值</p></li><li><p>如果不用主键, 如下list分区可以创建成功，一般情况下, 一张表肯定会有一个主键(所以如果需要用其他键来做分区, 参考下一篇博文<a href="2017/12/17/mysql/2017-12-17-mysql-102/">分区键, 主键, 唯一索引关系</a>)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `list_part` (  </div><div class="line">`id` int(11) NOT NULL COMMENT &apos;用户ID&apos;,  </div><div class="line">`province_id` int(2) NOT NULL DEFAULT 0 COMMENT &apos;省&apos;,  </div><div class="line">`name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">`sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男, 1为女&apos;</div><div class="line">) ENGINE=INNODB DEFAULT CHARSET=utf8</div><div class="line">PARTITION BY LIST (province_id) (  </div><div class="line">PARTITION p0 VALUES IN (1,2,3,4,5,6,7,8),  </div><div class="line">PARTITION p1 VALUES IN (9,10,11,12,16,21),  </div><div class="line">PARTITION p2 VALUES IN (13,14,15,19),  </div><div class="line">PARTITION p3 VALUES IN (17,18,20,22,23,24)</div><div class="line">);</div><div class="line"></div><div class="line">// 创建成功, 会看到分区效果 (InnoDB默认分区最小是96k)</div><div class="line">$ ls |grep list_part |xargs du -sh</div><div class="line">96K    list_part#P#p0.ibd</div><div class="line">96K    list_part#P#p1.ibd</div><div class="line">96K    list_part#P#p2.ibd</div><div class="line">96K    list_part#P#p3.ibd</div><div class="line">12K    list_part.frm</div><div class="line">4.0K    list_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="hash分区"><a href="#hash分区" class="headerlink" title="hash分区"></a>hash分区</h3><ol><li><p>HASH分区主要用来确保数据在预先确定数目的分区中平均分布, 你所要做的只是</p><ul><li>对将要被哈希的列值, 指定一个列值或表达式;</li><li>指定被分区的表将要被分割成的分区数量;</li><li>对HASH分区，使用的用户函数必须返回一个大于0的整数值;</li></ul></li><li><p>创建表同时进行hash分区</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `hash_part` (  </div><div class="line">`id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;评论ID&apos;,  </div><div class="line">`comment` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;评论&apos;,  </div><div class="line">`ip` varchar(25) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;来源IP&apos;,  </div><div class="line">PRIMARY KEY (`id`)  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1  </div><div class="line">PARTITION BY HASH(id)  </div><div class="line">PARTITIONS 3;</div></pre></td></tr></table></figure></li><li><p>查看分区效果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ls |grep hash_part |xargs du -sh</div><div class="line">96K    hash_part#P#p0.ibd</div><div class="line">96K    hash_part#P#p1.ibd</div><div class="line">96K    hash_part#P#p2.ibd</div><div class="line">12K    hash_part.frm</div><div class="line">4.0K    hash_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="key分区"><a href="#key分区" class="headerlink" title="key分区"></a>key分区</h3><ol><li><p>按照KEY进行分区, 类似于按照HASH分区</p><ul><li>HASH分区是使用用户定义的表达式</li><li>而KEY分区的哈希函数是由MySQL服务器提供</li></ul></li><li><p>创建表同时进行key分区</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `key_part` (  </div><div class="line">`news_id` int(11) NOT NULL  COMMENT &apos;新闻ID&apos;,  </div><div class="line">`content` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;新闻内容&apos;,  </div><div class="line">`u_id` varchar(25) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;来源IP&apos;,  </div><div class="line">`create_time` DATE NOT NULL DEFAULT &apos;0000-00-00 00:00:00&apos; COMMENT &apos;时间&apos;  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8  </div><div class="line">PARTITION BY LINEAR HASH(YEAR(create_time))  </div><div class="line">PARTITIONS 3;</div></pre></td></tr></table></figure></li><li><p>查看分区效果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ls |grep key_part |xargs du -sh</div><div class="line">96Kkey_part#P#p0.ibd</div><div class="line">96Kkey_part#P#p1.ibd</div><div class="line">96Kkey_part#P#p2.ibd</div><div class="line">12Kkey_part.frm</div><div class="line">4.0Kkey_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h3><ol><li><p>子分区是分区表中每个分区的再次分割, 对于已经通过<code>RANGE</code>或<code>LIST</code>分区了的表再进行子分区是可能的, 子分区既可以使用<code>HASH</code>分区, 也可以使用<code>KEY</code>分区; 这也被称为复合分区(composite partitioning)</p><ul><li>如果一个分区中创建了子分区, 其他分区也要有子分区</li><li>如果创建了子分区, 每个分区中的<strong>子分区数必须相同</strong></li><li>同一分区内的子分区, 名字不相同, 不同分区内的子分区名子可以相同(5.1.50不适用)</li></ul></li><li><p>创建表同时, 进行子分区操作</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `sub_part` (  </div><div class="line">`news_id` int(11) NOT NULL  COMMENT &apos;新闻ID&apos;,  </div><div class="line">`content` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;新闻内容&apos;,  </div><div class="line">`u_id`  int(11) NOT NULL DEFAULT 0 COMMENT &apos;来源IP&apos;,  </div><div class="line">`create_time` DATE NOT NULL DEFAULT &apos;0000-00-00 00:00:00&apos; COMMENT &apos;时间&apos;  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8  </div><div class="line">PARTITION BY RANGE(YEAR(create_time))  </div><div class="line">SUBPARTITION BY HASH(TO_DAYS(create_time))(  </div><div class="line">    PARTITION p0 VALUES LESS THAN (1990)(</div><div class="line">        SUBPARTITION s0,SUBPARTITION s1,SUBPARTITION s2</div><div class="line">    ),  </div><div class="line">    PARTITION p1 VALUES LESS THAN (2000)(</div><div class="line">        SUBPARTITION s3,SUBPARTITION s4,SUBPARTITION good</div><div class="line">    ),  </div><div class="line">    PARTITION p2 VALUES LESS THAN MAXVALUE(</div><div class="line">        SUBPARTITION tank0,SUBPARTITION tank1,SUBPARTITION tank3</div><div class="line">    )  </div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>查看分区后, 数据表文件结构</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ ls |grep sub_part |xargs du -sh</div><div class="line">96K    sub_part#P#p0#SP#s0.ibd</div><div class="line">96K    sub_part#P#p0#SP#s1.ibd</div><div class="line">96K    sub_part#P#p0#SP#s2.ibd</div><div class="line">96K    sub_part#P#p1#SP#good.ibd</div><div class="line">96K    sub_part#P#p1#SP#s3.ibd</div><div class="line">96K    sub_part#P#p1#SP#s4.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank0.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank1.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank3.ibd</div><div class="line">12K    sub_part.frm</div><div class="line">4.0K    sub_part.par</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;MySQL是从5.1开始支持分区功能的, 在MySQL中, 数据是以文件的形势存在磁盘上的, 默认放在 ‘/mysql/d
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
