<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2019-10-28T06:49:31.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Chrome的Network分析 HTTP 报文</title>
    <link href="http://blog.renyimin.com/2019/10/28/http/2019-10-28-chrome-network-http/"/>
    <id>http://blog.renyimin.com/2019/10/28/http/2019-10-28-chrome-network-http/</id>
    <published>2019-10-28T06:49:31.000Z</published>
    <updated>2019-10-28T06:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>跨页面加载保存请求: <code>Preserve log</code><br>停用浏览器缓存: <code>Disable cache</code><br>模拟慢速网络连接: <code>Throttling</code>, 可自定义网速</p><p>手动清除浏览器 Cookie: 右键点击请求选择 <code>Clear Browser Cookies</code></p><p>过滤器, 属性过滤</p><ul><li><code>domain</code>: 仅显示来自指定域的资源 (你可以使用通配符字符 (*) 纳入多个域)</li><li><code>has-response-header</code>: 显示包含指定 HTTP 响应标头的资源</li><li><code>is</code>: 使用 <code>is:running</code> 可以查找 WebSocket 资源, <code>is:from-cache</code> 可查找缓存读出的资源<br><img src="/img/http/chrom-network-01.png"></li><li><code>larger-than</code>: 显示大于指定大小的资源(以字节为单位), 将值设为 1000 等同于设置为1k</li><li><code>method</code>: 显示通过指定 HTTP 方法类型检索的资源</li><li><p><code>mime-type</code>: 显示指定 MIME 类型的资源<br>多属性间通过空格实现 AND 操作</p></li><li><p><code>scheme</code>: 显示通过未保护 HTTP (<code>scheme:http</code>) 或受保护 HTTPS (<code>scheme:https</code>) 检索的资源</p></li><li><code>set-cookie-domain</code>: 显示具有 Set-Cookie 标头并且 Domain 属性与指定值匹配的资源</li><li><code>set-cookie-name</code>: 显示具有 Set-Cookie 标头并且名称与指定值匹配的资源</li><li><code>set-cookie-value</code>: 显示具有 Set-Cookie 标头并且值与指定值匹配的资源</li><li><code>status-code</code>: 仅显示 HTTP 状态代码与指定代码匹配的资源 (status-code:302)</li></ul><p>请求列表 Waterfall 列: 各请求相关活动的直观分析图<br>请求时间详细分布</p><ul><li>Queueing: 浏览器在以下情况下对请求排队<br>存在更高优先级的请求<br>此源已打开六个 TCP 连接，达到限值，仅适用于 HTTP/1.0 和 HTTP/1.1<br>浏览器正在短暂分配磁盘缓存中的空间</li><li>Stalled: 请求可能会因 Queueing 中描述的任何原因而停止</li><li>DNS Lookup: 浏览器正在解析请求的 IP 地址</li><li><p>Proxy Negotiation: 浏览器正在与代理服务器协商请求</p></li><li><p>Request sent: 正在发送请求</p></li><li>ServiceWorker Preparation: 浏览器正在启动 Service Worker</li><li>Request to ServiceWorker: 正在将请求发送到 Service Worker</li><li>Waiting (TTFB): 浏览器正在等待响应的第一个字节<br>TTFB 表示 Time To First Byte (至第一字节的时间)。 此时间包括 1 次往返延迟时间及服务器准备响应所用的时间</li><li>Content Download: 浏览器正在接收响应</li><li>Receiving Push: 浏览器正在通过 HTTP/2 服务器推送接收此响应的数据</li><li>Reading Push: 浏览器正在读取之前收到的本地数据</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;跨页面加载保存请求: &lt;code&gt;Preserve log&lt;/code&gt;&lt;br&gt;停用浏览器缓存: &lt;code&gt;Disable cache&lt;/code&gt;&lt;br&gt;模拟慢速网络连接: &lt;code&gt;Throttling&lt;/code&gt;, 可自定义网速&lt;/p&gt;
&lt;p&gt;手动清除浏览器 C
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.renyimin.com/2019/10/24/http/2019-10-24-OpenRestry/"/>
    <id>http://blog.renyimin.com/2019/10/24/http/2019-10-24-OpenRestry/</id>
    <published>2019-10-24T12:31:09.000Z</published>
    <updated>2019-10-28T02:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>OpenResty, 它是一个 “更好更灵活的 Nginx”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OpenResty, 它是一个 “更好更灵活的 Nginx”&lt;/p&gt;

      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark 抓包分析 HTTPS</title>
    <link href="http://blog.renyimin.com/2019/10/24/network/https-wireshark/"/>
    <id>http://blog.renyimin.com/2019/10/24/network/https-wireshark/</id>
    <published>2019-10-24T09:10:36.000Z</published>
    <updated>2019-11-04T02:43:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTPS-实现原理简介"><a href="#HTTPS-实现原理简介" class="headerlink" title="HTTPS 实现原理简介"></a>HTTPS 实现原理简介</h1><p>混合加密技术: 证书校验是使用CA机构提供的非对称加密, 然后使用非对称加密传递一个秘钥, 再使用对称加密</p><ol><li>要使用HTTPS进行通信的服务端, 需要向CA机构申请数字证书, 来证明自己身份的有效性 (服务器会提供一对 公私钥)</li><li>当客户端请求的时候, 服务端把证书发给客户端, 客户端验证证书有效, 也就是认证了服务端的有效性, 并且拿出数字证书中包含的 (服务器)公钥</li><li>客户端生成一个随机数, 使用(服务器写入CA证书中的)公钥加密, 并且传递给服务端</li><li>服务端用私钥解密, 拿到随机数。之后客户端和服务端就用这个随机数进行加密通信</li></ol><p>小结: HTTPS最关键的就是使用数字证书来证明服务器的有效性, 然后使用非对称加密来传递对称加密的密钥 (这里要说明的是, 实际使用中对称加密的密钥, 并不是直接由客户端生成的随机数, 这里为了说明方便而简单这样理解。实际上的对称加密密钥是要根据协商的加密算法组件来决定的)</p><h1 id="HTTPS-数字证书的验证-概述"><a href="#HTTPS-数字证书的验证-概述" class="headerlink" title="HTTPS 数字证书的验证 概述"></a>HTTPS 数字证书的验证 概述</h1><h2 id="CA证书认证流程概述"><a href="#CA证书认证流程概述" class="headerlink" title="CA证书认证流程概述"></a>CA证书认证流程概述</h2><ol><li><p>浏览器通过URL请求后台服务器, 服务器接收到请求后, 会给浏览器发送一个自己的CA数字证书</p></li><li><p>浏览器接收到数字证书后</p><ul><li>首先从证书的内容中获取证书的颁发机构, 然后从浏览器系统中去寻找此颁发机构是否为浏览器的信任机构 (这里解析一下, 世界上就几个权威的CA机构, 这几个机构的信息都是预先嵌入到我们的浏览器系统中的), 如果收到的一个数字证书但其颁发机构没有在我们浏览器系统中的, 那么就会有警告提示无法确认证书的真假, 如果是受信任的机构, 那么就到下一步</li><li>此时, 就可以从浏览器中找到CA机构的根公钥, 用这个根公钥去解析证书的签名(这个签名是证书发布之前CA机构用自己的根私钥加密而成的, 所以这里只能由根证书的根公钥去解密)得到一个hash值H1<br>然后用证书的指纹算法对证书的内容再进行hash计算得到另一个hash值H2, 如果此时H1和H2是相等的, 就代表证书没有被篡改过<br>在证书没有被修改过的基础上, 再检查证书上的使用者的URL (比如csdn.net) 和我们请求的URL是否相等, 如果相等, 那么就可以证明当前浏览器连接的网址也是正确的, 而不是一些钓鱼网之类的<blockquote><p>假设, 浏览器的连接被某个钓鱼网截取了, 钓鱼网也可以发一个自己的证书给浏览器, 要知道如果钓鱼网站的证书和真实网站的整数是同一个CA机构的话, 前面也是会被内置在浏览器中的CA机构的根公钥解密的, 也会得到 H1, 然后也可以通过证书没有被篡改的验证<br><strong>但是在证书没有被篡改的情况下, 通过对比证书上的URL和我们请求的URL, 就可以发现这个证书的URL不是我们所要连接的网址, 所以说钓鱼网也骗不了我们</strong></p></blockquote></li></ul></li><li><p>到这里, 已经验证了证书是没有被篡改的并且确认连接的URL也是正确的, 然后我们获取到了证书上的公钥<br> 这个公钥是你访问的网站服务器在申请CA证书时, 所提供的服务器 公钥(私钥由服务器自己保管), 这个公钥会写在CA证书内, 该公钥和CA证书的根公钥不是一回事, 注意区分</p></li></ol><h2 id="对称秘钥的安全传递"><a href="#对称秘钥的安全传递" class="headerlink" title="对称秘钥的安全传递"></a>对称秘钥的安全传递</h2><ol><li><p>接下来就是, 如何将一个对称加密算法的秘钥安全地发给服务器</p><ul><li>首先随机生成一个字符串S作为我们的秘钥, 然后通过证书中(由网站服务器所提供)的 公钥 加密成密文, 将密文发送给服务器 (因为此密文是用公钥加密的, 这是一个非对称加密, 这个密文只有你访问的网站服务器上的 私钥 才能进行解密, 所以说任何第三方截取到密文也是没用的, 因为没有对应的私钥所以解析不出来)<br>当然, 发送密文的时候也会对消息内容进行签名操作, 即对密文内容进行hash计算得到一个hash值, 将这个签名加密以后和消息内容一起发送出去<br>接收方收到消息以后, 通过私钥解析出密文和签名的hash值, 同时也会对接收的消息内容进行同样的计算得到另一个hash值, 通过比对两个hash值是否相同来判断密文是否有修改过</li></ul></li><li><p>过了以上步骤, 客户端和服务端都持有了对称加密算法的秘钥, 然后兄弟两就可以愉快地安全通信了</p></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>HTTPS采用的是 <code>非对称加密</code> + <code>对称加密</code> 这种混合加密方式<br>数字证书的验证有两个重要的步骤, 第一是验证数字证书没有被篡改以及连接的URL是否正确, 第二是通过RSA机制的原理安全地将对称加密算法的秘钥发送给对方。这两步都完成以后, 整个HTTPS的数字证书的验证就算是成功了。</p><h1 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h1><ol><li><p>所用连接: <a href="https://cdn.staticfile.org/font-awesome/4.6.3/css/font-awesome.min.css" target="_blank" rel="noopener">https://cdn.staticfile.org/font-awesome/4.6.3/css/font-awesome.min.css</a><br><img src="/img/https/wireshark-https-01.png"></p></li><li><p>抓包<br><img src="/img/https/wireshark-https-02.png"></p></li><li><p>分析<br>~~<br>参考: <a href="https://blog.csdn.net/firefile/article/details/80537053#1__3" target="_blank" rel="noopener">https://blog.csdn.net/firefile/article/details/80537053#1__3</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTPS-实现原理简介&quot;&gt;&lt;a href=&quot;#HTTPS-实现原理简介&quot; class=&quot;headerlink&quot; title=&quot;HTTPS 实现原理简介&quot;&gt;&lt;/a&gt;HTTPS 实现原理简介&lt;/h1&gt;&lt;p&gt;混合加密技术: 证书校验是使用CA机构提供的非对称加密, 然
      
    
    </summary>
    
      <category term="network" scheme="http://blog.renyimin.com/categories/network/"/>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/network/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
      <category term="network" scheme="http://blog.renyimin.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 证书申请</title>
    <link href="http://blog.renyimin.com/2019/10/24/http/2019-10-24-HTTS/"/>
    <id>http://blog.renyimin.com/2019/10/24/http/2019-10-24-HTTS/</id>
    <published>2019-10-24T09:10:36.000Z</published>
    <updated>2019-11-01T06:39:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p>系统, 浏览器</p><h1 id="数字证书的申请"><a href="#数字证书的申请" class="headerlink" title="数字证书的申请"></a>数字证书的申请</h1><h1 id="HTTPS-整体过程"><a href="#HTTPS-整体过程" class="headerlink" title="HTTPS 整体过程"></a>HTTPS 整体过程</h1><h2 id="浏览器验证证书流程"><a href="#浏览器验证证书流程" class="headerlink" title="浏览器验证证书流程"></a>浏览器验证证书流程</h2><ol><li>浏览器向服务器发请求<a href="https://www.example.com" target="_blank" rel="noopener">https://www.example.com</a></li><li>服务器将caFile和pubkey1(实际上就是申请证书流程中生成的一对秘钥中的公钥pubk1)发给浏览器</li><li>浏览器收到caFile文件进行分析，知道了签名算法；拿到CA机构名称后，由于浏览器中内置了该CA机构的根证书，所以知道pubk2；还知道caFile文件中的签名值sigVal以及原文（caFile的一部分，这部分在申请证书流程中称为CSR文件）知道这四个条件，就可以验证签名了，若验证签名成功则进入第4步。</li><li>接下来浏览器校验证书申请者的身份，从caFile中取出pubk1和网站地址w1。如果w1和<a href="https://www.example.com一摸一样，而且pubk1与连接成功后服务器发下来的公钥pubkey1相等，则说明浏览器连接的https://www.example.com没问题，而且没有受到中间人攻击" target="_blank" rel="noopener">https://www.example.com一摸一样，而且pubk1与连接成功后服务器发下来的公钥pubkey1相等，则说明浏览器连接的https://www.example.com没问题，而且没有受到中间人攻击</a></li><li>一旦服务器校验成功，接下来就是进行秘钥协商，这个协商成功后的秘钥就是真正用来加密业务数据的秘钥</li></ol><h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><ol><li>一台服务器只能有一个证书? 一个证书如何解决一台服务器上多个https域名的问题?</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h1&gt;&lt;p&gt;系统, 浏览器&lt;/p&gt;
&lt;h1 id=&quot;数字证书的申请&quot;&gt;&lt;a href=&quot;#数字证书的申请&quot; class=&quot;headerlink&quot; title=&quot;数字
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS是什么?SSL/TLS又是什么?</title>
    <link href="http://blog.renyimin.com/2019/10/23/http/2019-10-23-HTTS/"/>
    <id>http://blog.renyimin.com/2019/10/23/http/2019-10-23-HTTS/</id>
    <published>2019-10-23T12:31:09.000Z</published>
    <updated>2019-11-01T06:35:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前曾谈到过 HTTP 的一些缺点, 其中的 <code>无状态</code> 在加入 <code>Cookie</code> 后得到了解决, 而另两个缺点 — <code>明文</code> 和 <code>不安全</code> 仅凭 HTTP 自身是无力解决的, 需要引 入新的 <code>HTTPS</code> 协议</p><blockquote><p>由于 HTTP 天生 <code>明文</code> 的特点, 整个传输过程完全透明, 任何人都能够在链路中截获、 修改或者伪造请求 / 响应报文, 数据不具有可信性<br>比如, “代理服务”, 它作为 HTTP 通信的中间人, 在数据上下行的时候可以添加或删除部分头字段, 也可以使用黑白名单过滤 body 里的关键字, 甚至直接发送虚假的请求、响应, 而浏览器和源服务器都没有办法判断报文的真伪<br>因此 HTTP 明文这一特性, 对于网络购物、网上银行、证券交易等需要高度信任的应用场景来说是非常致命的。<br>如果没有基本的安全保护, 使用互联网进行各种电子商务、电子政务就根本无从谈起<br>对于安全性要求不那么高的新闻、视频、搜索等网站来说, 由于互联网上的恶意用户、恶意代理越来越多, 也很容易遭到 “流量劫持” 的攻击, 在页面里强行嵌入广告, 或者分流用户, 导致各种利益损失<br>对于你我这样的普通网民来说, HTTP 不安全的隐患就更大了, 上网的记录会被轻易截获, 网站是否真实也无法验证, 黑客可以伪装成银行网站, 盗取真实姓名、密码、银行卡等敏感信息, 威胁人身安全和财产安全</p></blockquote><h1 id="什么是安全"><a href="#什么是安全" class="headerlink" title="什么是安全?"></a>什么是安全?</h1><p>通常认为, 如果通信过程具备了四个特性, 就可以认为是安全的, 这四个特性是: <code>机密性</code>、<code>完整性</code>, <code>身份认证(真实性)</code> 和 <code>不可否认</code> (HTTPS 的出场, 为 HTTP 增加了这四大安全特性)</p><h2 id="机密性-Secrecy-Confidentiality"><a href="#机密性-Secrecy-Confidentiality" class="headerlink" title="机密性(Secrecy/Confidentiality)"></a>机密性(Secrecy/Confidentiality)</h2><p>机密性是指传输的数据是采用Session Key（会话密钥）加密的, 在网络上是看不到明文的</p><h2 id="完整性-Integrity-也叫一致性"><a href="#完整性-Integrity-也叫一致性" class="headerlink" title="完整性(Integrity, 也叫一致性)"></a>完整性(Integrity, 也叫一致性)</h2><p>是指为了避免网络中传输的数据被非法篡改, 使用MAC算法来保证消息的完整性 (每部分数据均有mac验证, 验证时计算数据的mac然后与接收到的mac比较, 即可确定数据是否完整)</p><h2 id="身份认证-Authentication"><a href="#身份认证-Authentication" class="headerlink" title="身份认证(Authentication)"></a>身份认证(Authentication)</h2><p>真实性是指通信的对方是可信的, 利用了PKI（Public Key Infrastructure 即『公钥基础设施』）来保证公钥的真实性</p><h2 id="不可否认-Non-repudiation-Undeniable"><a href="#不可否认-Non-repudiation-Undeniable" class="headerlink" title="不可否认(Non-repudiation/Undeniable)"></a>不可否认(Non-repudiation/Undeniable)</h2><p>是这个消息就是你给我发的, 无法伪装和否认, 是因为使用了签名的技术来保证的<br>session key 只有通信双方有, 并且不在网络上传输, 因此攻击者无法伪造使用session key加密的数据, 所以具有不可抵赖性<br><a href="https://zhidao.baidu.com/question/1435954777259099899.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1435954777259099899.html</a></p><p>（机密性由对称加密AES保证, 完整性由SHA384摘要算法保证, 身份认证和不可否认由RSA 非对称加密保证）</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS 是如何做到这些安全特性呢?<br>秘密就在于 HTTPS 名字里的 <code>S</code>, 它把 HTTP 下层的传输协议由 <code>TCP/IP</code> 换成了 <code>SSL/TLS</code>, 由 <code>HTTP over TCP/IP</code> 变成了 <code>HTTP over SSL/TLS</code>, 让 HTTP 运行在了安全的 SSL/TLS 协议上, 收发报文不再使用 Socket API, 而是调用专门的安全接口<br><img src="/img/http/https-01.png"><br>所以说, HTTPS 本身并没有什么 惊世骇俗的本事, 全是靠着后面的 <code>SSL/TLS</code> “撑腰”, 只要学会了 SSL/TLS, HTTPS 自然就OK了</p><blockquote><p>SSL 即安全套接层(Secure Sockets Layer), 在 OSI 模型中处于第 5 层(会话层), 由 网景公司于 1994 年发明, 有 v2 和 v3 两个版本, 而 v1 因为有严重的缺陷从未公开过<br>SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议, 于是互联网工程组 IETF 在 1999 年把它改名为 TLS(传输层安全, Transport Layer Security), 正式标准化, 版 本号从 1.0 重新算起, 所以 TLS1.0 实际上就是 SSLv3.1<br>到今天 TLS 已经发展出了三个版本, 分别是 2006 年的 1.1、2008 年的 1.2 和去年 (2018)的 1.3, 每个新版本都紧跟密码学的发展和互联网的现状, 持续强化安全和性能, 已经成为了信息安全领域中的权威标准<br>目前应用的最广泛的 TLS 是 1.2, 而之前的协议(TLS1.1/1.0、SSLv3/v2)都已经被认为是不安全的, 各大浏览器即将在 2020 年左右停止支持, 所以接下来的讲解都针对的是 TLS1.2</p></blockquote><ol><li><p>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成,  综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术</p></li><li><p>浏览器 和 服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信, 这些算法的组合被称为 <code>密码套件</code>(cipher suite, 也叫加密套件)<br>TLS 的密码套件命名非常规范, 格式很固定, 基本的形式是 <code>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</code><br>(比如 <code>ECDHE-RSA-AES256-GCM-SHA384</code> 的意思就是: “握手时使用 ECDHE 算法进行密钥交换, 用 RSA 签名和身份认证, 握手后的通信使用 AES 对称算法, 密钥长度 256 位, 分组模式是 GCM, 摘要算法 SHA384 用于消息认证和 产生随机数”)</p></li></ol><blockquote><p>说到 TLS, 就不能不谈到 OpenSSL, 它是一个著名的开源密码学程序库和工具包, 几乎支 持所有公开的加密算法和协议, 已经成为了事实上的标准, 许多应用软件都会使用它作为底层库来实现 TLS 功能, 包括常用的 Web 服务器 Apache、Nginx 等<br>OpenSSL 目前有三个主要的分支, 1.0.2 和 1.1.0 都将在今年(2019)年底不再维护, 最新的长期支持版本是 1.1.1<br>由于 OpenSSL 是开源的, 所以它还有一些代码分支, 比如 Google 的 BoringSSL、 OpenBSD 的 LibreSSL, 这些分支在 OpenSSL 的基础上删除了一些老旧代码, 也增加了一些新特性, 虽然背后有 大金主, 但离取代 OpenSSL 还差得很远</p></blockquote><h1 id="HTTPS如何为-HTTP-增加四个特性的"><a href="#HTTPS如何为-HTTP-增加四个特性的" class="headerlink" title="HTTPS如何为 HTTP 增加四个特性的"></a>HTTPS如何为 HTTP 增加四个特性的</h1><h2 id="机密性"><a href="#机密性" class="headerlink" title="机密性"></a>机密性</h2><p>机密性是信息安全的基础; 实现机密性最常用的手段是 “加密(encrypt)”, 只有掌握特殊 “钥匙”(密钥(key)) 的人才能再转换出原始文本; 加密前的消息叫 “明文”(plain text/clear text), 加密后的乱码叫”密文”(cipher text), 加密解密的操作过程就是”加密算法”<br>所有的加密算法都是公开的, 任何人都可以去分析研究, 而算法使用的 “密钥” 则必须保密, “密钥”就是一长串的数字, 但约定俗成的度量单位是 “位”(bit), 而不是”字节”(byte)<br>按照密钥的使用方式, 加密可以分为两大类: 对称加密和非对称加密</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><ol><li><p>“对称加密”就是指加密和解密时使用的密钥都是同一个, 是 “对称” 的。只要保证了密钥的安全, 那整个通信过程就可以说具有了 机密性</p></li><li><p>TLS 里有非常多的对称加密算法可供选择, 比如 RC4、DES、3DES、AES、ChaCha20 等, 但前三种算法都被认为是不安全的, 通常都禁止使用, 目前常用的只有 <code>AES</code> 和 <code>ChaCha20</code></p><ul><li><code>AES</code> 的意思是 高级加密标准(Advanced Encryption Standard), 密钥长度可以是 128、192 或 256; 它是 DES 算法的替代者, 安全强度很高, 性能也很好, 而且有的硬件还会做特殊优化, 所以非常流行, 是应用最广泛的对称加密算法</li><li><code>ChaCha20</code> 是 Google 设计的另一种加密算法, 密钥长度固定为 256 位, 纯软件运行性能要超过 AES, 曾经在移动客户端上比较流行, 但 ARMv8 之后也加入了 AES 硬件优化, 所以现在不再具有明显的优势, 但仍然算得上是一个不错算法</li></ul></li></ol><h3 id="加密分组模式"><a href="#加密分组模式" class="headerlink" title="加密分组模式"></a>加密分组模式</h3><p>对称算法还有一个 <code>分组模式</code> 的概念, 它可以让算法用固定长度的密钥加密任意长度的明文<br>最早的分组模式有 ECB、CBC、CFB、OFB 等几种, 但都陆续被发现有安全漏洞, 所以现在基本都不怎么用了; 最新的分组模式被称为 AEAD(Authenticated Encryption with Associated Data),在加密的同时增加了认证的功能, 常用的是 GCM、CCM 和 Poly1305<br>把上面这些组合起来, 就可以得到 TLS 密码套件中定义的对称加密算法。比如:<br><code>AES128-GCM</code>, 意思是密钥长度为 128 位的 AES 算法, 使用的分组模式是 GCM;<br><code>ChaCha20-Poly1305</code> 的意思是 ChaCha20 算法, 使用的分组模式是 Poly1305;</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>对称加密看上去好像完美地实现了机密性, 但其中有一个很大的问题: 如何把密钥安全地传递给对方, 术语叫 “密钥交换”; 因为在对称加密算法中只要持有密钥就可以解密, 如果你和网站约定的密钥在传递途中被黑客窃取, 那他就可以在之后随意解密收发的数据, 通信过程也就没有机密性可言了, 这个问题该怎么解决呢?</p><blockquote><p>这个问题该怎么解决呢?<br>你或许会说:“把密钥再加密一下发过去就好了”, 但传输“加密密钥的密钥”又成了新问题。这就像是”鸡生蛋、蛋生鸡”, 可以无限递归下去。只用对称加密算法, 是绝对无法解决密钥交换的问题的</p></blockquote><p>所以就出现了 非对称加密(也叫公钥加密算法)</p><ol><li>非对称加密 有两个密钥, 一个叫 <code>公钥</code>(public key), 一个叫 <code>私钥</code>(private key), 两个密钥是不同的(不对称), 公钥可以公开给任何人使用, 而私钥必须严格保密</li><li>公钥和私钥有个特别的 <code>单向</code> 性, 虽然都可以用来加密解密, 但公钥加密后只能用私钥解密, 反过来, 私钥加密后也只能用公钥解密</li><li><p>非对称加密可以解决 密钥交换 的问题。网站秘密保管私钥, 在网上任意分发公钥, 你想要登录网站只要用公钥加密就行了, 密文只能由私钥持有者才能解密。而黑客因为没有私钥, 所以就无法破解密文<br><img src="/img/http/https-publickey-01.png"></p></li><li><p>非对称加密算法的设计要比对称算法难得多, 在 TLS 里只有很少的几种, 比如 <code>DH</code>、 <code>DSA</code>、<code>RSA</code>、<code>ECC</code> 等</p></li></ol><ul><li><p><code>RSA</code> 可能是其中最著名的一个, 几乎可以说是非对称加密的代名词, 它的安全性基于 “整数分解” 的数学难题, 使用两个超大素数的乘积作为生成密钥的材料, 想要从公钥推算出私钥是非常困难的<br>10 年前 RSA 密钥的推荐长度是 1024, 但随着计算机运算能力的提高, 现在 1024 已经不安全, 普遍认为至少要 2048 位</p></li><li><p><code>ECC(Elliptic Curve Cryptography)</code> 是非对称加密里的 “后起之秀”, 它基于 “椭圆曲线 离散对数” 的数学难题, 使用特定的曲线方程和基点生成公钥和私钥<br>子算法 <code>ECDHE</code> 用于 密钥交换, <code>ECDSA</code> 用于数字签名<br>(比起 RSA, ECC 在安全强度和性能上都有明显的优势。160 位的 ECC 相当于 1024 位的 RSA, 而 224 位的 ECC 则相当于 2048 位的 RSA。因为密钥短, 所以相应的计算量、消耗 的内存和带宽也就少, 加密解密的性能就上去了, 对于现在的移动互联网非常有吸引力。)</p></li></ul><h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><ol><li><p>虽然非对称加密没有 密钥交换 的问题, 但因为它们都是基于复杂的数学难题, 运算速度很慢(即使是 ECC 也要比 对称加密算法AES 差上好几个数量级), 如果仅用非对称加密, 虽然保证了安全, 但实用性就变成了零</p></li><li><p>因此就需要考虑, 是不是能够把对称加密和非对称加密结合起来呢, 两者互相取长补短, 即能高效地加密解密, 又能安全地密钥交换, <strong>这就是现在 TLS 里使用的混合加密方式</strong>: </p><ul><li>在通信刚开始的时候使用 非对称算法, 比如 <code>RSA</code>、<code>ECDHE</code>, 首先解决密钥交换的问题</li><li>然后用随机数产生对称算法使用的 <code>会话密钥 (session key)</code>, 再用公钥加密。因为会话密钥很短, 通常只有 16 字节或 32 字节, 所以慢一点也无所谓</li><li>对方拿到密文后用私钥解密, 取出会话密钥。这样, 双方就实现了对称密钥的安全交换, 后续就不再使用非对称加密, 全都使用对称加密</li></ul></li><li><p>从下往上如下图<br><img src="/img/http/https-publickey-02.png"><br>这样混合加密就解决了对称加密算法的密钥交换问题, 而且安全和性能兼顾, 完美地实现了机密性</p></li></ol><p>不过这只是 “万里长征的第一步”, 后面还有完整性、身份认证、不可否认等特性没有实现, 所以现在的通信还不是绝对安全</p><h1 id="TLS1-2连接过程解析"><a href="#TLS1-2连接过程解析" class="headerlink" title="TLS1.2连接过程解析"></a>TLS1.2连接过程解析</h1><h2 id="HTTPS-建立连接"><a href="#HTTPS-建立连接" class="headerlink" title="HTTPS 建立连接"></a>HTTPS 建立连接</h2><ol><li><p>当你在浏览器地址栏里键入 <code>https</code> 开头的 URI, 再按下回车, 会发生什么呢?<br>浏览器首先要从 URI 里提取出协议名和域名, 因为协议名是 https, 所以浏览器就知道了端口号是默认的 443, 它再用 DNS 解析域名,  得到目标的 IP 地址, 然后就可以使用三次握手与网站建立 TCP 连接了</p></li><li><p>在 HTTP 协议里, 建立连接后, 浏览器会立即发送请求报文。但现在是 HTTPS 协议, 它需要再用另外一个 握手 过程, 在 TCP 上建立安全连接, 之后才是收发 HTTP 报文。<br> 这个 握手 过程与 TCP 有些类似, 是 HTTPS 和 TLS 协议里最重要、最核心的部分, 懂了它, 你就可以自豪地说自己 掌握了HTTPS</p></li></ol><h2 id="TLS-协议的组成"><a href="#TLS-协议的组成" class="headerlink" title="TLS 协议的组成"></a>TLS 协议的组成</h2><p>在讲 TLS 握手之前, 先简单介绍一下 TLS 协议的组成<br>TLS 包含几个子协议, 你也可以理解为它是由几个不同职责的模块组成, 比较常用的有 <code>记录协议</code>、<code>警报协议</code>、<code>握手协议</code>、<code>变更密码规范协议</code> 等</p><ul><li><code>记录协议</code>(Record Protocol) 规定了 TLS 收发数据的基本单位: 记录(record), 它有点像是 TCP 里的 segment, 所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出, 也并不需要像 TCP 那样返回 ACK</li><li><code>警报协议</code>(Alert Protocol) 的职责是向对方发出警报信息, 有点像是 HTTP 协议里的状态码。比如, protocol_version 就是不支持旧版本, bad_certificate 就是证书有问题, 收到 警报后另一方可以选择继续, 也可以立即终止连接</li><li><code>握手协议</code>(Handshake Protocol) 是 TLS 里最复杂的子协议, 要比 TCP 的 SYN/ACK 复 杂的多, 浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息, 然 后交换证书和密钥参数, 最终双方协商得到会话密钥, 用于后续的混合加密系统</li><li>最后一个是 <code>变更密码规范协议</code>(Change Cipher Spec Protocol), 它非常简单, 就是一个“通知”, 告诉对方, 后续的数据都将使用加密保护。那么反过来, 在它之前, 数据都是明文的</li></ul><p>……………</p><h1 id="迁移HTTPS的必要性"><a href="#迁移HTTPS的必要性" class="headerlink" title="迁移HTTPS的必要性"></a>迁移HTTPS的必要性</h1><p>如果你做移动应用开发的话, 那么就一定知道, Apple、Android、某信等开发平台在 2017 年就相继发出通知, 要求所有的应用必须使用 HTTPS 连接, 禁止不安全的 HTTP<br>在台式机上, 主流的浏览器 Chrome、Firefox 等也早就开始 强推 HTTPS, 把 HTTP 站 点打上 不安全 的标签, 给用户以 心理压力<br>Google 等搜索巨头还利用自身的“话语权”优势, 降低 HTTP 站点的排名, 而给 HTTPS 更大的权重, 力图让网民只访问到 HTTPS 网站<br>这些手段都逐渐 挤压 了纯明文 HTTP 的生存空间,  迁移到 HTTPS 已经不是要不要做的问题, 而是要怎么做的问题了, HTTPS 的大潮无法阻挡, 如果还是死守着 HTTP, 那么无疑会被冲刷到互联网的角落里<br>目前国内外的许多知名大站都已经实现了 全站 HTTPS , 打开常用的某宝、某东、某 浪, 都可以在浏览器的地址栏里看到 小锁头 , 如果你正在维护的网站还没有实施 HTTPS,  那可要抓点紧了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前曾谈到过 HTTP 的一些缺点, 其中的 &lt;code&gt;无状态&lt;/code&gt; 在加入 &lt;code&gt;Cookie&lt;/code&gt; 后得到了解决
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 缓存代理</title>
    <link href="http://blog.renyimin.com/2019/10/23/http/2019-10-23-HTTP-Proxy-cache/"/>
    <id>http://blog.renyimin.com/2019/10/23/http/2019-10-23-HTTP-Proxy-cache/</id>
    <published>2019-10-23T11:50:17.000Z</published>
    <updated>2019-10-23T11:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>把之前介绍的 HTTP 缓存控制 和 HTTP 的代理服务 结合起来就是这节所要说的 <strong>缓存代理</strong>, 也就是支持缓存控制的代理服务</p><p>之前谈到缓存时, 主要讲了客户端(浏览器)上的缓存控制, 它能够减少响应时间、节约带宽, 提升客户端的用户体验。但 HTTP 传输链路上, 不只是客户端有缓存, 服务器上的缓存也是非常有价值的, 可以让请求不必走完整个后续处理流程, 而是”就近”获得响应结果</p><p>HTTP 的服务器缓存功能主要由代理服务器来实现(即缓存代理), 而源服务器系统内部虽然也经常有各种缓存(如 Memcache、Redis、Varnish 等), 但与 HTTP 没有太多关系, 所以这里暂且不说</p><p><img src="/img/http/http-proxy-cache.png" width="500/"></p><p>1。 代理服务收到源服务器发来的响应数据后需要做两件事</p><pre><code>- 第一个当然是把报文转发给客户端, 而第二个就是把报文存入自己的 Cache 里- 下一次再有相同的请求, 代理服务器就可以直接发送 304 或者缓存数据, 不必再从源服务器那里获取。这样就降低了客户端的等待时间, 同时节约了源服务器的网络带宽</code></pre><ol><li>作为中转站的 代理服务器, 它除了具备 客户端和服务器的双重角色, 可以使用之前的 <code>Cache-Control</code> 属性外, 还有一些特有的 <code>Cache-Control</code> 属性<br> 因为它和客户端还是有一些不一样, 客户端的缓存只是用户自己使用, 而代理的缓存可能会为非常多的客户端提供服务。所以, 需要对它的缓存再多一些限制条件</li></ol><h1 id="代理服务器-Cache-Control"><a href="#代理服务器-Cache-Control" class="headerlink" title="代理服务器 Cache-Control"></a>代理服务器 Cache-Control</h1><ol><li>代理服务器首先要区分源服务器给他的缓存, 是让客户端缓存还是让代理缓存, 可以使用两个新属性 <code>private</code> 和 <code>public</code><ul><li>private 表示缓存只能在客户端保存, 是用户 私有的, 不能放在代理上与别人共享</li><li>而 public 的意思就是缓存完全开放, 是存在代理服务器上, 谁都可以存, 谁都可以用</li></ul></li></ol><ol><li><p>其次, 缓存失效后的重新验证也要区分开 (即 条件请求 <code>Last-modified</code> 和 <code>ETag</code>)</p><ul><li><code>must-revalidate</code> 是只要过期就必须回源服务器验证</li><li>而新的 <code>proxy-revalidate</code> 只要求代理的缓存过期后必须验证, 客户端不必回源, 只验证到代理这个环节就行了</li></ul></li><li><p>再其次, 缓存的生存时间可以使用新的 <code>s-maxage</code> (s 是 share 的意思, 注意 maxage 中间没有 “-“), 只限定在代理上能够存多久, 而客户端仍然使用 “max-age”</p></li><li><p>还有一个代理专用的属性 <code>no-transform</code><br> 代理有时候会对缓存下来的数据做一些优化, 比如把图片生成 png、webp 等几种格式, 方便今后的请求处理, 而 <code>no-transform</code> 就会禁止这样做, 不许“偷偷摸摸搞小动作”</p></li><li><p>注意: 源服务器在设置完“Cache-Control”后必须要为报文加上“Last- modified”或“ETag”字段。否则, 客户端和代理后面就无法使用条件请求来验证缓存是否有效, 也就不会有 304 缓存重定向</p></li><li><p>下面的流程图是完整的服务器端缓存控制策略, 可以同时控制客户端和代理<br><img src="/img/http/http-proxy-cache-001.png"><br><img src="/img/http/http-proxy-cache-002.png"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把之前介绍的 HTTP 缓存控制 和 HTTP 的代理服务 结合起来就是这节所要说的 &lt;strong&gt;缓存代理&lt;/strong&gt;, 也就是支持缓存控制的代理服务&lt;/p&gt;
&lt;p&gt;之前谈到缓存时, 主要讲了客户端(浏览器)上的缓存控制, 它能够减少响应时间、节约带宽, 提升客户
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 代理服务</title>
    <link href="http://blog.renyimin.com/2019/10/23/http/2019-10-23-HTTP-Proxy/"/>
    <id>http://blog.renyimin.com/2019/10/23/http/2019-10-23-HTTP-Proxy/</id>
    <published>2019-10-23T08:41:43.000Z</published>
    <updated>2019-10-23T06:09:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>引入 HTTP 代理后, 原来简单的双方通信就变复杂了一些, 加入了一个或者多个中间人,  但整体上来看, 还是一个有顺序关系的链条, 而且链条里相邻的两个角色仍然是简单的一对一通信, 不会出现越级的情况<br><img src="/img/http/http-proxy-01.png" width="500/"><br>链条的起点还是客户端(也就是浏览器), 中间的角色被称为代理服务器(proxy server), 链条的终点被称为源服务器(origin server)</p><h1 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h1><ol><li><p>“代理” 这个词听起来好像很神秘, 有点“高大上”的感觉, 但其实 HTTP 协议里对它并没有什么特别的描述, 它就是在客户端和服务器原本的通信链路中插入的一个中间环节, 也是一台服务器, 但提供的是 “代理服务”<br>所谓的“代理服务”就是指服务本身不生产内容, 而是处于中间位置转发上下游的请求和响应, 具有双重身份:面向下游的用户时, 表现为服务器, 代表源服务器响应客户端的请求;<br>而面向上游的源服务器时, 又表现为客户端, 代表客户端发送请求;</p></li><li><p>代理有很多的种类, 例如 匿名代理、透明代理、正向代理和反 向代理, 这里主要是聊聊实际工作中最常见的 反向代理, 它在传输链路中更靠近源服务器, 为源服务器提供代理服务</p></li></ol><h1 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h1><p>由于代理处在 HTTP 通信过程的中间位置, 相应地就对上屏蔽了真实客户端, 对下屏蔽了真实服务器。在这个中间层的里就可以做很多的事情, 为 HTTP 协议增加更多的灵活性, 实现客户端和服务器的 “双赢”</p><ol><li><p>代理最基本的一个功能是 <strong>负载均衡</strong><br>因为在面向客户端时屏蔽了源服务器, 客户端看到的只是代理服务器, 源服务器究竟有多少台、是哪些 IP 地址 客户端都不知道, 于是代理服务器就可以掌握请求分发的“大权”, 决定由后面的哪台服务器来响应请求<br>(代理中常用的负载均衡算法如轮询、一致性哈希等等, 这些算法的目标都是尽量把外部的流量合理地分散到多台源服务器, 提高系统的整体资源利用率和性能)</p></li><li><p>除了负载均衡, 代理服务还可以执行其他的更多功能, 如:</p><ul><li>健康检查: 使用“心跳”等机制监控后端服务器, 发现有故障就及时“踢出”集群, 保证服务高可用;</li><li>安全防护: 保护被代理的后端服务器, 限制 IP 地址或流量, 抵御网络攻击和过载; </li><li>加密卸载: 对外网使用 SSL/TLS 加密通信认证, 而在安全的内网不加密, 消除加解密成本;</li><li>数据过滤: 拦截上下行的数据, 任意指定策略修改请求或者响应; </li><li>内容缓存: 暂存、复用服务器响应</li></ul></li></ol><h1 id="代理相关头字段"><a href="#代理相关头字段" class="headerlink" title="代理相关头字段"></a>代理相关头字段</h1><p>代理的好处很多, 但因为它“欺上瞒下”的特点, 隐藏了真实客户端和服务器, 如果双方想要获得这些“丢失”的原始信息, 该怎么办呢?</p><h2 id="via"><a href="#via" class="headerlink" title="via"></a>via</h2><p>首先, 代理服务器需要用字段 <code>Via</code> 标明代理的身份<br>Via 是一个通用字段, 请求头 或 响应头里都可以出现, 每当报文经过一个代理节点, 代理服务器就会把自身的信息追加到字段的末尾, 就像是经手人盖了一个章; 如果通信链路中有很多中间代理, 就会在 Via 里形成一个链表, 这样就可以知道报文究竟走过了多少个环节才到达了目的地。<br>例如下图中有两个代理: proxy1 和 proxy2, 客户端发送请求会经过这两个代理, 依次添加就是 “Via: proxy1, proxy2”, 等到服务器返回响应报文的时候就要反过来走, 头字段就是 “Via: proxy2, proxy1”<br><img src="/img/http/http-via-01.png" width="500/"></p><p>不过, Via 字段只解决了客户端和源服务器判断是否存在代理的问题, 还不能知道对方的真实信息</p><h2 id="X-Forwarded-For、X-Real-IP"><a href="#X-Forwarded-For、X-Real-IP" class="headerlink" title="X-Forwarded-For、X-Real-IP"></a>X-Forwarded-For、X-Real-IP</h2><p>比如, 服务器的 IP 地址应该是保密的, 关系到企业的内网安全, 所以一般不会让客户端知道。 但反过来看, 服务器通常是需要知道客户端的真实 IP 地址, 方便做访问控制、用户画像、统计分析<br>可惜的是 HTTP 标准里并没有为此定义头字段, 但已经出现了很多 “事实上的标准”, 最 常用的两个头字段是 <code>X-Forwarded-For</code> 和 <code>X-Real-IP</code></p><ol><li><p><code>X-Forwarded-For</code> 的字面意思是 “为谁而转发”, 形式上和 “Via” 差不多, 也是每经过一个代理节点就会在字段里追加一个信息; 但 <code>Via</code> 追加的是代理主机名(或者域名), 而 <code>X-Forwarded-For</code> 追加的是请求方的 IP 地址, 所以, 在字段里最左边的 IP 地址就客户端的地址</p></li><li><p><code>X-Real-IP</code> 是另一种获取客户端真实 IP 的手段, 它的作用很简单, 就是记录客户端 IP 地址, 没有中间的代理信息, 相当于是 <code>X-Forwarded-For</code> 的简化版。如果客户端和源 服务器之间只有一个代理, 那么这两个字段的值就是相同的<br>…</p></li></ol><h1 id="代理协议"><a href="#代理协议" class="headerlink" title="代理协议"></a>代理协议</h1><ol><li><p>有了 <code>X-Forwarded-For</code> 等头字段, 源服务器就可以拿到准确的客户端信息了, 但对于代理服务器来说它并不是一个最佳的解决方案<br> 因为通过 “X-Forwarded-For” 操作代理信息必须要解析 HTTP 报文头, 这对于代理来说成本比较高, 原本只需要简单地转发消息就好, 而现在却必须要费力解析数据再修改数据, 会降低代理的转发性能<br> 另一个问题是 “X-Forwarded-For” 等头必须要修改原始报文, 而有些情况下是不允许甚至不可能的(比如使用 HTTPS 通信被加密)</p></li><li><p>所以就出现了一个专门的“代理协议”(The PROXY protocol), 它由知名的代理软件 HAProxy 所定义, 也是一个“事实标准”, 被广泛采用(注意并不是 RFC)</p></li><li><p>……</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引入 HTTP 代理后, 原来简单的双方通信就变复杂了一些, 加入了一个或者多个中间人,  但整体上来看, 还是一个有顺序关系的链条, 而且链条里相邻的两个角色仍然是简单的一对一通信, 不会出现越级的情况&lt;br&gt;&lt;img src=&quot;/img/http/http-proxy-
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 缓存控制 和 条件请求</title>
    <link href="http://blog.renyimin.com/2019/10/22/http/2019-10-22-HTTP-CacheControl/"/>
    <id>http://blog.renyimin.com/2019/10/22/http/2019-10-22-HTTP-CacheControl/</id>
    <published>2019-10-22T06:30:12.000Z</published>
    <updated>2019-10-23T11:43:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于 HTTP “请求 - 应答” 模式的特点, 这里将 HTTP的缓存 大致分为 <strong>客户端缓存</strong>(也就是浏览器的缓存) 和 <strong>服务器端缓存</strong></p><h1 id="服务器端缓存控制"><a href="#服务器端缓存控制" class="headerlink" title="服务器端缓存控制"></a>服务器端缓存控制</h1><p>服务器标记资源有效期使用的头字段是 <code>Cache-Control</code> </p><ol><li><p><code>Cache-Control</code> 字段里的 <code>max-age</code> 属性 是用来标记资源的有效期 (<code>Cache-Control: max-age=30</code> 相当于告诉浏览器, 这个页面只能缓存30秒, 之后就算是过期)<br> 注意: <code>max-age</code> 是 “生存时间” (又叫 “新鲜度” “缓存寿命”), 时间的计算起点是 响应报文的创建时刻(即 <code>Date</code> 字段, 也就是离开服务器的时刻), 而不是客户端收到报文的时刻, 也就是说包含了在链路传输过程中所有节点所停留的时间<br> (比如, 服务器设定 <code>Cache-Control: max-age=5</code>, 但因为网络质量很糟糕, 等浏览器收到响应报文已经过去了 4 秒, 那么这个资源在客户端就最多能够再存 1 秒钟, 之后就会失效)<br> <code>max-age</code> 是 HTTP 缓存控制最常用的属性, 此外在响应报文里还可以用如下其他的属性来更精确地指示浏览器应该如何使用缓存</p></li><li><p><code>no_store</code>: 不允许缓存, 用于某些变化非常频繁的数据, 例如秒杀页面</p></li><li><p><code>no_cache</code>: 它的字面含义容易与 <code>no_store</code> 搞混, 实际的意思并不是不允许缓存, 而是可以缓存, 但在使用之前必须要去服务器验证是否过期, 是否有最新的版本 (貌似就是虽然存了, 但是不用)<br> 如果验证没有过期, 则直接取客户端浏览器中的缓存; 否则, 客户端重新缓存新的数据, 然后再返回;<br> “no-cache” 属性可以理解为 “max-age=0, must-revalidate” </p></li><li><p><code>must-revalidate</code>: 又是一个和 <code>no_cache</code> 相似的词, 它的意思是如果缓存不过期就可以继续使用, 但过期了如果还想用就必须去服务器验证<br> 这个状态貌似比较正常, 缓存有效就用, 缓存没效就重新取~~ </p></li><li><p>除了 <code>Cache-Control</code>, 服务器也可以使用 <code>Expires</code> 字段来标记资源的有效期, 不过其优先级低于 Cache-Control; 另外还有一个历史遗留字段 <code>Pragma: no-cache</code>, 它相当于 <code>Cache-Control: no-cache</code>, 除非是为了兼容HTTP/1.0 否则不建议使用</p></li><li><p>小结<br>服务器的缓存控制策略流程图大致如下, 对照着它就可以在今后的后台开发里明确 <code>Cache-Control</code> 的用法了<br><img src="/img/http/http-cache-control-01.png" width="500/"></p></li></ol><p><img src="/img/http/http-cache-control-02.png"></p><h1 id="客户端缓存控制"><a href="#客户端缓存控制" class="headerlink" title="客户端缓存控制"></a>客户端缓存控制</h1><ol><li><p>注意: 仅仅当 服务器端 使用了 <code>Cache-Control: max-age=30</code> 时, 你点击浏览器 “刷新” 按钮会发现, 貌似缓存并未生效, 如下测试:<br>~~<br>这是因为: 不止是服务器可以发 <code>Cache-Control</code> 头, 客户端浏览器也可以发 <code>Cache-Control</code>, 也就是说 “请求-应答” 的双方都可以用这个字段进行缓存控制, 互相协商缓存的使用策略<br>(而当你点 “刷新” 按钮的时候, 浏览器会在请求头里加一个 <code>Cache-Control: max-age=0</code>, 由于 <code>max-age</code> 是 “生存时间”, max-age=0 的意思就是 不进行缓存,而是每次都去服务器去最新数据, 而本地缓存里的数据至少保存了几秒钟)</p></li><li><p><code>Ctrl+F5</code>(MacOS是 <code>shift+command+r</code>) 的 <strong>强制刷新</strong> 又是什么样的呢?<br>尝试发现, 它是发了一个 <code>Cache-Control: no-cache</code>, 含义和 <code>max-age=0</code> 基本一样, 就看后台的服务器怎么理解, 通常两者的效果是相同的</p></li><li><p>那么, 浏览器的缓存究竟什么时候才能生效呢?</p><ul><li>试着点一下浏览器的 <code>前进</code> <code>后退</code> 按钮, 再看开发者工具, 你就会惊喜地发现 <code>from disk cache</code> 的字样, 意思是没有发送网络请求, 而是读取的磁盘上的缓存<br>~~</li><li>如果用第 18 讲里的重定向跳转功能, 也可以发现浏览器使用了缓存<br>~~</li></ul></li></ol><h1 id="条件请求"><a href="#条件请求" class="headerlink" title="条件请求"></a>条件请求</h1><p>HTTP 协议定义了一系列 <code>If</code> 开头的 <code>条件请求</code> 字段, 专门用来验证资源是否过期 (验证的责任是服务器的责任, 浏览器只需”坐享其成”)</p><p>1.客户端的 条件请求 一共有5个头字段, 我们最常用的是 <code>if-Modified-Since</code> 和 <code>If-None-Match</code> 这两个<br>它们需要第一次的响应报文预先提供 <code>last-modified</code> 和 <code>ETag</code>, 然后第二次请求时就可以带上缓存里的原值, 验证资源是否是最新的, 如果资源没有变, 服务器就回应一个 <code>304 Not Modified</code>, 表示缓存依然有效, 浏览器就可以更新一下有效期, 然后放心大胆地使用缓存了<br><img src="/img/http/http-cache-if-01.png"></p><ul><li><code>Last-modified</code> 很好理解, 就是文件的最后修改时间</li><li><code>ETag</code> 是 “实体标签(Entity Tag)” 的缩写, 是资源的一个唯一标识, 主要是用来解决 修改时间无法准确区分文件变化的问题<br>比如, 一个文件在一秒内修改了多次, 但因为修改时间是秒级, 所以这一秒内的新版本无法区分<br>再比如, 一个文件定期更新, 但有时会是同样的内容, 实际上没有变化, 如果用修改时间判断 就会误以为发生了变化, 传送给浏览器就会浪费带宽<br>使用 ETag 就可以精确地识别资源的变动情况, 让浏览器能够更有效地利用缓存</li><li>ETag 还有 “强”、”弱” 之分<br>强 ETag 要求资源在字节级别必须完全相符<br>弱 ETag 在值前有个 <code>W/</code> 标记, 只要求资源在语义上没有变化, 但内部可能会有部分发生了改变(例如 HTML 里的标签顺序调整, 或者多了几个空格)</li><li>小结<blockquote><p>还是拿生鲜速递做比喻最容易理解:<br>你打电话给超市, “我这个西瓜是 3 天前买的, 还有最新的吗?”。超市看了一下库存,  说:“没有啊, 我这里都是 3 天前的。”于是你就知道了, 再让超市送货也没用, 还是吃 冰箱里的西瓜吧。这就是“if-Modified-Since”和“Last-modified”<br>但你还是想要最新的, 就又打电话:“有不是沙瓤的西瓜吗?”, 超市告诉你都是沙瓤的 (Match), 于是你还是只能吃冰箱里的沙瓤西瓜。这就是“If-None-Match”和“弱 ETag”<br>第三次打电话, 你说 “有不是 8 斤的沙瓤西瓜吗?”, 这回超市给了你满意的答复:“有 个 10 斤的沙瓤西瓜”。于是, 你就扔掉了冰箱里的存货, 让超市重新送了一个新的大西瓜。这就是“If-None-Match”和“强 ETag”</p></blockquote></li></ul><p>2.条件请求里其他的三个头字段是 <code>If-Unmodified-Since</code>、<code>If-Match</code> 和 <code>If-Range</code>, 其实只要你掌握了 <code>if-Modified-Since</code> 和 <code>If-None-Match</code>, 可以轻易地举一反三</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>用好 HTTP 的缓存控制和条件请求, 可以减少响应时间、节约网络流量</p><ol><li>服务器使用 Cache-Control 设置缓存策略, 常用的是 <code>max-age</code>, 表示资源的有效期</li><li>浏览器收到数据就会存入缓存, 如果没过期就可以直接使用, 过期就要去服务器验证是否仍然可用</li><li>验证资源是否失效需要使用 <strong>条件请求</strong>, 常用的是 <code>if-Modified-Since</code> 和 <code>If-None-Match</code>, 收到 304 就可以复用缓存里的资源</li><li>验证资源是否被修改的条件有两个: <code>Last-modified</code> 和 <code>ETag</code>, 需要服务器预先在响应报文里设置, 搭配条件请求使用</li><li>浏览器也可以发送 <code>Cache-Control</code> 字段, 使用 <code>max-age=0</code> 或 <code>no_cache</code> 刷新数据</li></ol><h1 id="客户端缓存控制补充"><a href="#客户端缓存控制补充" class="headerlink" title="客户端缓存控制补充"></a>客户端缓存控制补充</h1><p>客户端在 HTTP 缓存体系里要面对的是 代理 和 源服务器, 所以是必须区别对待的, 直接上图<br><img src="/img/http/http-proxy-cache-003.png"><br><img src="/img/http/http-proxy-cache-004.png"><br>比如 如果服务端返回的响应头设置了 <code>Cache-Control: public, max-age=10, s-maxage=30</code>, 数据可以在浏览器里存 10 秒, 在代理上存 30 秒</p><ol><li><p>可以看到, 关于缓存的生存时间, 多了两个新属性 <code>max-stale</code> 和 <code>min-fresh</code></p><ul><li><code>max-stale</code> 的意思是如果代理上的缓存过期了也可以接受, 但不能过期太多, 超过 x 秒就会不要了</li><li><code>min-fresh</code> 的意思是缓存必须有效, 而且必须在 x 秒后依然有效<br>(max-stale是可以接受的过期时间, min-fresh是可以接受的新鲜时间。 不好理解也没事, 这两个属性用的不多, 可以以后实际遇到了再体会)</li></ul></li><li><p>有的时候客户端还会发出一个特别的 <code>only-if-cached</code> 属性, 表示只接受代理缓存的数据, 不接受源服务器的响应。如果代理上没有缓存或者缓存过期, 就应该给客户端返回一个 504(Gateway Timeout)</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;鉴于 HTTP “请求 - 应答” 模式的特点, 这里将 HTTP的缓存 大致分为 &lt;strong&gt;客户端缓存&lt;/strong&gt;(也就是浏览器的缓存) 和 &lt;strong&gt;服务器端缓存&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;服务器端缓存控制&quot;&gt;&lt;a href=&quot;#服务器
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>XSS(Cross Site Scripting) 跨站脚本攻击</title>
    <link href="http://blog.renyimin.com/2019/10/22/http/2019-10-22-XSS/"/>
    <id>http://blog.renyimin.com/2019/10/22/http/2019-10-22-XSS/</id>
    <published>2019-10-22T02:29:12.000Z</published>
    <updated>2019-10-22T06:16:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>XSS(Cross Site Scripting)攻击 全称 跨站脚本攻击, 是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆, 故将跨站脚本攻击缩写为XSS, XSS是一种经常出现在web应用中的计算机安全漏洞</p><p><a href="https://www.cnblogs.com/mao2080/p/9460397.html" target="_blank" rel="noopener">https://www.cnblogs.com/mao2080/p/9460397.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;XSS(Cross Site Scripting)攻击 全称 跨站脚本攻击, 是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆, 故将跨站脚本攻击缩写为XSS, XSS是一种经常出现在web应用中的计算机安全漏洞&lt;/p&gt;
&lt;p&gt;&lt;a h
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>XSRF</title>
    <link href="http://blog.renyimin.com/2019/10/22/http/2019-10-22-XSRF/"/>
    <id>http://blog.renyimin.com/2019/10/22/http/2019-10-22-XSRF/</id>
    <published>2019-10-22T02:29:12.000Z</published>
    <updated>2019-10-22T03:36:58.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Cookie</title>
    <link href="http://blog.renyimin.com/2019/10/21/http/2019-10-21-HTTP-Cookie/"/>
    <id>http://blog.renyimin.com/2019/10/21/http/2019-10-21-HTTP-Cookie/</id>
    <published>2019-10-21T05:10:31.000Z</published>
    <updated>2019-10-22T07:37:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP协议 是 “无状态” 的, 但却是可扩展的, 后来发明的 Cookie 技术, 就给 HTTP 增加了 “记忆能力”</p><h1 id="Cookie-的工作过程"><a href="#Cookie-的工作过程" class="headerlink" title="Cookie 的工作过程"></a>Cookie 的工作过程</h1><p>Cookie 的传递主要用到两个字段: 响应头字段 <code>Set-Cookie</code> 和 请求头字段 <code>Cookie</code></p><ol><li><p>当用户通过浏览器第一次访问服务器的时候, 服务器肯定是不知道他的身份的。所以, 服务器就要创建一个独特的身份标识数据, 格式是 <code>key=value</code>, 然后放进 <code>Set-Cookie</code> 字段里,  随着响应报文一同发给浏览器<br> 浏览器收到响应报文, 看到里面有 <code>Set-Cookie</code>, 知道这是服务器给的身份标识, 于是就保存起来, 下次再请求的时候就自动把这个值放进 <code>Cookie</code> 字段里发给服务器 </p></li><li><p>浏览器第二次请求时, 请求头字段里面有了 Cookie 字段, 服务器就知道这个用户不是新人, 之前来过, 就拿出 Cookie 里的值, 识别出用户的身份, 然后提供个性化的服务<br> 服务器可以在响应头里添加多个 <code>Set-Cookie</code>, 存储多个 “key=value”, 但浏览器这边发送时不需要用多个 Cookie 字段, 只要在一行里用 <code>;</code> 隔开就行</p></li></ol><h1 id="Cookie-的属性"><a href="#Cookie-的属性" class="headerlink" title="Cookie 的属性"></a>Cookie 的属性</h1><p>Cookie 就是服务器委托浏览器存储在客户端里的一些数据, 而这些数据通常都会记录用户的关键识别信息。所以在 “key=value” 外, 还需要再用一些手段来保护Cookie, 防止外泄或窃取, 这些手段就是 Cookie 的属性<br><img src="/img/http/http-cookie-01.png"></p><p>为了保护 Cookie, 还要给它设置有效期、作用域等属性, 常用的有 Max-Age、Expires、Domain、HttpOnly 等</p><h2 id="Expires、Max-Age"><a href="#Expires、Max-Age" class="headerlink" title="Expires、Max-Age"></a>Expires、Max-Age</h2><p>首先, 我们应该设置 Cookie 的生存周期, 也就是它的有效期, 让它只能在一段时间内可用, 就像是食品的” 保鲜期”, 一旦超过这个期限浏览器就认为是 Cookie 失效, 在存储里删除, 也不会发送给服务器<br>Cookie 的有效期可以使用 <code>Expires</code> 和 <code>Max-Age</code> 两个属性来设置:</p><ul><li><code>Expires</code> 俗称 “过期时间”, 用的是绝对时间点, 可以理解为 “截止日期”(deadline)</li><li><code>Max-Age</code> 用的是相对时间, 单位是<strong>秒</strong>, 浏览器用收到报文的时间点再加上 Max-Age, 就可以得到失效的绝对时间</li><li><code>Expires</code> 和 <code>Max-Age</code> 可以同时出现, 两者的失效时间可以一致, 也可以不一致, <strong>但浏览器会优先采用 Max-Age 计算失效期</strong></li></ul><h2 id="Domain、Path"><a href="#Domain、Path" class="headerlink" title="Domain、Path"></a>Domain、Path</h2><p>其次, 需要设置 Cookie 的作用域, 让浏览器仅发送给特定的服务器 和 URI, 避免被其他网站盗用<br>作用域的设置比较简单, <code>Domain</code> 和 <code>Path</code> 指定了 Cookie 所属的域名和路径, 浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分, 对比 Cookie 的属性, 如果不满足条件, 就不会在请求头里发送 Cookie</p><p>使用这两个属性可以为不同的 域名 和 路径 分别设置各自的 Cookie (比如 “/19-1” 用一个 Cookie, “/19-2” 再用另外一个 Cookie, 两者互不干扰, 不过现实中为了省事, 通常 Path 就用一个 “/“ 或者直接省略,表示域名下的任意路径都允许使用该Cookie)</p><h2 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h2><p>最后要考虑的就是Cookie 的安全性了, 尽量不要让服务器以外的人看到<br>写过前端的同学一定知道, 在 JS 脚本里可以用 <code>document.cookie</code> 来读写 Cookie 数据,这就带来了安全隐患, 有可能会导致 “跨站脚本”(XSS)攻击窃取数据</p><p>属性 “HttpOnly” 会告诉浏览器, 此 Cookie 只能通过浏览器 HTTP 协议传输, 禁止其他方式访问, 浏览器的 JS 引擎就无法使用 document.cookie 等一切相关的 API, 脚本攻击也就无从谈起了</p><h2 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h2><p>另一个属性 “SameSite”, 可以防范”跨站请求伪造”(XSRF)攻击, 设置 <code>SameSite=Strict</code> 可以严格限定 Cookie 不能随着跳转链接跨站发送, 而 <code>SameSite=Lax</code> 则略宽松一点, 允许 GET/HEAD 等安全方法, 但禁止 POST 跨站发送</p><h2 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h2><p>还有一个属性叫 “Secure”, 表示这个 Cookie 仅能用 HTTPS 协议加密传输, 明文的 HTTP 协议会禁止发送, 但 Cookie 本身不是加密的,浏览器里还是以明文的形式存在</p><h1 id="Cookie-应用"><a href="#Cookie-应用" class="headerlink" title="Cookie 应用"></a>Cookie 应用</h1><p>Cookie 最基本的一个用途就是身份识别, 保存用户的登录信息, 实现会话事务 (比如, 你用账号和密码登录某电商, 登录成功后网站服务器就会发给浏览器一个 Cookie, 内容大概是“name=yourid”, 这样就成功地把身份标签贴在了你身上)</p><p>Cookie 的另一个常见用途是广告跟踪</p><h1 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h1><p>Cookie 是由浏览器负责存储的, 而不是操作系统。所以, 它是 <strong>浏览器绑定</strong> 的, 只能在本浏览器内生效 (如果你换个浏览器或者换台电脑, 新的浏览器里没有服务器对应的 Cookie, 只能再走一遍 Set-Cookie 流程)<br>Cookie 这个词来源于计算机编程里的术语 <code>Magic Cookie</code>, 意思是不透明的数据, 并不是 “小甜饼” 的含义 (虽然字面意思如此)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTTP协议 是 “无状态” 的, 但却是可扩展的, 后来发明的 Cookie 技术, 就给 HTTP 增加了 “记忆能力”&lt;/p&gt;
&lt;h1 id=&quot;Cookie-的工作过程&quot;&gt;&lt;a href=&quot;#Cookie-的工作过程&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>02.</title>
    <link href="http://blog.renyimin.com/2019/09/23/nio-socket/2019-09-23-02/"/>
    <id>http://blog.renyimin.com/2019/09/23/nio-socket/2019-09-23-02/</id>
    <published>2019-09-23T08:42:19.000Z</published>
    <updated>2019-09-23T08:42:24.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="NIO" scheme="http://blog.renyimin.com/categories/NIO/"/>
    
    
      <category term="NIO" scheme="http://blog.renyimin.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>01.</title>
    <link href="http://blog.renyimin.com/2019/09/23/nio-socket/2019-09-23-01/"/>
    <id>http://blog.renyimin.com/2019/09/23/nio-socket/2019-09-23-01/</id>
    <published>2019-09-23T08:41:23.000Z</published>
    <updated>2019-09-23T08:42:09.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="NIO" scheme="http://blog.renyimin.com/categories/NIO/"/>
    
    
      <category term="NIO" scheme="http://blog.renyimin.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>四次挥手</title>
    <link href="http://blog.renyimin.com/2019/08/28/network/tcpip-4-wave/"/>
    <id>http://blog.renyimin.com/2019/08/28/network/tcpip-4-wave/</id>
    <published>2019-08-28T11:26:17.000Z</published>
    <updated>2019-11-01T08:52:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP是全双工模式, 需要两边的连接全部关闭, 此TCP会话才算完全关闭, 四次挥手使得TCP的全双工连接能够可靠的终止<br>另外 <code>TIMED_WAIT</code> 也使得连接终止后网络上残余的发送给该连接的数据被丢弃而不至于被新连接接收<br><img src="/img/tools/wireshark/wave.jpg"></p><ol><li><p>第一次挥手<br>当客户端认为数据发送完成, 它会向服务器发送 释放连接 的请求, 该请求只有报文头, 头中携带的主要参数为: <code>FIN=1, seq=u</code> (此时, 客户端 将进入 <code>FIN-WAIT-1</code> 状态)</p><ul><li><code>FIN=1</code>: 表示该报文段是一个 连接释放 请求</li><li><code>seq=u</code>: u-1 是 客户端 向 服务器 发送的最后一个字节的序号</li></ul></li><li><p>第二次挥手<br>服务器收到连接释放请求后, 会通知相应的应用程序, 告诉它 <code>客户端-&gt;服务器</code> 这个方向的连接已经释放 (此时 服务器 进入 <code>CLOSE-WAIT</code> 状态), 并向 客户端 发送连接释放的应答, 其报文头包含: <code>ACK=1, seq=v, ack=u+1</code><br>客户端收到该应答, 进入 <code>FIN-WAIT-2</code> 状态, 等待服务器发送连接释放请求<br>(第二次挥手完成后, <code>客户端-&gt;服务端</code> 方向的连接已经释放, 服务端不会再接收数据, 客户端也不会再发送数据; 但 <code>服务端-&gt;客户端</code> 方向的连接仍然存在, <strong>服务端可以继续向客户端发送数据</strong>)</p></li><li><p>第三次挥手<br>当服务器向客户端发完所有数据后, 向客户端发送连接释放请求, 请求头: <code>FIN=1, ACK=1, seq=w, ack=u+1</code>, 服务器便进入 <code>LAST-ACK</code> 状态</p></li><li><p>第四次挥手<br>客户端收到释放请求后, 向服务器发送确认应答, 此时客户端进入 <code>TIME-WAIT</code> 状态, 该状态会持续2MSL时间, 若该时间段内没有服务器的重发请求的话, 就进入 <code>CLOSED</code> 状态; 当服务器收到确认应答后, 也便进入 <code>CLOSED</code> 状态</p></li></ol><h1 id="四次挥手抓包"><a href="#四次挥手抓包" class="headerlink" title="四次挥手抓包"></a>四次挥手抓包</h1><ol><li><p>服务端监听端口<br><img src="/img/network/tcp-socket-01.png"></p></li><li><p>客户端连接上来<br><img src="/img/network/tcp-socket-02.png"></p></li><li><p>客户端发送消息 + 客户端断开连接 + 服务器端断开连接<br><img src="/img/network/tcp-socket-03.png"></p></li></ol><p>隐藏 RST 标志位 相关内容</p><!--# TCP 的 RST 标志位1. 正常关闭连接的时候使用 `FIN`标志位, 但是如果是关闭异常连接, 则使用RST, 发送RST包与FIN包存在两点不同：    - RST不必等缓冲区的包都发出去, 直接就丢弃缓存区的包发送RST包。而FIN需要先处理完缓存区的包    - 接收端收到RST包后, 也不必发送ACK包来确认而FIN需要ACK包确认 (可以观察上述抓包效果)2. TCP处理程序会在自己认为的异常时刻发送RST包, 存在如下几种场景:    - A向B发起连接, 但B之上并没有应用监听相应的端口, 这时B操作系统上的TCP处理程序会发RST包     - 请求超时    有89、27两台主机。主机89向主机27发送了一个SYN, 表示希望连接8888端口, 主机27回应了主机89一个SYN表示可以连接。但是主机89却很不友好, 莫名其妙的发送了一个RST表示我不想连接你了    后来经过排查发现, 在主机89上的程序在建立了socket之后, 用setsockopt的SO_RCVTIMEO选项设置了recv的超时时间为100ms (这和服务器单方面关闭是一样的)3. 在一个已关闭的socket上收到数据    比如, AB正常建立连接了, 正在通讯时, A向B发送了FIN包要求关连接, B发送ACK后, 网断了, A通过若干原因放弃了这个连接（例如进程重启）。网通了后, B又开始发数据包, A收到后表示压力很大, 不知道这野连接哪来的, 就发了个RST包强制把连接关了, B收到后会出现connect reset by peer错误4. 字节流接收不完全    关于TCP, 我想我们在教科书里都读到过一句话, 'TCP是一种可靠的连接'。 而这可靠有这样一种含义, 那就是操作系统接收到的来自TCP连接中的每一个字节, 我都会让应用程序接收到。如果应用程序不接收怎么办? RST5. 参考: https://blog.csdn.net/h2604396739/article/details/85255092--><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>1.为什么 ServerSocket 关闭后, ClientSocket 仍可以发送一次请求, 第二次发送才显示发送不出去<br>客户端socket连接成功 (三次握手)<br><img src="/img/network/tcp-question-socket-01.png"></p><p>客户端第一次写数据成功 + <code>服务端-&gt;客户端</code>单向socket连接关闭<br><img src="/img/network/tcp-question-socket-02.png"></p><p><code>客户端-&gt;服务器</code>socket连接仍然存在, 可以发送, 但是发送后, 服务器端返回了 <code>RST</code>标志位<br><img src="/img/network/tcp-question-socket-03.png"><br>再次发送才会发送失败</p><p>2.为什么客户端要先进入 TIME-WAIT 状态, 等待2MSL时间后才进入CLOSED状态?<br>为了保证服务器能收到客户端的确认应答, 若客户端发完确认应答后直接进入CLOSED状态, 那么如果该应答丢失, 服务器等待超时后就会重新发送连接释放请求, 但此时客户端已经关闭了, 不会作出任何响应, 因此服务器永远无法正常关闭</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/cenglinjinran/p/8482412.html" target="_blank" rel="noopener">https://www.cnblogs.com/cenglinjinran/p/8482412.html</a><br><a href="http://dy.163.com/v2/article/detail/ECQ04CUU05315U6Q.html" target="_blank" rel="noopener">http://dy.163.com/v2/article/detail/ECQ04CUU05315U6Q.html</a></p><!--<img src="/img/tools/wireshark/wave-4.png" />-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCP是全双工模式, 需要两边的连接全部关闭, 此TCP会话才算完全关闭, 四次挥手使得TCP的全双工连接能够可靠的终止&lt;br&gt;另外 &lt;code&gt;TIMED_WAIT&lt;/code&gt; 也使得连接终止后网络上残余的发送给该连接的数据被丢弃而不至于被新连接接收&lt;br&gt;&lt;img s
      
    
    </summary>
    
      <category term="network" scheme="http://blog.renyimin.com/categories/network/"/>
    
    
      <category term="network" scheme="http://blog.renyimin.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>TCP 三次握手 -- 为什么TCP需要三次握手, 而不是两次, 四次或五次?</title>
    <link href="http://blog.renyimin.com/2019/08/28/network/tcpip-questions-01/"/>
    <id>http://blog.renyimin.com/2019/08/28/network/tcpip-questions-01/</id>
    <published>2019-08-28T11:17:36.000Z</published>
    <updated>2019-11-01T09:38:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三次握手简介"><a href="#三次握手简介" class="headerlink" title="三次握手简介"></a>三次握手简介</h1><p><img src="/img/network/tcp-00.jpg"><br>注意:</p><ul><li><code>ACK</code>(ACKNOWLEDGEMENT) 是TCP的标志位 (wireshark抓包可查看 <code>Flags</code>下的<code>Acknowledgement</code>字段)</li><li><code>ack</code> 不一样, 是应答的下一次的起始点 (wireshark抓包可查看 <code>Acknowledgement number</code> 字段)<!-- (混乱使用`ACK`和`ack`的地方很多, 如 https://segmentfault.com/a/1190000018918988, https://blog.csdn.net/lengxiao1993/article/details/82771768) --></li></ul><h2 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h2><p>客户端向服务端发送连接请求报文段, 该报文段的头部中 <code>SYN=1</code>, <code>ACK=0</code>, <code>seq=x</code>; 请求发送后, 客户端便进入 <code>SYN-SENT</code> 状态</p><ul><li><code>SYN=1, ACK=0</code> 表示该报文段为连接请求报文</li><li><code>seq=x</code> 为本次TCP通信的字节流的初始序号</li></ul><h2 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h2><p>服务端收到连接请求报文段后, 如果同意连接, 则会发送一个应答: <code>SYN=1, ACK=1, seq=y, ack=x+1</code> (ack 对应上一步的 seq); 该应答发送完成后便进入 <code>SYN-RCVD</code> 状态</p><ul><li><code>SYN=1, ACK=1</code> 表示该报文段为连接同意的应答报文</li><li><code>seq=y</code> 表示服务端作为发送者时, 发送字节流的初始序号</li><li><code>ack=x+1</code> 表示服务端希望下一个数据报发送序号从x+1开始的字节</li></ul><h2 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h2><p>当客户端收到连接同意的应答后, 还要向服务端发送一个确认报文段, 表示: 服务端发来的连接同意应答已经成功收到; 该报文段的头部为: <code>ACK=1, seq=x+1, ack=y+1</code> (<code>此处的ack</code> 对应上一步的 <code>seq</code>, <code>此处的seq</code>对应<code>上一步的ack</code>)<br>客户端发完这个报文段后便进入ESTABLISHED状态, 服务端收到这个应答后也进入 <code>ESTABLISHED</code> 状态, 此时连接的建立完成!</p><h1 id="为什么两次握手不行"><a href="#为什么两次握手不行" class="headerlink" title="为什么两次握手不行?"></a>为什么两次握手不行?</h1><h2 id="确保两方都有-发送-接收-消息的能力"><a href="#确保两方都有-发送-接收-消息的能力" class="headerlink" title="确保两方都有 发送/接收 消息的能力"></a>确保两方都有 发送/接收 消息的能力</h2><ol><li><p>TCP 建立连接时的 <code>三次握手</code>, 如果用一次电话通讯来描述, 过程大致如下<br>第一步: server 知道 client 可以发消息<br><img src="/img/network/tcp-01.png"><br>第二步: client 知道 server 可以接收/发送消息<br><img src="/img/network/tcp-02.png"><br>第三步: server 知道 client 可以接收消息<br><img src="/img/network/tcp-03.png"></p></li><li><p>如果少了第三步, 那 server 是不知道 client 是否可以接收消息 的</p><blockquote><ul><li>灰猫：”喂喂, 白猫通知, 你能听到我说话么?” 这是是第一次握手, 也就是说 灰猫(client)发送消息的能力没有问题</li><li>然后白猫回了一句 “灰猫同志, 我能听到你说话! 那你能听到我说话么?” 这是第二次握手 白猫回了黑猫一句, 说明server具有 发送消息的能力, 也同时具有接受消息的能力</li><li>灰猫到此时, 虽然具有发送消息的能力, 但服务端不确定其是否具有接收消息的能力, 最后灰猫说 “嗯, 白猫同志, 我也能听到你说话, 开始….”, 这是第三次握手  client可以回答server的问题, 证明client也具备接收消息的能力<br><strong>这样就可以进行通话了(建立了TCP连接)</strong></li></ul></blockquote></li><li><p>小结, 对于两次握手来说</p></li></ol><ul><li>服务器收到了客户端的消息, 服务器知道了客户端是可以发送消息的</li><li>客户端从服务器接受到了消息, 客户端知道了服务器接受到了我的消息才回复, 说明服务器的接受消息能力和发送消息的能力没问题</li><li>但由于没有第三次握手, 所以服务器不知道客户端是否具有接受消息的能力</li></ul><p>综上所述, 客户端确保了服务器的接受发送没问题, 但是服务器仅仅只知道客户端的发送消息没问题, 这并不是可靠的, 所以两次握手不可以</p><h2 id="网络阻塞时-两次握手出现问题"><a href="#网络阻塞时-两次握手出现问题" class="headerlink" title="网络阻塞时, 两次握手出现问题"></a>网络阻塞时, 两次握手出现问题</h2><ol><li><p>假设客户端和服务器进行TCP连接, 第一次握手时请求发生了阻塞<br><img src="/img/network/tcp-001.png"></p></li><li><p>由于客户端没有收到服务器的应答报文, 客户端认为这个TCP连接请求丢失了; 于是会重新发送TCP连接请求, 这次没有阻塞, 成功连接了<br>因为是讨论的两次握手, 所以只进行两次连接就可以进行通信了<br><img src="/img/network/tcp-002.png"></p></li><li><p>通信结束后, 也正常断开了连接<br><img src="/img/network/tcp-003.png"></p></li><li><p>谁曾想, 突然, 最开始的阻塞的连接请求(A客户端以为丢失了), 但其实并没有丢失, 只是阻塞了而已, 阻塞一段时间网络又畅通了, 于是TCP连接请求成功到达了服务器, 服务器又以为是客户端又要进行数据传输, 于是服务器就又对这个连接请求进行应答, 两次握手, 于是又成功建立了TCP连接<br><img src="/img/network/tcp-004.png"><br>但是由于客户端以为这个连接请求已经丢失了, 所以不会利用这个建立的连接进行数据通信, 虽然服务器分配给了资源给客户端, 但是客户端并不进行数据传输, 这样就白白浪费了服务器的资源, 试想一下如果网络很拥堵, <strong>服务器岂不是浪费了一堆资源, 可能对于正常的连接请求都无法处理了</strong></p></li></ol><p>参考: <a href="http://dy.163.com/v2/article/detail/ECQ04CUU05315U6Q.html" target="_blank" rel="noopener">http://dy.163.com/v2/article/detail/ECQ04CUU05315U6Q.html</a></p><h1 id="为什么不是-四次-五次握手"><a href="#为什么不是-四次-五次握手" class="headerlink" title="为什么不是 四次, 五次握手?"></a>为什么不是 四次, 五次握手?</h1><p>从经典的 <code>红蓝军通讯问题</code> 来分析, 两军为了实现协同出击, 在通讯上要想实现最终确认, 理论上其实是不可行的(双方对通信的确认是没有止境的), 也是无解的;<br>在TCP协议中, 不使用四次, 五次握手, 是因为再多的握手和 三次握手 达到的效果其实都是一样的, 反而消耗更多的资源, 得不偿失<br>所以 TCP/IP<strong>至少且比较恰当的是</strong>需要三次握手</p><p>主要是为了防止 失效的请求报文段 被服务端接收, 从而产生错误</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三次握手简介&quot;&gt;&lt;a href=&quot;#三次握手简介&quot; class=&quot;headerlink&quot; title=&quot;三次握手简介&quot;&gt;&lt;/a&gt;三次握手简介&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/img/network/tcp-00.jpg&quot;&gt;&lt;br&gt;注意:&lt;/p&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
      <category term="network" scheme="http://blog.renyimin.com/categories/network/"/>
    
    
      <category term="network" scheme="http://blog.renyimin.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>tcp/ip -- questions</title>
    <link href="http://blog.renyimin.com/2019/08/26/network/tcpip-questions-02/"/>
    <id>http://blog.renyimin.com/2019/08/26/network/tcpip-questions-02/</id>
    <published>2019-08-26T11:17:36.000Z</published>
    <updated>2019-11-04T02:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="现代浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开-什么情况下会断开"><a href="#现代浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开-什么情况下会断开" class="headerlink" title="现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开? 什么情况下会断开?"></a>现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开? 什么情况下会断开?</h1><ol><li><p>在 HTTP/1.0 中, 一个服务器在发送完一个 HTTP 响应后, 会断开 TCP 链接, 但是这样会导致每次请求都会重新建立和断开 TCP 连接, 代价过大;<br> 所以虽然标准中没有设定, 但某些服务器对 <code>Connection: keep-alive</code> 的 Header 进行了支持, 意思是说, 完成这个 HTTP 请求之后, 不要断开 HTTP 请求使用的 TCP 连接, 这样的好处是连接可以被重新使用, 之后发送 HTTP 请求的时候不需要重新建立 TCP 连接, 并且如果维持连接, 那么 SSL 的开销也可以避免</p></li><li><p>持久连接: 既然维持 TCP 连接好处这么多, HTTP/1.1 就把 Connection 头写进标准, 并且默认开启持久连接, 除非请求中写明 <code>Connection: close</code>, 那么浏览器和服务器之间是会维持一段时间的 TCP 连接, 不会一个请求结束就断掉<br> 所以第一个问题的答案是: 默认情况下建立 TCP 连接不会断开, 只有在请求报头中声明 <code>Connection: close</code> 才会在请求完成后关闭连接</p></li><li><p>下面两张图片是我短时间内两次访问 <a href="https://www.github.com" target="_blank" rel="noopener">https://www.github.com</a> 的时间统计<br><img src="/img/network/question-011.png" width="450/"></p></li></ol><p>初始化连接和 SSL 开销消失了, 说明使用的是同一个 TCP 连接:<br><img src="/img/network/question-012.png" width="450/"></p><h1 id="一次http请求-谁会先断开TCP连接-什么情况下客户端先断-什么情况下服务端先断"><a href="#一次http请求-谁会先断开TCP连接-什么情况下客户端先断-什么情况下服务端先断" class="headerlink" title="一次http请求, 谁会先断开TCP连接? 什么情况下客户端先断, 什么情况下服务端先断?"></a>一次http请求, 谁会先断开TCP连接? 什么情况下客户端先断, 什么情况下服务端先断?</h1><h1 id="一个tcp连接可以发送多少个http请求"><a href="#一个tcp连接可以发送多少个http请求" class="headerlink" title="一个tcp连接可以发送多少个http请求?"></a>一个tcp连接可以发送多少个http请求?</h1><ol><li>如果tcp连接保持长连接, 只要在tcp连接（默认两小时）不断开, 可以一直串行发送数量无上限</li><li>如果tcp连接不保持长连接(<code>Connection:close</code>), 则只能发一次http请求</li><li>如果http2, 采用多路复用技术Multiplexing, 一个tcp可以并发多个http请求, 同样也是无上限</li><li>如果和服务器建立多个tcp连接(chrome 浏览器一个host默认tcp连接并发数6, 这个限制是有原因的, Ipv4地址稀有资源, 涉及到NAT转换, 内网外网的端口映射详见<a href="https://blog.csdn.net/qfzhangwei/article/details/90614129" target="_blank" rel="noopener">https://blog.csdn.net/qfzhangwei/article/details/90614129</a>), 底层还是长连接, 则发送数量无上限；</li></ol><h1 id="一个-TCP-连接中-HTTP-请求发送可以一起发送么（比如一起发三个请求-再三个响应一起接收）"><a href="#一个-TCP-连接中-HTTP-请求发送可以一起发送么（比如一起发三个请求-再三个响应一起接收）" class="headerlink" title="一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求, 再三个响应一起接收）?"></a>一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求, 再三个响应一起接收）?</h1><ol><li><p>HTTP/1.1 存在一个问题, 单个 TCP 连接在同一时刻只能处理一个请求, 意思是说: 两个请求的生命周期不能重叠, 任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠</p></li><li><p>虽然 HTTP/1.1 规范中规定了 <code>Pipelining</code> 来试图解决这个问题, 但是这个功能在浏览器中默认是关闭的</p></li><li><p>但是, HTTP2 提供了 Multiplexing 多路传输特性, 可以在一个 TCP 连接中同时完成多个 HTTP 请求, 至于 Multiplexing 具体怎么实现的就是另一个问题了, 下面看一下使用 HTTP2 的效果</p></li></ol><h1 id="为什么有的时候刷新页面不需要重新建立-SSL-连接"><a href="#为什么有的时候刷新页面不需要重新建立-SSL-连接" class="headerlink" title="为什么有的时候刷新页面不需要重新建立 SSL 连接?"></a>为什么有的时候刷新页面不需要重新建立 SSL 连接?</h1><p>在第一个问题的讨论中已经有答案了, TCP 连接有的时候会被浏览器和服务端维持一段时间, TCP 不需要重新建立, SSL 自然也会用之前的</p><h1 id="浏览器对同一-Host-建立-TCP-连接到数量有没有限制"><a href="#浏览器对同一-Host-建立-TCP-连接到数量有没有限制" class="headerlink" title="浏览器对同一 Host 建立 TCP 连接到数量有没有限制?"></a>浏览器对同一 Host 建立 TCP 连接到数量有没有限制?</h1><ol><li><p>假设我们还处在 HTTP/1.1 时代, 那个时候没有多路传输, 当浏览器拿到一个有几十张图片的网页该怎么办呢? 肯定不能只开一个 TCP 连接顺序下载, 那样用户肯定等的很难受, 但是如果每个图片都开一个 TCP 连接发 HTTP 请求, 那电脑或者服务器都可能受不了, 要是有 1000 张图片的话总不能开 1000 个TCP 连接吧, 你的电脑同意 NAT 也不一定会同意;<br> 所以答案是: 有  (Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。)<br> <a href="https://developers.google.com/web/tools/chrome-devtools/network/issues#queued-or-stalled-requestsdevelopers.google.com" target="_blank" rel="noopener">https://developers.google.com/web/tools/chrome-devtools/network/issues#queued-or-stalled-requestsdevelopers.google.com</a></p></li><li><p>那么回到最开始的问题, 收到的 HTML 如果包含几十个图片标签, 这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？</p><ul><li>如果图片都是 HTTPS 连接并且在同一个域名下, 那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2, 如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取, 但是可以确定的是 Multiplexing 很可能会被用到。</li><li>如果发现用不了 HTTP2 呢? 或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的, 所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接, 连接数量的最大限制取决于浏览器设置, 这些连接会在空闲的时候被浏览器用来发送新的请求, 如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。</li></ul></li></ol><p><a href="https://www.cnblogs.com/qcloud1001/p/9591172.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcloud1001/p/9591172.html</a></p><p>原文链接：<a href="https://blog.csdn.net/qq_36865108/article/details/84885506" target="_blank" rel="noopener">https://blog.csdn.net/qq_36865108/article/details/84885506</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;现代浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开-什么情况下会断开&quot;&gt;&lt;a href=&quot;#现代浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开-什么情况下会断开&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="network" scheme="http://blog.renyimin.com/categories/network/"/>
    
    
      <category term="network" scheme="http://blog.renyimin.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 协议简介</title>
    <link href="http://blog.renyimin.com/2019/08/26/network/2019-08-26-TCPIP/"/>
    <id>http://blog.renyimin.com/2019/08/26/network/2019-08-26-TCPIP/</id>
    <published>2019-08-26T10:28:05.000Z</published>
    <updated>2019-11-04T02:47:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP/IP五层协议 和 OSI的七层协议 对应关系如下<br><img src="/img/network/tcpip-01.png" width="450/"></p><p>在每一层都工作着不同的设备, 比如我们常用的交换机就工作在数据链路层的, 一般的路由器是工作在网络层的<br><img src="/img/network/tcpip-02.png"></p><p>在每一层实现的协议也各不同, 即每一层的服务也不同.下图列出了每层主要的协议:<br><img src="/img/network/tcpip-03.png"></p><p>各分层的协议 (在OSI模型中ARP协议属于链路层；而在TCP/IP四层模型中, ARP协议属于网络层)<br>OSI:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">物理层：EIA/TIA-232, EIA/TIA-499, V.35, V.24, RJ45, Ethernet, 802.3, 802.5, FDDI, NRZI, NRZ, B8ZS</span><br><span class="line"></span><br><span class="line">数据链路层：Frame Relay, HDLC, PPP, IEEE 802.3/802.2, FDDI, ATM,  IEEE 802.5/802.2</span><br><span class="line"></span><br><span class="line">网络层：IP, IPX, AppleTalk DDP, 【ARP,RARP】</span><br><span class="line"></span><br><span class="line">传输层：TCP, UDP, SPX</span><br><span class="line"></span><br><span class="line">会话层：RPC,SQL,NFS,NetBIOS,names,AppleTalk,ASP,DECnet,SCP</span><br><span class="line"></span><br><span class="line">表示层:TIFF,GIF,JPEG,PICT,ASCII,EBCDIC,encryption,MPEG,MIDI,HTML</span><br><span class="line"></span><br><span class="line">应用层：FTP,WWW,Telnet,NFS,SMTP,Gateway,SNMP</span><br></pre></td></tr></table></figure></p><p>参考极客时间: <a href="https://time.geekbang.org/course/detail/100026801-93590" target="_blank" rel="noopener">https://time.geekbang.org/course/detail/100026801-93590</a><br><img src="/img/network/tcpip-05.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCP/IP五层协议 和 OSI的七层协议 对应关系如下&lt;br&gt;&lt;img src=&quot;/img/network/tcpip-01.png&quot; width=&quot;450/&quot;&gt;&lt;/p&gt;
&lt;p&gt;在每一层都工作着不同的设备, 比如我们常用的交换机就工作在数据链路层的, 一般的路由器是工作在
      
    
    </summary>
    
      <category term="network" scheme="http://blog.renyimin.com/categories/network/"/>
    
    
      <category term="network" scheme="http://blog.renyimin.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>OSI 七层模型</title>
    <link href="http://blog.renyimin.com/2019/08/26/network/2019-08-26-OSI/"/>
    <id>http://blog.renyimin.com/2019/08/26/network/2019-08-26-OSI/</id>
    <published>2019-08-26T07:17:23.000Z</published>
    <updated>2019-11-04T02:47:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h1><p><img src="/img/network/osi-01.png" width="450/"></p><h1 id="应用层-七层"><a href="#应用层-七层" class="headerlink" title="应用层 (七层)"></a>应用层 (七层)</h1><p><code>应用层</code> 是 OSI参考模型中最靠近用户的一层, 是为计算机用户提供应用接口, 也为用户直接提供各种网络服务 (常见应用层的网络服务协议有：HTTP, HTTPS, FTP, POP3、SMTP 等)</p><h1 id="表示层-六层"><a href="#表示层-六层" class="headerlink" title="表示层 (六层)"></a>表示层 (六层)</h1><p><code>表示层</code> (也有叫 <code>表现层</code>), 提供各种用于应用层数据的编码和转换功能, 确保一个系统的应用层发送的数据能被另一个系统的应用层识别 (数据压缩 和 加密 也是表示层可提供的转换功能之一)</p><blockquote><p>对于A,B两个不同国家的公司, 他们之间可以商定统一用英语作为交流的语言, 此时表示层, 就可以用来将应用层传递的信息转成英语, 同时为了防止别的公司看到, 公司A的人也会对这份报价单做一些加密的处理, 这就是表示的作用, 将应用层的数据转换翻译等 (我们的远程调用也经常会涉及到数据的加密、Json化)</p></blockquote><h1 id="会话层-五层"><a href="#会话层-五层" class="headerlink" title="会话层 (五层)"></a>会话层 (五层)</h1><p><code>会话层</code> 就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成<br>(和 HTTP Session 、telnet远程登录session 有异曲同工之妙)</p><h1 id="传输层-四层"><a href="#传输层-四层" class="headerlink" title="传输层 (四层)"></a>传输层 (四层)</h1><p><code>传输层</code> 建立了主机端到端的链接, 传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务, 包括处理差错控制和流量控制等问题;<br>该层向高层屏蔽了下层数据通信的细节, 使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路;</p><p>我们通常说的, <code>TCP</code>、<code>UDP</code> 就是在这一层; <strong>另外传输层还会指明应用层所提供的目标端口号</strong>;</p><p> 四层传输层传输的叫 <code>段(segment)</code>;</p><h1 id="网络层-三层"><a href="#网络层-三层" class="headerlink" title="网络层 (三层)"></a>网络层 (三层)</h1><ol><li><p>本层通过 IP寻址 来建立两个节点之间的连接, 为源端的运输层送来的分组, 选择合适的路由和交换节点, 正确无误地按照地址传送给目的端的运输层 (也是通常说的<code>IP层</code>)</p><blockquote><p>网络层就相当于快递公司庞大的快递网络, 全国不同的集散中心, 比如说, 从深圳发往北京的顺丰快递(陆运为例啊, 空运好像直接就飞到北京了), 首先要到顺丰的深圳集散中心, 从深圳集散中心再送到武汉集散中心, 从武汉集散中心再寄到北京顺义集散中心 (<strong>这个每个集散中心, 就相当于网络中的一个IP节点</strong>)</p></blockquote></li><li><p>通常, 第三层网络层, 路由器传输的数据的叫 <code>数据包(package)</code></p><blockquote><p> 路由器中包含了三层: 物理层、数据链路层、网络层<br>路由器接收到的数据包package (其数据部分 包装了数据链路层以太网mac地址信息), 而路由器作为网络层设备, 使用的是因特网的ip协议, 所以需要拆包, 拿到ip地址, 并在自己内部使用 数据链路层的 ARP协议找到下一条的mac地址, 并再次包装上数据链路层的头信息, 发送给下一跳的设备<br>(设备和设备之间还是使用的mac地址, 不过在路由器设备中会通过ip来寻找mac)</p></blockquote></li><li><p>如下图:<br><img src="/img/network/osi-3-router-01.png" width="400/"></p></li></ol><h1 id="数据链路层-二层"><a href="#数据链路层-二层" class="headerlink" title="数据链路层 (二层)"></a>数据链路层 (二层)</h1><ol><li><p>该层会将比特组合成字节, 再将字节组合成 <code>帧</code>(交换机转发的以太网数据叫 <code>帧(frame)</code>) , 然后使用链路层地址(以太网使用MAC地址)来访问介质, 并进行差错检测</p></li><li><p>通常, 数据链路层的数据称为 <code>帧(frame)</code> (第三层网络层, 路由器传输的数据的叫 <code>数据包(package)</code>; 四层传输层传输的叫 <code>段(segment)</code>)</p></li><li><p>交换机</p></li></ol><ul><li><p>也叫 第二层交换机 (以太网交换机): </p><blockquote><p>第二层交换机是对应于 OSI/RM 的第二协议层来定义的, 因为它只能工作在 OSI/RM 开放体系模型的第二层 －－ 数据链路层;<br>第二层交换机依赖于链路层中的信息 (如MAC地址) 完成不同端口数据间的线速交换, 主要功能包括物理编址、错误校验、帧序列以及数据流控制, 这是最原始的交换技术产品;<br>目前桌面型交换机一般是属于这类型, 因为桌面型的交换机一般来说所承担的工作复杂性不是很强, 又处于网络的最基层, 所以也就只需要提供最基本的数据链接功能即可 (目前第二层交换机应用最为普遍(主要是价格便宜), 功能符合中、小企业实际应用需求, 一般应用于小型企业或中型以上企业网络的桌面层次)</p></blockquote></li><li><p>三层交换机</p><blockquote><p>三层交换技术其实就是: 二层交换技术+三层转发技术<br>它解决了局域网中网段划分之后, 网段中子网必须依赖路由器进行管理的局面, 解决了传统路由器低速、复杂所造成的网络瓶颈问题;<br>第三层交换是在网络交换机中引入路由模块而取代传统路由器实现交换与路由相结合的网络技术。它根据实际应用时的情况, 灵活地在网络第二层或者第三层进行网络分段。具有三层交换功能的设备是一个带有第三层路由功能的第二层交换机。<br>(在京东购买交换机时, 可以搜索 二层交换机 或者 三层交换机(相比二层交换机自然要贵一些, 毕竟至少多了路由功能))</p></blockquote></li></ul><h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><ol><li><p><code>以太网</code>(Ethernet) 是一种计算机<strong>局域网</strong>技术, IEEE组织的IEEE 802.3标准制定了以太网的技术标准, 它规定了包括物理层的连线、电子信号和介质访问层协议的内容 (以太网是目前应用最普遍的局域网技术, 取代了其他局域网技术如令牌环、FDDI 和 ARCNET)</p><blockquote><p>以太网是现实世界中最普遍的一种计算机网络。以太网有两类: 第一类是经典以太网, 第二类是交换式以太网, 使用了一种称为交换机的设备连接不同的计算机。<br> 经典以太网是以太网的原始形式, 运行速度从3~10 Mbps不等;<br> 而交换式以太网正是广泛应用的以太网, 可运行在100、1000和10000Mbps那样的高速率, 分别以快速以太网、千兆以太网和万兆以太网的形式呈现;</p></blockquote></li><li><p>交换机在构建局域网时, 主要就是使用以太网MAC地址确定目标 (所以 交换机, 以太网适配器(网卡) 都是工作在数据链路层)</p></li></ol><h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><ol><li><p>阿里云的 SLB负载均衡(Server Load Balancer) 产品, 其<a href="https://help.aliyun.com/document_detail/27544.html?spm=a2c4g.11186623.2.16.179dc91fdfJeem" target="_blank" rel="noopener">文档</a>中提到</p><blockquote><p>阿里云当前提供 四层 和 七层 的负载均衡服务</p><ul><li>四层采用开源软件LVS(Linux Virtual Server) + keepalived的方式实现负载均衡, 并根据云计算需求对其进行了个性化定制<br>如果相应的负载均衡实例服务端口使用的是四层协议（TCP或UDP）, 那么LVS集群内每个节点都会根据负载均衡实例负载均衡策略, 将其承载的服务请求按策略直接分发到后端ECS服务器</li><li>七层采用Tengine实现负载均衡, Tengine是由淘宝网发起的Web服务器项目, 它在 Nginx 的基础上, 针对有大访问量的网站需求, 添加了很多高级功能和特性<br>如果相应的负载均衡实例服务端口使用的是七层HTTP协议, 那么LVS集群内每个节点会先将其承载的服务请求均分到Tengine集群, Tengine集群内的每个节点再根据负载均衡策略, 将服务请求按策略最终分发到后端ECS服务器<br>如果相应的负载均衡实例服务端口使用的是七层HTTPS协议, 与上述HTTP处理过程类似, 差别是在按策略将服务请求最终分发到后端ECS服务器前, 先调用Key Server进行证书验证及数据包加解密等前置操作</li></ul></blockquote></li><li><p>对于常听到的 <code>二层交换机</code>、<code>三层交换机</code> 这些词中所谓的 <code>层</code>, 也都是根据OSI参考模型的分层来说的第x层;</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/qishui/p/5428938.html" target="_blank" rel="noopener">https://www.cnblogs.com/qishui/p/5428938.html</a><br><a href="https://blog.csdn.net/wdkirchhoff/article/details/43915825" target="_blank" rel="noopener">https://blog.csdn.net/wdkirchhoff/article/details/43915825</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OSI-七层模型&quot;&gt;&lt;a href=&quot;#OSI-七层模型&quot; class=&quot;headerlink&quot; title=&quot;OSI 七层模型&quot;&gt;&lt;/a&gt;OSI 七层模型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/img/network/osi-01.png&quot; width=&quot;450/
      
    
    </summary>
    
      <category term="network" scheme="http://blog.renyimin.com/categories/network/"/>
    
    
      <category term="network" scheme="http://blog.renyimin.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.renyimin.com/2019/07/31/PHP/2018-03-10-mac-env/"/>
    <id>http://blog.renyimin.com/2019/07/31/PHP/2018-03-10-mac-env/</id>
    <published>2019-07-31T03:26:02.000Z</published>
    <updated>2019-07-31T03:26:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://laravel-china.github.io/php-the-right-way/" target="_blank" rel="noopener">http://laravel-china.github.io/php-the-right-way/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://laravel-china.github.io/php-the-right-way/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://laravel-china.github.io/php-the-right-w
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.renyimin.com/2019/07/30/distributed-consensus/tcc/"/>
    <id>http://blog.renyimin.com/2019/07/30/distributed-consensus/tcc/</id>
    <published>2019-07-30T08:45:56.000Z</published>
    <updated>2019-07-30T08:45:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/soundcode/p/5590710.html" target="_blank" rel="noopener">https://www.cnblogs.com/soundcode/p/5590710.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/soundcode/p/5590710.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/soundcode/p/5590710.htm
      
    
    </summary>
    
    
  </entry>
  
</feed>
