<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2018-01-19T01:43:29.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql(InnoDB)事务隔离级别(REPEATABLE READ) 与 锁,MVCC</title>
    <link href="http://blog.renyimin.com/2017/12/31/2017-12-31-mysql_transaction-05/"/>
    <id>http://blog.renyimin.com/2017/12/31/2017-12-31-mysql_transaction-05/</id>
    <published>2017-12-31T08:30:11.000Z</published>
    <updated>2018-01-19T01:43:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h3><p>(可重复读)</p><ol><li><p>之前已经了解到, 该隔离级别可以解决<code>不可重复读问题</code> (当然, 也能解决<code>脏读问题</code>), 那么如果单纯用锁来实现, 可能会是如下这样子:</p><ul><li>既然<code>REPEATABLE READ</code> 隔离级别可以解决<code>脏读</code>, <code>不可重复读</code>的问题, 也就是它既可以让事务只能读其他事务已提交的的记录, 又能在同一事务中保证多次读取的数据即使被其他事务修改, 也是一致的。</li><li>解决<code>脏读问题</code>:<br>  试想一下, 当在事务A中读取数据D的时候, 假设D之前已经在事务B中了, 并且事务B中对数据D做了修改, 但是事务B还没有完成(commit/rollback), 那如何让事务A无法读取数据D呢?<br>  当事务B在对数据D做写操作的时候, 假设给数据D加上了行级的排他锁(X lock), 那事务A自然只能阻塞等事务A完成后才能读取数据D了, 这样就解决了<code>脏读问题</code>。</li><li>解决 <code>不可重复读问题</code>:<br>  试想一下, 当在事务A中第一次读取了数据D之后, 直接给该数据D加S共享锁, 那其他事务自然只能阻塞等事务A完成后才能对数据D做修改操作了, 这样就解决了<code>不可重复读</code>, 在事务A中多次读取数据D, 都是一样的。</li></ul></li><li><p>上面使用<code>S锁+X锁</code>确实可以实现 <code>READ COMMITTED</code> 隔离级别的效果, 也就避免了<code>脏读问题</code>和<code>不可重复读问题</code>, 当然, 这里的问题仍然是低效！！！！</p></li><li><p>因为 MySQL 在事务隔离级别Read committed 、Repeatable Read下，InnoDB 存储引擎采用<code>非锁定</code>的<code>一致性读</code>－－即读取数据不用加锁，即采用的是MVCC中<code>一致性非锁定读</code>模式, 所以, InnoDB的做法是: <strong>读不影响写，写不影响读</strong>。</p><ul><li>读不影响写: 当数据正在执行读操作时，其他事务的写操作不会因此去等待当前事务行上S锁的释放，而是会去读取行的一个快照数据。   </li><li>写不影响读：当数据正在执行写操作时，其他事务的读操作不会因此去等待当前事务行上X锁的释放，而是会去读取行的一个快照数据。    </li></ul></li><li><p>所以总结来看, <code>READ UNCOMMITTED</code> 和 <code>REPEATABLE READ</code> 这两个隔离级别都是使用 <code>写用排他锁 + 读用MVCC</code>, 区别可以参考 <a href="/2017/12/28/2017-12-28-mysql_mvcc/">MySQL-InnoDB-MVCC多版本并发控制</a></p></li></ol><ul><li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html" target="_blank" rel="external">MySQL官方文档</a></li><li><a href="https://www.imooc.com/article/17290" target="_blank" rel="external">慕课mark_rock同学手记</a></li><li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="external">美团技术博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;REPEATABLE-READ&quot;&gt;&lt;a href=&quot;#REPEATABLE-READ&quot; class=&quot;headerlink&quot; title=&quot;REPEATABLE READ&quot;&gt;&lt;/a&gt;REPEATABLE READ&lt;/h3&gt;&lt;p&gt;(可重复读)&lt;/p&gt;
&lt;ol&gt;
&lt;l
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="事务" scheme="http://blog.renyimin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="MVCC" scheme="http://blog.renyimin.com/tags/MVCC/"/>
    
      <category term="隔离级别与锁" scheme="http://blog.renyimin.com/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>mysql(InnoDB)事务隔离级别(READ COMMITTED) 与 锁,MVCC</title>
    <link href="http://blog.renyimin.com/2017/12/31/2017-12-31-mysql_transaction-04/"/>
    <id>http://blog.renyimin.com/2017/12/31/2017-12-31-mysql_transaction-04/</id>
    <published>2017-12-31T02:01:47.000Z</published>
    <updated>2018-01-02T01:33:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h3><p>(提交读)</p><ol><li><p>了解了<a href="/2017/12/29/2017-12-29-mysql_transaction-02/">之前 <code>READ UNCOMMITTED</code> 隔离级别是如何加锁的</a>, 并且在文章中, 已经知道 <code>READ COMMITTED</code> 隔离级别可以解决脏读的问题, 那接下来, 对于 <code>READ COMMITTED</code> 隔离级别, 试想一下如果让你用锁来设计, 你会怎么做?</p><ul><li>既然<code>READ COMMITTED</code> 隔离级别可以解决<code>脏读</code>的问题, 也就是他可以让事务只能读其他事务已提交的的记录。</li><li>如果用锁机制来实现该隔离级别:<br>  试想一下, 当在事务A中读取数据D的时候, 假设D之前已经在事务B中了, 并且事务B中对数据D做了修改, 但是事务B还没有完成(commit/rollback), 那如何让事务A无法读取数据D呢?<br>  当事务B在对数据D做写操作的时候, 假设给数据D加上了行级的排他锁(X lock), 那事务A自然只能阻塞等事务A完成后才能读取数据D了!</li><li>数据库这样做的话确实实现了<code>READ COMMITTED</code>隔离级别的效果, 也就避免了<code>脏读</code>, 但问题是这是一种很低效的做法, 因为对于大部分应用来说, 读操作是多于写操作的, 当写操作加锁时, 那么读操作全部被阻塞, 这样在大用户量高并发的情况下, 会直接降低数据库的读效率。</li></ul></li><li><p>那么, 既然用锁机制实现该隔离级别是低效的做法, 数据库是如何做的?<br> 之前在相关<a href="/2017/12/28/2017-12-28-mysql_mvcc/">MVCC的文章</a>中可以得到答案: 数据库是使用了 <strong>排他锁+MVCC</strong> 的机制来实现该隔离级别的, 而不是单纯的使用锁或者单纯的使用MVCC</p></li></ol><h3 id="READ-COMMITTED与锁-测试"><a href="#READ-COMMITTED与锁-测试" class="headerlink" title="READ COMMITTED与锁 测试"></a>READ COMMITTED与锁 测试</h3><ol><li><p>数据表结构如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+---------------+-----+--------+--------------------+</div><div class="line">| id | user_name     | age | gender | desctiption        |</div><div class="line">+----+---------------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼     | 127 |      2 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠-rym | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人     |   0 |      2 | 我有一身肉    |</div><div class="line">+----+---------------+-----+--------+--------------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li><li><p>重新设置<code>客户端1</code>事务隔离级别为read committed: <code>SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @@SESSION.tx_isolation;</div><div class="line">+------------------------+</div><div class="line">| @@SESSION.tx_isolation |</div><div class="line">+------------------------+</div><div class="line">| REPEATABLE-READ        |</div><div class="line">+------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; SELECT @@SESSION.tx_isolation;</div><div class="line">+------------------------+</div><div class="line">| @@SESSION.tx_isolation |</div><div class="line">+------------------------+</div><div class="line">| READ-COMMITTED         |</div><div class="line">+------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li><li><p>再重新打开一个<code>客户端2</code>并设置事务隔离级别为read committed;</p></li><li><p>在<code>客户端1</code>中打开事务, 然后更改数据, 先不提交; 然后在<code>客户端2</code>中打开事务, 读取<code>客户端1</code>中尚未提交的那条被修改数据<br> <img src="/img/mysql/transaction/committed_result_01.png" width="470" height="660"></p></li><li><p>结果发现在<code>客户端2</code>中可以正常读取到那条数据, 只不过, 那条数据并不是被<code>客户端1</code>事务中修改后的数据, 而是最初的<code>稳定数据</code>, 这就避免了<code>脏读</code>!!  </p></li><li><p>对于该隔离级别修改数据时使用的锁类型, 其分析方法, 和之前一篇<a href="2017/12/29/2017-12-29-mysql_transaction-02/">MySQL(INNODB引擎)事务READ UNCOMMITTED隔离级别和锁的关系</a> 是一样的：</p><ul><li>可以在<code>客户端1</code>的事务在修改数据并且未提交时, 在<code>客户端2</code>中对同一数据进行修改, 然后在<code>客户端2</code>阻塞阶段通过<br><code>查看表的加锁情况: select * from information_schema.INNODB_LOCKS;</code>,<br><code>事务状态: select * from information_schema.INNODB_TRX;</code>,<br>进行分析, 结果就不展示了, 可以自行测试一下, 该隔离级别修改数据时使用的也是排他锁, 并且<code>客户端2</code>的修改语句会锁等待~<br>(和之前分析READ UNCOMMITTED隔离级别一样, 既然使用了排他锁, 竟然别的事务还能读取, 这特么不就又违反了排他锁的特性么? 还是那句话, 另一个事务在读取的时候并不会加锁, 而是用的MVCC机制读取的镜像)</li></ul></li><li><p>小结:<br> InnoDB在该隔离级别(READ COMMITTED)写数据是使用排他锁, 读取数据不加锁而是使用了MVCC机制, 这样就可以大大提高并发读写效率, 写不影响读, <strong>因为读并未加锁, 读的是记录的镜像版本</strong>!!</p></li></ol><ul><li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html" target="_blank" rel="external">MySQL官方文档</a></li><li><a href="https://www.imooc.com/article/17289" target="_blank" rel="external">慕课mark_rock同学手记</a></li><li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="external">美团技术博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;READ-COMMITTED&quot;&gt;&lt;a href=&quot;#READ-COMMITTED&quot; class=&quot;headerlink&quot; title=&quot;READ COMMITTED&quot;&gt;&lt;/a&gt;READ COMMITTED&lt;/h3&gt;&lt;p&gt;(提交读)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="事务" scheme="http://blog.renyimin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="MVCC" scheme="http://blog.renyimin.com/tags/MVCC/"/>
    
      <category term="隔离级别与锁" scheme="http://blog.renyimin.com/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>mysql(InnoDB)事务隔离级别(READ UNCOMMITTED) 与 锁</title>
    <link href="http://blog.renyimin.com/2017/12/29/2017-12-29-mysql_transaction-02/"/>
    <id>http://blog.renyimin.com/2017/12/29/2017-12-29-mysql_transaction-02/</id>
    <published>2017-12-29T11:12:11.000Z</published>
    <updated>2018-01-04T01:56:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先针对自己以前错误的思维做个记录, 可以直接跳过</p><ol><li>由于以前看到很多资料在谈到并发控制的时候, 都会提到用<code>锁</code>来控制并发, MySQL也不例外, 也有很多和锁相关的概念(留到后面会单独整理一篇笔记出来), 所以一提到高并发产生的问题, 我会不自觉地提出一个疑问: <code>现在并发出问题了, 那怎么用锁的相关知识来解决?</code>;</li><li>而且近期一段时间也一直在看很多有关MySQL锁相关的资料,书籍, 于是乎 <code>死锁</code>, <code>锁冲突</code>, <code>行锁</code>,<code>表锁</code>, <code>读锁</code>, <code>写锁</code>, <code>乐观锁</code>, <code>悲观锁</code> ……等等 N多锁相关的名词(后面的笔记会把所有自己遇到的, 全部整理并进行分析), 大量的篇幅, 高深晦涩的描述, 直接导致我意识里认为<code>嗯, 锁真tm高大上, 真tm高端, 肯定tm就是它了</code>; </li><li>于是就进入了思想误区, 认为在解决<code>脏读</code>,<code>不可重复读</code>,<code>幻读</code>的资料中, 应该大篇幅的描述如何用锁相关的知识来解决这些问题, 然而略失落了, 资料倒是提了点儿锁的知识, 但更多的是用事务的哪个隔离级别来解决这些问题, <code>锁</code>哪儿去了?</li><li><p>尤其是在分析<code>脏读</code>,<code>不可重复读</code>,<code>幻读</code>这几个问题的时候, 一上去就全乱了, 比如 <code>脏读</code>, 如果总是以MySQL锁的相关知识作为前提来分析, <strong>就会陷入误区</strong> ‘事务A读取数据的时候肯定会加S锁的, 事务B自然是无法对未完成的事务A中的数据进行修改的, 我Ca, <strong>这种脏读的场景根本就不成立嘛!</strong>‘, 那为什么不提锁, 而是用隔离级别来解决。<br> <img src="/img/mysql/transaction/022_zangdu.png" width="609" height="175"><br>……<br>……</p></li><li><p>晕了几天之后,终于稍微醒了点……</p><blockquote><p><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="external">参考美团技术博客</a><br> <img src="/img/mysql/transaction/meituan_suo.png" width="609" height="313"></p></blockquote></li><li><p>显然, <strong>事务隔离级别的核心就是锁, 各隔离级别使用了不同的加锁策略</strong>，在分析之前的几个高并发事务问题的时候, <code>隔离级别(锁)</code>自然是不能作为前置知识点的, 而是最终问题的解决方案! </p></li></ol><h2 id="“READ-UNCOMMITTED与锁”的困惑"><a href="#“READ-UNCOMMITTED与锁”的困惑" class="headerlink" title="“READ UNCOMMITTED与锁”的困惑"></a>“READ UNCOMMITTED与锁”的困惑</h2><p>(未提交读)</p><ol><li><p>在READ UNCOMMITTED级别, 事务中的修改, 即使还没有提交, 对其他事务也都是可见的; 也就是说事务可以读取未提交的数据, 这也就造成了 <code>脏读(Dirty Read)</code> 的出现。</p></li><li><p>这个级别会导致很多问题, 而且从性能上来说, READ COMMITTED 并不会比其他的级别好太多, 却缺乏其他级别的很多好处, 在实际应用中一般很少使用。</p></li><li><p>虽然很少使用, 但还是有必要了解一下, <strong>它这个隔离级别究竟是怎么隔离的, 竟然还能容许很多问题的存在？</strong> (老兄亏你还算个隔离级别, 怎么办事儿的…) 网上相关资料五花八门, 下面列几个出来(希望你看完不要激动):</p><ul><li><p><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="external">美团技术博客</a>:<br><img src="/img/mysql/transaction/meituan_readuncommitted.png" width="550" height="229"></p></li><li><p><a href="https://segmentfault.com/a/1190000004469395#articleHeader10" target="_blank" rel="external">segmentfault一篇文章</a><br><img src="/img/mysql/transaction/seg_readuncommitted.png" width="550" height="300"></p></li><li><p><a href="http://blog.csdn.net/flyingfalcon/article/details/53045672" target="_blank" rel="external">CSDN一篇文章</a><br><img src="/img/mysql/transaction/csdn_readuncommitted.png" width="550" height="86"></p></li><li><p><a href="http://blog.csdn.net/ozwarld/article/details/8259796" target="_blank" rel="external">CSDN一篇文章</a><br><img src="/img/mysql/transaction/csdn_readuncommitted_02.png" width="550" height="151"></p></li></ul></li><li><p>说实话, 资料查到这份儿上, 我已经快崩溃了, 就<code>READ UNCOMMITTED</code>这个隔离级别:</p><ul><li>有说读写都不加锁的</li><li>有说’修改完数据立即加S锁的, 修改时撤掉S锁’</li><li>有说’写加S锁,事务结束释放’的</li><li>有说’写加X锁,事务结束释放’的</li></ul></li><li><p><strong>行啦, 不查了, 再查就崩溃了, 自己去测一下吧!!!</strong></p></li></ol><ul><li>本次测试是使用MAMP PRO中mysql5.6版本</li><li><p>先准备一张测试表<code>test_transaction</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">DROP TABLE IF EXISTS `test_transaction`;</div><div class="line">CREATE TABLE `test_transaction` (</div><div class="line">  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;,</div><div class="line">  `user_name` char(20) NOT NULL COMMENT &apos;姓名&apos;,</div><div class="line">  `age` tinyint(3) NOT NULL COMMENT &apos;年龄&apos;,</div><div class="line">  `gender` tinyint(1) NOT NULL COMMENT &apos;1:男, 2:女&apos;,</div><div class="line">  `desctiption` text NOT NULL COMMENT &apos;简介&apos;,</div><div class="line">  PRIMARY KEY (`id`),</div><div class="line">  KEY `name_age_gender_index` (`user_name`,`age`,`gender`)</div><div class="line">) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;</div><div class="line"></div><div class="line">INSERT INTO `test_transaction` VALUES (1, &apos;金刚狼&apos;, 127, 1, &apos;我有一双铁爪&apos;);</div><div class="line">INSERT INTO `test_transaction` VALUES (2, &apos;钢铁侠&apos;, 120, 1, &apos;我有一身铁甲&apos;);</div><div class="line">INSERT INTO `test_transaction` VALUES (3, &apos;绿巨人&apos;, 0, 2, &apos;我有一身肉&apos;);</div></pre></td></tr></table></figure></li><li><p>如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼 | 127 |      2 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">3 rows in set (0.00 sec)</div></pre></td></tr></table></figure></li></ul><h2 id="READ-UNCOMMITTED与锁-测试"><a href="#READ-UNCOMMITTED与锁-测试" class="headerlink" title="READ UNCOMMITTED与锁 测试"></a>READ UNCOMMITTED与锁 测试</h2><h3 id="演示该隔离级别脏读效果"><a href="#演示该隔离级别脏读效果" class="headerlink" title="演示该隔离级别脏读效果"></a>演示该隔离级别脏读效果</h3><ol><li><p>先查看当前会话(当前客户端)事务的隔离级别: <code>SELECT @@SESSION.tx_isolation;</code><br> 可以看到: <code>REPEATABLE READ</code> 是InnoDB存储引擎的默认事务隔离级别</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @@SESSION.tx_isolation;</div><div class="line">+------------------------+</div><div class="line">| @@SESSION.tx_isolation |</div><div class="line">+------------------------+</div><div class="line">| REPEATABLE-READ        |</div><div class="line">+------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li><li><p>重新设置当前客户端事务隔离级别为read uncommitted: <code>SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code><br> 注意, 此时只是当前会话端的隔离级别被改, 其余客户端连接自然还是默认的REPEATABLE READ隔离级别<br> <img src="/img/mysql/transaction/set_transaction_level.png" width="535" height="811"></p></li><li><p>接下来将客户端2的事务隔离级别也设置为read uncommitted;<br> <img src="/img/mysql/transaction/set_transaction_level_02.png" width="535" height="740"></p></li><li><p>客户端1开启事务,并执行一个查询’读取数据’:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @@SESSION.tx_isolation;</div><div class="line">+------------------------+</div><div class="line">| @@SESSION.tx_isolation |</div><div class="line">+------------------------+</div><div class="line">| READ-UNCOMMITTED       |</div><div class="line">+------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; begin;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; select * from test_transaction where id=2;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure><p> <strong>注意, 客户端1此时的事务并未提交</strong></p></li><li><p>客户端2开启事务, 并修改客户端1查询的数据</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @@SESSION.tx_isolation;</div><div class="line">+------------------------+</div><div class="line">| @@SESSION.tx_isolation |</div><div class="line">+------------------------+</div><div class="line">| READ-UNCOMMITTED       |</div><div class="line">+------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; begin;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; update test_transaction set user_name=&apos;钢铁侠-托尼&apos; where id=2;</div><div class="line">Query OK, 1 row affected (0.00 sec)</div><div class="line">Rows matched: 1  Changed: 1  Warnings: 0</div><div class="line">mysql&gt;</div></pre></td></tr></table></figure><ul><li>此时发现, 客户端2可以对客户端1正在读取的记录进行修改, 而根据锁相关知识, <code>如果说客户端1在读取记录的时候加了S锁, 那么客户端2是不能加X锁对该记录进行更改的</code>, 所以可以得出结论: 要么是客户端1读取记录的时候没有加S锁, 要么是客户端2更改该记录的时候没有加X锁(这样即使客户端1加了S锁,对它这个不加锁的事务也无可奈何), 那么究竟是哪种情况导致的? 下面继续进行分析…</li><li><strong>注意, 客户端2此时的事务也并未提交</strong></li></ul></li><li><p>切换到客户端1, 再次查询数据, 发现数据已经变成了’钢铁侠-托尼’; 然后客户端2 <code>rollback</code> 事务, 再到客户端1中查询,发现user_name又变成了’钢铁侠’, 那之前独到’钢铁侠-托尼’就是脏数据了, 这就是一次 <code>脏读</code><br> <img src="/img/mysql/transaction/result_01.png" width="515" height="845"></p></li></ol><h3 id="测试-分析该隔离级别如何加锁"><a href="#测试-分析该隔离级别如何加锁" class="headerlink" title="测试,分析该隔离级别如何加锁"></a>测试,分析该隔离级别如何加锁</h3><ol><li>重新构造测试条件<br> <img src="/img/mysql/transaction/qianti_02.png" width="525" height="930"></li><li><p>客户端1开启事务, 然后对数据做修改</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; begin;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; update test_transaction set user_name=&apos;钢铁侠-rymuscle&apos; where id=2;</div><div class="line">Query OK, 1 row affected (0.00 sec)</div><div class="line">Rows matched: 1  Changed: 1  Warnings: 0</div><div class="line">mysql&gt;</div></pre></td></tr></table></figure><p> <strong>注意, 客户端1此时的事务并未提交</strong></p></li><li><p>客户端2开启事务, 对相同的数据行做修改</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mysql&gt; begin;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; update test_transaction set user_name=&apos;钢铁侠-rym&apos; where id=2;</div><div class="line">....阻塞等待了</div></pre></td></tr></table></figure><p> 最终会如下:<br> <img src="/img/mysql/transaction/zuse.png" width="555" height="290"></p></li><li><p><strong>注意:</strong> 在上面的过程, 在客户端2阻塞阶段, 你可以通过一个新的客户端来分析, 客户端2在锁等待的情况下的 <code>加锁情况</code> 和 <code>事务状态</code>:</p><ul><li><p>查看表的加锁情况: <code>select * from information_schema.INNODB_LOCKS;</code></p><p><img src="/img/mysql/transaction/lock_result.png" width="605" height="340"></p></li><li>事务状态 <code>select * from information_schema.INNODB_TRX;</code><br><img src="/img/mysql/transaction/transaction_state_01.png" width="805" height="880"></li></ul></li><li><p>所以, <strong>READ UNCOMMITTED 隔离级别下, 写操作是会加锁的, 而且是X排他锁, 直到客户端1事务完成, 锁才释放, 客户端2才能进行写操作</strong></p></li><li><p>接下来你肯定会纳闷 “既然该隔离级别下事务在修改数据的时候加的是x锁, 并且是事务完成后才释放, 那之前的测试客户端2在事务中修改完数据之后, 为什么事务还没完成, 也就是x锁还在, 结果客户端1却能读取到客户端2修改的数据”？<strong>这完全不符合排他锁的特性啊(要知道,排他锁会阻塞除当前事务之外的其他事务的读,写操作)</strong></p><ul><li><p>其实网上已经有人在sqlserver的官网上找到了相关资料:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ansactions running at the READ UNCOMMITTED level do not issue shared locks to prevent other transactions from modifying data read by the current transaction. </div><div class="line">READ UNCOMMITTED transactions are also not blocked by exclusive locks that would prevent the current transaction from reading rows that have been modified but not committed by other transactions. </div><div class="line">When this option is set, it is possible to read uncommitted modifications, which are called dirty reads. Values in the data can be changed and rows can appear or disappear in the data set before the end of the transaction. </div><div class="line">This option has the same effect as setting NOLOCK on all tables in all SELECT statements in a transaction. </div><div class="line">This is the least restrictive of the isolation levels.</div></pre></td></tr></table></figure></li><li><p>翻译翻译, 在思考思考, 其实说的是<br>在 READ UNCOMMITTED 级别运行的事务不会发出共享锁来防止其他事务修改当前事务读取的数据, 既然不加共享锁了, 那么当前事务所读取的数据自然就可以被其他事务来修改。<br>而且当前事务要读取其他事务未提交的修改, 也不会被排他锁阻止, 因为排他锁会阻止其他事务再对其锁定的数据加读写锁, <strong>但是可笑的是, 事务在该隔离级别下去读数据的话根本什么锁都不加, 这就让排他锁无法排它了, 因为它连锁都没有</strong>。<br>这就导致了事务可以读取未提交的修改, 称为脏读。</p></li></ul></li></ol><p><strong>所以可以得出</strong>: <code>READ UNCOMMITTED</code>隔离级别下, 读不会加任何锁。而写会加排他锁，并到事务结束之后释放。</p><p>参考资料:<br>-《高性能MySQL》</p><ul><li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html" target="_blank" rel="external">MySQL官方文档</a></li><li><a href="https://www.imooc.com/article/17291" target="_blank" rel="external">慕课mark_rock同学手记</a></li><li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="external">美团技术博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;先针对自己以前错误的思维做个记录, 可以直接跳过&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于以前看到很多资料在谈到并发控制的时候, 都会提到用&lt;code
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="事务" scheme="http://blog.renyimin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="隔离级别与锁" scheme="http://blog.renyimin.com/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-InnoDB-MVCC多版本并发控制</title>
    <link href="http://blog.renyimin.com/2017/12/28/2017-12-28-mysql_mvcc/"/>
    <id>http://blog.renyimin.com/2017/12/28/2017-12-28-mysql_mvcc/</id>
    <published>2017-12-28T13:07:12.000Z</published>
    <updated>2018-01-18T13:22:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>(Multiversion Concurrency Control)</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近正在啃《高性能MySQL》这本书, 当看到事务相关知识时, 决定对该知识点稍微深入一下, 这里主要先说一下本人在啃相关知识点时的曲折之路:<br>1.首先是事务相关ACID特性, 之前已经有相关笔记进行过介绍, 这里不再重复;</p><p>2.接下来是高并发事务相关的问题, 像是 <code>脏读</code>, <code>不可重复读</code>, <code>幻读</code>, <code>更新丢失</code>等问题之前也有介绍;</p><p>3.再下来就是MySQL应对高并发事务的诸多问题是如何给出解决方案的(其中包含各个隔离级别的简介);</p><p>4.然后就是各个隔离级别的具体介绍及与锁的关系, 也就是在这部分知识点, 发现了之前并没有过多关心的知识点 <code>MVCC多版本并发控制</code>, 然后一发不可收拾了…</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><p><a href="http://mysql.taobao.org/monthly/2017/12/01/" target="_blank" rel="external">阿里数据库内核’2017/12’月报</a>中对MVCC的解释是:</p><blockquote><p><strong>多版本控制</strong>: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。</p></blockquote></li><li><p>&lt;高性能MySQL&gt;中对MVCC的部分介绍</p><blockquote><p>MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。<strong>基于提升并发性能的考虑</strong>, 它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL, 包括Oracle,PostgreSQL等其他数据库系统也都实现了MVCC, 但各自的实现机制不尽相同, 因为MVCC没有一个统一的实现标准。<br>可以认为MVCC是行级锁的一个变种, 但是它在很多情况下避免了加锁操作, 因此开销更低。虽然实现机制有所不同, 但大都实现了非阻塞的读操作，写操作也只锁定必要的行。<br>MVCC的实现方式有多种, 典型的有乐观(optimistic)并发控制 和 悲观(pessimistic)并发控制。<br>MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 <code>READ UNCOMMITTED</code> 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 <code>SERIALIZABLE</code> 则会对所有读取的行都加锁。</p></blockquote><p> 从书中可以了解到:</p><ul><li>MVCC是被Mysql中 <code>事务型存储引擎InnoDB</code> 所支持的;</li><li><strong>应对高并发事务, MVCC比单纯的行锁更高效</strong>; </li><li>MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;</li><li>MVCC可以使用 <code>乐观(optimistic)锁</code> 和 <code>悲观(pessimistic)锁</code>来实现;</li><li>各数据库中MVCC实现并不统一</li><li>但是书中提到 “InnoDB的MVCC是通过在每行记录后面保存<strong>两个隐藏的列</strong>来实现的”(网上也有很多此类观点), 但其实并不准确, 可以参考<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html" target="_blank" rel="external">MySQL官方文档</a>, 可以看到, InnoDB存储引擎在数据库每行数据的后面添加了<strong>三个字段</strong>, 不是两个!!</li></ul></li></ol><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><code>read view</code>, <code>快照snapshot</code><br>1.<a href="http://mysql.taobao.org/monthly/2017/10/01/" target="_blank" rel="external">淘宝数据库内核月报/2017/10/01/</a><br>此文虽然是以PostgreSQL进行的说明, 但并不影响理解, 在”事务快照的实现”该部分有细节需要注意:</p><pre><code>- **事务快照是用来存储数据库的事务运行情况。** - 一个事务快照的创建过程可以概括为：查看当前所有的未提交并活跃的事务，存储在数组中选取未提交并活跃的事务中最小的XID，记录在快照的xmin中选取所有已提交事务中最大的XID，**加1**后记录在xmax中</code></pre><p>2.注意: 上文中在PostgreSQL中<code>snapshot</code>的概念, 对应MySQL中, 其实就是你在网上看到的<code>read view</code>,<code>快照</code>这些概念;<br>    比如<a href="http://hedengcheng.com/?p=148#_Toc322691905" target="_blank" rel="external">何登成</a>就有关于<code>Read view</code>的介绍;<br>    而 <a href="https://www.cnblogs.com/digdeep/p/4947694.html" target="_blank" rel="external">此文</a> 却仍是使用<code>快照</code>来介绍;</p><p>3.read view 主要是用来做可见性判断的, 比较普遍的解释便是”本事务不可见的当前其他活跃事务”, 但正是该解释, 可能会造成一节理解上的误区, 所以此处提供两个参考, 供给大家<strong>避开理解误区</strong>:</p><pre><code>- read view中的`高水位low_limit_id`可以参考 &quot;https://github.com/zhangyachen/zhangyachen.github.io/issues/68&quot;, &quot;https://www.zhihu.com/question/66320138(呵呵一笑百媚生)&quot;- 如果单纯按照&apos;https://www.jianshu.com/p/fd51cb8dc03b&apos;中的read view介绍来理解, 在rc级别下做演示, 就会发现使用该算法会出错!- 其实上面第1点中加粗部分也是相关高水位的介绍( 注意进行了+1 )</code></pre><p>4.另外, 对于read view快照的生成时机, 也非常关键, <strong>也正是因为生成时机的不同, 造成了RC,RR两种隔离级别的不同可见性</strong>, 可以参考 <a href="http://www.sohu.com/a/194511597_610509" target="_blank" rel="external">http://www.sohu.com/a/194511597_610509</a>, <a href="https://www.cnblogs.com/digdeep/p/4947694.html" target="_blank" rel="external">https://www.cnblogs.com/digdeep/p/4947694.html</a> 两篇文章;</p><pre><code>- 在innodb中(默认repeatable read级别), 事务在begin/start transaction之后的第一条select读操作后, 会创建一个快照(read view), 将当前系统中活跃的其他事务记录记录起来;- 在innodb中(默认repeatable committed级别), 事务中每条select语句都会创建一个快照(read view);- [参考](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_consistent_read)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">With REPEATABLE READ isolation level, the snapshot is based on the time when the first read operation is performed.</div><div class="line"> 使用REPEATABLE READ隔离级别，快照是基于执行第一个读操作的时间。</div><div class="line">With READ COMMITTED isolation level, the snapshot is reset to the time of each consistent read operation.</div><div class="line">使用READ COMMITTED隔离级别，快照被重置为每个一致的读取操作的时间。</div></pre></td></tr></table></figure></code></pre><p>5.undo-log </p><ul><li><p>可以参考<a href="http://mysql.taobao.org/monthly/2015/04/01/" target="_blank" rel="external">数据库内核月报2015/04/01</a></p><blockquote><p>前言 </p><ul><li>Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。</li><li>Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作（例如bug#69812）。</li><li>大多数对数据的变更操作包括INSERT/DELETE/UPDATE，其中INSERT操作在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除（谁会对刚插入的数据有可见性需求呢！！），而对于UPDATE/DELETE则需要维护多版本信息，在InnoDB里，UPDATE和DELETE操作产生的Undo日志被归成一类，即update_undo</li></ul></blockquote></li><li><p>另外, 在回滚段中的undo logs分为: <code>insert undo log</code> 和 <code>update undo log</code></p><ul><li>insert undo log : 事务对insert新记录时产生的undolog, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。</li><li>update undo log : 事务对记录进行delete和update操作时产生的undo log, 不仅在事务回滚时需要, 一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。</li></ul></li></ul><p>6.InnoDB存储引擎在数据库每行数据的后面添加了三个字段</p><ul><li><p>6字节的<code>事务ID</code>(<code>DB_TRX_ID</code>)字段: 用来标识最近一次对本行记录做修改(insert|update)的事务的标识符, 即最后一次修改(insert|update)本行记录的事务id。<br>  至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted, <strong>并非真正删除</strong>。</p></li><li><p>7字节的<code>回滚指针</code>(<code>DB_ROLL_PTR</code>)字段: 指写入回滚段(rollback segment)的 <code>undo log</code> record (撤销日志记录记录)。<br>  如果一行记录被更新, 则 <code>undo log</code> record 包含 ‘重建该行记录被更新之前内容’ 所必须的信息。</p></li><li><p>6字节的<code>DB_ROW_ID</code>字段: 包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。<br>  结合聚簇索引的相关知识点, 我的理解是, 如果我们的表中没有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 但聚簇索引会使用DB_ROW_ID的值来作为主键; 如果我们有自己的主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID 了 。<br>  关于聚簇索引, 《高性能MySQL》中的篇幅对我来说已经够用了, 稍后会整理一下以前的学习笔记, 然后更新上来。</p></li></ul><p>7.可见性比较算法（这里每个比较算法后面的描述是建立在rr级别下，rc级别也是使用该比较算法,此处未做描述）<br>设要读取的行的最后提交事务id(即当前数据行的稳定事务id)为 <code>trx_id_current</code><br>当前新开事务id为 <code>new_id</code><br>当前新开事务创建的快照<code>read view</code> 中最早的事务id为<code>up_limit_id</code>, 最迟的事务id为<code>low_limit_id</code>(注意这个low_limit_id=未开启的事务id=当前最大事务id+1)<br>比较:</p><ul><li>1.<code>trx_id_current &lt; up_limit_id</code>, 这种情况比较好理解, 表示, 新事务在读取该行记录时, 该行记录的稳定事务ID是小于, 系统当前所有活跃的事务, 所以当前行稳定数据对新事务可见, 跳到步骤5.</li><li>2.<code>trx_id_current &gt;= trx_id_last</code>, 这种情况也比较好理解, 表示, 该行记录的稳定事务id是在本次新事务创建之后才开启的, 但是却在本次新事务执行第二个select前就commit了，所以该行记录的当前值不可见, 跳到步骤4。</li><li>3.<code>trx_id_current &lt;= trx_id_current &lt;= trx_id_last</code>, 表示: 该行记录所在事务在本次新事务创建的时候处于活动状态，从up_limit_id到low_limit_id进行遍历，如果trx_id_current等于他们之中的某个事务id的话，那么不可见, 调到步骤4,否则表示可见。</li><li>4.从该行记录的 DB_ROLL_PTR 指针所指向的回滚段中取出最新的undo-log的版本号, 将它赋值该 <code>trx_id_current</code>，然后跳到步骤1重新开始判断。</li><li>5.将该可见行的值返回。</li></ul><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>1.下面是一个非常简版的演示事务对某行记录的更新过程, 当然, InnoDB引擎在内部要做的工作非常多:<br><img src="/img/mysql/mvcc/yanshi_01.png" width="600" height="819/"></p><p>2.下面是一套比较算法的应用过程<br><img src="/img/mysql/mvcc/yanshi_02.png" width="602/"><br><img src="/img/mysql/mvcc/yanshi_03.png" width="602/"><br>也可参考<a href="https://github.com/zhangyachen/zhangyachen.github.io/issues/68中的案例" target="_blank" rel="external">https://github.com/zhangyachen/zhangyachen.github.io/issues/68中的案例</a></p><h2 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h2><p>1.MySQL的InnoDB存储引擎默认事务隔离级别是RR(可重复读), 是通过 “行排他锁+MVCC” 一起实现的, 不仅可以保证可重复读, 还可以<strong>部分</strong>防止幻读;</p><p>2.为什么是部分防止幻读, 而不是完全防止?</p><ul><li>效果: 在如果事务B在事务A执行中, insert了一条数据并提交, 事务A再次查询, 虽然读取的是undo中的旧版本数据(防止了部分幻读), 但是事务A中执行update或者delete都是可以成功的!!</li><li>因为在innodb中的操作可以分为<code>当前读(current read)</code>和<code>快照读(snapshot read)</code>:</li></ul><p>3.快照读(snapshot read)<br>    简单的select操作(当然不包括 select … lock in share mode, select … for update)</p><p>4.当前读(current read) <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" target="_blank" rel="external">官网文档 Locking Reads</a></p><ul><li>select … lock in share mode</li><li>select … for update</li><li>insert</li><li>update</li><li>delete<br>在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。<br>innodb在快照读的情况下并没有真正的避免幻读, 但是在当前读的情况下避免了不可重复读和幻读!!! </li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>一般我们认为MVCC有下面几个特点：</p><ul><li>每行数据都存在一个版本，每次数据更新时都更新该版本</li><li>修改时Copy出当前版本, 然后随意修改，各个事务之间无干扰</li><li>保存时比较版本号，如果成功(commit)，则覆盖原记录, 失败则放弃copy(rollback)</li><li>就是每行都有版本号，保存时根据版本号决定是否成功，<strong>听起来含有乐观锁的味道, 因为这看起来正是，在提交的时候才能知道到底能否提交成功</strong></li></ul></li><li><p>而InnoDB实现MVCC的方式是:</p><ul><li>事务以排他锁的形式修改原始数据</li><li>把修改前的数据存放于undo log，通过回滚指针与主数据关联</li><li>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</li></ul></li><li><p><strong>二者最本质的区别是</strong>: 当修改数据时是否要<code>排他锁定</code>，如果锁定了还算不算是MVCC？</p></li></ol><ul><li>Innodb的实现真算不上MVCC, 因为并没有实现核心的多版本共存, <code>undo log</code> 中的内容只是串行化的结果, 记录了多个事务的过程, 不属于多版本共存。但理想的MVCC是难以实现的, 当事务仅修改一行记录使用理想的MVCC模式是没有问题的, 可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的MVCC就无能为力了。</li><li>比如, 如果事务A执行理想的MVCC, 修改Row1成功, 而修改Row2失败, 此时需要回滚Row1, 但因为Row1没有被锁定, 其数据可能又被事务B所修改, 如果此时回滚Row1的内容，则会破坏事务B的修改结果，导致事务B违反ACID。 这也正是所谓的 <code>第一类更新丢失</code> 的情况。</li><li>也正是因为InnoDB使用的MVCC中结合了排他锁, 不是纯的MVCC, 所以第一类更新丢失是不会出现了, 一般说更新丢失都是指第二类丢失更新。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.jianshu.com/p/fd51cb8dc03b" target="_blank" rel="external">最初读的一篇文章</a></li><li>关于read view创建时机: <ul><li><a href="http://www.sohu.com/a/194511597_610509" target="_blank" rel="external">http://www.sohu.com/a/194511597_610509</a></li><li><a href="https://www.cnblogs.com/digdeep/p/4947694.html" target="_blank" rel="external">https://www.cnblogs.com/digdeep/p/4947694.html</a></li><li><a href="https://www.zhihu.com/question/265280455/answer/292022808" target="_blank" rel="external">https://www.zhihu.com/question/265280455/answer/292022808</a></li></ul></li><li>关于比较算法 low_limit_id 高水位事务: <ul><li><a href="https://github.com/zhangyachen/zhangyachen.github.io/issues/68" target="_blank" rel="external">https://github.com/zhangyachen/zhangyachen.github.io/issues/68</a></li><li><a href="https://www.zhihu.com/question/66320138" target="_blank" rel="external">https://www.zhihu.com/question/66320138</a></li><li><a href="https://www.zhihu.com/question/265280455/answer/292022808" target="_blank" rel="external">https://www.zhihu.com/question/265280455/answer/292022808</a></li></ul></li><li>大咖问答:<a href="https://www.zhihu.com/inbox/4577674200" target="_blank" rel="external">https://www.zhihu.com/inbox/4577674200</a></li><li>更多可以参考数据库内核月报:<ul><li><a href="https://yq.aliyun.com/articles/303200?spm=5176.100240.searchblog.9.271fd153pQ9FgV" target="_blank" rel="external">https://yq.aliyun.com/articles/303200?spm=5176.100240.searchblog.9.271fd153pQ9FgV</a></li></ul></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html" target="_blank" rel="external">官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(Multiversion Concurrency Control)&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近正在啃《高性能MySQL》这本书, 当看到事务相关知
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="事务" scheme="http://blog.renyimin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="MVCC" scheme="http://blog.renyimin.com/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>MySQL(INNODB引擎)高并发事务问题及解决方案</title>
    <link href="http://blog.renyimin.com/2017/12/27/2017-12-27-mysql_transaction-01/"/>
    <id>http://blog.renyimin.com/2017/12/27/2017-12-27-mysql_transaction-01/</id>
    <published>2017-12-27T13:01:07.000Z</published>
    <updated>2018-01-18T12:39:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h2><ol><li><p>事务：可以理解为一个 <strong>独立的</strong> 工作单元, <strong>在这个独立的工作单元中, 可以有一组操作; 放在这个独立工作单元中的一组操作, 要么全部执行成功, 要么全部执行失败</strong>。</p></li><li><p>仍然通过最经典的银行转账应用来解释一下: 假设有两个角色 ‘Iron Man’(余额500), ‘Wolverine’(余额15), 现在 ‘Iron Man’ 通过该银行应用给 ‘Wolverine’ 转账100元, 那么本次转账操作至少需要三个步骤</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">检查`Iron Man`余额`&gt;=100`元</div><div class="line">从`Iron Man`余额中`-100`元</div><div class="line">给`Wolverine`余额`+100`元</div></pre></td></tr></table></figure></li><li><p><strong>注意</strong>: 上面的三个步操作，其实就需要打包在一个事务中, 这样就可以保证一组操作可以作为一个 <code>独立的工作单元</code> 来执行。并且在 <code>独立工作单元</code>(即事务) 中的这三个操作, 只要有任何一个操作失败, 则事务就整体就是失败的, 那就必须回滚所有已经执行的步骤。<br> 假设第二步操作成功, 但是第三步操作失败, 那么整个事务也就应该是失败的, 那就必须将第二步的操作也回滚。(其实这里也体现了事务最基本的一个特性: <strong>保证数据的一致性</strong>)</p></li><li><p>当然, 在真实高并发场景下, 事务需要做的事情其实还很多, 因为高并发会出现很多意想不到的问题, 后面会简要分析一下可能会出现的一些问题。</p></li></ol><h2 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h2><p>在分析高并发事务的问题前, 我们要先熟悉一下<strong>事务的几个标准特性</strong>, 因为一个运行良好的事务处理系统必须具备这些标准特性, 而且这些高并发问题的解决也离不开事务的这几个标准特性!!! </p><ol><li><p>Atomicity 原子性<br> 一个事务必须被视为<code>一个不可分割的最小工作单元</code>, 整个事务中的所有操作要么全部提交成功, 要么全部失败回滚。<br> 对于一个事务来说, 不能只成功执行其中的一部分操作, 这就是事务的原子性。</p></li><li><p>Consistency 一致性<br> 你大概可以这样来理解: 虽然数据表中的数据可能一直在变化, 但是事务的<code>一致性</code>特性总是能够保证 <strong>数据库总是从一个一致性的状态 转换到 另一个一致性的状态</strong>; 比如在之前的转账例子:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">转账前的一致性状态是: &apos;Iron Man&apos;(余额500), &apos;Wolverine&apos;(余额15)</div><div class="line">转账成功后的一致性状态是: &apos;Iron Man&apos;(余额400), &apos;Wolverine&apos;(余额115)</div><div class="line">转账如果失败的话, 一致性的状态应该回滚到转账前的状态: &apos;Iron Man&apos;(余额500), &apos;Wolverine&apos;(余额15)</div></pre></td></tr></table></figure></li><li><p><strong>Isolation 隔离性</strong></p><ul><li><p><strong>通常来说</strong>, 一个事务所做的修改在最终提交以前, 对其他事务是不可见的;<br>比如在之前的转账例子中, 在执行完成第二步, 但是第三步还没开始的时候, 此时有另一个账户汇总的程序开始运行, <strong>那么这个程序所拿到的A账户余额应该是没有被减100的余额才对</strong></p></li><li><p>后面我们还会详细讨论事务<code>隔离性</code>的 <code>隔离级别</code>, 到时候就知道这里为什么说<code>通常来说</code>对其他事务是不可见的; (也就是还有特例, 比如最低隔离级别 <code>READ UNCOMMITTED</code>, 对其他事务的可见就造成了<code>脏读问题</code>的出现)</p></li><li><p>事务有四种隔离级别(从低到高: <code>READ UNCOMMITTED</code>, <code>READ COMMITTED</code>, <code>REPEATABLE READ</code>, <code>SERIALIZABLE</code>)</p></li></ul></li><li><p>Durability 持久性<br> 一旦事务被最终提交, 则在事务这个独立单元中的所有操作所做的修改将会 <code>永久保存到数据库中</code>; (这里所说的<code>永久</code>可以理解为 被事务修改的数据 是真正存放到了表中, 而不是存放在了诸如临时表之类的地方。)</p></li></ol><h2 id="高并发事务的问题"><a href="#高并发事务的问题" class="headerlink" title="高并发事务的问题"></a>高并发事务的问题</h2><p>在并发量比较大的时候, 很容易出现 <strong>多个事务同时进行</strong> 的情况。假设有两个事务正在同时进行, <strong>值得注意的是</strong>: 它们两者之间是互相不知道对方的存在的, 各自都对自身所处的环境<strong>过分乐观</strong>, 从而并没有对自己所操作的数据做一定的保护处理, 所以<strong>最终导致了一些问题的出现</strong>;</p><p>接下来, 在分析高并发事务的问题时, 你可能已经了解过一些关于锁的概念, 但是接下来分析这些高并发问题时, 暂时不会带入锁的概念, 只会列出问题, 并直接告诉你各个问题是使用事务隔离性的哪个隔离级别来解决掉的;</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><ol><li><p>如果mysql中一个事务A读取了另一个并行事务B未最终提交的写数据, 那事务A的这次读取就是<code>脏读</code>。(因为事务A读取的是’脏数据’, 是’非持久性’的数据)</p><ul><li>之所以说是’非持久性数据’, ‘脏数据’, 是因为事务B最终可能会因为内部其他后续操作的失败或者系统后续突然崩溃等原因, 导致事务最终整体提交失败, 那么事务A此时读取到的数据在表中其实会被回滚, 那事务A拿到的自然就是脏的数据了。</li><li>图示:<br><img src="/img/mysql/transaction/dirty_read.png" width="608" height="190"></li></ul></li><li><p>事务A在T4阶段读取库存为20, 这个库存其实就属于<code>脏数据</code>, 因为事务B最终会回滚这个数据, 所以如果事务A使用库存20进行后续的操作, 就会引发问题, 因为事务A拿到的数据已经和表中的真实数据不一致了。</p></li><li><p>那么这个问题如何解决呢?<br> 在MySQL中, 其实事务已经用自身特性(<code>隔离性</code>的 – <code>READ COMMITED</code>或以上隔离级别)解决了这个问题;<br> <strong><code>READ COMMITED</code>级别保证了, 只要是当前语句执行前已经提交的数据都是可见的</strong>。</p></li></ol><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><ol><li><p>假设现在上面的 <code>脏读问题</code> 已经被完全解决了, 那就意味着事务中每次读取到的数据都是 <code>持久性</code> 的数据(被别的事务最终 提交/回滚 完成后的数据)。</p></li><li><p>但是你需要知道的是: 解决了脏读问题, 只是能保证你在事务中每次读到的数据都是持久性的数据而已!!!!</p></li><li><p>如果在一个事务中多次读取同一个数据, 正好在两次读取之间, 另外一个事务确实已经完成了对该数据的修改并提交, 那问题就来了: 可能会出现多次读取结果不一致的现象。<br><img src="/img/mysql/transaction/bukechongfudu.png" width="607" height="204"></p></li><li><p>那么这个问题如何解决呢?<br> 在MySQL中, 事务已经用自身特性(<code>隔离性</code>的 – <code>REPEATABLE READ</code>或以上隔离级别)解决了这个问题;<br> <strong><code>REPEATABLE READ</code>级别保证了, 只要是当前事务执行前已经提交的数据都是可见的</strong>。</p></li></ol><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><ol><li><p>由于很多人(当然也包括本人), 容易搞混 <code>不可重复读</code> 和 <code>幻读</code>, 这两者确实非常相似。</p><ul><li>但 <code>不可重复读</code> 主要是说多次读取一条记录, 发现该记录中某些列值被修改过。 </li><li>而 <code>幻读</code> 主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计), 发现结果不一致(比如发现增加/减少了一条记录)。(可以参考<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html" target="_blank" rel="external">MySQL官方文档对 Phantom Rows 的介绍</a>)</li></ul></li><li><p>其实对于 <code>幻读</code>, MySQL的InnoDB引擎默认的<code>RR</code>级别已经通过<code>MVCC自动帮我们解决了</code>(并非完全解决), 所以该级别下, 你也模拟不出幻读的场景; 退回到 <code>RC</code> 隔离级别的话, 你又容易把<code>幻读</code>和<code>不可重复读</code>搞混淆, 所以这可能就是比较头痛的点吧!</p><p> 另外可以参考《高性能MySQL》对 <code>RR</code> 隔离级别的描述 </p><blockquote><p>理论上RR级别是无法解决幻读的问题, 但是由于InnoDB引擎的RR级别还使用了MVCC, 所以也就避免了幻读的出现!</p></blockquote></li></ol><h3 id="幻读的延伸"><a href="#幻读的延伸" class="headerlink" title="幻读的延伸"></a>幻读的延伸</h3><p>MVCC虽然解决了<code>幻读</code>问题, 但严格来说, MVCC只是<strong>部分</strong>解决幻读问题, 接下来进行演示:</p><ol><li><p>打开客户端1查看隔离级别及初始数据</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @@SESSION.tx_isolation;</div><div class="line">+------------------------+</div><div class="line">| @@SESSION.tx_isolation |</div><div class="line">+------------------------+</div><div class="line">| REPEATABLE-READ        |</div><div class="line">+------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li><li><p>打开客户端2查看隔离级别及初始数据</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @@SESSION.tx_isolation;</div><div class="line">+------------------------+</div><div class="line">| @@SESSION.tx_isolation |</div><div class="line">+------------------------+</div><div class="line">| REPEATABLE-READ        |</div><div class="line">+------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li><li><p>在客户端2中开启事务, 然后查询数据</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mysql&gt; begin;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li><li><p>在客户端1中插入一条id为4的新数据 (直接自动提交)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mysql&gt; insert into test_transaction (`id`,`user_name`,`age`,`gender`,`desctiption`) values (4, &apos;死侍&apos;, 18, 0, &apos;A bad boy&apos;);</div><div class="line">Query OK, 1 row affected (0.00 sec)</div><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</div><div class="line">|  4 | 死侍    |  18 |      0 | A bad boy          |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">4 rows in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li><li><p>在客户端2事务中再次查询数据, 发现数据没有变化(表示<strong>可以重复读, 并且克服了幻读</strong>)!! <strong>但是在客户端2事务中插入一条id为4的新数据, 发现提示数据已经存在!!!</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">mysql&gt; begin;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select * from test_transaction;</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">| id | user_name | age | gender | desctiption        |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</div><div class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</div><div class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</div><div class="line">+----+-----------+-----+--------+--------------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; insert into test_transaction (`id`,`user_name`,`age`,`gender`,`desctiption`) values (4, &apos;死侍&apos;, 18, 0, &apos;A bad boy&apos;);</div><div class="line">1062 - Duplicate entry &apos;4&apos; for key &apos;PRIMARY&apos;    //( 后面会看到: 其实是因为insert是当前读)</div><div class="line">mysql&gt; </div><div class="line"></div><div class="line">//并且, 此时`update/delete`也是可以操作这条在事务中看不到的记录的! //( 后面会看到: update，delete也都是当前读)</div></pre></td></tr></table></figure></li><li><p>那么这是什么问题呢?</p><ul><li>可以参考<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="external">MySQL官方文档 – 一致性非阻塞读</a><blockquote><p>The snapshot of the database state applies to SELECT statements within a transaction, not necessarily to DML statements. If you insert or modify some rows and then commit that transaction, a DELETE or UPDATE statement issued from another concurrent REPEATABLE READ transaction could affect those just-committed rows, even though the session could not query them. If a transaction does update or delete rows committed by a different transaction, those changes do become visible to the current transaction.<br>个人认为应该翻译为: 数据库状态的快照适用于事务中的SELECT语句, 而不一定适用于所有DML语句。 如果您插入或修改某些行, 然后提交该事务, 则从另一个并发REPEATABLE READ事务发出的DELETE或UPDATE语句就可能会影响那些刚刚提交的行, 即使该事务无法查询它们。 如果事务更新或删除由不同事务提交的行, 则这些更改对当前事务变得可见。</p></blockquote></li></ul></li><li><p>其实, MVCC并发控制中的读操作分为两类: <code>快照读 (snapshot read)</code> 与 <code>当前读 (current read)</code></p><ul><li><a href="https://www.cnblogs.com/cat-and-water/p/6427612.html" target="_blank" rel="external">参考</a></li><li><p>在RR级别下, 快照读是通过MVVC(多版本控制)和undo log来实现的, 而当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。如果需要实时显示数据，还是需要通过加锁来实现。这个时候会使用next-key技术来实现。</p></li><li><p>快照读, 读取专门的快照 (对于RC，快照（ReadView）会在每个语句中创建。对于RR，快照是在事务启动时创建的), 快照读的操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">简单的select操作 (不包括: select ... lock in share mode, select ... for update)</div></pre></td></tr></table></figure></li><li><p>当前读, 读取最新版本的记录, 没有快照。 在InnoDB中，当前读取根本不会创建任何快照。当前读的操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select ... lock in share mode</div><div class="line">select ... for update</div><div class="line">insert</div><div class="line">update</div><div class="line">delete</div></pre></td></tr></table></figure></li></ul></li><li><p>当然, 使用<code>隔离性</code>的最高隔离级别<code>SERIALIZABLE</code>也可以解决<code>幻读</code>, 但该隔离级别在实际中很少使用!</p></li></ol><h2 id="更新丢失"><a href="#更新丢失" class="headerlink" title="更新丢失"></a>更新丢失</h2><ol><li><p>最后聊一下<code>高并发事务</code>的另一个问题 – <code>丢失更新问题</code>, 该问题和之前几个问题需要区分开, 因为解决方案不是一类!</p></li><li><p>第一类丢失更新: A事务撤销时, 把已经提交的B事务的更新数据覆盖了。<br> <img src="/img/mysql/transaction/diushigengxin_01.png" width="608" height="243"><br> 不过, 通过后面<a href="/2017/08/01/2017-08-01-mysql_mvcc/">MVCC相关文章</a>最后的小结你会了解到, 这类更新丢失问题是不会出现的, 因为InnoDB存储引擎的隔离级别都使用了排他锁, 即使是 MVCC也不是纯MVCC, 也用到了排他锁! 这样的话事务A在未完成的时候, 其他事务是无法对事务A涉及到的数据做修改并提交的。</p></li><li><p>第二类丢失更新: A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失。<br> <img src="/img/mysql/transaction/diushigengxin_02.png" width="608" height="246"><br> 此类更新丢失问题, 无法依靠前三种隔离级别来解决, 只能用最高隔离级别 <code>Serializable</code> 或者手动使用<code>乐观锁</code>, <code>悲观锁</code>来解决。<br> 当然, 更新操作不是在所有情况下都会导致丢失更新问题, 如果你更改的最终状态是确定的, 而不是类似递减或者递增, 那是不会造成丢失更新问题的!!</p></li><li><p>最高隔离级别<code>Serializable</code>在实际应用场景中并不被采用, 对于手动使用<code>乐观锁</code>, <code>悲观锁</code>的方案, 将会在以后关于锁的文章中一并给出!</p></li></ol><p>参考资料:</p><ul><li><a href="http://mysql.taobao.org/monthly/2017/06/07/" target="_blank" rel="external">淘宝数据库内核6月报</a></li><li>《高性能MySQL》</li><li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="external">美团技术博客</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/" target="_blank" rel="external">MySQL官方文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事务的概念&quot;&gt;&lt;a href=&quot;#事务的概念&quot; class=&quot;headerlink&quot; title=&quot;事务的概念&quot;&gt;&lt;/a&gt;事务的概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;事务：可以理解为一个 &lt;strong&gt;独立的&lt;/strong&gt; 工作单元, &lt;strong&gt;在这个
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="事务" scheme="http://blog.renyimin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>HTTP - 并行连接, 持久连接</title>
    <link href="http://blog.renyimin.com/2017/04/21/2017-04-21-HTTP-Connection-Keep-Alive/"/>
    <id>http://blog.renyimin.com/2017/04/21/2017-04-21-HTTP-Connection-Keep-Alive/</id>
    <published>2017-04-21T12:10:11.000Z</published>
    <updated>2018-01-25T05:57:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常被误解的Connection首部"><a href="#常被误解的Connection首部" class="headerlink" title="常被误解的Connection首部"></a>常被误解的Connection首部</h2><ol><li><p>HTTP允许在客户端和最终的源端服务器之间存在一串HTTP中间实体(代理, 高速缓存等)。可以从客户端开始, 逐跳地将HTTP报文经过这些中间设备, 转发到源端服务器上去(或者进行反向传递)。</p></li><li><p>HTTP的Connection首部字段中有一个由,分隔的 <code>连接标签</code> 列表;</p></li><li><p>Connection首部可以承载3种不同类型的标签, 因此非常令人费解:</p><ul><li>HTTP首部字段名, 列出了只与此链接有关的首部; </li><li>任意标签值, 用于描述此链接的非标准选项;</li><li>close, 说空操作完成之后需要关闭这条持久连接;</li></ul></li><li><p>如果连接标签中包含了一个HTTP首部字段的名称, 那么这个首部字段就包含了一些连接有关的信息, 不能将其转发出去, 在将报文转发出去之前, 必须删除Connection首部列出的所有首部字段。<br> 由于Connection搜捕可以防止无意中对本地首部的转发, 因此将逐跳字首部名放入Connection首部被称为”对首部的保护”。<br> (<strong>Connection首部是个逐跳首部, 只适用于单条传输链路, 不应该沿着传输链路向下传输</strong> (参考P101))<br> <img src="/img/http/connection-not-field.png" width="550/"></p></li></ol><h2 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h2><ol><li><p>在串行请求时, 浏览器可以先完整地请求原始的HTML页面, 然后请求第一个嵌入对象, 然后请求第二个嵌入对象等, 以这种简单的方式对每个嵌入式对象进行串行处理, 很明显这样处理很慢!!</p></li><li><p>HTTP允许客户端打开多条连接, 并行地执行多个HTTP事务, 如下图, 并行加载了四幅嵌入式图片, 每个事务都有自己的TCP连接:<br> <img src="/img/http/http-concurrence-request-01.png" width="550/"></p></li><li><p>并行连接可能会提高页面的加载速度</p><ul><li>包含嵌入对象的组合页面如果能通过并行连接克服单条连接的空载时间和带宽限制, 加载速度也会有所提高。时延可以重叠起来, 而且如果单条连接没有充分利用客户端的因特网带宽, 可以将为用带宽分配来装载其他对象。</li><li>如下图, 串行和并行的对比, 并行情况下, 先装载的是封闭的HTML页面, 然后并行处理其余3个事务, 每个事务都有自己的连接。(图片的装载是并行的, 连接的时延也是重叠的)<br><img src="/img/http/chuanxing-01.png" width="550/"><br><img src="/img/http/http-concurrence-request-02.png" width="550/"></li><li>由于软件开销的存在, 每个连接请求之间总会有一些小的时延, 但连接请求和传输时间<strong>基本上</strong>都是重叠起来的!</li></ul></li><li><p>并行连接不一定更快</p><blockquote><p>即使并行连接的速度可能会更快, 但是并不一定总是更快。<br> 因为在客户端的网络带宽如果不足时, 大部分的时间可能都是用来传送数据的。在这种情况下, 一个连接到速度较快服务器上的HTTP事务就会很容易耗尽所有可用的Modem带宽。<br> 如果并行加载多个对象, 每个对象都会去竞争这有限的带宽, 每个对象都会以较慢的速度按比例加载, 这样带来的性能提升就很小, 甚至没什么提升。<br> 而且打开大量连接会消耗很多内存资源, 从而引发自身性能问题。<br> 复杂的Web有可能会有数十或数百个内嵌对象, 客户端可能可以打开数百个连接, 但Web服务器通常要同时处理很多其他用户的请求, 所以很少有Web服务器希望出现这样的情况。<br> 一百个用户同时发出申请, 每个用户打开100个连接, 服务器就要负责处理1W个连接, 这会造成服务器性能的严重下降。对高负荷的代理来说也同样如此。<br> 实际上, 浏览器确实使用了并行连接, 但它们会将并行连接的总数限制为一个较小的值(通常是四个)。服务器可以随意关闭来自特定客户端的超量连接。</p></blockquote></li><li><p>并行连接可能让人”感觉”更快一些<br>通过上面的介绍, 我们知道并行连接并不总是能使页面加载更快, 但即使实际上没有加快页面的传输速度, 并行连接通常也会让用户<code>觉得</code>页面加载的更快了,<br>因为多个组件对象同时出现屏幕上时, 用户能够看到加载的进展。如果整个屏幕上有很多动作在进行, 即使实际上整个页面的下载时间更长, 用户也会认为Web页面加载得更快一些。</p></li></ol><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><ol><li><p>HTTP/1.1(以及HTTP/1.0的各种增强版本)允许HTTP设备在事务处理结束之后将TCP连接保持在打开状态, 以便未来的HTTP请求能够重用现存的连接。在事务处理结束之后仍然保持在打开状态的TCP连接被称为<strong>持久连接</strong>。</p></li><li><p>非持久连接会在每个事务结束之后关闭, 持久连接会在不同事务之间保持打开状态, 直到客户端或服务器其决定将其关闭为止。</p></li><li><p>重用已对目标服务器打开的空闲持久连接, 就可以避开缓慢的连接建立阶段。而且已经打开的连接还可以避免慢启动的拥塞使用阶段, 以便更快速地进行数据的传输。</p></li><li><p>持久连接和并行连接</p><blockquote><p>之前已经了解过”并行连接可以提高复合页面的传输速度, 但并行连接也有一些缺点”;<br>而持久连接有一些比并行连接更好的地方,持久连接降低了时延和连接建立的开销, 将连接保持在已调谐状态, 而且减少了打开连接的潜在数量。<br>但是, 管理持久连接时要特别小心, 不然就会积累大量的空闲连接, 耗费本地以及远程客户端和服务器上的资源。</p></blockquote><p> 持久连接与并行连接配合使用可能是更高效的方式。现在, 很多Web应用程序都会打开少量的并行连接, 其中的每一个都是持久连接。</p></li><li><p>持久连接有两种类型: 比较老的 <code>HTTP/1.0+&quot;keep-alive&quot;</code> 连接, 以及现代的 <code>HTTP/1.1 &quot;persistent&quot;</code> 连接。</p></li></ol><h2 id="HTTP-1-0-keep-alive连接"><a href="#HTTP-1-0-keep-alive连接" class="headerlink" title="HTTP/1.0+keep-alive连接"></a>HTTP/1.0+keep-alive连接</h2><ol><li><p>前言:<br>大约从1996年开始, 很多HTTP/1.0浏览器和服务器都进行了扩展, 以支持一种被称为keep-alive连接的早期实验型持久连接。<br>这些早期的持久连接收到了一些互操作性设计方面问题的困扰, 这些问题在后期的HTTP/1.1版本中都得到了修正, 但很多客户端和服务器仍然在使用这些早期的keep-alive连接。</p></li><li><p>下图在”串行连接上实现了4个HTTP事务的时间线” 与 “在一条持久连接上实现同样事务” 所需的时间线进行了比较, <strong>显示了keep-alive连接的一些性能优点</strong><br> <strong>由于去除了创建连接和关闭连接的开销, 所以时间线有所缩减</strong><br> <img src="/img/http/keep-alive-vs-chuanxing.png" width="500/"></p></li></ol><h3 id="Keep-Alive操作"><a href="#Keep-Alive操作" class="headerlink" title="Keep-Alive操作"></a><strong>Keep-Alive操作</strong></h3><p>客户端和服务器要配合</p><ol><li><p>keep-alive已经不再使用了, 而且在当前的HTTP/1.1规范中也已经没有了对它的说明了。但浏览器和服务器对keep-alive握手的使用仍然相当广泛, 因此HTTP的实现者应该做好与之进行交互操作的准备.</p></li><li><p>实现HTTP/1.0 keep alive连接的客户端可以通过包含<code>Connection: Keep-Alive</code>首部请求将一条连接保持在打开状态。</p></li><li><p>如果服务器愿意为下一条请求将连接保持在打开状态, 就在响应中包含相同的首部。如果响应中没有<code>Connection: Keep-Alive</code>首部, 客户端就认为服务器不支持keep-alive, 会在发回响应报文之后关闭连接。</p></li></ol><h3 id="还有keep-alive首部"><a href="#还有keep-alive首部" class="headerlink" title="还有keep-alive首部"></a>还有keep-alive首部</h3><ol><li><p>注意, keep-Alive首部只是请求将连接保持在活跃状态。发出keep-alive请求之后, 客户端和服务器并不一定会同意进行keep-alive会话。<br> 它们可以在任意时刻关闭空闲的keep-alive连接, 并可随意限制keep-alive连接所处理事务的数量。</p></li><li><p>可以用<code>Keep-Alive通用首部字段</code>中指定的, 有逗号分隔的选项来调节keep-alive的行为:</p><ul><li>参数timeout: 是在Keep-Alive响应首部发送的, 它估计了服务器希望将连接保持在活跃状态的时间。这并不是一个承诺值。</li><li>参数max: 是在Keep-Alive响应首部发送的, 它估计了服务器还希望为多少个事务保持次连接的活跃状态。这并不是一个承诺值。</li><li>Keep-Alive首部还可以支持任意未经处理的属性, 这些属性主要用于诊断和调试。语法为 <code>name [=value]</code>。</li></ul></li><li><p>Keep-Alive首部完全是可选的, 但只有在提供了 Connection:Keep-Alive 时才能使用它。<br> 下面这个例子说明服务器最多还会为另外5个事务保持连接的打开状态, 或者将打开状态保持到连接空闲了2分钟之后。</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Connection: Keep-Alive</div><div class="line">Keep-Alive: max=<span class="number">5</span>, timeout=<span class="number">120</span></div></pre></td></tr></table></figure></li></ol><h3 id="keep-alive连接的限制和规则"><a href="#keep-alive连接的限制和规则" class="headerlink" title="keep-alive连接的限制和规则"></a>keep-alive连接的限制和规则</h3><ol><li><p>在HTTP/1.0中, keep-alive并不是默认使用的。客户端必须发送一个 <code>Connection: Keep-Alive</code> 请求首部来激活keep-alive连接。</p></li><li><p>Connection: Keep-Alive 首部必须随所有希望保持持久连接的报文一起发送。<br> 如果客户端没有发送Connection: Keep-Alive首部, 服务器就会在那条请求之后关闭连接。</p></li><li><p>客户端如果探明响应中没有Connection: Keep-Alive响应首部, 就可以知道服务器发出响应之后是否会关闭连接了。</p></li><li><p>一般都是在检测到连接关闭之后, 就可以确定报文实体主体部分的长度。如果想”无需检测到连接关闭 就能确定报文实体主体部分的长度”,<br> 那你的响应报文的实体主体部分必须有正确的Connect-Length, 有多部件媒体类型, 或者用分块传输编码的方式进行了编码。<br> 在一条keep-alive信道中回送错误的 Connection-Length 是很糟糕的事, 这样的话, 事务处理的另一端就无法精确地检测出一条报文的结束和另一条报文的开始了。</p></li><li><p>代理和网关必须执行Connection首部的规则, 代理或网关必须在将报文转发出去或将其高速缓存之前, 删除在Connection首部中命名的所有首部字段以及Connection首部本身。</p></li><li><p>严格来说, 不应该与无法确定是否支持Connection首部的代理服务器建立keep-alive连接, 以防止出现下面要介绍的<code>哑代理</code>问题, 在实际应用中不是总能做到这一点的。 </p></li><li><p>从技术上来讲, 应该忽略所有来自HTTP/1.0设备的Connection首部字段(包括Connection:Keep-Alive), 因为他们可能是由比较老的代理服务器误转发的。<br>但是实际上, 尽管可能会有在老代理上挂起的危险, 有些客户端和服务器还是会违反这条规则。</p></li><li><p>除非重复发送请求会产生其他副作用, 否则 “如果在客户端受到完整响应之前连接就关闭了, 那么客户端一定要做好重试请求的准备”。 </p></li></ol><h3 id="Keep-Alive和哑代理"><a href="#Keep-Alive和哑代理" class="headerlink" title="Keep-Alive和哑代理"></a>Keep-Alive和哑代理</h3><ol><li><p>正常情况下, 如果客户端与一台服务器对话, 客户端可以发送一个 Connection:Keep-Alive 首部来告知服务器它希望保持连接的活跃状态, 如果服务器支持keep-alive, 就回送一个 Connection:Keep-Alive 首部, 否则就不回送。</p></li><li><p>问题是出在代理上 — 尤其是那些不理解Connection首部, 而且不知道在沿着转发链路将报文转发出去之前应该将Connection首部删除的代理。<br> 很多老式或简单的代理都是<code>盲中继(blind relay)</code>, 他们只是将字节从一个连接转发到两一个连接中去, 不对Connection首部进行特殊处理。</p></li><li><p>下图就是一个Web客户端通过一个作为盲中继使用的哑代理与Web服务器进行对话的例子:<br> <img src="/img/http/blind-relay.png" width="500/"><br> 更多参考: P101<br> 盲中继的更多问题参考 4.5.7 (??)</p></li><li><p>为了防止此类代理通信问题的发生, 现在的代理都决不能转发Connection首部和所有名字出现在Connection值中的首部。<br> 另外还有几个不能作为Connection首部的值, 并且也不能被代理转发或作为缓存响应使用的首部:<br> Proxy-Authenticate, Proxy-Connection, Transfer-Encoding 和 Upgrade;</p></li></ol><h2 id="HTTP-1-1-persistent连接"><a href="#HTTP-1-1-persistent连接" class="headerlink" title="HTTP/1.1 persistent连接"></a>HTTP/1.1 persistent连接</h2><ol><li>HTTP/1.1主键停止了对keep-alive连接的支持, 用一种名为持久连接(persistent connection)的改进型设计取代了它。<br> 持久连接的目的与keep-alive连接的目的相同, 但机制更优一些。</li><li><p>与HTTP/1.0的keep-alive连接不同, HTTP/1.1持久连接在默认情况下是激活的。除非特别指明, 否则HTTP/1.1假定所有连接都是持久的。<br> 要在事务处理结束之后将连接关闭, HTTP/1.1应用程序必须向报文中显示地添加一个<code>Connection:close</code>首部。<br> 这是与以前的HTTP协议很重要的区别, 在以前的版本中, keep-alive连接要么是可选的, 要么根本就不支持。</p></li><li><p>HTTP/1.1客户端假定在收到响应后, 除非响应中包含了 <code>Connection:close</code>首部, 不然HTTP/1.1连接就仍维持在打开状态。<br> 但是, 客户端和服务器仍然可以随时关闭空闲的连接。 不发送 <code>Connection:close</code> 并不以为这服务器承诺永远将连接保持在打开状态。</p></li></ol><h3 id="persistent连接的限制和规则"><a href="#persistent连接的限制和规则" class="headerlink" title="persistent连接的限制和规则 (??)"></a>persistent连接的限制和规则 (??)</h3><ol><li>发送了 <code>Connection:close</code> 请求首部之后, 客户端就无法在那条连接上发送更多的请求了。</li><li>如果客户端不想在连接上发送其他请求了, 就应该在最后一条请求中发送一个 <code>Connection:close</code>  请求首部。</li><li>只有当连接上所有的报文都有正确的, 自定义报文长度时 – 也就是, 实体主体部分的长度都和响应 Connect-Length 一致, 或者是用分块传输编码方式编码的 — 连接才能持久保持。</li><li>HTTP/1.1的代理必须能够分别管理与客户端和服务器的持久连接 — 每个持久连接都值适用于一跳传输。</li><li>(由于较老的代理会转发Connection首部, 所以)HTTP/1.1的代理服务器不应该与HTTP/1.0客户端建立持久连接, 除非他们了解客户端的处理能力。<br> 实际上, 这一点是很难做到的, 很多厂商都违背了这一原则。</li><li>尽管服务器不应该试图在传输报文的过程中关闭连接, 而且在关闭连接之前至少应该响应一条请求, 但不管Connection首部取了什么值, HTTP/1.1设备都可以在任意时刻关闭连接。</li><li>HTTP/1.1应用程序必须能够从异步的关闭中恢复出来, 只要不存在可能会累积起来的副作用, 客户端都应该重试这条请求。(??)</li><li>除非重复发送请求会产生其他副作用, 否则 “如果在客户端收到完整响应之前连接就关闭了, 那么客户端必须要重新发送请求”</li><li>一个用户客户端对任何服务器或代理, 最多只能维护两条持久连接, 以防服务器过载。<br> 代理可能需要更多到服务器的连接来支持并发用户的通信, 所以如果有N个用户试图访问服务器的话, 代理最多要维持2N条到任意服务器或父代理的连接。</li></ol><h2 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h2><ol><li>HTTP/1.1允许在持久连接上可选地会用<strong>请求管道</strong>。这是在keep-alive连接上的进一步性能优化。在相应到达之前, 可以将多条请求放入队列。<br> 当第一条请求通过网络流向地球另一端的服务器时, 第二条和第三条也可以开始发送了。<br> 在高时延网络条件下, 这样做可以降低网络的回环时间, 提高性能。</li><li>如下图:<br> <img src="/img/http/pipeline-persistent-connections.png" width="550/"><h3 id="对管道化连接的限制"><a href="#对管道化连接的限制" class="headerlink" title="对管道化连接的限制"></a>对管道化连接的限制</h3></li><li><strong>如果HTTP客户端无法确认连接是持久的, 就不应该使用管道</strong>。</li><li>必须按照与请求相同的顺序回送HTTP响应。<strong>HTTP报文中没有序列号标签, 因此如果收到的响应失序了, 就没办法将其与请求匹配起来了</strong>。</li><li>HTTP客户端必须做好连接会在任意时刻关闭的准备, 还要准备好重发所有未完成的管道化请求。<br> 如果客户端打开了一条持久连接, 并立即发出了10条请求, 服务器可能在只处理了5条请求后关闭了连接, 剩下的5条请求会失败, 客户端必须能够应对这些过早关闭连接的情况, 重新发出这些请求。</li><li>HTTP客户端不应该用管道化的方式发送回产生副作用的请求(比如POST)。<br> 总之, 出错的时候, 管道化方式会阻塞客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全地重试<strong>POST这样的非幂等请求</strong>, 所以出错时, 就存在某些方法永远不会被执行的风险。</li></ol><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><h3 id="“任意”解除连接"><a href="#“任意”解除连接" class="headerlink" title="“任意”解除连接"></a>“任意”解除连接</h3><p>所有HTTP客户端, 服务器或代理都可以在任意时刻关闭一条TCP传输连接, 通常会在一条报文结束时关闭连接, 但出错的时候, 也可能在首部行中间, 或其他奇怪的地方关闭连接。<br>对管道化持久连接来说, 这种情形是很常见的。HTTP应用程序可以在经过任意一段时间之后，关闭持久连接。比如，在持久连接空闲一段时间之后，服务器可能会决定将其关闭。<br>但是，服务器永远都无法确定在它关闭”空闲”连接的那一刻，在线路的那一头的客户端有没有数据要发送。如果出现这种情况，客户端就会在写入半截请求报文时发现出现了连接错误。</p><h3 id="Conetent-Length-及-截尾操作"><a href="#Conetent-Length-及-截尾操作" class="headerlink" title="Conetent-Length 及 截尾操作"></a>Conetent-Length 及 截尾操作</h3><p>每条HTTP响应都应该有精确的Content-Length首部，用来描述响应主体的尺寸。<strong>如果老的HTTP服务器省略了Content-Length或者包含错误的长度指示，这样就要一来服务器发出连接关闭来说明数据的真是末尾</strong>。</p><h3 id="连接关闭容限-重试及幂等性"><a href="#连接关闭容限-重试及幂等性" class="headerlink" title="连接关闭容限,重试及幂等性"></a>连接关闭容限,重试及幂等性</h3><p>即使在非错误情况下,连接也可以在任意时刻关闭。<br>HTTP应用程序要做好正确处理非预期关闭的准备。<br>如果在客户端执行事务的过程中, 传输连接关闭了, 那么, 除非事务处理会带来一些副作用, 否则客户端就应该重新打开连接, 并重试一次。<br>对管道化连接来说, 这种情况更加严重一些。客户端可以将大量请求放入队列中排队, 但源端服务器可以关闭连接, 这样就会留下大量未处理的请求, 需要重新调度。</p><p>副作用是很重要的问题, 如果在发送出一些请求数据之后, 收到返回结果之前, 连接关闭了, 客户端就无法百分之百地确定服务器端实际激活了多少事务。<br>有些事务, 比如GET一个静态的HTML页面, 可以反复执行多次, 也不会有什么变化。而其他一些事务, 比如向一个在线书店POST一张订单, 就不能重复执行, 不然会有下多张订单的危险。</p><p>如果一个事务， 不管是执行一次还是很多次，得到的结果都相同, <strong>这个事务就是幂等的</strong>。实现者们可以认为GET、HEAD、PUT、DELETE、TRACE和OPTIONS方法都共享这一特性。客户端不应该以管道化方式传送非幂等请求(比如POST)。<br>否则，传输连接的过早终止就会造成一些不确定的后果。要发送一条非幂等请求，就需要等待来自前一条清求的响应状态。</p><p>尽管用户Agent代理可能会让操作员来选择是否对请求进行重试，但一定不能自动重试非幂等方法或序列。<br><strong>比如，大多数浏览器都会在重载一个缓存的POST响应时提供一个对话框，询问用户是否希望再次发起事务处理</strong>。</p><h3 id="正常关闭连接"><a href="#正常关闭连接" class="headerlink" title="正常关闭连接"></a>正常关闭连接</h3><ol><li><p>正常关闭连接<br>TCP连接是双向的。TCP连接的每一端都有一个输入队列和一个输出队列, 用于数据的读或写。放入一端输出队列中的数据最终会出现在另一端的输入队列中。</p></li><li><p>完全关闭与半关闭<br>应用程序可以关闭TCP输入和输出信道中的任意一个, 或者将两者都关闭了。<br>套接字调用close()会将TCP连接的输入和输出信道都关闭了, 这被称作 “完全关闭”。<br>还可以用套接字调用shutdown()单独关闭输入或输出信道。这被称为”半关闭”。<br><img src="/img/http/close-shutdown-pipeline.png" width="350/"></p></li><li><p>TCP关闭及重置错误<br>….</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《HTTP权威指南》– 第四章<br>《图解HTTP协议》<br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/HTTP</a><br><a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">https://tools.ietf.org/html/rfc2616</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常被误解的Connection首部&quot;&gt;&lt;a href=&quot;#常被误解的Connection首部&quot; class=&quot;headerlink&quot; title=&quot;常被误解的Connection首部&quot;&gt;&lt;/a&gt;常被误解的Connection首部&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;H
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP - 缓存</title>
    <link href="http://blog.renyimin.com/2017/04/19/2017-04-19-HTTP-cache/"/>
    <id>http://blog.renyimin.com/2017/04/19/2017-04-19-HTTP-cache/</id>
    <published>2017-04-19T13:15:10.000Z</published>
    <updated>2018-02-01T10:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h2><p>Web缓存是指可以自动保存常见文档副本的HTTP设备。当Web请求抵达缓存设备时, 如果缓存设备本地有”已缓存的”副本, 就可以从本地设备而不是原始服务器中提取这个文档。<br>使用缓存的优点:<br>1.减少了冗余的数据传输, 节省了你的网络费用</p><blockquote><p>有很多客户端访问一个流行的原始服务器页面时, 服务器会多次传输同一份文档, 每次传送给一个客户端。<br>这样就会导致一些相同的字节在网络中一遍遍地传输, 这些冗余的数据传输会耗尽昂贵的网络带宽, 降低传输速度, 加重Web服务器的负载。<br>有了缓存, 就可以保留第一条服务器响应的副本, 后继请求就可以由缓存的副本来应对了, 这样可以减少那些流入/流出原始服务器而被浪费掉了的重复流量。</p></blockquote><p>2.缓解了网络本身的瓶颈问题, 不需要更多的带宽就能够更快地加载页面</p><blockquote><p>很多网络为本地网络客户端提供的带宽比为远程度服务器提供的带宽要宽。(这个大家应该有深有体会, 局域网内传输是很快的!!!)<br>如果客户端能够从一个快速局域网的缓存中得到一份副本, 那么缓存就可以提高性能—尤其是要传输比较大的文件时。</p></blockquote><p>3.降低了对原始服务器的要求, 服务器可以更快地响应, 避免过载的出现</p><blockquote><p>瞬间拥塞: 突发事件(爆发性新闻, 抢购等)使很多人几乎同时去访问一个Web文档时, 就会出现瞬间拥塞, 由此造成的过多流量峰值可能会使网络和Web服务器产生灾难性的崩溃。<br>而缓存在应对瞬间拥塞时就显得非常重要。</p></blockquote><p>4.降低了<strong>距离时延</strong>, 因为从较远的地方加载页面会更慢一些<br>即使带宽不是问题, 距离也可能成为问题。<strong>每台网络路由器都会增加因特网流量的时延</strong>。即使客户端和服务器之间没有太多的路由器, <strong>光速自身也会造成显著的时延</strong>。</p><blockquote><p>比如波士顿到旧金山的直线距离大约为2700英里, 在最好的情况下, 以光速传输(186000英里/秒)的信号可以在大约15毫秒从波士顿传送到旧金山, 并在30毫秒内完成一个往返。<br>假设某个Web页面包含了20个小图片, 都在旧金山的一台服务器上, 如果波士顿的一个客户端打开了4条到服务器的并行连接, 而且保持着连接的活跃状态, 光速自身就要消耗大约1/4秒(240毫秒)的下载时间。如果服务器位于(距离旧金山6700英里)的东京, 时延就会变成600毫秒。<br>中等复杂的web页面会带来几秒钟的光速时延。<br>况且实际应用中, 信号的传输速度会比光速低一些, 因此距离时延会更加严重。</p></blockquote><p>而将缓存放在附近的机房里可以将文件传输距离从数千英里缩短为数十米。</p><h2 id="缓存命中、未命中"><a href="#缓存命中、未命中" class="headerlink" title="缓存命中、未命中"></a>缓存命中、未命中</h2><ol><li><p>如果一些请求到达缓存设备时, 缓存设备可以用本地已有的副本为这些请求提供服务, 就被称为<strong>缓存命中</strong>。</p></li><li><p>如果一些请求到达缓存设备时, 缓存设备本地没有副本提供给这些请求, 而将请求转发给原始服务器, 这就被称为<strong>缓存未命中</strong>。</p></li><li><p>后面还有 <strong>再验证命中</strong> 和 <strong>再验证未命中</strong> 的概念;</p></li></ol><h2 id="引出文档过期-和-服务器再验证"><a href="#引出文档过期-和-服务器再验证" class="headerlink" title="引出文档过期 和 服务器再验证"></a>引出文档过期 和 服务器再验证</h2><ol><li><p>已缓存的数据要与服务器数据保持一致: 缓存设备本地的副本 并不是时刻都与原始服务器上的文档一样, 毕竟服务器中的这些文档会随着时间发生变化(比如有些报告可能每个月都会变化, 而在线报纸每天都会变化, 财经数据可能每过几秒就会发生变化)。所以, 如果缓存提供的总是老的数据, 就会变得毫无用处。</p></li><li><p>HTTP通过一些简单的机制, 可以做到: 在不要求服务器记住有哪些缓存设备拥有其文档副本的情况下, 保持已缓存数据与服务器数据之间的充分一致。<br> HTTP将这些简单的机制称为 <strong>文档过期(document expiration)</strong>(也就是缓存副本的过期时间) 和 <strong>服务器再验证(server revalidation)</strong>。</p></li></ol><h2 id="缓存副本的过期时间"><a href="#缓存副本的过期时间" class="headerlink" title="缓存副本的过期时间"></a>缓存副本的过期时间</h2><ol><li><p>原始服务器通过 老式的HTTP/1.0+的实体首部字段<code>Expires</code> 或 新式的HTTP/1.1的通用首部字段<code>Cache-Control:max-age</code> 可以向每个文档附加一个<strong>过期日期</strong>。</p><ul><li><code>Expires</code> 和 <code>Cache-Control:max-age</code> 所做的事情本质上是一直的, 但由于 <code>Cache-Control</code> 首部使用的是相对时间而不是绝对时间, 所以我们更倾向与使用比较新的 <code>Cache-Control</code> 首部。</li><li><code>Expires</code> 绝对日期依赖于计算机时钟的正确设置</li><li>如下图:<br><img src="/img/http/expire-max-age.png" width="550/"></li></ul></li><li><p>在<strong>缓存文档过期之前</strong>, 缓存设备可以随意使用这些副本, 而且无需与服务器做任何联系(<strong><em>当然, 除非客户端请求中包含”阻止提供缓存”的首部<code>Cache-Control:no-store</code>, 或者客户端请求中包含”只有经过验证才能返回缓存副本”的首部<code>Cache-Control:no-cache</code></em></strong>),<br>但是一旦已缓存文档过期, 缓存设备就必须与服务器进行核对(<strong><em>当然, 除非你设置了<code>Cache-Control:only-if-cached</code>要求只使用缓存</em></strong>),询问文档是否被修改过, 如果被修改过, 就要获取一份新鲜(带有新的过期日期)的副本。</p></li></ol><p>3.<strong>注意</strong>: </p><pre><code>- 不推荐使用Expires首部, 它指定的是实际的过期日期而不是秒数。HTTP设计者后来认为, 由于很多服务器的时钟都不同步, 或者不正确, 所以最好还是用剩余秒数, 而不是绝对时间来表示过期时间。- 有些服务器还会回送一个`Expires:0`响应头,视图将文档置于永远过期的状态, 但这种语法是非法的, 可能给某个软件带来问题, 应该试着支持这种结构的输入, 但是不应该产生这种结构的输出。- 而 `Cache-Control` 的 `max-age` 则可以设置 `Cache-Control: max-age=0`</code></pre><ol><li>另外, 注意 <code>no-cache</code> 和 <code>must-revalidate</code> 的区别<ul><li>no-cache: 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验。</li><li>must-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。(这应该是缓存系统的默认行为, 但must-revalidate指令使得这个要求是明确的<a href="https://stackoverflow.com/questions/2932890/http-cache-control-max-age-must-revalidate" target="_blank" rel="external">参考</a>)</li><li><a href="https://segmentfault.com/a/1190000007317481" target="_blank" rel="external">可参考</a></li></ul></li></ol><h2 id="缓存副本过期后的”再验证”"><a href="#缓存副本过期后的”再验证”" class="headerlink" title="缓存副本过期后的”再验证”"></a>缓存副本过期后的”再验证”</h2><ol><li><p>原始服务器上的内容可能会发生变化, 缓存要不时地对其进行检测, 看看自己保存的副本是否仍是服务器上最新的副本。这种”新鲜度检测”就被称为HTTP再验证(revalidation)。</p></li><li><p>虽然缓存可以在任意时刻, 以任意的频率从对副本进行再验证, 但是由于缓存中通常会包含数百万的文档, 而且网络带宽是很珍贵的, 所以大部分缓存<strong>只有在客户端发起请求,并且副本旧的足以需要再次检测的时候</strong>, 才会对副本进行再验证。</p></li><li><p><strong>副本旧的足以需要再次检测的时候?</strong> 也就是缓存副本的过期时间已到!!</p></li><li><p>但是仅仅是已缓存文档过期了, 还不能说明该过期文档和原始服务器上的文档有实际的区别, 这只是意味着<strong>到时间进行再验证了</strong>！</p></li></ol><h3 id="再验证命中-缓慢命中"><a href="#再验证命中-缓慢命中" class="headerlink" title="再验证命中(缓慢命中)"></a>再验证命中(缓慢命中)</h3><ol><li><p>缓存对副本进行再验证时, 会向原始服务器发送一个小的再验证请求。如果发现内容没有变化, 服务器会以一个小的 <code>304 Not Modified</code> 进行响应。<br> 只要缓存知道副本仍然有效, 就会再次将副本标识为暂时新鲜的, 并将副本提供给客户端, 这被称为<strong>再验证命中(revalidate hit)</strong> 或 <strong>缓慢命中(slow hit)</strong>。<br> <img src="/img/http/revalidate-hit-01.png" width="300/"></p></li><li><p><strong>当然, 这种方式确实还是需要与原始服务器进行核对, 所以会比单纯的缓存命中要慢, 但是它并没有从服务器中获取对象数据, 所以要比缓存未命中要快一些。</strong></p></li></ol><h3 id="再验证未命中"><a href="#再验证未命中" class="headerlink" title="再验证未命中"></a>再验证未命中</h3><ol><li><p>缓存对副本进行再验证时, 会向原始服务器发送一个小的再验证请求。如果缓存发现服务器对象与已缓存副本不同, 则服务器会向客户端发送一条普通的, 带有完整内容的 <code>HTTP 200 OK</code> 响应;<br> <img src="/img/http/revalidate-not-hit-01.png" width="300/"></p></li><li><p><strong>当然, 这种方式确实不仅需要与原始服务器进行核对, 而且会从服务器中获取对象数据, 所以理论上貌似要比缓存未命中要慢一些, 但其实差不多</strong></p></li></ol><h3 id="再验证-–-服务器对象被删除"><a href="#再验证-–-服务器对象被删除" class="headerlink" title="再验证 – 服务器对象被删除"></a>再验证 – 服务器对象被删除</h3><p>如果再验证发现服务器对象已经被删除, 服务器就回送一个 <code>404 Not Found</code> 响应, 缓存也会将其副本删除。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>成功的再验证 比 缓存未命中 要快</strong><br><strong>失败的再验证 几乎和 缓存未命中 速度一样</strong></p><h3 id="再验证–条件方法"><a href="#再验证–条件方法" class="headerlink" title="再验证–条件方法"></a>再验证–条件方法</h3><ol><li><p>为了有效地进行再验证, HTTP定义了一些特殊的请求, <strong>不用从服务器上获取整个对象, 就可以快速检测出内容是否是最新的</strong>。</p></li><li><p>HTTP的<code>条件方法</code>可以高效地实现再验证。<br> HTTP允许缓存向原始服务器发送一个 “条件GET”, 请求只有在服务器文档与缓存中现有的副本不同时, web服务器才会回送对象主体;<br> 通过这种方式, 将新鲜度检测和对象获取结合成了单个条件GET。<br> 向GET请求报文中添加一些特殊的<code>条件首部</code>, 就可以发起<code>条件GET</code>。</p></li><li><p>HTTP定义了5个条件请求首部, 对 <code>缓存再验证</code> 来说有用的2个首部是 <code>If-Mofified-Since</code> 和 <code>If-None-Match</code>, 所有的条件首部都以前缀<code>If-</code>开头。<br> <img src="/img/http/revalidate-01.png" width="500/"></p></li></ol><h3 id="If-Modified-Since-Date-再验证"><a href="#If-Modified-Since-Date-再验证" class="headerlink" title="If-Modified-Since:Date 再验证"></a>If-Modified-Since:Date 再验证</h3><ol><li><p>最常见的缓存再验证首部是 <code>请求首部字段 If-Modified-Since</code>, <code>If-Modified-Since</code>再验证请求通常被称为IMS请求。</p><ul><li>如果自If-Modified-Since指定日期之后, 文档被修改了, <code>If-Modified-Since</code> 条件就为真, 通常GET就会成功执行, <strong>携带新首部的新文档</strong>会被返回给缓存, 新首部除了其他信息之外, 还包含了一个新的过期日期;</li><li>如果自If-Modified-Since指定日期之后, 文档没被修改, <code>If-Modified-Since</code> 条件就为假, 会向客户端<strong>返回一个小的 304 Not Modified响应报文</strong>, 为了提高有效性, <strong>不会返回文档主体</strong>。<br>这些首部是放在响应中返回的, 但是只会返回哪些需要在源端更新的首部, 比如, Content-Type首部通常不会被修改, 所以通常不需要发送。一般会发送一个新的过期日期。</li></ul></li><li><p>请求首部字段<code>If-Modified-Since</code> 和 实体首部字段<code>Last-Modified</code> 配合工作。</p><ul><li>原始服务器会将最后的修改日期附加到所提供的文档上去, 当缓存要对已缓存文档进行再验证时, 就会包含一个<code>If-Modified-Since</code>首部, 其中携带有最后修改已缓存副本的日期: <code>If-Modified-Since:&lt;cached last-modified date&gt;</code></li><li>如果在此期间原始服务器文档被修改了, 最后的修改日期就会不同了, 这样<code>If-Modified-Since</code>条件就为真, 原始服务器就会回送新的文档；</li><li>否则, 服务器会注意到缓存的最后修改日期与服务器文档当前的最后修改日期相符合, 则会返回一个 <code>304 Not Modified</code> 响应。</li></ul></li><li><p>小结: 如果在验证发现原始服务器内容未发生变化, If-Modified-Since在验证会返回304响应, 如果发生了变化, 就返回带有新主体的200响应。</p></li></ol><h3 id="If-None-Match-实体标签再验证"><a href="#If-None-Match-实体标签再验证" class="headerlink" title="If-None-Match 实体标签再验证"></a>If-None-Match 实体标签再验证</h3><h4 id="实体标签"><a href="#实体标签" class="headerlink" title="实体标签"></a>实体标签</h4><ol><li><p>有些情况下使用最后修改日期进行再验证是不够的:</p><ul><li>有些文档可能会被周期性地重写, 但实际包含的数据常常却是一样的。<strong>尽管内容没有发生变化, 但是修改日期会发生变化</strong>。</li><li>有些文档可能内容被修改了, 但是<strong>所做的修改并不重要</strong>, 不需要让世界范围内的缓存都重装数据(比如对拼写或注释的修改)。<br>  <strong>涉及到弱验证器</strong></li><li>有些服务器无法准确地判定其页面的最后修改日期。</li><li>有些服务器提供的文档会在亚秒间隙发生变化(比如,实时监视器), 对这些服务器来说, <strong>以秒为粒度的修改日期可能就不够用了</strong>。</li></ul></li><li><p>为了解决上述问题, HTTP有一个被称为 <code>实体标签(ETag)</code> 的 <code>版本标识符</code>, 这个实体标签是附加到文档上的任意标签, 标签可能可能包含了文档序列号或版本名, 或是文档内容的校验及其他指纹信息。<br> 当对文档进行修改时, 可以修改文档的实体标签来说明这个新的版本。这样, 如果实体标签被修改了, 缓存就可以用 <code>If-None-Match</code> 条件首部来GET文档的新副本了。</p></li><li><p>假设缓存中有一个文档已经过(Expires:, Cache-Control:max-age)期, 或者其他配置导致需要再次验证, 如果缓存中有一个实体标签为v2.6, 则它会与原始服务器进行再验证:</p><ul><li>如果服务器上的实体标签已经发生了变化(可能变成了v3.0, 和v2.6不再匹配), 服务器则会在一个 <code>200 OK</code> 响应中返回新的内容以及新的Etag标签 ;</li><li>如果标签仍然与原始服务器标签匹配, 则会返回一条304 Not Modified响应;</li></ul></li></ol><h4 id="弱验证器"><a href="#弱验证器" class="headerlink" title="弱验证器"></a>弱验证器</h4><ol><li><p>只要原始服务器内容发生变化, 则实体标签就会变化, 正常情况下, 强验证器就会对比失败, 导致服务器会在一个 <code>200 OK</code> 响应中返回新的内容以及新的Etag标签;</p></li><li><p>有时, 服务器希望对文档进行一些不重要的修改, 并且不需要使所有已缓存副本都失效<br>HTTP1.1支持的”弱验证器”, 就允许对一些内容做修改, 此时服务器会用前缀 <code>W/</code> 来标识弱验证器。</p></li><li><p>不管相关的实体值以何种方式发生了变化, 强实体标签都要发生变化, 而相关实体在语义上发生了比较重要的变化时, 弱实体标签页应该发生变化。</p></li></ol><h3 id="实体标签-和-最近修改日期"><a href="#实体标签-和-最近修改日期" class="headerlink" title="实体标签 和 最近修改日期"></a>实体标签 和 最近修改日期</h3><blockquote><p>如果服务器回送了一个实体标签, HTTP/1.1客户端就必须使用实体标签验证器。<br>如果服务器只回送了一个Last-Modified值, 客户端就可以使用 If-Modified-Since 验证。<br>如果实体标签和最后修改日期都提供了, 客户端就应该使用这两种再验证方案, 这样HTTP1.0和HTTP1.1换成你都可以正确响应了。</p></blockquote><p>除非HTTP/1.1原始服务器无法生成实体标签验证器, 否则就应该发送一个出去, 如果使用弱实体标签有优势的话, 发送的可能就是个弱实体标签, 而不是强实体标签。而且最好同时发送一个最近修改值。<br>如果HTTP/1.1缓存或服务器受到的请求既带有 If-Modified-Since, 又带有实体标签条件首部, <strong>那么只有这两个条件都满足时, 才能返回 <code>304 Not Modified</code> 响应</strong>(也就是两个都做验证)。</p><h2 id="缓存状态码-200-和-304"><a href="#缓存状态码-200-和-304" class="headerlink" title="缓存状态码 200 和 304"></a>缓存状态码 200 和 304</h2><h3 id="200-ok"><a href="#200-ok" class="headerlink" title="200 ok :"></a><code>200 ok</code> :</h3><p>参考P176: HTTP没有为用户提供一种手段来区分响应是缓存命中的, 还是访问原始服务器得到的。<strong>在这两种情况下, 响应状态码都是200OK</strong>, 说明响应有主体部分。…..</p><ol><li><p>缓存命中(这里指的是公共的代理缓存命中)</p><ul><li>客户端第一次访问资源, 浏览器和服务器之间有代理服务器, 这样的话, 由于这个代理服务器是个公共代理, 所以里面可能已经有了 “服务器响应的资源和200 ok副本”, 所以代理服务器会直接响应 “服务器响应的资源和200 ok副本”给客户端;<br><img src="/img/http/cdn-public-proxy-200.png" width="600/"></li></ul></li><li><p>访问原始服务器</p><ul><li>浏览器和服务器之间没有代理服务器, 这样的话, 客户端第一次请求资源, 则服务器直接 响应 200 ok 和 资源对象 给客户端;</li><li>客户端多次访问资源, 浏览器和服务器之间有代理服务器, 但是由于种种原因, 缓存需要再验证, 并且结果发现<strong>再验证未命中</strong>, 则服务器会响应资源对象和200 ok给代理缓存, 然后代理再响应”服务器响应的资源和200 ok副本”给客户端;</li></ul></li><li><p>浏览器直接取的自己的本地缓存<br> 此处由于浏览器之前缓存了 代理缓存服务器cdn 上的缓存副本, <strong>所以浏览器缓存的副本和上面cdn代理缓存的副本一样</strong>(age缓存时间都没变), 只不过会标注”已缓存”来表示没有响应主体部分<br> <img src="/img/http/cdn-private-200.png" width="600/"></p></li><li><p><code>304 Not Modified</code> 是缓存和服务器多确认了一次缓存有效性检测后, 发现<strong>缓存再验证命中</strong>, 但是用的还是缓存。</p></li><li><p>小结:</p><ul><li><code>304 Not Modified</code> 比 <code>再验证未命中返回200 OK</code> 快, 但是比 <code>public缓存命中返回 200 ok</code> 慢;</li><li><code>public缓存命中返回 200 ok</code> 比 <code>private 浏览器缓存命中返回 200 ok</code> 慢;</li></ul></li><li><p>参考 http权威指南176页</p></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>cache-control默认是public还是private??</p><h2 id="其他原因导致条件再验证"><a href="#其他原因导致条件再验证" class="headerlink" title="其他原因导致条件再验证????"></a>其他原因导致<code>条件再验证</code>????</h2><p>除了缓存中的副本过期会导致<code>条件再验证</code>, 还有一些客户端行为会导致条件再验证;</p><p><a href="https://www.cnblogs.com/ziyunfei/p/5642796.html" target="_blank" rel="external">https://www.cnblogs.com/ziyunfei/p/5642796.html</a><br>immutable, 反正大概就是说 在缓存过期时间内, 即使用户刷新页面(这说的是普通刷新, 不包括强制刷新), 也不会去做再验证（因为还特么没有到我设置的过期时间, 那必然没有过期, 你来验证也是白验证, 而且服务器还会响应304, 虽然字节很少, 但也架不住量大）</p><h2 id="公有和私有缓存"><a href="#公有和私有缓存" class="headerlink" title="公有和私有缓存"></a>公有和私有缓存</h2><ol><li><p>通用首部字段(general header fields)<code>Cache-Control</code>有两个缓存响应指令: <code>public</code> 和 <code>private</code> </p></li><li><p>缓存可以是<code>单个用户专用的</code>, 也可以是<code>数千名用户共享的</code> ;</p></li></ol><ul><li>专用缓存被称为<code>私有缓存(private cache)</code>, 私有缓存是个人的缓存, 包含了单个用户最常用的页面 ;</li><li>共享缓存被称为<code>公有缓存(public cache)</code>, 公有缓存包含了某个用户团体常用页面 ;</li></ul><h3 id="私有缓存"><a href="#私有缓存" class="headerlink" title="私有缓存"></a>私有缓存</h3><p>私有缓存不需要很大的动力或存储空间, 这样就可以将其做的很小, 很便宜。<br>Web浏览器中就有内建的私有缓存—大多数浏览器都会将常用文档缓存在你个人电脑的磁盘和内存中, 并且允许用户去配置缓存的大小和各种设置;</p><h3 id="公有缓存"><a href="#公有缓存" class="headerlink" title="公有缓存"></a>公有缓存</h3><ol><li>公有缓存是特殊的共享代理服务器, 被称为缓存代理服务器(caching proxy server), 或者更常见地被称为代理缓存(proxy cache)。</li><li>代理缓存会从自己本地缓存中给用户提供缓存资源, 或者代表用户与服务器进行联系。公有缓存会接受来自多个用户的访问, 所以通过它可以更好地减少冗余流量。</li><li>如下图: </li></ol><ul><li>每个客户端都会重复地访问一个(还不在私有缓存中的)新的”热门”文档。每个私有缓存都要获取同一份文档, 这样它就会多次穿过网络。</li><li>而使用共享的公有缓存时, 对于这个流行的对象, 缓存只要取一次就行了, 它会用共享的副本为所有的请求服务, 以降低网络流量。<br><img src="/img/http/private-public-cache-01.png" width="416/"></li></ul><h2 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h2><ol><li><p>客户端可以用 <code>Cache-Control</code> 请求首部来 <strong>强化</strong> 或 <strong>放松</strong> 对过期时间的限制。</p><ul><li>有些应用程序对文档的新鲜度要求很高, 对于这些应用程序, 客户端可以用 Cache-Control 首部使过期时间更严格;</li><li>另一方面, 为了提高性能, 可靠性或开支的一种折中方式, 客户端可能会放松新鲜度要求;</li></ul></li><li><p>如下对 <code>Cache-Control</code> 的请求指令进行了小结:<br><img src="/img/http/cache-control-01.png" width="600/"><br><a href="https://stackoverflow.com/questions/33818854/what-is-difference-between-max-age-and-max-stale-in-cache-control-mechanism" target="_blank" rel="external">HTTP Cache-Control: max-age和max-stale=s的区别</a></p></li><li><p><code>Pagma:no-cache</code> 和 <code>Cache-Control:no-cache</code> 一样, 不过是为了兼容HTTP/1.0;</p></li></ol><h2 id="HTTP过期算法测试"><a href="#HTTP过期算法测试" class="headerlink" title="HTTP过期算法测试"></a>HTTP过期算法测试</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//第一次刷新</span></div><div class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>($_SERVER[<span class="string">'HTTP_IF_MODIFIED_SINCE'</span>])) &#123;</div><div class="line">    header(<span class="string">"HTTP/1.1 200"</span>);</div><div class="line">    header(<span class="string">'Cache-Control: max-age=30'</span>); <span class="comment">// 放到下一行就不生效了(响应头还特么还有顺序?)</span></div><div class="line">    header(<span class="string">'Age:10'</span>);</div><div class="line">    <span class="comment">// 发现浏览器确实拿着这个日期去判断有没有过期</span></div><div class="line">    header(<span class="string">'Date:'</span>. date(<span class="string">'D, d M Y H:i:s'</span>, time()).<span class="string">' GMT'</span>);</div><div class="line">    header(<span class="string">'Last-Modified:'</span>. date(<span class="string">'D, d M Y H:i:s'</span>, time()<span class="number">-20000</span>).<span class="string">' GMT'</span>);</div><div class="line">    <span class="keyword">echo</span> <span class="number">123</span>;</div><div class="line">    <span class="keyword">exit</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//算法: expirationTime = responseTime(Date头) + freshnessLifetime(max-age/Exprie值) - currentAge(Age头)</span></div><div class="line"><span class="comment">// 此处浏览器判断 当前时间 + 30 - 10 , 差别多有20秒的过期时间</span></div><div class="line"><span class="comment">//发现只有超时之后, 才会显示出下面的信息   (firefox准确无误地实现,在未过期之前, 是不会带If-Modified-Since头去请求的)</span></div><div class="line"><span class="keyword">echo</span> <span class="number">456789</span>;<span class="keyword">die</span>;</div><div class="line"><span class="comment">//chrome比较蛋疼, 会交替显示 123 和 456789</span></div></pre></td></tr></table></figure><h2 id="稍后…"><a href="#稍后…" class="headerlink" title="稍后…."></a>稍后….</h2><p>稍后还需要研究一下浏览器的缓存机制, 普通刷新, 刷新, 回车 等机制的异同<br>还有强缓存 弱缓存的概念</p><p>参考:<br>HTTP权威指南 – 第七章 缓存<br>《图解HTTP协议》<br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/HTTP</a><br><a href="https://tools.ietf.org/html/rfc2616#section-4.5" target="_blank" rel="external">RFC 2616</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="external">MDN Web docs</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web缓存&quot;&gt;&lt;a href=&quot;#Web缓存&quot; class=&quot;headerlink&quot; title=&quot;Web缓存&quot;&gt;&lt;/a&gt;Web缓存&lt;/h2&gt;&lt;p&gt;Web缓存是指可以自动保存常见文档副本的HTTP设备。当Web请求抵达缓存设备时, 如果缓存设备本地有”已缓存的”副
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP - 请求Method</title>
    <link href="http://blog.renyimin.com/2017/04/14/2017-04-14-HTTP-Method/"/>
    <id>http://blog.renyimin.com/2017/04/14/2017-04-14-HTTP-Method/</id>
    <published>2017-04-14T12:31:10.000Z</published>
    <updated>2018-01-25T05:32:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>HTTP/1.1 中实现的 method，见<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">RFC2616</a>, 有: <code>OPTIONS</code>, <code>GET</code>, <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>, <code>CONNECT</code></p><ul><li>RFC2616中提到: PATCH，LINK，UNLINK方法被定义，但并不常见, 在<a href="https://tools.ietf.org/html/rfc2068" target="_blank" rel="external">RFC 2068</a>中实现;</li><li>《图解http协议》中LINK,UNLINK已经被http1.1废弃;</li></ul></li><li><p>规范中虽然是上面那样定义的, 但具体还要看不同应用各自是如何去实现的, 有些应用会完整实现, 有些还会扩展, 有些可能会实现一部分</p><ul><li><p>参考symfony中的 <a href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpFoundation/Request.php" target="_blank" rel="external">symfony/src/Symfony/Component/HttpFoundation/Request.php</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> METHOD_HEAD = <span class="string">'HEAD'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_GET = <span class="string">'GET'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_POST = <span class="string">'POST'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_PUT = <span class="string">'PUT'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_PATCH = <span class="string">'PATCH'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_DELETE = <span class="string">'DELETE'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_PURGE = <span class="string">'PURGE'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_OPTIONS = <span class="string">'OPTIONS'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_TRACE = <span class="string">'TRACE'</span>;</div><div class="line"><span class="keyword">const</span> METHOD_CONNECT = <span class="string">'CONNECT'</span>;</div></pre></td></tr></table></figure></li><li><p>而像postman这种工具, 实现的就比较多:<br><img src="/img/http/postman-http-method.png" width="400/"></p></li></ul></li></ol><h2 id="简要分析"><a href="#简要分析" class="headerlink" title="简要分析"></a>简要分析</h2><ol><li><p><code>PUT</code>: 对已有资源进行更新操作, 所以是 update 操作;</p><ul><li><strong>put和post有什么区别呢</strong>?<br>在HTTP中, PUT被定义为idempotent(幂等性)的方法，POST则不是，这是一个很重要的区别。<blockquote><p>一个简单例子: 假设一个博客系统提供一个Web API(<a href="http://superblogging/blogs/post/{blog-name}" target="_blank" rel="external">http://superblogging/blogs/post/{blog-name}</a>), 可以使用PUT或者POST进行请求, HTTP的body部分就是博文内容，这是一个很简单的REST API例子。</p></blockquote></li><li><p>我们应该用PUT还是POST？<br>取决于这个REST服务的行为是否是idempotent(幂等)的, 假如发送两个请求, 希望服务器端是产生两个博客帖子，那就说明这个服务不是idempotent的, 因为多次使用产生了副作用了, 那就应该使用POST方法。<br>但如果是希望后一个请求把第一个请求覆盖掉(这不正是修改么), 那这个服务就是idempotent的。</p></li><li><p>虽然POST和PUT差别不大, 用错了也没关系, 但是你的服务一放到internet上，如果不遵从HTTP协议的规范，就可能给自己带来麻烦</p></li></ul></li><li><p><code>POST</code>: 上面已经提过了, 所以<strong>POST是非幂等的</strong>;</p><ul><li>POST和PUT都可以上传文件或者创建新信息, 但主要看你的REST服务行为是否是幂等的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">再比如, 在我们的支付系统中，一个api的功能是创建收款金额二维码，它和金额相关，每个用户可以有多个二维码，如果连续调用则会创建新的二维码，这个时候就用POST</div><div class="line">还是那个例子，用户的账户二维码只和用户关联，而且是一一对应的关系，此时这个api就可以用PUT，因为每次调用它，都将刷新用户账户二维码</div></pre></td></tr></table></figure></li></ul></li><li><p><code>PATCH</code></p><ul><li>对已有资源的操作:用于资源的部分内容的更新, 例如更新某一个字段。具体比如说只更新用户信息的电话号码字段, 而PUT用于更新某个资源较完整的内容, 比如说用户要重填完整表单更新所有信息, 后台处理更新时可能只是保留内部记录ID不变。</li><li>当资源不存在时: PATCH 可能会去创建一个新的资源, 这个意义上像是 saveOrUpdate 操作。</li><li>参考:<br>  <a href="https://segmentfault.com/q/1010000005685904/" target="_blank" rel="external">https://segmentfault.com/q/1010000005685904/</a><br>  <a href="https://unmi.cc/restful-http-patch-method/" target="_blank" rel="external">https://unmi.cc/restful-http-patch-method/</a><br>  <a href="http://restcookbook.com/HTTP%20Methods/patch/" target="_blank" rel="external">http://restcookbook.com/HTTP%20Methods/patch/</a><br>  <a href="https://tools.ietf.org/html/rfc5789" target="_blank" rel="external">https://tools.ietf.org/html/rfc5789</a></li></ul></li><li><p><code>HEAD</code>: HEAD和 <code>GET</code> 本质是一样的, 区别在于如果使用HEAD, 响应体将不会被返回，而仅仅返回HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景: 欲判断某个资源是否存在, 我们通常使用GET, 但这里用HEAD则意义更加明确。</p></li><li><p><code>GET</code>: 比较简单, 直接获取资源;</p></li><li><p><code>OPTIONS</code>: 这个方法很有趣, 但极少使用。它用于获取当前URL所支持的方法。若请求成功, 则它会在HTTP头中包含一个名为”Allow”的头, 值是所支持的方法, 如”GET, POST”。<br> 之前[介绍跨域]时, <code>CORS方案 -- (not-so-simple request)</code>中的”预检”请求用的请求方法就是 <code>OPTIONS</code></p></li><li><p><code>CONNECT</code> : 要求用隧道协议连接代理, 如使用SSL</p></li><li><p><code>TRACE</code> : 书中谁比较少用</p><blockquote><p>TRACE_Method是HTTP（超文本传输）协议定义的一种协议调试方法，该方法会使服务器原样返回任意客户端请求的任何内容。<br>TRACE和TRACK是用来调试web服务器连接的HTTP方式。支持该方式的服务器存在跨站脚本漏洞，通常在描述各种浏览器缺陷的时候，把”Cross-Site-Tracing”简称为XST。攻击者可以利用此漏洞欺骗合法用户并得到他们的私人信息。（这个命令好怕怕，无知好吓人啊）<br>如何关闭Apache的TRACE请求<br>虚拟主机用户可以在.htaccess文件中添加如下代码过滤TRACE请求:<br>RewriteEngine on<br>RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)<br>RewriteRule .* - [F]<br>服务器用户在httpd.conf尾部添加如下指令后重启apache即可:<br>TraceEnable off </p></blockquote></li><li><p><code>DELETE</code> : <a href="https://tools.ietf.org/html/rfc2616#section-9.7" target="_blank" rel="external">参考</a></p></li><li><p><code>PURGE</code> : 非规范中定义的方法</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;HTTP/1.1 中实现的 method，见&lt;a href=&quot;https://tools.ietf.org/html/rf
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>OOP - Proxy</title>
    <link href="http://blog.renyimin.com/2016/08/07/2016-08-07-OOP-Proxy/"/>
    <id>http://blog.renyimin.com/2016/08/07/2016-08-07-OOP-Proxy/</id>
    <published>2016-08-07T13:05:36.000Z</published>
    <updated>2018-01-22T03:06:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代理模式是常用的结构型设计模式之一, 当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问, 为了保证客户端使用的透明性, 所访问的<strong>真实对象与代理对象需要实现相同的接口</strong>。<br>根据代理模式的使用目的不同, 代理模式又可以分为多种类型, 例如 保护代理、远程代理、虚拟代理、缓冲代理等, 它们应用于不同的场合, 满足用户的不同需求。</p><p>代理模式是一种对象结构型模式。在代理模式中通过引入了一个新的代理对象, 代理对象在客户端对象和目标对象之间起到中介的作用, 它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ol><li>代理模式的结构比较简单, 其核心是<strong>代理类</strong>, 为了让客户端能够一致性地对待<code>真实对象</code> 和 <code>代理对象</code>, 在代理模式中引入了抽象层, 代理模式结构如下:<br> <img src="/img/oop/proxy/proxy-uml.png" width="392/"></li><li><p>代理模式包含如下三个角色:</p><ul><li><p>Subject(抽象主题角色): 它声明了真实主题和代理主题的共同接口, 这样一来在任何使用真实主题的地方都可以使用代理主题, <strong>客户端通常需要针对抽象主题角色进行编程</strong>。</p></li><li><p>Proxy(代理主题角色): 它包含了对真实主题的引用, 从而可以在任何时候操作真实主题对象; 在代理主题角色中提供一个与真实主题角色相同的接口, 以便在任何时候都可以替代真实主题; 代理主题角色还可以控制对真实主题的使用, 负责在需要的时候创建和删除真实主题对象, 并对真实主题对象的使用加以约束。<br>  通常, 在代理主题角色中, 客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作, 而不仅仅是单纯调用真实主题对象中的操作。</p></li><li><p>RealSubject(真实主题角色): 它定义了代理角色所代表的真实对象, 在真实主题角色中实现了真实的业务操作, 客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</p></li></ul></li><li><p>代码实现:<br> 代理模式的结构图比较简单, 但是在真实的使用和实现过程中要复杂很多, 特别是代理类的设计和实现。</p><ul><li><p>抽象主题类可以是接口、抽象类或具体类, 它声明了真实主题类和代理类的公共方法, 客户端针对抽象主题类编程, 一致性地对待真实主题和代理主题, 典型的抽象主题类代码如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Request</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>真实主题类继承了抽象主题类, 提供了业务方法的具体实现, 其典型代码如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Request</span><span class="params">()</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        <span class="comment">//业务方法具体实现代码  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>代理类也是抽象主题类的子类，它维持一个对真实主题对象的引用，调用在真实主题中实现的业务方法，在调用时可以在原有业务方法的基础上附加一些新的方法来对功能进行扩充或约束，最简单的代理类实现代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">private</span> $realSubject = <span class="keyword">new</span> RealSubject(); <span class="comment">//维持一个对真实主题对象的引用  </span></div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">PreRequest</span><span class="params">()</span>   </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        <span class="comment">//</span></div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Request</span><span class="params">()</span>   </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        PreRequest();  </div><div class="line">        $realSubject-&gt;Request(); <span class="comment">//调用真实主题对象的方法  </span></div><div class="line">        PostRequest();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">PostRequest</span><span class="params">()</span>   </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">       <span class="comment">//</span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li><li><p>但是, 在实际开发过程中, 代理类的实现比上述代码要复杂很多, 代理模式根据其目的和实现方式不同可分为很多种类, 其中常用的几种代理模式简要说明如下:</p><ul><li><p>远程代理(Remote Proxy): 为一个位于不同的地址空间的对象提供一个本地的代理对象, 这个不同的地址空间可以是在同一台主机中, 也可是在另一台主机中, 远程代理又称为大使(Ambassador)。</p></li><li><p>虚拟代理(Virtual Proxy): 如果需要创建一个资源消耗较大的对象, 先创建一个消耗相对较小的对象来表示, 真实对象只在需要时才会被真正创建。</p></li><li><p>保护代理(Protect Proxy): 控制对一个对象的访问, 可以给不同的用户提供不同级别的使用权限。</p></li><li><p>缓冲代理(Cache Proxy): 为某一个目标操作的结果提供临时的存储空间, 以便多个客户端可以共享这些结果。</p></li><li><p>智能引用代理(Smart Reference Proxy): 当一个对象被引用时, 提供一些额外的操作, 例如将对象被调用的次数记录下来等。</p></li></ul></li></ol><p>在这些常用的代理模式中, 有些代理类的设计非常复杂, 例如远程代理类, 它封装了底层网络通信和对远程对象的调用, 其实现较为复杂。</p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><ol><li><p>实例说明:</p><blockquote><p>某软件公司承接了某信息咨询公司的收费商务信息查询系统的开发任务, 该系统的基本需求如下:<br>(1)在进行商务信息查询之前用户需要通过身份验证, 只有合法用户才能够使用该查询系统;<br>(2)在进行商务信息查询时系统需要记录查询日志, 以便根据查询次数收取查询费用。<br>该软件公司开发人员已完成了商务信息查询模块的开发任务, 现希望能够以一种松耦合的方式向原有系统增加身份验证和日志记录功能, 客户端代码可以无区别地对待原始的商务信息查询模块和增加新功能之后的商务信息查询模块, 而且可能在将来还要在该信息查询模块中增加一些新的功能。<br>试使用代理模式设计并实现该收费商务信息查询系统。</p></blockquote></li><li><p>实例分析及类图<br>通过分析, 可以采用一种间接访问的方式来实现该商务信息查询系统的设计, 在客户端对象和信息查询对象之间增加一个代理对象, 让代理对象来实现<code>身份验证</code>和<code>日志记录</code>等功能, 而无须直接对原有的商务信息查询对象进行修改, 如下图:<br><img src="/img/oop/proxy/proxy-01.png" width="488/"><br>在上图中, <strong>客户端对象通过代理对象间接访问具有商务信息查询功能的真实对象</strong>, 在代理对象中除了调用真实对象的商务信息查询功能外, <strong>还增加了身份验证和日志记录等功能</strong>。<br>使用代理模式设计该商务信息查询系统, 结构图如下:<br><img src="/img/oop/proxy/proxy-uml-01.png" width="452/"><br>图中:<br> 业务类AccessValidator用于验证用户身份; 它提供方法Validate()来实现身份验证;<br> 业务类Logger用于记录用户查询日志; 它提供方法Log()来保存日志;<br> Searcher充当抽象主题角色;<br> RealSearcher充当真实主题角色;<br> ProxySearcher充当代理主题角色; 维持了对RealSearcher对象、AccessValidator对象和Logger对象的引用。</p></li><li>代码:</li></ol><p>本实例是 <code>保护代理</code> 和 <code>智能引用代理</code> 的应用实例, 在代理类ProxySearcher中实现对真实主题类的权限控制和引用计数, 如果需要在访问真实主题时增加新的访问控制机制和新功能, 只需增加一个新的代理类, 再修改配置文件, 在客户端代码中使用新增代理类即可, 源代码无须修改, <strong>符合开闭原则</strong>。</p><h2 id="各种代理参考"><a href="#各种代理参考" class="headerlink" title="各种代理参考"></a><a href="http://blog.csdn.net/lovelion/article/details/8228132" target="_blank" rel="external">各种代理参考</a></h2><h2 id="代理模式效果"><a href="#代理模式效果" class="headerlink" title="代理模式效果"></a>代理模式效果</h2><p>代理模式是常用的结构型设计模式之一, 它为对象的间接访问提供了一个解决方案, 可以对对象的访问进行控制。<br>代理模式类型较多, 其中远程代理、虚拟代理、保护代理等在软件开发中应用非常广泛。</p><p>代理模式的共同优点如下：</p><ul><li>能够协调调用者和被调用者, 在一定程度上降低了系统的耦合度;</li><li>客户端可以针对抽象主题角色进行编程, 增加和更换代理类无须修改源代码, 符合开闭原则, 系统具有较好的灵活性和可扩展性;</li></ul><p>此外, 不同类型的代理模式也具有独特的优点, 例如:</p><ul><li><p>远程代理为位于两个不同地址空间对象的访问提供了一种实现机制, 可以将一些消耗资源较多的对象和操作移至性能更好的计算机上, 提高系统的整体运行效率;</p></li><li><p>虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象, 可以在一定程度上节省系统的运行开销;</p></li><li><p>缓冲代理为某一个操作的结果提供临时的缓存存储空间, 以便在后续使用中能够共享这些结果, 优化系统性能, 缩短执行时间;</p></li><li><p>保护代理可以控制对一个对象的访问权限, 为不同用户提供不同级别的使用权限;</p></li></ul><p>代理模式的主要缺点如下:</p><ul><li><p>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。</p></li><li><p>实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。</p></li></ul><p>模式适用场景<br>代理模式的类型较多, 不同类型的代理模式有不同的优缺点, 它们应用于不同的场合:</p><ul><li>当客户端对象需要访问远程主机中的对象时可以使用远程代理。</li><li>当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。</li><li>当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。</li><li>当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。</li><li>当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。</li></ul><p><a href="http://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="external">参考</a><br><a href="http://blog.csdn.net/lovelion/article/details/8227953" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;代理模式是常用的结构型设计模式之一, 当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问, 为了保证客户端使用的透
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
      <category term="对象结构型" scheme="http://blog.renyimin.com/tags/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>OOP - Iterator</title>
    <link href="http://blog.renyimin.com/2016/07/28/2016-07-28-OOP-Iterator/"/>
    <id>http://blog.renyimin.com/2016/07/28/2016-07-28-OOP-Iterator/</id>
    <published>2016-07-28T13:07:31.000Z</published>
    <updated>2018-01-18T03:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们可以将电视机看成一个存储电视频道的集合对象, 通过遥控器可以对电视机中的电视频道集合进行操作, 如返回上一个频道、跳转到下一个频道或者跳转至指定的频道。<br>遥控器为我们操作电视频道带来很大的方便, 用户并不需要知道这些频道到底如何存储在电视机中。</p><p>而在软件开发中, 也存在大量类似电视机一样的类, 它们可以存储多个成员对象(元素), 这些类通常称为聚合类(Aggregate Classes), 对应的对象称为聚合对象。</p><p>为了更加方便地操作这些聚合对象, 同时可以很灵活地为聚合对象增加不同的遍历方法, 我们也需要类似电视机遥控器一样的角色, 可以访问一个聚合对象中的元素但又不需要暴露它的内部结构。</p><p>本篇将要学习的迭代器模式将为聚合对象提供一个遥控器, 通过引入迭代器, 客户端无须了解聚合对象的内部结构即可实现对聚合对象中成员的遍历, 还可以根据需要很方便地增加新的遍历方式。</p><h2 id="引用”销售管理系统中数据的遍历”"><a href="#引用”销售管理系统中数据的遍历”" class="headerlink" title="引用”销售管理系统中数据的遍历”"></a>引用”销售管理系统中数据的遍历”</h2><ol><li><p>初始方案:</p><blockquote><p>Sunny软件公司为某商场开发了一套销售管理系统, 在对该系统进行分析和设计时, Sunny软件公司开发人员发现经常需要对系统中的商品数据、客户数据等进行遍历, 为了复用这些遍历代码, Sunny公司开发人员设计了一个抽象的数据集合类AbstractObjectList, 而将存储商品和客户等数据的类作为其子类, AbstractObjectList类结构如下图所示：<br> <img src="/img/oop/iterator/iterator-01.png" width="167" height="230"></p></blockquote></li><li><p>问题: 违反 单一职责, 接口隔离</p><blockquote><p>Sunny软件公司开发人员通过对AbstractObjectList类结构进行分析, 发现该设计方案存在如下几个问题：<br> 在类图中, addObject()、removeObject() 等方法用于管理数据, 而next()、isLast()、previous()、isFirst()等方法用于遍历数据。这将导致聚合类的职责过重, 它既负责存储和管理数据, 又负责遍历数据, 违反了 “单一职责原则”, 由于聚合类非常庞大, 实现代码过长, 还将给测试和维护增加难度。<br> 如果将抽象聚合类声明为一个接口, 则在这个接口中充斥着大量方法, 不利于子类实现, 违反了 “接口隔离原则”。<br> 如果将所有的遍历操作都交给子类来实现, 将导致子类代码庞大, 而且必须暴露AbstractObjectList的内部存储细节, 向子类公开自己的私有属性, 否则子类无法实施对数据的遍历，这将破坏AbstractObjectList类的封装性。</p></blockquote></li><li><p>如何解决上述问题?<br> 解决方案之一就是将聚合类中负责遍历数据的方法提取出来, 封装到专门的类中, 实现数据存储和数据遍历分离, 无须暴露聚合类的内部属性即可对其进行操作, 而这正是迭代器模式的意图所在。</p></li></ol><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><ol><li><p>在软件开发中, 我们经常需要使用聚合对象来存储一系列数据。聚合对象拥有两个职责: 一是存储数据, 二是遍历数据。<br> 从依赖性来看，前者是聚合对象的基本职责；<br> 而后者既是可变化的，又是可分离的。<br> 因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为 <strong>“迭代器”</strong> 的对象中，<strong>由迭代器来提供遍历聚合对象内部数据的行为</strong>，这将简化聚合对象的设计，更符合 “单一职责原则” 的要求。</p></li><li><p>迭代器模式(Iterator Pattern)定义：提供一种方法来访问聚合对象, 而不用暴露这个对象的内部表示, 其别名为游标(Cursor)模式。迭代器模式是一种对象行为型模式。</p></li><li><p>在迭代器模式结构中包含<code>聚合</code>和<code>迭代器</code>两个层次结构, 考虑到系统的灵活性和可扩展性, 在迭代器模式中应用了工厂方法模式, 其模式结构如下所示:<br> <img src="/img/oop/iterator/iterator-02.png" width="395" height="280"></p></li><li><p><strong>在迭代器模式结构图中包含如下几个角色</strong>:</p><ul><li>Iterator(抽象迭代器): 它定义了访问和遍历元素的接口, 声明了用于遍历数据元素的方法, 例如: 用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。</li><li><p>ConcreteIterator(具体迭代器): 它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。</p></li><li><p>Aggregate(抽象聚合类):它用于存储和管理元素对象, 声明一个createIterator()方法用于创建一个迭代器对象, 充当抽象迭代器工厂角色。</p></li><li><p>ConcreteAggregate(具体聚合类): 它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。</p><p>在迭代器模式中, 提供了一个外部的迭代器来对聚合对象进行访问和遍历, 迭代器定义了一个访问该聚合元素的接口, 并且可以跟踪当前遍历的元素, 了解哪些元素已经遍历过而哪些没有。<br>迭代器的引入, 将使得对一个复杂聚合对象的操作变得简单。</p></li></ul></li><li><p>下面我们结合代码来对迭代器模式的结构进行进一步分析, 在迭代器模式中应用了工厂方法模式, 抽象迭代器对应于抽象产品角色, 具体迭代器对应于具体产品角色, 抽象聚合类对应于抽象工厂角色, 具体聚合类对应于具体工厂角色</p><ul><li><p>在抽象迭代器中声明了用于遍历聚合对象中所存储元素的方法，典型代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span></span>; <span class="comment">//将游标指向第一个元素  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>; <span class="comment">//将游标指向下一个元素  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>; <span class="comment">//判断是否存在下一个元素  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span></span>; <span class="comment">//获取游标指向的当前元素  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>在具体迭代器中将实现抽象迭代器声明的遍历数据的方法，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;  </div><div class="line"></div><div class="line">    <span class="keyword">private</span> ConcreteAggregate objects; <span class="comment">//维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据 </span></div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor; <span class="comment">//定义一个游标，用于记录当前访问位置  </span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(ConcreteAggregate objects)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.objects=objects;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;  ......  &#125;  </div><div class="line">          </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;  ......  &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;  ......  &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span> </span>&#123;  ......  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>需要注意的是抽象迭代器接口的设计非常重要:<br>  一方面需要充分满足各种遍历操作的要求, 尽量为各种遍历方法都提供声明;<br>  另一方面又不能包含太多方法, 因为接口中方法太多将给子类的实现带来麻烦;<br>  另外, 如果需要在具体迭代器中为聚合对象增加全新的遍历操作, 则必须修改抽象迭代器和具体迭代器的源代码，这将 <strong>违反“开闭原则”</strong>, 因此在设计时要考虑全面,避免之后修改接口。</p></li><li><p>聚合类用于存储数据并负责创建迭代器对象, 最简单的抽象聚合类代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;  </div><div class="line">    <span class="function">Iterator <span class="title">createIterator</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>具体聚合类作为抽象聚合类的子类，一方面负责存储数据，另一方面实现了在抽象聚合类中声明的工厂方法createIterator()，用于返回一个与该具体聚合类对应的具体迭代器对象，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;    </div><div class="line">    ......    </div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(<span class="keyword">this</span>);  </div><div class="line">    &#125;  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li><li><p>理解迭代器模式中 <code>具体聚合类</code> 与 <code>具体迭代器类</code> 之间存在的<strong>依赖关系</strong>和<strong>关联关系</strong>。 迭代器模式中应用了工厂方法模式(<strong>每个具体的聚合对象都对应一个具体的迭代器</strong>);</p></li></ol><h2 id="销售管理系统的解决方案代码-参考"><a href="#销售管理系统的解决方案代码-参考" class="headerlink" title="销售管理系统的解决方案代码 参考"></a><a href="http://blog.csdn.net/lovelion/article/details/9992679" target="_blank" rel="external">销售管理系统的解决方案代码 参考</a></h2><ol><li><p>如果需要增加一个新的具体聚合类, 如客户数据集合类, 并且需要为客户数据集合类提供不同于商品数据集合类的正向遍历和逆向遍历操作, 那么只需增加一个新的聚合子类和一个新的具体迭代器类即可;原有类库代码无须修改, <strong>符合“开闭原则”</strong>; </p></li><li><p>如果需要为ProductList类更换一个迭代器, 只需要增加一个新的具体迭代器类作为抽象迭代器类的子类, 重新实现遍历方法, 原有迭代器代码无须修改, 也符合“开闭原则”;</p></li><li><p>但是如果要在迭代器中增加新的方法, 则需要修改抽象迭代器源代码, <strong>这将违背“开闭原则”</strong>。</p></li></ol><h2 id="PHP迭代器"><a href="#PHP迭代器" class="headerlink" title="PHP迭代器"></a>PHP迭代器</h2><ol><li>PHP SPL 中已经提供了迭代器接口<code>Iterator</code>和容器接口<code>IteatorAggragate</code><br> <img src="/img/oop/iterator/iterator-php-01.png" width="308/"></li><li>并且PHP SPL已经提供了很多具体的迭代器对象<br> <img src="/img/oop/iterator/iterator-php-02.png" width="344/"></li><li><p>当然, 如果SPL准备的迭代器还不够, 你可以为你的<code>聚合类</code>创建<code>自定义的迭代器</code></p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="comment">// 实现自己的具体迭代器</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">private</span> $position = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> $array = <span class="keyword">array</span>();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($array)</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;array = $array;</div><div class="line">        <span class="keyword">$this</span>-&gt;position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rewind</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">current</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;array[<span class="keyword">$this</span>-&gt;position];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">key</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;position;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        ++<span class="keyword">$this</span>-&gt;position;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">valid</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;array[<span class="keyword">$this</span>-&gt;position]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Class MyAggregate 聚合容器</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">IteratorAggregate</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> $property;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 添加属性</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> $property</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addProperty</span><span class="params">($property)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;property[] = $property;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getIterator</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(<span class="keyword">$this</span>-&gt;property);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Class Client 客户端测试</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">//创建一个容器</span></div><div class="line">        $concreteAggregate = <span class="keyword">new</span> ConcreteAggregate();</div><div class="line">        <span class="comment">// 添加属性</span></div><div class="line">        $concreteAggregate-&gt;addProperty(<span class="string">'属性1'</span>);</div><div class="line">        <span class="comment">// 添加属性</span></div><div class="line">        $concreteAggregate-&gt;addProperty(<span class="string">'属性2'</span>);</div><div class="line">        <span class="comment">//给容器创建迭代器</span></div><div class="line">        $iterator = $concreteAggregate-&gt;getIterator();</div><div class="line">        <span class="comment">//遍历</span></div><div class="line">        <span class="keyword">while</span>($iterator-&gt;valid())</div><div class="line">        &#123;</div><div class="line">            $key   = $iterator-&gt;key();</div><div class="line">            $value = $iterator-&gt;current();</div><div class="line">            <span class="keyword">echo</span> <span class="string">'键: '</span>.$key.<span class="string">' 值: '</span>.$value.<span class="string">'&lt;hr&gt;'</span>;</div><div class="line">            $iterator-&gt;next();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Client:: test();</div></pre></td></tr></table></figure></li><li><p>和 <code>工厂方法</code>模式非常类似,并且做到了 ‘开闭原则’, 当你具体聚合类需要更换迭代器的时候, 不用修改客户端代码, 只用维护具体的聚合类即可!<br> (工厂方法模式, 也类似, 当你的一个日志记录器需要修改, 只用修改具体的那个工厂即可, 当然, 由于是做修改而不是扩展, 所以还是符合’开闭’原则的)</p></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>迭代器模式是一种使用频率非常高的设计模式, 通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来, 聚合对象只负责存储数据, 而遍历数据由迭代器来完成。</p></li><li><p>由于很多编程语言的类库都已经实现了迭代器模式, 因此在实际开发中，我们只需要直接使用Java、C#等语言已定义好的迭代器即可, 迭代器已经成为我们操作聚合对象的基本工具之一。</p></li><li><p>迭代器模式的主要优点如下：</p><ul><li>它支持以不同的方式遍历一个聚合对象, 在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法, 我们也可以自己定义迭代器的子类以支持新的遍历方式。</li><li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</li><li><strong>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求</strong>。</li></ul></li><li><p>迭代器模式的主要缺点如下:</p><ul><li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</li><li>抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。</li></ul></li><li><p>在以下情况下可以考虑使用迭代器模式:</p><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。</li><li>需要为一个聚合对象提供多种遍历方式。</li><li>为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。</li></ul></li></ol><p><a href="http://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="external">参考</a><br><a href="http://blog.csdn.net/lovelion/article/details/9992005" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们可以将电视机看成一个存储电视频道的集合对象, 通过遥控器可以对电视机中的电视频道集合进行操作, 如返回上一个频道、跳转到下一个频道或者跳
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
      <category term="对象行为型" scheme="http://blog.renyimin.com/tags/%E5%AF%B9%E8%B1%A1%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>OOP - Adapter</title>
    <link href="http://blog.renyimin.com/2016/07/24/2016-07-24-OOP-Adapter/"/>
    <id>http://blog.renyimin.com/2016/07/24/2016-07-24-OOP-Adapter/</id>
    <published>2016-07-24T14:02:13.000Z</published>
    <updated>2018-01-17T06:01:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>我的笔记本电脑的工作电压是20V, 而我国的家庭用电是220V, 如何让20V的笔记本电脑能够在220V的电压下工作？<br>答案是引入一个电源适配器(AC Adapter), 俗称充电器或变压器, 有了这个电源适配器, 生活用电和笔记本电脑即可兼容!</p></blockquote><p>在软件开发中, 有时也存在类似这种不兼容的情况, 我们也可以像引入一个电源适配器一样引入一个称之为适配器的角色, 来协调这些存在不兼容的结构, 这种设计方案即为适配器模式。</p><h2 id="引用玩具厂家的例子"><a href="#引用玩具厂家的例子" class="headerlink" title="引用玩具厂家的例子"></a>引用玩具厂家的例子</h2><ol><li><p>一开始的和谐<br>黑枣玩具公司专门生产玩具, 生产的玩具如狗,猫,狮子,鱼等动物, 每个玩具都可以进行’张嘴’与’闭嘴’操作, 分别调用 <code>openMouth</code> 与 <code>closeMouth</code> 方法。<br>在这个时候, 我们很容易想到可以定义一个抽象玩具类Toy, 甚至是接口Toy, 这些都不是问题, 然后其他的具体玩具类去继承/实现父类, 实现父类的方法。<br>到现在为止, 一切看起来都很正常, 都很和谐, 代码如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Toy</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">openMouth</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">closeMouth</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Toy</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">openMouth</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Dog open Mouth\n"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">closeMouth</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Dog open Mouth\n"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Toy</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">openMouth</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Cat open Mouth\n"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">closeMouth</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Cat open Mouth\n"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>平衡的破坏<br>后来为了扩大业务, 现在黑枣玩具公司与红枣遥控公司合作, 红枣遥控公司可以使用遥控设备对动物进行嘴巴控制, 不过红枣遥控公司的遥控设备是调用的动物的doMouthOpen及doMouthClose方法。<br>黑枣玩具公司的程序员现在必须要做的是对Toy系列类进行升级改造, 使Toy能调用doMouthOpen及doMouthClose方法。(又或者让红枣公司来适应自己, 但毕竟自己做的是偏底层,想做强做大)。</p></li></ol><p>考虑实现的方法时, 我们很直接地想到, 你需要的话我再在我的父类子类里给你添加这么两个方法就好啦。于是, 代码现在可能会被改造成:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Toy</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">openMouth</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">closeMouth</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//为红枣遥控公司控制接口增加doMouthOpen方法</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthOpen</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//为红枣遥控公司控制接口增加doMouthClose方法</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthClose</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Toy</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">openMouth</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Dog open Mouth\n"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">closeMouth</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Dog open Mouth\n"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//增加的方法(用来适配红枣遥控公司)</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthOpen</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;doMouthOpen();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//增加的方法</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthClose</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;closeMouth();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Toy</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">openMouth</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Cat open Mouth\n"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">closeMouth</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Cat open Mouth\n"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//增加的方法</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthOpen</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;doMouthOpen();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//增加的方法</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthClose</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;closeMouth();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当你一次又一次在父类子类里面重复添加着这两个方法的时候，总会想着如此重复的工作，但是, 当有数百个子类的时候, 这样做下去你就会觉得自己很傻。(其实我经常当这样的傻子)</p><ol><li>更加烦躁<br>当你刚改完上面的代码, 黑枣玩具公司又要与绿枣遥控公司合作, 因为绿枣遥控公司遥控设备更便宜稳定。<br>不过绿枣遥控公司的遥控设备是调用的动物的<code>operMouth(type)</code>方法来实现嘴巴控制。如果type为0则闭嘴,反之张嘴。<br>这下好了, 程序员又得对Toy及其子类进行升级, 这样下去搁谁都不淡定了, 你的代码可能如下:<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Toy</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">openMouth</span><span class="params">()</span></span>;  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">closeMouth</span><span class="params">()</span></span>;  </div><div class="line">    </div><div class="line">    <span class="comment">//这是给之前红枣公司增加的适配方法</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthOpen</span><span class="params">()</span></span>;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthClose</span><span class="params">()</span></span>;  </div><div class="line">  </div><div class="line">    <span class="comment">//这又是为绿枣遥控公司控制接口增加的适配方法  </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">operateMouth</span><span class="params">($type = <span class="number">0</span>)</span></span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Toy</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">openMouth</span><span class="params">()</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        <span class="keyword">echo</span> <span class="string">"Dog open Mouth\n"</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">closeMouth</span><span class="params">()</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        <span class="keyword">echo</span> <span class="string">"Dog open Mouth\n"</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthOpen</span><span class="params">()</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        <span class="keyword">$this</span>-&gt;doMouthOpen();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthClose</span><span class="params">()</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        <span class="keyword">$this</span>-&gt;closeMouth();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operateMouth</span><span class="params">($type = <span class="number">0</span>)</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        <span class="keyword">if</span> ($type == <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">$this</span>-&gt;closeMouth();  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="keyword">$this</span>-&gt;operateMouth();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Toy</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">openMouth</span><span class="params">()</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        <span class="keyword">echo</span> <span class="string">"Cat open Mouth\n"</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">closeMouth</span><span class="params">()</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        <span class="keyword">echo</span> <span class="string">"Cat open Mouth\n"</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthOpen</span><span class="params">()</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        <span class="keyword">$this</span>-&gt;doMouthOpen();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthClose</span><span class="params">()</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        <span class="keyword">$this</span>-&gt;closeMouth();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operateMouth</span><span class="params">($type = <span class="number">0</span>)</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        <span class="keyword">if</span> ($type == <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">$this</span>-&gt;closeMouth();  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="keyword">$this</span>-&gt;operateMouth();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>在这个时候, 程序员就必须要动脑子想办法了, 就算自己勤快, 万一哪天紫枣,青枣,黄枣,山枣这些遥控公司全来的时候, 忽略自己不断增多的工作量不说, 这个Toy类可是越来越大, 总有一天程序员不崩溃, 系统也会崩溃。</p><h2 id="问题在出在哪里呢？"><a href="#问题在出在哪里呢？" class="headerlink" title="问题在出在哪里呢？"></a>问题在出在哪里呢？</h2><ol><li><p>像上面那样编写代码, <strong>代码违反了’开-闭’原则</strong>。</p></li><li><p>我们现在面临的是: 新的接口方法要实现, 旧的接口(Toy抽象类)也不能动, 那就是得引入一个新的类–我们本文的主角–适配器。<br> 适配器要完成的功能很明确, 引用现有接口的方法实现新的接口的方法。</p></li></ol><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ol><li><p>适配器模式(Adapter): 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p></li><li><p>通用类图:<br> <img src="/img/oop/adapter/adapter-uml.png" width="424" height="691/"></p></li><li><p>代码:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">   <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Toy</span>  </span></div><div class="line"><span class="class">   </span>&#123;  </div><div class="line">       <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">openMouth</span><span class="params">()</span></span>;  </div><div class="line">     </div><div class="line">       <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">closeMouth</span><span class="params">()</span></span>;  </div><div class="line">   &#125;  </div><div class="line">     </div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Toy</span>  </span></div><div class="line"><span class="class">   </span>&#123;  </div><div class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">openMouth</span><span class="params">()</span>  </span></div><div class="line"><span class="function">       </span>&#123;  </div><div class="line">           <span class="keyword">echo</span> <span class="string">"Dog open Mouth\n"</span>;  </div><div class="line">       &#125;  </div><div class="line">     </div><div class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">closeMouth</span><span class="params">()</span>  </span></div><div class="line"><span class="function">       </span>&#123;  </div><div class="line">           <span class="keyword">echo</span> <span class="string">"Dog close Mouth\n"</span>;  </div><div class="line">       &#125;  </div><div class="line">   &#125;  </div><div class="line">     </div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Toy</span>  </span></div><div class="line"><span class="class">   </span>&#123;  </div><div class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">openMouth</span><span class="params">()</span>  </span></div><div class="line"><span class="function">       </span>&#123;  </div><div class="line">           <span class="keyword">echo</span> <span class="string">"Cat open Mouth\n"</span>;  </div><div class="line">       &#125;  </div><div class="line">     </div><div class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">closeMouth</span><span class="params">()</span>  </span></div><div class="line"><span class="function">       </span>&#123;  </div><div class="line">           <span class="keyword">echo</span> <span class="string">"Cat close Mouth\n"</span>;  </div><div class="line">       &#125;  </div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   </div><div class="line">   <span class="comment">//目标角色:红枣遥控公司</span></div><div class="line">   <span class="class"><span class="keyword">interface</span> <span class="title">RedTarget</span>  </span></div><div class="line"><span class="class">   </span>&#123;  </div><div class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthOpen</span><span class="params">()</span></span>;  </div><div class="line">     </div><div class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthClose</span><span class="params">()</span></span>;  </div><div class="line">   &#125;  </div><div class="line">     </div><div class="line">   <span class="comment">//目标角色:绿枣遥控公司</span></div><div class="line">   <span class="class"><span class="keyword">interface</span> <span class="title">GreenTarget</span>  </span></div><div class="line"><span class="class">   </span>&#123;  </div><div class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operateMouth</span><span class="params">($type = <span class="number">0</span>)</span></span>;  </div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   </div><div class="line">   <span class="comment">//类适配器角色:红枣遥控公司  </span></div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">RedAdapter</span> <span class="keyword">implements</span> <span class="title">RedTarget</span>  </span></div><div class="line"><span class="class">   </span>&#123;  </div><div class="line">       <span class="keyword">private</span> $adaptee;  </div><div class="line">     </div><div class="line">       <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(Toy $adaptee)</span>  </span></div><div class="line"><span class="function">       </span>&#123;  </div><div class="line">           <span class="keyword">$this</span>-&gt;adaptee = $adaptee;  </div><div class="line">       &#125;  </div><div class="line">     </div><div class="line">       <span class="comment">//委派调用Adaptee的sampleMethod1方法  </span></div><div class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthOpen</span><span class="params">()</span>  </span></div><div class="line"><span class="function">       </span>&#123;  </div><div class="line">           <span class="keyword">$this</span>-&gt;adaptee-&gt;openMouth();  </div><div class="line">       &#125;  </div><div class="line">     </div><div class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doMouthClose</span><span class="params">()</span>  </span></div><div class="line"><span class="function">       </span>&#123;  </div><div class="line">           <span class="keyword">$this</span>-&gt;adaptee-&gt;closeMouth();  </div><div class="line">       &#125;  </div><div class="line">   &#125;  </div><div class="line">     </div><div class="line">   <span class="comment">//类适配器角色:绿枣遥控公司  </span></div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">GreenAdapter</span> <span class="keyword">implements</span> <span class="title">GreenTarget</span>  </span></div><div class="line"><span class="class">   </span>&#123;  </div><div class="line">       <span class="keyword">private</span> $adaptee;  </div><div class="line">     </div><div class="line">       <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(Toy $adaptee)</span>  </span></div><div class="line"><span class="function">       </span>&#123;  </div><div class="line">           <span class="keyword">$this</span>-&gt;adaptee = $adaptee;  </div><div class="line">       &#125;  </div><div class="line">     </div><div class="line">       <span class="comment">//委派调用Adaptee：GreenTarget的operateMouth方法  </span></div><div class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operateMouth</span><span class="params">($type = <span class="number">0</span>)</span>  </span></div><div class="line"><span class="function">       </span>&#123;  </div><div class="line">           <span class="keyword">if</span> ($type) &#123;  </div><div class="line">               <span class="keyword">$this</span>-&gt;adaptee-&gt;openMouth();  </div><div class="line">           &#125; <span class="keyword">else</span> &#123;  </div><div class="line">               <span class="keyword">$this</span>-&gt;adaptee-&gt;closeMouth();  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">testDriver</span>  </span></div><div class="line"><span class="class">   </span>&#123;  </div><div class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span>  </span></div><div class="line"><span class="function">       </span>&#123;  </div><div class="line">            <span class="comment">//实例化一只狗玩具  </span></div><div class="line">           $adaptee_dog = <span class="keyword">new</span> Dog();  </div><div class="line">           <span class="keyword">echo</span> <span class="string">"给狗套上红枣适配器\n"</span>;  </div><div class="line">           $adapter_red = <span class="keyword">new</span> RedAdapter($adaptee_dog);  </div><div class="line">           <span class="comment">//张嘴  </span></div><div class="line">           $adapter_red-&gt;doMouthOpen();  </div><div class="line">           <span class="comment">//闭嘴  </span></div><div class="line">           $adapter_red-&gt;doMouthClose();  </div><div class="line">           <span class="keyword">echo</span> <span class="string">"给狗套上绿枣适配器\n"</span>;  </div><div class="line">           $adapter_green = <span class="keyword">new</span> GreenAdapter($adaptee_dog);  </div><div class="line">           <span class="comment">//张嘴  </span></div><div class="line">           $adapter_green-&gt;operateMouth(<span class="number">1</span>);  </div><div class="line">           <span class="comment">//闭嘴  </span></div><div class="line">           $adapter_green-&gt;operateMouth(<span class="number">0</span>);  </div><div class="line">       &#125;  </div><div class="line">   &#125;  </div><div class="line">     </div><div class="line">   $test = <span class="keyword">new</span> testDriver();  </div><div class="line">   $test-&gt;run();</div></pre></td></tr></table></figure></li></ol><p>最后的结果就是,Toy类及其子类在不改变自身的情况下, 通过适配器实现了不同的接口。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>将一个类的接口转换成客户希望的另外一个接口, 使原本因不兼容而不能在一起工作的那些类,可以在一起工作。</p><p>适配器模式核心思想：把对某些相似的类的操作转化为一个统一的’接口’(这里是比喻的说话)–适配器,或者比喻为一个’界面’统一或屏蔽了那些类的细节。<br>适配器模式还构造了一种’机制’, 使’适配’的类可以很容易的增减, 而不用修改与适配器交互的代码, 符合’减少代码间耦合’的设计原则。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="external">参考</a><br><a href="http://blog.51cto.com/haolloyin/346128" target="_blank" rel="external">参考</a><br><a href="https://www.cnblogs.com/DeanChopper/p/4770572.html" target="_blank" rel="external">参考 适配器</a><br><a href="http://www.cnblogs.com/whoknows/articles/adapter_in_php.html" target="_blank" rel="external">参考 适配器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我的笔记本电脑的工作电压是20V, 而我国的家庭用电是220V, 如何让20V的笔记本电脑能够在220V的电压下工
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
      <category term="结构型" scheme="http://blog.renyimin.com/tags/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Laravel-Facade</title>
    <link href="http://blog.renyimin.com/2016/07/21/2016-07-21-Laravel-Facade/"/>
    <id>http://blog.renyimin.com/2016/07/21/2016-07-21-Laravel-Facade/</id>
    <published>2016-07-21T13:13:05.000Z</published>
    <updated>2018-01-17T03:17:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h2><ol><li><p>以获取配置项的 <code>Illuminate\Support\Facades\Config</code> 追踪Facade?<br> 追踪到 <code>Illuminate\Support\Facades</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static function __callStatic($method, $args)</div><div class="line">    &#123;</div><div class="line">        $instance = static::getFacadeRoot();</div><div class="line">        if (! $instance) &#123;</div><div class="line">            throw new RuntimeException(&apos;A facade root has not been set.&apos;);</div><div class="line">        &#125;</div><div class="line">        switch (count($args)) &#123;</div><div class="line">            case 0:</div><div class="line">                return $instance-&gt;$method();</div><div class="line">            case 1:</div><div class="line">                return $instance-&gt;$method($args[0]);</div><div class="line">            case 2:</div><div class="line">                return $instance-&gt;$method($args[0], $args[1]);</div><div class="line">            case 3:</div><div class="line">                return $instance-&gt;$method($args[0], $args[1], $args[2]);</div><div class="line">            case 4:</div><div class="line">                return $instance-&gt;$method($args[0], $args[1], $args[2], $args[3]);</div><div class="line">            default:</div><div class="line">                return call_user_func_array([$instance, $method], $args);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>这也就是为什么使用Facade的类可以直接使用静态调用的方式来调用方法, 正是Facade中的 <code>__callStatic</code> 方法生效了!</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代码追踪&quot;&gt;&lt;a href=&quot;#代码追踪&quot; class=&quot;headerlink&quot; title=&quot;代码追踪&quot;&gt;&lt;/a&gt;代码追踪&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;以获取配置项的 &lt;code&gt;Illuminate\Support\Facades\Config&lt;/code
      
    
    </summary>
    
      <category term="Laravel" scheme="http://blog.renyimin.com/categories/Laravel/"/>
    
    
      <category term="Laravel" scheme="http://blog.renyimin.com/tags/Laravel/"/>
    
      <category term="Facade" scheme="http://blog.renyimin.com/tags/Facade/"/>
    
  </entry>
  
  <entry>
    <title>OOP - Facade</title>
    <link href="http://blog.renyimin.com/2016/07/19/2016-07-19-OOP-Facade/"/>
    <id>http://blog.renyimin.com/2016/07/19/2016-07-19-OOP-Facade/</id>
    <published>2016-07-19T11:56:09.000Z</published>
    <updated>2018-01-17T03:33:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>外观模式是一种使用频率非常高的结构型设计模式, 它通过引入一个外观角色来简化客户端与子系统之间的交互, 为复杂的子系统调用提供一个统一的入口, 降低子系统与客户端的耦合度, 且客户端调用非常方便;</p><p>在软件开发中, 有时候为了完成一项较为复杂的功能, 一个客户类需要和多个业务类交互, 由于涉及到的类比较多, 导致使用时代码较为复杂，此时，特别需要一个类似服务员一样的角色, 由它来负责和多个业务类进行交互, 而客户类只需与该类交互。</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><ol><li><p>外观模式中, 一个子系统的外部与其内部的通信, 通过一个统一的外观类进行, 外观类将客户类与子系统的内部复杂性分隔开, 使得客户类只需要与外观角色打交道, 而不需要与子系统内部的很多对象打交道。(在外观模式中, 那些需要交互的业务类被称为子系统(Subsystem))</p></li><li><p>外观模式: 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口, 这个接口使得这一子系统更加容易使用。</p><ul><li>外观模式又称为门面模式, 它是一种对象结构型模式。</li><li>外观模式是迪米特法则的一种具体实现, 通过引入一个新的外观角色可以降低原有系统的复杂度, 同时降低客户类与子系统的耦合度。<blockquote><p>迪米特法则(Law of Demeter)又叫作最少知道原则(Least Knowledge Principle 简写LKP)<br>就是说一个对象应当对其他对象有尽可能少的了解, 不和陌生人说话。英文简写为: LoD.</p></blockquote></li></ul></li><li><p>外观模式没有一个一般化的类图描述, 通常使用下图来表示外观模式<br> <img src="/img/oop/facade/facade-uml.png" width="365" height="265/"></p><p> 外观模式包含如下两个角色：</p><ul><li>Facade(外观角色): 在客户端可以调用它的方法, 在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任; 在正常情况下, 它将所有从客户端发来的请求委派到相应的子系统去, 传递给相应的子系统对象处理。</li><li>SubSystem(子系统角色): 在软件系统中可以有一个或者多个子系统角色, 每一个子系统可以不是一个单独的类, 而是一个类的集合, 它实现子系统的功能; 每一个子系统都可以被客户端直接调用, 或者被外观角色调用, 它处理由外观类传过来的请求; 子系统并不知道外观的存在, 对于子系统而言, 外观角色仅仅是另外一个客户端而已。</li></ul></li><li><p>外观模式的主要目的在于降低系统的复杂程度, 在面向对象软件系统中, 类与类之间的关系越多, 表示系统中类之间的耦合度太大, 这样的系统在维护和修改时都缺乏灵活性, 因为一个类的改动会导致多个类发生变化, 而外观模式的引入在很大程度上降低了类与类之间的耦合关系。<br> 引入外观模式之后, 增加新的子系统或者移除子系统都非常方便, 客户类无须进行修改(或者极少的修改), 只需要在外观类中增加或移除对子系统的引用即可。<br> 从这一点来说, <strong>外观模式在一定程度上并不符合开闭原则</strong>, 增加新的子系统需要对原有系统进行一定的修改, 虽然这个修改工作量不大。</p></li><li><p>未完待续</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/lovelion/article/details/17517213）[参考](http://blog.51cto.com/haolloyin/category2.html）[参考](http://blog.csdn.net/lovelion/article/details/8258121" target="_blank" rel="external">参考</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;外观模式是一种使用频率非常高的结构型设计模式, 它通过引入一个外观角色来简化客户端与子系统之间的交互, 为复杂的子系统调用提供一个统一的入口
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>OOP - Observer</title>
    <link href="http://blog.renyimin.com/2016/06/08/2016-07-15-OOP-Observer/"/>
    <id>http://blog.renyimin.com/2016/06/08/2016-07-15-OOP-Observer/</id>
    <published>2016-06-08T12:13:17.000Z</published>
    <updated>2018-01-17T03:33:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>在日常交通中, 当红灯亮起, 来往的汽车将停止; 而绿灯亮起, 汽车可以继续前行。在这个过程中, 交通信号灯是汽车的观察目标, 而汽车是观察者; 随着交通信号灯的变化, 汽车的行为也将随之而变化, 一盏交通信号灯可以指挥多辆汽车;</p></li><li><p>在软件系统中, 有些对象之间也存在类似交通信号灯和汽车之间的关系, 一个对象的状态或行为的变化, 将导致其他对象的状态或行为也发生改变, 它们之间将产生联动。</p></li><li><p>为了更好地描述对象之间存在的这种一对多(包括一对一)的联动, <strong>观察者模式应运而生</strong>, 它定义了对象之间一种一对多的依赖关系, 让一个对象的改变能够影响其他对象。</p></li></ol><h2 id="多人联机对战游戏的设计"><a href="#多人联机对战游戏的设计" class="headerlink" title="多人联机对战游戏的设计"></a>多人联机对战游戏的设计</h2><p>引出观察者模式</p><ol><li><p>Sunny软件公司欲开发一款多人联机对战游戏(类似魔兽世界、星际争霸等游戏), 在该游戏中, 多个玩家可以加入同一战队组成联盟, 当战队中某一成员受到敌人攻击时将给所有其他盟友发送通知, 盟友收到通知后将作出响应。</p></li><li><p>Sunny软件公司开发人员需要提供一个设计方案来实现战队成员之间的联动。Sunny软件公司开发人员通过对系统功能需求进行分析, 发现在该系统中战队成员之间的联动过程可以简单描述为：<code>联盟成员受到攻击</code>–&gt;<code>发送通知给盟友</code>–&gt;<code>盟友作出响应</code>。<br> 如果按照上述思路来设计系统, 由于联盟成员在受到攻击时需要通知他的每一个盟友, 因此每个联盟成员都需要持有其他所有盟友的信息, 这将导致系统开销较大;<br> 因此Sunny公司开发人员决定引入一个新的角色 —— <code>战队控制中心</code> ——来负责维护和管理每个战队所有成员的信息;<br> 当一个联盟成员受到攻击时, 将向相应的战队控制中心发送求助信息, 战队控制中心再逐一通知每个盟友盟友再作出响应。<br> 如下图:<br> <img src="/img/oop/observer/kongzhizhongxin.png" height="200/"><br> 在图中, 受攻击的联盟成员将与战队控制中心产生联动, 战队控制中心还将与其他盟友产生联动。</p></li><li><p>如何实现对象之间的联动? 如何让一个对象的状态或行为改变时, 依赖于它的对象能够得到通知并进行相应的处理？本篇所介绍的观察者模式将为对象之间的联动提供一个优秀的解决方案, 下面就让我们正式进入观察者模式的学习。</p></li></ol><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ol><li>观察者模式是使用频率最高的设计模式之一, 它用于建立一种对象与对象之间的依赖关系, 一个对象发生改变时将自动通知其他对象, 其他对象将相应作出反应。</li><li><p>观察者模式(Observer Pattern)定义：</p><ul><li>对象之间的一种一对多依赖关系, 使得每当一个对象状态发生改变时, 其相关依赖对象皆得到通知并被自动更新。</li><li>观察者模式的别名包括<code>发布-订阅</code>(Publish/Subscribe)模式、<code>模型-视图(Model/View)模式</code>, <code>源-监听器(Source/Listener)模式</code> 或 <code>从属者(Dependents)模式</code>。</li><li>观察者模式是一种<strong>对象行为型模式</strong>。</li><li><p>观察者模式描述了如何建立对象与对象之间的依赖关系, 以及如何构造满足这种需求的系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">观察者模式包含`观察目标` 和 `观察者` 两类对象, 一个目标可以有任意数目的与之相依赖的观察者, 一旦观察目标的状态发生改变, 所有的观察者都将得到通知。</div><div class="line">作为对这个通知的响应, **每个观察者都将监视观察目标的状态**以使其状态与目标状态同步, 这种交互也称为发布-订阅(Publish-Subscribe)。</div><div class="line">观察目标是通知的发布者, 它发出通知时并不需要知道谁是它的观察者, 可以有任意数目的观察者订阅它并接收通知。</div></pre></td></tr></table></figure></li><li><p>观察者模式结构中通常包括观察目标和观察者两个继承层次结构，其结构如下图所示：<br><img src="/img/oop/observer/observer-01.png" width="607"></p></li></ul></li><li><p>在观察者模式结构图中包含如下几个角色:</p><ul><li>Subject(目标): 目标又称为主题, 它是指被观察的对象。<br>  在目标中定义了一个观察者集合, 一个目标可以接受任意数量的观察者来观察目标自己, 目标提供一系列方法来增加和删除观察者对象, 同时它定义了通知方法 <code>notify()</code>。目标类可以是接口，也可以是抽象类或具体类。</li><li><p>ConcreteSubject(具体目标): 具体目标是目标类的子类;<br>  通常它包含有经常发生改变的数据, 当它的状态发生改变时, 向它的各个观察者发出通知;</p></li><li><p>Observer(观察者): 观察者将对观察目标的改变做出反应, 观察者一般定义为接口, 该接口声明了更新数据的方法 <code>update()</code>, 因此又称为抽象观察者。</p></li><li>ConcreteObserver(具体观察者):<br>  在具体观察者中维护一个指向具体目标对象的引用, 它存储了本观察者的有关状态, 这些状态需要和具体目标的状态保持一致;<br>  它实现了在抽象观察者Observer中定义的update()方法, 通常在实现时, 可以调用具体目标类的 <code>attach()</code> 方法将自己添加到目标类的集合中或通过 <code>detach()</code> 方法将自己从目标类的集合中删除。</li></ul></li><li><p>下面通过代码来进行分析</p><ul><li><p>先看被观察的目标</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">//注册方法, 用于向观察者集合中增加一个观察者</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">attach</span><span class="params">(Observer $observer)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//注销方法, 用于在观察者集合中删除一个观察者</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">detach</span><span class="params">(Observer $observer)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//通知所有注册过的观察者对象</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notify</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">// 定义一个观察者集合,用于存放所有观察者对象</span></div><div class="line">    <span class="keyword">private</span> $observers = [];</div><div class="line"></div><div class="line">    <span class="comment">//注册方法, 用于向观察者集合中增加一个观察者</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">attach</span><span class="params">(Observer $observer)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> array_push(<span class="keyword">$this</span>-&gt;observers, $observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//注销方法, 用于在观察者集合中删除一个观察者</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">detach</span><span class="params">(Observer $observer)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        $index = array_search($observer, <span class="keyword">$this</span>-&gt;observers);</div><div class="line">        <span class="keyword">if</span> ($index === <span class="keyword">FALSE</span> || ! array_key_exists($index, <span class="keyword">$this</span>-&gt;observers)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;observers[$index]);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//通知所有观察者</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notify</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!is_array(<span class="keyword">$this</span>-&gt;observers)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;observers <span class="keyword">as</span> $observer) $observer-&gt;update();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>观察者</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//抽象观察者角色</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="comment">// 更新方法</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//观察者的名称</span></div><div class="line">    <span class="keyword">private</span> $name;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name)</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;name = $name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//更新方法</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">'Observer '</span>, <span class="keyword">$this</span>-&gt;name, <span class="string">' has notified.&lt;br /&gt;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>客户端操作</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实例化一个'观察目标'</span></div><div class="line">$subject = <span class="keyword">new</span> ConcreteSubject();</div><div class="line"><span class="comment">//实例化一个观察者</span></div><div class="line">$observer1 = <span class="keyword">new</span> ConcreteObserver(<span class="string">'lant01'</span>);</div><div class="line"><span class="comment">//'观察目标'添加第一个观察者</span></div><div class="line">$subject-&gt;attach($observer1);</div><div class="line"><span class="comment">//'观察目标' 通知 已经观察了目标自己的观察者</span></div><div class="line">$subject-&gt;notify();</div><div class="line"></div><div class="line"><span class="keyword">echo</span> <span class="string">'添加第二个观察者后, 再次通知: &lt;br/&gt;'</span>;</div><div class="line">$observer2 = <span class="keyword">new</span> ConcreteObserver(<span class="string">'lant02'</span>);</div><div class="line">$subject-&gt;attach($observer2);</div><div class="line">$subject-&gt;notify();</div><div class="line"></div><div class="line"><span class="keyword">echo</span> <span class="string">'删除第一个观察者后, 再次通知: &lt;br/&gt;'</span>;</div><div class="line">$subject-&gt;detach($observer1);</div><div class="line">$subject-&gt;notify();</div></pre></td></tr></table></figure></li><li><p>结果:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observer lant01 has notified.</div><div class="line">添加第二个观察者后, 再次通知:</div><div class="line">Observer lant01 has notified.</div><div class="line">Observer lant02 has notified.</div><div class="line">删除第一个观察者后, 再次通知:</div><div class="line">Observer lant02 has notified.</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="复杂情况-–-违反”开放-封闭原则”"><a href="#复杂情况-–-违反”开放-封闭原则”" class="headerlink" title="复杂情况 – 违反”开放-封闭原则”"></a>复杂情况 – 违反”开放-封闭原则”</h2><ol><li><p>在有些更加复杂的情况下, 具体观察者类 <code>ConcreteObserver</code> 的 <code>update()</code> 方法在执行时需要使用到 <code>具体目标类ConcreteSubject中的状态(属性)</code><br> 因此在 <code>ConcreteObserver</code> 与 <code>ConcreteSubject</code> 之间有时候还存在关联或依赖关系, 在 <code>ConcreteObserver</code> 中定义一个 <code>ConcreteSubject</code> 实例, 通过该实例获取存储在 <code>ConcreteSubject</code> 中的状态。</p></li><li><p>如果ConcreteObserver的update()方法不需要使用到ConcreteSubject中的状态属性，则可以对观察者模式的标准结构进行简化, 在具体观察者ConcreteObserver和具体目标ConcreteSubject之间无须维持对象引用。<br> 如果观察者和观察目标在具体层具有关联关系, 系统的扩展性将受到一定的影响, 增加新的具体目标类有时候需要修改原有观察者的代码, 在一定程度上违反了<strong>开闭原则</strong>, 但是如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响。</p></li></ol><h2 id="多人对战游戏的解决方案"><a href="#多人对战游戏的解决方案" class="headerlink" title="多人对战游戏的解决方案"></a>多人对战游戏的解决方案</h2><p>注意此时不太是简单的观察者模式(不是简单 <code>观察者</code> 对 <code>观察目标</code>), 因为每个玩家既可以发布求救请求, 又可以去救援别人<br>(此时队员对应了战队中心之后, 战队中心又对应了队员)<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//战队控制中心</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TeamControlCenter</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">//盟友加入战队</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setPlayers</span><span class="params">(Observer $observer)</span></span>;</div><div class="line">    <span class="comment">//盟友退出战队</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">removePlayers</span><span class="params">(Observer $observer)</span></span>;</div><div class="line">    <span class="comment">//通知战队其他成员</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notify</span><span class="params">($observerName)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteTeamControlCenter</span> <span class="keyword">implements</span> <span class="title">TeamControlCenter</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">// 用于存放本战队所有成员</span></div><div class="line">    <span class="keyword">private</span> $players = [];</div><div class="line">    <span class="comment">// 战队名称</span></div><div class="line">    <span class="keyword">private</span> $teamName;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($teamName)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;teamName = $teamName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//注册方法, 用于向观察者集合中增加一个观察者</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setPlayers</span><span class="params">(Observer $player)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (array_push(<span class="keyword">$this</span>-&gt;players, $player)) <span class="keyword">echo</span> $player-&gt;getPlayerName() . <span class="string">' 成功加入 '</span> . <span class="keyword">$this</span>-&gt;teamName . <span class="string">'战队!'</span> , <span class="string">'&lt;br/&gt;'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//注销方法, 用于在观察者集合中删除一个观察者</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">removePlayers</span><span class="params">(Observer $player)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        $index = array_search($player, <span class="keyword">$this</span>-&gt;players);</div><div class="line">        <span class="keyword">if</span> ($index === <span class="keyword">FALSE</span> || ! array_key_exists($index, <span class="keyword">$this</span>-&gt;players)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;players[$index]);</div><div class="line">        <span class="keyword">echo</span> $player-&gt;getPlayerName() . <span class="string">' 成功退出 '</span> . <span class="keyword">$this</span>-&gt;teamName . <span class="string">'战队!'</span> , <span class="string">'&lt;br/&gt;'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//通知所有观察者</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notify</span><span class="params">($playerName)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!is_array(<span class="keyword">$this</span>-&gt;players)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;players <span class="keyword">as</span> $player) &#123;</div><div class="line">            <span class="keyword">if</span> ($player-&gt;getPlayerName() != $playerName) $player-&gt;helpOther();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//抽象观察者角色</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">// 接收队友求救</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">helpOther</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 被攻击,发出求救</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">beAttacked</span><span class="params">(TeamControlCenter $concreteTeamControlCenter)</span></span>;</div><div class="line">    <span class="comment">// 获取名字</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPlayerName</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//每个玩家都是观察者</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">//玩家(观察者)的名称</span></div><div class="line">    <span class="keyword">private</span> $playerName;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($playerName)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;playerName = $playerName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPlayerName</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;playerName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遭受攻击, 发求救</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">beAttacked</span><span class="params">(TeamControlCenter $concreteTeamControlCenter)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">'我是 '</span> . <span class="keyword">$this</span>-&gt;playerName, <span class="string">', 我被攻击了&lt;br /&gt;'</span>;</div><div class="line">        <span class="comment">// 被攻击的话, 要通知战队中心, 让战队中心通知其他队友</span></div><div class="line">        $concreteTeamControlCenter-&gt;notify(<span class="keyword">$this</span>-&gt;playerName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//支援盟友</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">helpOther</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">'撑住!!!'</span> . <span class="keyword">$this</span>-&gt;playerName, <span class="string">' 来救你了&lt;br /&gt;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//创建战队控制中心</span></div><div class="line">$langya_team = <span class="keyword">new</span> ConcreteTeamControlCenter(<span class="string">'狼牙'</span>);</div><div class="line"><span class="comment">//创建玩家</span></div><div class="line">$player1 = <span class="keyword">new</span> Player(<span class="string">'金刚狼'</span>);</div><div class="line">$player2 = <span class="keyword">new</span> Player(<span class="string">'死侍'</span>);</div><div class="line"><span class="comment">//玩家加入一个战队</span></div><div class="line">$langya_team-&gt;setPlayers($player1);</div><div class="line">$langya_team-&gt;setPlayers($player2);</div><div class="line"></div><div class="line">$player1-&gt;beAttacked($langya_team);</div></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/lovelion/article/details/17517213）[参考](http://blog.51cto.com/haolloyin/category2.html）[参考](http://blog.csdn.net/lovelion/article/details/7720522" target="_blank" rel="external">参考</a><br><a href="http://blog.csdn.net/lovelion/article/details/7720537" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在日常交通中, 当红灯亮起, 来往的汽车将停止; 而绿灯亮起, 汽车可以继续前行。在这个过程中, 交通信号灯是汽车的观察目
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>OOP - Prototype</title>
    <link href="http://blog.renyimin.com/2016/06/08/2016-07-13-OOP-Prototype/"/>
    <id>http://blog.renyimin.com/2016/06/08/2016-07-13-OOP-Prototype/</id>
    <published>2016-06-08T12:13:17.000Z</published>
    <updated>2018-01-17T03:33:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Sunny软件公司一直使用自行开发的一套OA(Office Automatic, 办公自动化)系统进行日常工作办理, 但在使用过程中, 越来越多的人对工作周报的创建和编写模块产生了抱怨。<br>追其原因, Sunny软件公司的OA管理员发现, 由于某些岗位每周工作存在重复性, 工作周报内容都大同小异, 如下图工作周报示意图。<br>    <img src="/img/oop/prototype/prototype-01.png" width="605" height="207/"><br>这些周报<strong>只有一些小地方存在差异</strong>，但是现行系统每周默认创建的周报都是空白报表，用户只能通过重新输入或不断复制粘贴来填写重复的周报内容，极大降低了工作效率，浪费宝贵的时间。如何快速创建相同或者相似的工作周报，成为Sunny公司OA开发人员面临的一个新问题。</p><p>Sunny公司的开发人员通过对问题进行仔细分析, 决定按照如下思路对工作周报模块进行重新设计和实现：</p><pre><code>- 除了允许用户创建新周报外，还允许用户将创建好的周报保存为模板; - 用户在再次创建周报时，可以创建全新的周报，还可以选择合适的模板复制生成一份相同的周报，然后对新生成的周报根据实际情况进行修改，产生新的周报;- 只要按照如上两个步骤进行处理，工作周报的创建效率将得以大大提高。这个过程让我们想到平时经常进行的两个电脑基本操作：复制和粘贴，通过对已有对象的复制和粘贴，我们可以创建大量的相同对象。</code></pre><p>如何在一个面向对象系统中实现对象的复制和粘贴呢？本篇介绍的原型模式正为解决此类问题而诞生。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><ol><li><p>在使用原型模式时，我们需要首先创建一个原型对象，再通过复制这个原型对象来创建更多同类型的对象。原型模式的定义如下：</p><ul><li>原型模式(Prototype  Pattern): 使用原型实例指定创建对象的种类, 并且通过拷贝这些原型创建新的对象, 原型模式是一种对象创建型模式;</li><li><p>原型模式的工作原理很简单: 将一个原型对象传给那个要发动创建的对象, 这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。<br>由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的。<br>原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。</p><p>需要注意的是通过克隆方法所创建的对象是全新的对象, 它们在内存中拥有新的地址, 通常对克隆所产生的对象进行修改对原型对象不会造成任何影响, 每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。</p></li></ul></li><li><p>PHP中的拷贝有 <code>深拷贝</code> 和 <code>浅拷贝</code>，先来分析一下这两者的区别</p><ul><li>浅拷贝: 被拷贝对象的所有变量都含有与原对象相同的值, 而且对其他对象的引用仍然是指向原来的对象, 即浅拷贝只负责当前对象实例, 对引用的对象不做拷贝。</li><li><p>深拷贝: 被拷贝对象的所有的变量都含有与原来对象相同的值, 除了那些引用其他对象的变量, 那些引用其他对象的变量将指向一个被拷贝的新对象，而不再是原来那些被引用的对象。(即深拷贝把要拷贝的对象所引用的对象也拷贝了一次。而这种对被引用到的对象拷贝叫做间接拷贝)。</p><p>在决定以深拷贝的方式拷贝一个对象的时候, 必须决定对间接拷贝的对象是采取 <code>浅拷贝</code> 还是 <code>深拷贝</code>。</p><p>序列化深拷贝: 利用序列化来做深拷贝, 把对象写到流里的过程是序列化的过程, 这一过程称为“冷冻”或“腌咸菜”, 反序列化对象的过程叫做“解冻”或“回鲜”。</p></li></ul></li><li><p>原型模式结构图<br> <img src="/img/oop/prototype/prototype-02.png" width="468" height="221/"></p><ul><li>Prototype(抽象原型类): 它是声明克隆方法的接口, 是所有具体原型类的父类, 可以是抽象类也可以是接口, 甚至还可以是具体实现类;</li><li>ConcretePrototype(具体原型类): 它实现在抽象原型类中声明的克隆方法, 在克隆方法中返回自己的一个克隆对象;</li><li>Client(客户类): 让一个原型对象克隆原型对象自身从而创建一个新的对象, 在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。<br>原型模式的核心在于如何实现克隆方法</li></ul></li><li><p>原型模式简单演示</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Prototype</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">//浅拷贝</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//深拷贝</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title">Prototype</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">private</span> $_name;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;_name = $name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setName</span><span class="params">($name)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;_name = $name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//浅拷贝</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">clone</span> <span class="keyword">$this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//深拷贝</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        $serialize_obj = serialize(<span class="keyword">$this</span>);</div><div class="line">        $clone_obj = unserialize($serialize_obj);</div><div class="line">        <span class="keyword">return</span> $clone_obj;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> $string;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsePrototype</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">shallow</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        $demo = <span class="keyword">new</span> Demo();</div><div class="line">        $demo-&gt;string = <span class="string">"susan"</span>;</div><div class="line">        $object_shallow_first = <span class="keyword">new</span> ConcretePrototype($demo);</div><div class="line">        $object_shallow_second = $object_shallow_first-&gt;shallowCopy();</div><div class="line"></div><div class="line">        var_dump($object_shallow_first-&gt;getName());</div><div class="line">        <span class="keyword">echo</span> <span class="string">'&lt;br/&gt;'</span>;</div><div class="line">        var_dump($object_shallow_second-&gt;getName());</div><div class="line">        <span class="keyword">echo</span> <span class="string">'&lt;br/&gt;'</span>;</div><div class="line"></div><div class="line">        $demo-&gt;string = <span class="string">"sacha"</span>;</div><div class="line">        var_dump($object_shallow_first-&gt;getName());</div><div class="line">        <span class="keyword">echo</span> <span class="string">'&lt;br/&gt;'</span>;</div><div class="line">        var_dump($object_shallow_second-&gt;getName());</div><div class="line">        <span class="keyword">echo</span> <span class="string">'&lt;br/&gt;'</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">deep</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        $demo = <span class="keyword">new</span> Demo();</div><div class="line">        $demo-&gt;string = <span class="string">"Siri"</span>;</div><div class="line">        $object_deep_first = <span class="keyword">new</span> ConcretePrototype($demo);</div><div class="line">        $object_deep_second = $object_deep_first-&gt;deepCopy();</div><div class="line"></div><div class="line">        var_dump($object_deep_first-&gt;getName());</div><div class="line">        <span class="keyword">echo</span> <span class="string">'&lt;br/&gt;'</span>;</div><div class="line">        var_dump($object_deep_second-&gt;getName());</div><div class="line">        <span class="keyword">echo</span> <span class="string">'&lt;br/&gt;'</span>;</div><div class="line"></div><div class="line">        $demo-&gt;string = <span class="string">"Demo"</span>;</div><div class="line">        var_dump($object_deep_first-&gt;getName());</div><div class="line">        <span class="keyword">echo</span> <span class="string">'&lt;br/&gt;'</span>;</div><div class="line">        var_dump($object_deep_second-&gt;getName());</div><div class="line">        <span class="keyword">echo</span> <span class="string">'&lt;br/&gt;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$up = <span class="keyword">new</span> UsePrototype;</div><div class="line">$up-&gt;shallow();</div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;hr&gt;'</span>;</div><div class="line">$up-&gt;deep();</div></pre></td></tr></table></figure></li></ol><h2 id="原型管理器的引入和实现"><a href="#原型管理器的引入和实现" class="headerlink" title="原型管理器的引入和实现"></a>原型管理器的引入和实现</h2><p>原型管理器(Prototype Manager)是将多个原型对象存储在一个集合中, 供客户端使用;<br>它是一个专门负责克隆对象的工厂, 其中定义了一个集合用于存储原型对象, 如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。<br>在原型管理器中针对抽象原型类进行编程, 以便扩展。其结构如下图：<br><img src="/img/oop/prototype/prototype-03.png" width="438" height="175/"></p><ol><li>下面通过模拟一个简单的公文管理器来介绍原型管理器的设计与实现：<blockquote><p>Sunny软件公司在日常办公中有许多公文需要创建、递交和审批，例如《可行性分析报告》、《立项建议书》、《软件需求规格说明书》、《项目进展报告》等，<br> 为了提高工作效率，在OA系统中为各类公文均创建了模板，用户可以通过这些模板快速创建新的公文，这些公文模板需要统一进行管理，系统根据用户请求的不同生成不同的新公文。</p></blockquote></li><li>我们使用带原型管理器的原型模式实现公文管理器的设计，其结构如下图：<br><img src="/img/oop/prototype/prototype-04.png" width="645"></li></ol><h2 id="原型模式总结"><a href="#原型模式总结" class="headerlink" title="原型模式总结"></a>原型模式总结</h2><ol><li><p>原型模式作为一种快速创建大量相同或相似对象的方式, 在软件开发中应用较为广泛, 很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的典型应用;</p></li><li><p>主要优点</p><ul><li>当创建新的对象实例较为复杂时, 使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。</li><li>扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。</li><li>原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</li><li>可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。</li></ul></li><li><p>主要缺点</p><ul><li>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</li><li>在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</li></ul></li><li><p>适用场景(在以下情况下可以考虑使用原型模式)</p><ul><li>创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。</li><li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</li><li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</li></ul></li></ol><p><a href="http://blog.csdn.net/lovelion/article/details/17517213）[参考](http://blog.51cto.com/haolloyin/category2.html）[参考](http://blog.csdn.net/lovelion/article/details/7424559" target="_blank" rel="external">参考</a><br><a href="http://blog.csdn.net/lovelion/article/details/7424594" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Sunny软件公司一直使用自行开发的一套OA(Office Automatic, 办公自动化)系统进行日常工作办理, 但在使用过程中, 越来
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>OOP - Abstract  Factory</title>
    <link href="http://blog.renyimin.com/2016/06/08/2016-06-08-OOP-Factory/"/>
    <id>http://blog.renyimin.com/2016/06/08/2016-06-08-OOP-Factory/</id>
    <published>2016-06-08T12:13:17.000Z</published>
    <updated>2018-01-17T02:04:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工厂方法模式通过引入工厂等级结构, 解决了简单工厂模式中工厂类职责太重的问题;<br>但由于工厂方法模式中的每个工厂只生产一类产品, 可能会导致系统中存在大量的工厂类, 势必会增加系统的开销;<br>此时, 我们可以考虑<strong>将一些相关的产品组成一个 “产品族”, 由同一个工厂来统一生产</strong>, 这就是我们本文将要学习的抽象工厂模式的基本思想。</p><h2 id="界面皮肤库的初始设计"><a href="#界面皮肤库的初始设计" class="headerlink" title="界面皮肤库的初始设计"></a>界面皮肤库的初始设计</h2><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>未完待续</p><p><a href="http://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="external">参考</a><br><a href="http://blog.csdn.net/lovelion/article/details/9319181" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工厂方法模式通过引入工厂等级结构, 解决了简单工厂模式中工厂类职责太重的问题;&lt;br&gt;但由于工厂方法模式中的每个工厂只生产一类产品, 可能会
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>OOP - Factory Method</title>
    <link href="http://blog.renyimin.com/2016/06/05/2016-06-05-OOP-Factory/"/>
    <id>http://blog.renyimin.com/2016/06/05/2016-06-05-OOP-Factory/</id>
    <published>2016-06-05T11:12:21.000Z</published>
    <updated>2018-01-16T05:31:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>之前已经了解到: 简单工厂模式虽然降低了一定的耦合度, 但仍然存在一个严重问题: 当系统中需要引入新产品时, 由于静态工厂方法是通过所传入参数的不同来创建不同的产品, 所以必定还要修改工厂类的源代码, <strong>又将违背“开闭原则”</strong>。</p></li><li><p>如何实现增加新产品而不影响已有代码？<strong>工厂方法模式</strong>应运而生。</p></li></ol><h2 id="日志记录器的设计"><a href="#日志记录器的设计" class="headerlink" title="日志记录器的设计"></a>日志记录器的设计</h2><p>Sunny软件公司欲开发一个系统运行日志记录器(Logger), 该记录器可以通过多种途径保存系统的运行日志, 如通过文件记录或数据库记录, 用户可以通过修改配置文件灵活地更换日志记录方式。<br>在设计各类日志记录器时, Sunny公司的开发人员发现需要对日志记录器进行一些初始化工作, 初始化参数的设置过程较为复杂, 而且某些参数的设置有严格的先后次序, 否则可能会发生记录失败。<br>如何封装记录器的初始化过程并保证多种记录器切换的灵活性是Sunny公司开发人员面临的一个难题。</p><p>Sunny公司的开发人员通过对该需求进行分析，发现该日志记录器有两个设计要点: </p><ul><li>需要封装日志记录器的初始化过程, 这些初始化工作较为复杂, 例如需要初始化其他相关的类, 还有可能需要读取配置文件(例如连接数据库或创建文件), 导致代码较长, 如果将它们都写在构造函数中, 会导致构造函数庞大, 不利于代码的修改和维护;</li><li>用户可能需要更换日志记录方式, 在客户端代码中需要提供一种灵活的方式来选择日志记录器, <strong>尽量在不修改源代码的基础上</strong>更换或者增加日志记录方式。</li></ul><h2 id="简单工厂模式的设计"><a href="#简单工厂模式的设计" class="headerlink" title="简单工厂模式的设计"></a>简单工厂模式的设计</h2><ol><li>Sunny公司开发人员最初使用简单工厂模式对日志记录器进行了设计，初始结构如下图所示:<br> <img src="/img/oop/factory/simple-factory-04.png" width="516" height="317/"></li><li><p>在图中, LoggerFactory充当创建日志记录器的工厂, 提供了工厂方法 createLogger() 用于创建日志记录器, Logger是抽象日志记录器接口, 其子类为具体日志记录器。其中, 工厂类LoggerFactory代码片段如下所示:</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为了突出设计重点, 代码进行了简化, 省略了具体日志记录器类的初始化代码。</span></div><div class="line"><span class="comment">//日志记录器工厂  </span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggerFactory</span> </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="comment">//静态工厂方法  </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createLogger</span><span class="params">($type)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span>($type == <span class="string">'db'</span>)) &#123;  </div><div class="line">            <span class="comment">//连接数据库, 代码省略  </span></div><div class="line">            <span class="comment">//...</span></div><div class="line">            <span class="comment">//创建数据库日志记录器对象  </span></div><div class="line">            $logger = <span class="keyword">new</span> DatabaseLogger();   </div><div class="line">            <span class="comment">//初始化数据库日志记录器，代码省略 </span></div><div class="line">            <span class="comment">//...</span></div><div class="line">            <span class="keyword">return</span> logger;  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($type == <span class="string">'file'</span>) &#123;  </div><div class="line">            <span class="comment">//创建日志文件 </span></div><div class="line">            <span class="comment">//...</span></div><div class="line">            <span class="comment">//创建文件日志记录器对象  </span></div><div class="line">            Logger logger = <span class="keyword">new</span> FileLogger();   </div><div class="line">            <span class="comment">//初始化文件日志记录器，代码省略  </span></div><div class="line">            <span class="comment">//...</span></div><div class="line">            <span class="keyword">return</span> logger;            </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>正如之前学习的简单工厂模式, 存在问题:</p><ul><li>工厂类过于庞大，包含了大量的if…else…代码，导致维护和测试难度增大;</li><li><strong>系统扩展不灵活</strong>，如果增加新类型的日志记录器，必须修改静态工厂方法的业务逻辑，<strong>违反了“开闭原则”</strong>。</li></ul></li><li><p>如何解决这两个问题, 这就是本文所介绍的 <strong>工厂方法模式</strong> 的动机之一。</p></li></ol><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><ol><li><p>在简单工厂模式中只提供一个工厂类, 该工厂类处于对产品类进行实例化的中心位置, 它需要知道每一个产品对象的创建细节, 并决定何时实例化哪一个产品类。<br> <strong>简单工厂模式最大的缺点是: 当有新产品要加入到系统中时, 必须修改工厂类, 需要在其中加入必要的业务逻辑, 这违背了“开闭原则”。</strong><br> 此外, 在简单工厂模式中, 所有的产品都由同一个工厂创建, 工厂类职责较重, 业务逻辑较为复杂, 具体产品与工厂类之间的耦合度高, 严重影响了系统的灵活性和扩展性, 而工厂方法模式则可以很好地解决这一问题!</p></li><li><p>在工厂方法模式中, 我们不再提供一个统一的工厂类来创建所有的产品对象, 而是针对不同的产品提供不同的工厂, 系统提供一个与产品等级结构对应的工厂等级结构, 工厂方法模式定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">工厂方法模式(Factory Method Pattern): 定义一个用于创建对象的接口, 让子类决定将哪一个类实例化。</div><div class="line">工厂方法模式让一个类的实例化延迟到其子类。</div><div class="line">工厂方法模式又简称为工厂模式(Factory Pattern), 又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。</div><div class="line">工厂方法模式是一种类创建型模式。</div></pre></td></tr></table></figure></li><li><p>工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。工厂方法模式结构如下图所示：</p></li><li><p>在工厂方法模式结构图中包含如下几个角色:</p><ul><li>Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。</li><li>ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</li><li>Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</li><li>ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</li></ul></li><li><p>与简单工厂模式相比, 工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类，其典型代码如下所示：</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;  </div><div class="line">    <span class="keyword">public</span> Product factoryMethod();  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><pre><code>在抽象工厂中声明了工厂方法, 具体产品对象的创建由其子类负责, 客户端针对抽象工厂编程, 可在运行时再指定具体工厂类, 具体工厂类实现了工厂方法, 不同的具体工厂可以创建不同的具体产品，其典型代码如下所示：<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="comment">// 在实际使用时，具体工厂类在实现工厂方法时, 除了创建具体产品对象之外，</span></div><div class="line">        <span class="comment">// 还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>在客户端代码中，只需关心工厂类即可，**不同的具体工厂可以创建不同的产品**，典型的客户端类代码片段如下所示：<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Factory factory;  </div><div class="line">factory = <span class="keyword">new</span> ConcreteFactory(); <span class="comment">//可通过配置文件来实现 (通过配置来决定你要具体使用哪个具体的工厂类)  </span></div><div class="line">Product product;  </div><div class="line">product = factory-&gt;factoryMethod();</div></pre></td></tr></table></figure>可以通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。</code></pre><ol><li>工厂方法模式中的工厂方法能否为静态方法？为什么？<br> 貌似不太可以, 因为静态方法是类的, 不是对象的!</li></ol><h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><p>参考 <a href="http://blog.csdn.net/lovelion/article/details/9307137" target="_blank" rel="external">http://blog.csdn.net/lovelion/article/details/9307137</a></p><h2 id="隐藏工厂方法是"><a href="#隐藏工厂方法是" class="headerlink" title="隐藏工厂方法是"></a>隐藏工厂方法是</h2><p>参考 <a href="http://blog.csdn.net/lovelion/article/details/9307561" target="_blank" rel="external">http://blog.csdn.net/lovelion/article/details/9307561</a></p><p>工厂方法模式是简单工厂模式的延伸, 它继承了简单工厂模式的优点, 同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一, 是很多开源框架和API类库的核心模式。</p><h2 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h2><ul><li>在工厂方法模式中，具体的工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的具体工厂类是哪个，无须关心创建细节，甚至无须知道具体产品类的类名;</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类;</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ul><h2 id="主要缺点"><a href="#主要缺点" class="headerlink" title="主要缺点"></a>主要缺点</h2><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，<strong>系统中类的个数将成对增加</strong>，在一定程度上增加了系统的复杂度，有更多的类需要运行，会给系统带来一些额外的开销;</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到反射等技术，增加了系统的实现难度。</li></ul><p><a href="http://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="external">参考</a><br><a href="http://blog.csdn.net/lovelion/article/details/9306457" target="_blank" rel="external">参考</a><br><a href="http://blog.csdn.net/lovelion/article/details/9306745" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;之前已经了解到: 简单工厂模式虽然降低了一定的耦合度, 但仍然存在一个严重问题: 当系统中需要引入新产品时, 由于静态工厂
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>OOP - Simple Factory</title>
    <link href="http://blog.renyimin.com/2016/06/04/2016-06-04-OOP-Factory/"/>
    <id>http://blog.renyimin.com/2016/06/04/2016-06-04-OOP-Factory/</id>
    <published>2016-06-04T13:11:30.000Z</published>
    <updated>2018-01-17T03:33:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式是最常用的一类创建型设计模式, 通常所说的工厂模式是指<code>工厂方法模式</code>, 它也是使用频率最高的工厂模式。<br>简单工厂模式是工厂方法模式的”小弟”, 它不属于 GoF23种设计模式, 但在软件开发中应用也较为频繁, 通常将它作为学习其他工厂模式的入门。<br>此外，工厂方法模式还有一位”大哥” —— <strong>抽象工厂模式</strong>。这三种工厂模式各具特色, 难度也逐个加大, 在软件开发中它们都得到了广泛的应用, 成为面向对象软件中常用的创建对象的工具。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>假设公司开发的CRM系统可以显示饼状图的效果, 原始设计方案如下图: </p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> $chartObject = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($type)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">switch</span> ($chartType) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">'pie'</span> :</div><div class="line">                <span class="keyword">$this</span>-&gt;chartObject = <span class="keyword">new</span> PieChart();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'bar'</span> :</div><div class="line">                <span class="keyword">$this</span>-&gt;chartObject = <span class="keyword">new</span> BarChart();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="comment">//TODO</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;chartObject-&gt;display();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>客户端代码通过调用 ‘Client类’ 的构造函数来创建图表对象，根据参数 ‘type’ 可以得到不同类型的图表，然后再调用show()方法来显示相应的图表。</p></li></ol><h2 id="传统设计存在问题"><a href="#传统设计存在问题" class="headerlink" title="传统设计存在问题"></a>传统设计存在问题</h2><p><strong>不难看出，Client类是一个 “巨大的” 类, 在该类的设计中存在如下几个问题</strong>:</p><ul><li><p>Client类中包含很多 “if…else…” / “switch…case…”代码块，整个类的代码相当冗长, 阅读难度、维护难度和测试难度也越大, 而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断;</p></li><li><p>Client类的职责过重, 它将各种图表对象的创建和使用集中在一个类中实现, <strong>违反了“单一职责原则”</strong>, 不利于类的重用和维护;</p></li><li><p>当需要增加新类型的图表时，必须修改Client类的源代码，<strong>违反了’开闭原则’</strong>;</p></li><li><p>客户端只能通过new关键字来直接创建图像对象, 图像类与客户端Client类耦合度较高 (比如一旦类的名字发生变更, 你也必须修改Client代码的源代码);</p></li><li><p>客户端在创建Chart对象之前可能还需要进行大量初始化设置, 例如设置柱状图的颜色、高度等, 如果在Client类的构造函数中没有提供一个默认设置, 那就只能由客户端来完成初始设置，这些代码在每次创建图像对象时都会出现, 导致代码的重复。</p></li></ul><p>面对一个如此巨大、职责如此重，且与客户端代码耦合度非常高的类，我们应该怎么办？接下来介绍的 <code>简单工厂模式</code> 将在 一定程度上 解决上述问题。</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><ol><li><p>为了将图像对象的创建和使用分离, 使用简单工厂模式对图表库进行重构, 重构后的结构如下图所示：<br> <img src="/img/oop/factory/simple-factory-02.png" width="525" height="315/"></p><p> 在图中, Chart接口充当抽象产品类, 其子类PieChart和BarChart充当具体产品类, ChartFactory充当工厂类。</p></li><li><p>现在, 我们使用工厂类的 <code>静态工厂方法</code> 来创建产品对象, 如果需要更换产品, 虽然也需要更改Client源码, 但是只需修改传递给静态工厂方法中的参数即可, 例如将柱状图改为饼状图, 只需将代码 <code>$chartObject = ChartFactory::getChart(&quot;bar&quot;);</code> 改为：<code>$chartObject = ChartFactory::getChart(&quot;pie&quot;);</code>   </p></li></ol><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ol><li><p>现在你会发现: 在创建具体图像对象时, 每更换一个图像对象, 都需要修改客户端代码中静态工厂方法的参数(<strong>虽然修改都很小</strong>), 这对于客户端而言, <strong>还是违反了“开闭原则”</strong>;</p></li><li><p>有没有一种方法能够在不修改客户端代码的前提下更换具体产品对象呢？答案是肯定的，下面将介绍一种常用的实现方式:</p><ul><li>可以将静态工厂方法的参数放到配置文件中, 在配置文件中配置即可, 这样客户端代码如下所示：<br>由<code>$chartObject = ChartFactory::getChart(&quot;bar&quot;);</code><br>改为：<pre><code class="php">$type = Config::get(<span class="string">'chartType'</span>);$chartObject = ChartFactory::getChart(<span class="string">"pie"</span>);</code></pre></li></ul></li></ol><h2 id="简单工厂模式总结"><a href="#简单工厂模式总结" class="headerlink" title="简单工厂模式总结"></a>简单工厂模式总结</h2><ol><li><p>简单工厂模式提供了专门的工厂类用于创建对象, <strong>将对象的创建和对象的使用分离开</strong>, 它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用;</p></li><li><p>主要优点</p><ul><li><p>工厂类包含必要的判断逻辑, 可以决定在什么时候创建哪一个产品类的实例, 客户端可以免除直接创建产品对象的职责, 而仅仅“消费”产品, 简单工厂模式实现了对象创建和使用的分离;</p></li><li><p>客户端无须知道所创建的具体产品类的类名，只需要知道创建具体产品类所需要对应的参数即可, 对于一些复杂的类名, 通过简单工厂模式可以在一定程度减少使用者的记忆量;</p></li><li><p><strong>通过引入配置文件</strong>, 可以在不修改任何客户端代码的情况下更换和增加新的具体产品类, 在一定程度上提高了系统的灵活性, 做到了 <strong>一定程度的”开放-封闭原则”</strong>, 下面会看到其实工厂类部分还是违反的。</p></li></ul></li><li><p>主要缺点</p><ul><li><p>由于工厂类集中了所有产品的创建逻辑, 职责过重, 一旦不能正常工作, 整个系统都要受到影响;</p></li><li><p>使用简单工厂模式势, 势必会增加系统中类的个数(引入了新的工厂类), 增加了系统的复杂度和理解难度;</p></li><li><p><strong>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑, 在产品类型较多时, 有可能造成工厂逻辑过于复杂, 不利于系统的扩展和维护</strong>。(此处还是违反<strong>“开放-封闭原则”</strong>)</p></li><li><p>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p></li></ul></li><li><p>适用场景, 在以下情况下可以考虑使用<code>简单工厂模式</code>:</p><ul><li>工厂类负责创建的对象比较少, 由于创建的对象较少, 不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数, 对于如何创建对象并不关心。</li></ul></li></ol><p><strong>总之, 仍未完全做到 “开放-封闭原则”</strong></p><p><a href="http://blog.csdn.net/lovelion/article/details/17517213）[参考](http://blog.51cto.com/haolloyin/category2.html）[参考](http://blog.csdn.net/lovelion/article/details/9300731" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式是最常用的一类创建型设计模式, 通常所说的工厂模式是指&lt;code&gt;工厂方法模式&lt;/code&gt;, 它也是使用频率最高的工厂模式。&lt;br&gt;简单工厂模式是工厂方法模式的”小弟”, 它不属于 GoF23种设计模式, 但在软件开发中应用也较为频繁, 通常将它作为学习其他工厂模
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>OOP - 为什么要引入工厂类?</title>
    <link href="http://blog.renyimin.com/2016/06/03/2016-06-03-OOP-Why-Factory/"/>
    <id>http://blog.renyimin.com/2016/06/03/2016-06-03-OOP-Why-Factory/</id>
    <published>2016-06-03T05:10:39.000Z</published>
    <updated>2018-01-17T03:33:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工厂模式(包括<code>简单工厂模式</code>、<code>工厂方法模式</code> 和 <code>抽象工厂模式</code> )到底有什么用? 很多时候通过反射机制就可以很灵活地创建对象, 为毛还要工厂？</p><ol><li><p>首先要知道, 与一个对象相关的职责通常有三类:</p><ul><li>对象本身所具有的职责</li><li>创建对象的职责</li><li>使用对象的职责</li></ul></li><li><p>对象本身的职责比较容易理解, 就是对象自身所具有的一些数据和行为, 可通过一些公开的方法来实现它的职责。</p></li><li><p>接下来将简单讨论一下对象的创建职责 和 使用职责</p><h2 id="对象的-创建职责-和-使用职责"><a href="#对象的-创建职责-和-使用职责" class="headerlink" title="对象的 创建职责 和 使用职责"></a>对象的 创建职责 和 使用职责</h2></li><li><p>通常有以下几种创建对象的方式：</p><ul><li>使用new关键字直接创建对象;</li><li>通过反射机制创建对象;</li><li>通过clone()方法创建对象；</li><li>通过工厂类创建对象;</li></ul></li><li><p>在客户端代码中直接使用new关键字是最简单的一种创建对象的方式，但是它的<strong>灵活性较差</strong>，下面通过一个简单的示例来加以说明<br> 假设公司开发的CRM系统可以显示饼状图的效果, 原始设计方案如下图:</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PieChart</span></span></div><div class="line"><span class="class">    </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span><span class="params">()</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            <span class="keyword">echo</span> <span class="string">'piechart'</span>, <span class="string">'&lt;br/&gt;'</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BarChart</span></span></div><div class="line"><span class="class">    </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span><span class="params">()</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            <span class="keyword">echo</span> <span class="string">'barchart'</span>, <span class="string">'&lt;br/&gt;'</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//Client</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></div><div class="line"><span class="class">    </span>&#123;</div><div class="line">        <span class="keyword">public</span> $chartObject = <span class="keyword">null</span>;</div><div class="line">    </div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;chartObject = <span class="keyword">new</span> PieChart();</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">()</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;chartObject-&gt;display();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p> 在’client’类的构造函数中创建了’PieChart’类型的对象，并在’show’方法中调用了’chartObject’对象的’display()’方法, 这段代码看上去并没有什么问题;</p></li><li><p>下面我们来分析一下’Client’和’PieChart’之间的关系: ‘Client’类负责创建了一个’PieChart’类的对象, 并使用其方法’display()’来完成相应的业务处理;</p><ul><li>也就是说’Client’即负责对象的创建, 又负责对象的使用, <strong>创建对象和使用对象的职责耦合在一起</strong>;</li><li>同时, <strong>这样的设计会导致一个很严重的问题</strong>: 如果在 ‘Client’ 中希望能够使用另一个种类型的图像方案, 比如使用柱状图’BarChart’类的对象，那就必须修改’Client’类的源代码, <strong>违反了”开闭原则”</strong>。</li></ul></li><li><p>如何解决?</p></li></ol><h2 id="引出工厂类"><a href="#引出工厂类" class="headerlink" title="引出工厂类"></a>引出工厂类</h2><p>最常用的一种解决方法是将 ‘chartObject’ 对象的创建职责从 ‘Client’ 类中移除, 在 ‘Client’ 类之外创建对象, 那么谁来负责创建 ‘chartObject’ 对象呢?<br>答案是：工厂类; 通过引入工厂类, 客户类就不会再涉及对象的创建(只是对对象进行使用), 而创建对象的工厂类自然也只是负责创建对象(也不会涉及对象的使用)。<br>引入工厂类 ChartFactory 之后的结构如下图所示:<br><img src="/img/oop/factory/simple-factory-01.png" width="495" height="370/"></p><ol><li><p>工厂类的引入将降低维护工作量：</p><ul><li>如果图像类的构造函数发生变更, 或者需要添加或移除不同的图像类，你只要去维护 <code>ChartFactory</code> 的代码, 可能就不会影响到’Client’的代码;</li><li>而且如果 <code>Chart</code> 抽象接口发生改变, 例如添加、移除方法或改变方法名, 只需要修改 <code>Client</code>, 不会给 <code>ChartFactory</code> 带来任何影响;</li><li>在所有的工厂模式中, 我们都强调一点: 两个类A和B之间的关系应该仅仅是 <strong>A创建B</strong> 或是 <strong>A使用B</strong>, 而不能两种关系都有。将对象的创建和使用分离, 也使得系统更加符合 ‘单一职责原则’, 有利于对功能的复用和系统的维护;</li></ul></li><li><p>此外, 将对象的创建和使用分离还有一个好处:</p><ul><li>防止用来实例化一个类的代码在多个类中到处都是, 可以将有关创建的代码搬移到一个工厂类中。<br>因为有时候我们创建一个对象不只是简单调用其构造函数, 还需要设置一些参数, 可能还需要配置环境,<br>如果将这些代码散落在每一个创建对象的客户类中, 势必会出现代码重复、创建蔓延的问题, 而这些客户类其实无须承担对象的创建工作,<br>它们只需使用已创建好的对象就可以了。此时, 可以引入工厂类来封装对象的创建逻辑和客户代码的实例化/配置选项。</li></ul></li></ol><p><a href="http://blog.csdn.net/lovelion/article/details/17517213）[参考](http://blog.51cto.com/haolloyin/category2.html）[参考](http://blog.csdn.net/lovelion/article/details/7523392" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工厂模式(包括&lt;code&gt;简单工厂模式&lt;/code&gt;、&lt;code&gt;工厂方法模式&lt;/code&gt; 和 &lt;code&gt;抽象工厂模式&lt;/code&gt; )
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>OOP - Singleton-02</title>
    <link href="http://blog.renyimin.com/2016/05/27/2016-05-27-OOP-Singleton/"/>
    <id>http://blog.renyimin.com/2016/05/27/2016-05-27-OOP-Singleton/</id>
    <published>2016-05-27T12:07:13.000Z</published>
    <updated>2018-01-17T03:33:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前已经对单例模式有了比较简单的认识<br>接下来通过一些资料在系统了解一下单例模式;</p><h2 id="单例模式动机"><a href="#单例模式动机" class="headerlink" title="单例模式动机"></a>单例模式动机</h2><ol><li><p>对于一个软件系统的某些类而言, 我们无须创建多个实例。</p><blockquote><p>举个大家都熟知的例子 —— Windows任务管理器, 当你在Windows的”任务栏”的右键弹出菜单上多次点击”启动任务管理器”。<br>通常情况下，无论我们启动任务管理多少次，Windows系统始终只能弹出一个任务管理器窗口，也就是说在一个Windows系统中，任务管理器存在唯一性。<br>为什么要这样设计呢？我们可以从以下两个方面来分析：<br>其一，如果能弹出多个窗口，且这些窗口的内容完全一致，全部是重复对象，这势必会浪费系统资源，任务管理器需要获取系统运行时的诸多信息，这些信息的获取需要消耗一定的系统资源，包括CPU资源及内存资源等，浪费是可耻的，而且根本没有必要显示多个内容完全相同的窗口;<br>其二，如果弹出的多个窗口内容不一致，问题就更加严重了，这意味着在某一瞬间系统资源使用情况和进程、服务等信息存在多个状态，例如任务管理器窗口A显示“CPU使用率”为10%，窗口B显示“CPU使用率”为15%，到底哪个才是真实的呢？这纯属”调戏”用户，给用户带来误解，更不可取。<br>由此可见，确保Windows任务管理器在系统中有且仅有一个非常重要。</p></blockquote></li><li><p>回到实际开发中, 我们也经常遇到类似的情况, 为了节约系统资源, 有时需要确保系统中某个类只有唯一一个实例, 当这个唯一实例创建成功之后, 我们无法再创建一个同类型的其他对象, 所有的操作都只能基于这个唯一实例。<br> 为了确保对象的唯一性, 我们可以通过单例模式来实现, 这就是单例模式的动机所在。</p></li></ol><h2 id="参考一个负载均衡器的例子"><a href="#参考一个负载均衡器的例子" class="headerlink" title="参考一个负载均衡器的例子"></a><a href="http://blog.csdn.net/lovelion/article/details/7420885" target="_blank" rel="external">参考一个负载均衡器的例子</a></h2><blockquote><p>Sunny软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高系统的整体处理能力，缩短响应时间。<br>由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。<br>如何确保负载均衡器的唯一性是该软件成功的关键。</p></blockquote><ol><li><p>Sunny公司开发人员通过分析和权衡，决定使用单例模式来设计该负载均衡器, 将负载均衡器<code>LoadBalancer</code>设计为单例类, 其中包含一个存储服务器信息的集合serverList, 每次在serverList中随机选择一台服务器来响应客户端的请求,实现代码如下:</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoadBalancer</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $instance = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> $serverList = <span class="keyword">array</span>();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> === <span class="keyword">self</span>::$instance) &#123;</div><div class="line">            <span class="keyword">self</span>::$instance = <span class="keyword">new</span> <span class="keyword">self</span>();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 增加一台服务器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addServer</span><span class="params">($server)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;serverList[] = $server;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 减少一台宕机的服务器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">removeServer</span><span class="params">($key)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;serverList[$key]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 随机获取一台服务器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getServer</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        $random = mt_rand(<span class="number">0</span>, count(<span class="keyword">$this</span>-&gt;serverList)<span class="number">-1</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;serverList[$random];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;pre/&gt;'</span>;</div><div class="line">$loadBalancer1 = LoadBalancer::getInstance();</div><div class="line">$loadBalancer2 = LoadBalancer::getInstance();</div><div class="line">var_dump($loadBalancer1 === $loadBalancer2);</div><div class="line">$loadBalancer1-&gt;addServer(<span class="string">"Server 1"</span>);</div><div class="line">$loadBalancer1-&gt;addServer(<span class="string">"Server 2"</span>);</div><div class="line">$loadBalancer2-&gt;addServer(<span class="string">"Server 3"</span>);</div><div class="line">$loadBalancer2-&gt;addServer(<span class="string">"Server 4"</span>);</div><div class="line"></div><div class="line"><span class="comment">//模拟客户端请求的分发</span></div><div class="line"><span class="keyword">for</span> ($i=<span class="number">0</span>; $i&lt;<span class="number">10</span>; $i++) &#123;</div><div class="line">    $server = $loadBalancer1-&gt;getServer();</div><div class="line">    var_dump(<span class="string">"分发请求至服务器： "</span> . $server);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 结果:</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">bool(<span class="keyword">true</span>)</div><div class="line">string(<span class="number">36</span>) <span class="string">"分发请求至服务器： Server 1"</span></div><div class="line">string(<span class="number">36</span>) <span class="string">"分发请求至服务器： Server 3"</span></div><div class="line">string(<span class="number">36</span>) <span class="string">"分发请求至服务器： Server 4"</span></div><div class="line">string(<span class="number">36</span>) <span class="string">"分发请求至服务器： Server 3"</span></div><div class="line">string(<span class="number">36</span>) <span class="string">"分发请求至服务器： Server 3"</span></div><div class="line">string(<span class="number">36</span>) <span class="string">"分发请求至服务器： Server 3"</span></div><div class="line">string(<span class="number">36</span>) <span class="string">"分发请求至服务器： Server 3"</span></div><div class="line">string(<span class="number">36</span>) <span class="string">"分发请求至服务器： Server 3"</span></div><div class="line">string(<span class="number">36</span>) <span class="string">"分发请求至服务器： Server 1"</span></div><div class="line">string(<span class="number">36</span>) <span class="string">"分发请求至服务器： Server 4"</span></div></pre></td></tr></table></figure></li><li><p>虽然创建了四个LoadBalancer对象，但是它们实际上是同一个对象，因此，通过使用单例模式可以确保LoadBalancer对象的唯一性。</p></li></ol><h2 id="饿汉式单例与懒汉式单例的讨论"><a href="#饿汉式单例与懒汉式单例的讨论" class="headerlink" title="饿汉式单例与懒汉式单例的讨论"></a>饿汉式单例与懒汉式单例的讨论</h2><p>涉及到多线程<br>未完待续<br>…</p><p><a href="http://blog.csdn.net/lovelion/article/details/17517213）[参考](http://blog.51cto.com/haolloyin/category2.html）[参考](http://blog.csdn.net/lovelion/article/details/7420883" target="_blank" rel="external">参考</a><br><a href="http://blog.csdn.net/lovelion/article/details/7420886" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前已经对单例模式有了比较简单的认识&lt;br&gt;接下来通过一些资料在系统了解一下单例模式;&lt;/p&gt;
&lt;h2 id=&quot;单例模式动机&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
</feed>
