<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2017-10-25T10:30:52.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Restful API 安全性相关知识 (持续完善中...)</title>
    <link href="http://blog.renyimin.com/2016/06/26/2016-06-26-restful-02-%E5%AE%89%E5%85%A8/"/>
    <id>http://blog.renyimin.com/2016/06/26/2016-06-26-restful-02-安全/</id>
    <published>2016-06-26T04:21:08.000Z</published>
    <updated>2017-10-25T10:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Restful-API-–-接口安全性"><a href="#Restful-API-–-接口安全性" class="headerlink" title="Restful API – 接口安全性"></a>Restful API – 接口安全性</h2><ul><li>其实整套方案可以参考微信公众平台中 进行 <code>服务器配置</code> 时, <a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419318479&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信推荐的签名校验策略</a>;</li></ul><p>首先请注意，开发者在接收消息和事件时，都需要进行消息加解密（某些事件可能需要回复，回复时也需要先进行加密）。但是，通过API主动调用接口（包括调用客服消息接口发消息）时，不需要进行加密。</p><p>服务器配置时设置的token其实就相当于自定义的通信私钥;</p><ul><li>涉及到的相关要点如下:<br><code>客户端的身份认证</code> : 判断请求来源是否合法;<br><code>敏感数据的加密, 防篡改</code> : HTTPS, 数据加密, 签名;<br><code>replay的防范</code> : 防止重放攻击, 在冗余重放时间(服务器间时间误差)内结合nonce参数来保证;<br><code>api请求速率限制</code> : 为防止恶意调用(例如，限制每个用户的API的使用是在?秒内最多?次的API调用，当然速率要调整好)。</li></ul><h2 id="微信公众平台上有很多涉及到接口交互安全性的地方可供参考-同时可参考微信开放平台PHP对接的demo文件"><a href="#微信公众平台上有很多涉及到接口交互安全性的地方可供参考-同时可参考微信开放平台PHP对接的demo文件" class="headerlink" title="微信公众平台上有很多涉及到接口交互安全性的地方可供参考 (同时可参考微信开放平台PHP对接的demo文件):"></a>微信公众平台上有很多涉及到接口交互安全性的地方可供参考 (同时可参考微信开放平台PHP对接的demo文件):</h2><p>1.微信公众平台配置服务器时设置的 <code>url</code>, <code>token</code> 以及生成 <code>EncodingAESKey</code> 是为了让你确保你的公众平台服务器能够安全地 <code>接收</code> 来自微信服务器的请求，当然, <a href="http://blog.csdn.net/zhutulang/article/details/50614042" target="_blank" rel="external">你也可以选择不进行校验</a>, 不过对于你的服务器来说当然就是比较危险的, 因为一旦你的接口地址泄露, 就有可能被恶意调用;</p><ul><li>开发者的服务器通过调用微信服务器上的基础接口, 对外提供了很多可能包含用户资料的接口, 这样就要防止外部恶意窃取和调用;</li></ul><p>2.而开发者服务器可以通过微信公众平台的 <code>AppID</code> 和 <code>AppSecret</code> 获取 <code>access_token</code>(全局access_token, 微信有还有一个授权access_token), 这个是 <code>微信服务器</code> 授予 <code>开发者服务器</code> 的token, 为了限制有这个令牌的服务器才被授权可以调用微信服务器的接口; </p><ul><li><p><a href="http://blog.renyimin.com/2016/03/24/OAuth-07/">属于OAuth的 Client Credentials Grant 授权方案(客户端以自己的名义, 而不是以用户的名义, 向”服务提供商”进行认证)</a>, 获取access_token的接口如下:<br><code>https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</code></p></li><li><p>如果你们公司有 <code>数据中心</code>, <code>支付中心</code>, <code>用户中心</code> 等比较核心的服务来为公司的各个系统提供接口支持, 那你可能就需要有一个后台 <code>授权服务系统</code>, 专门管理这些服务中心的接口对内部系统的授权, 可以为每个系统生成 <code>APPID</code>, <code>APP_SECRET</code><br>然后各系统使用 <code>APPID</code>, <code>APP_SECRET</code> 到 <code>授权服务系统</code> 申请access_token,然后使用access_token来决定是否能调用本服务中的接口;</p></li></ul><p>3.OAuth网页授权 (授权码模式, 客户端是以用户的名义 向”服务提供商”进行认证)</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h2><ul><li>为什么开发者服务器调用微信服务器接口的时候, 不采用上一种方式呢?<br>其接口本身就是开放出来供客户端服务器使用的, 都是基础的功能性的接口, 一般是由能提供access_token的开发者服务器调用;<br>不用对参数做过多校验, 只要开发者服务器被授权就可以调用;</li></ul><ul><li>微信公众平台并没有通过APPID和APPSECRET来对客户端(我们自己的开发者服务器)进行校验, 而是通过 <code>Token</code> 来识别调用我们的开发者服务器的, 这个token是自主设置，与公众平台wiki中常提的access_token不是一回事, 这个token只用于验证开发者服务器;</li><li>另外, 微信公众平台使用了APPID来对传输的内容进行加密;</li><li><a href="http://www.cnblogs.com/technology/p/wenxin_security.html" target="_blank" rel="external">注意</a>: 服务器url和token为了保证在泄露之后不被别人利用, 我们还需要对ToUserName进行校验, 验证ToUserName是否和你的公众号匹配, 否则你的公众平台服务器上的功能有可能被他人使用;)</li><li>微信的签名是使用 <code>SHA1</code> 生成的(<a href="">参考 密码相关</a>);</li></ul><p>3.</p><p><a href="https://segmentfault.com/q/1010000011674185?_ea=2728292" target="_blank" rel="external">https://segmentfault.com/q/1010000011674185?_ea=2728292</a></p><h2 id="客户端身份认证"><a href="#客户端身份认证" class="headerlink" title="客户端身份认证"></a>客户端身份认证</h2><ol><li><code>HTTP Basic</code><br><code>HTTP Digest</code><br><code>API KEY</code><br><code>Oauth</code><br><code>JWT</code></li></ol><p>下面就简单聊聊这些认证方式:</p><h3 id="HTTP-Basic"><a href="#HTTP-Basic" class="headerlink" title="HTTP Basic"></a>HTTP Basic</h3><p>可以网上自行搜索, 基本上不会采用, 因为安全性比较低;</p><h3 id="HTTP-Digest"><a href="#HTTP-Digest" class="headerlink" title="HTTP Digest"></a>HTTP Digest</h3><p>想了解可以网上自行搜索, 以后可能会进行补充, 暂时未做学习;</p><h3 id="API-KEY"><a href="#API-KEY" class="headerlink" title="API KEY"></a>API KEY</h3><h3 id="OAUTH2"><a href="#OAUTH2" class="headerlink" title="OAUTH2"></a>OAUTH2</h3><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>openid可以主要参考微信公众平台的: <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432" target="_blank" rel="external">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432</a></p><p>重点: <a href="http://blog.csdn.net/degwei/article/details/51489391" target="_blank" rel="external">http://blog.csdn.net/degwei/article/details/51489391</a><br><a href="http://wiki.connect.qq.com/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_server-side" target="_blank" rel="external">http://wiki.connect.qq.com/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_server-side</a><br><a href="http://wiki.open.qq.com/wiki/website/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7OpenID_OAuth2.0" target="_blank" rel="external">http://wiki.open.qq.com/wiki/website/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7OpenID_OAuth2.0</a><br>参考: <a href="http://www.searchsoa.com.cn/showcontent_75305.htm" target="_blank" rel="external">http://www.searchsoa.com.cn/showcontent_75305.htm</a></p><p>WSSE(WS-Security)<br>参考文档 : <a href="https://www.ibm.com/developerworks/cn/webservices/ws-secure/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/webservices/ws-secure/</a></p><p><a href="http://php-di.org/" target="_blank" rel="external">http://php-di.org/</a></p><p>UnionID<br>AppName<br>AppID<br>AppSecret(AppKey)<br>    当应用通过OpenAPI调用腾讯开放平台资源时需要的加密串，用来验证应用的合法性。AppKey在创建应用时分配<br>OpenID<br>    OpenID是与APP通信的用户key，跳转到应用首页后，URL后会带该参数。根据APPID以及QQ号码生成，不同的appid下同一个QQ号生成的OpenID是不一样的（目前不接受同一个开发者名下的不同应用之间对于同一个用户的OpenID的互通）。<br>    OpenID在每个应用中都是唯一，作为用户的唯一标识，访问OpenAPI时必需传入OpenID。 </p><p>qq开放平台的专业术语解释:<br><a href="http://wiki.open.qq.com/wiki/%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD#1.3_AppKey" target="_blank" rel="external">http://wiki.open.qq.com/wiki/%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD#1.3_AppKey</a></p><blockquote><blockquote><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">参考 阮一峰</a></p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Restful-API-–-接口安全性&quot;&gt;&lt;a href=&quot;#Restful-API-–-接口安全性&quot; class=&quot;headerlink&quot; title=&quot;Restful API – 接口安全性&quot;&gt;&lt;/a&gt;Restful API – 接口安全性&lt;/h2&gt;&lt;ul&gt;

      
    
    </summary>
    
      <category term="Restful" scheme="http://blog.renyimin.com/categories/Restful/"/>
    
    
      <category term="Restful" scheme="http://blog.renyimin.com/tags/Restful/"/>
    
  </entry>
  
  <entry>
    <title>API Gateway</title>
    <link href="http://blog.renyimin.com/2016/06/17/restful--02--/"/>
    <id>http://blog.renyimin.com/2016/06/17/restful--02--/</id>
    <published>2016-06-17T12:21:08.000Z</published>
    <updated>2017-10-17T07:34:55.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Restful" scheme="http://blog.renyimin.com/categories/Restful/"/>
    
    
      <category term="Restful" scheme="http://blog.renyimin.com/tags/Restful/"/>
    
  </entry>
  
  <entry>
    <title>Encrypt Decrypt</title>
    <link href="http://blog.renyimin.com/2016/05/30/Encrypt%20and%20Decrypt/"/>
    <id>http://blog.renyimin.com/2016/05/30/Encrypt and Decrypt/</id>
    <published>2016-05-30T07:37:39.000Z</published>
    <updated>2017-10-24T04:51:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见的加密算法可以分成三类"><a href="#常见的加密算法可以分成三类" class="headerlink" title="常见的加密算法可以分成三类"></a>常见的加密算法可以分成三类</h1><p><code>对称加密算法</code><br><code>非对称加密算法</code><br><code>Hash算法</code></p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>指加密和解密使用相同密钥的加密算法;<br>对称加密算法的优点在于加解密的高速度和使用长密钥时的难破解性;<br>假设两个用户需要使用对称加密方法加密然后交换数据, 则用户最少需要2个密钥并交换使用, 如果企业内用户有n个, 则整个企业共需要n×(n-1)个密钥, 密钥的生成和分发将成为企业信息部门的恶梦;<br>对称加密算法的安全性取决于加密密钥的保存情况, 但要求企业中每一个持有密钥的人都保守秘密是不可能的, 他们通常会有意无意的把密钥泄漏出去——如果一个用户使用的密钥被入侵者所获得, 入侵者便可以读取该用户密钥加密的所有文档, 如果整个企业共用一个加密密钥, 那整个企业文档的保密性便无从谈起;</p><p>常见的对称加密算法: DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES ;</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>指加密和解密使用不同密钥的加密算法，也称为公私钥加密;<br>假设两个用户要加密交换数据, 双方交换公钥, 使用时一方用对方的公钥加密, 另一方即可用自己的私钥解密;<br>如果企业中有n个用户，企业需要生成n对密钥，并分发n个公钥。由于公钥是可以公开的，用户只要保管好自己的私钥即可，因此加密密钥的分发将变得十分简单。同时，由于每个用户的私钥是唯一的，其他用户除了可以可以通过信息发送者的公钥来验证信息的来源是否真实，还可以确保发送者无法否认曾发送过该信息。<br>非对称加密的缺点是加解密速度要远远慢于对称加密, 在某些极端情况下，甚至能比非对称加密慢上1000倍 ;</p><p>常见的非对称加密算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）</p><h2 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h2><p>Hash算法特别的地方在于它是一种单向算法, 用户可以通过Hash算法对目标信息生成一段特定长度的唯一的Hash值，却不能通过这个Hash值重新获得目标信息。因此Hash算法常用在<code>不可还原的密码存储</code>、<code>信息完整性校验</code>等。<br>常见的Hash算法: MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常见的加密算法可以分成三类&quot;&gt;&lt;a href=&quot;#常见的加密算法可以分成三类&quot; class=&quot;headerlink&quot; title=&quot;常见的加密算法可以分成三类&quot;&gt;&lt;/a&gt;常见的加密算法可以分成三类&lt;/h1&gt;&lt;p&gt;&lt;code&gt;对称加密算法&lt;/code&gt;&lt;br&gt;&lt;co
      
    
    </summary>
    
      <category term="密码" scheme="http://blog.renyimin.com/categories/%E5%AF%86%E7%A0%81/"/>
    
    
      <category term="密码" scheme="http://blog.renyimin.com/tags/%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>04 - 授权码模式各阶段参数分析</title>
    <link href="http://blog.renyimin.com/2016/05/25/2016-05-25-OAuth-01-03/"/>
    <id>http://blog.renyimin.com/2016/05/25/2016-05-25-OAuth-01-03/</id>
    <published>2016-05-25T12:10:12.000Z</published>
    <updated>2017-10-25T08:44:37.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一阶段-第三方站点将导向授权页"><a href="#第一阶段-第三方站点将导向授权页" class="headerlink" title="第一阶段: 第三方站点将导向授权页"></a>第一阶段: 第三方站点将导向授权页</h4><ol><li><p>第三方应用将用户导向授权页时, 传递的参数如下:</p><ul><li><code>response_type</code>: 表示授权类型, 必选项, 此处由于采用的是授权码模式, 所以值固定为 “code”</li><li><p><code>client_id/AppID</code>: 表示客户端的ID, 必选项<br>由于你可能会有多个站点需要对接OAuth授权服务器, 所以一般在授权服务平台登录之后, 是可以创建多个 <code>应用</code> 的 (不同的站点对接授权服务器中不同的<code>应用</code>);<br>每个<code>应用</code>对应你的一个 <code>第三方站点</code>, 开放平台会为每个<code>应用(第三方站点)</code>生成相应的 <code>AppID</code> 和 <code>AppSecret/AppKey</code>, 主要用来验证应用的合法性;</p></li><li><p><code>redirect_uri</code>: 设定的重定向到<code>第三方站点URI</code>, 必选项</p></li><li><code>scope</code>: 表示申请的权限范围, 可选项</li><li><code>state</code>: 表示客户端的当前状态, 可以指定任意值, 认证服务器会原封不动地返回这个值</li></ul></li><li><p>下面是各开放平台的参数对比:</p><ul><li><p><a href="http://open.weibo.com/wiki/Oauth2/authorize" target="_blank" rel="external">新浪</a><br><img src="/img/oauth/oauth_sina.png" width="500" height="560" alt="sina" align="center"></p></li><li><p><a href="http://wiki.connect.qq.com/%E4%BD%BF%E7%94%A8authorization_code%E8%8E%B7%E5%8F%96access_token" target="_blank" rel="external">QQ</a><br><img src="/img/oauth/oauth_qq.png" width="500" height="560" alt="qq" align="center"></p></li><li><p><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信</a><br><img src="/img/oauth/oauth_wechat.png" width="500" height="560" alt="wechat" align="center"></p></li><li><p><a href="https://developer.github.com/apps/building-integrations/setting-up-and-registering-oauth-apps/about-authorization-options-for-oauth-apps/" target="_blank" rel="external">GitHub</a><br><img src="/img/oauth/oauth_github.png" width="500" height="560" alt="github" align="center"></p></li><li><p><a href="https://doc.open.alipay.com/docs/doc.htm?treeId=193&amp;articleId=105656&amp;docType=1#s5" target="_blank" rel="external">蚂蚁金服</a><br><img src="/img/oauth/oauth_alipay.png" width="500" alt="github" align="center"></p></li></ul></li><li><p>简单测试:</p><ul><li><p>redirect_uri<br>在OAuth服务器中为第三方站点创建 <code>应用</code> 的时候, 设定的回调地址, 无论在认证服务器, 还是在第三方站点, 都会对其进行校验, <code>以防篡改</code>;</p><p>新浪授权传递错误 redirect_uri<br><img src="/img/oauth/jianshu_sina_err01.png" width="450" height="240" alt="github" align="center"></p><p>简书qq授权传递错误 redirect_uri<br><img src="/img/oauth/jianshu_qq_err01.png" width="450" height="200" alt="github" align="center"></p></li><li><p>state<br>第三方站点会对state做校验<br>给了一个新的弹框用来进行授权, 但是如果恶意用户复制出弹框中的url, 之后再修改state并刷新页面, 授权后发现:<br><img src="/img/oauth/zhihu_auth_qq_01.png" width="500" height="100" alt="github" align="center"></p></li></ul></li><li><p>从上面各平台也可以看到, 返回参数相对比较简单;</p><ul><li>返回的code是和授权页登录的用户身份相关的; (后面的access_token也是通过code和用户身份关联起来的)</li></ul></li></ol><h4 id="第二阶段-通过Authorization-Code获取Access-Token"><a href="#第二阶段-通过Authorization-Code获取Access-Token" class="headerlink" title="第二阶段: 通过Authorization Code获取Access Token"></a>第二阶段: 通过Authorization Code获取Access Token</h4><ol><li><p>如果第三方站点的用户在第一阶段的授权页中选择对第三方站点授权, 那么就第三方站点就会收到授权服务器的Authorization Code, 进而进入本阶段;<br>(每个用户在授权后, 第三方站点都需要到授权服务器上为用户获取一个access_token, 这个access_token就是以后第三方站点从授权服务器上获取用户信息的凭证了, 一般在获取到access_token令牌之后, 可以存储到session中)</p></li><li><p>本阶段, 我们在自己的第三方站点中就可以使用第一阶段的Authorization Code获取Access Token:</p><ul><li><p><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信</a></p></li><li><p><a href="http://wiki.connect.qq.com/%E4%BD%BF%E7%94%A8authorization_code%E8%8E%B7%E5%8F%96access_token" target="_blank" rel="external">qq</a><br><img src="/img/oauth/access_token_qq.png" width="650" height="680" alt="github" align="center"></p></li><li><p>基本上入参就像QQ互联那样大概有5个 (需要对每个参数进行了解);</p></li></ul></li><li><p>本阶段的返回参数比较有讲究, 一般为如下三个</p><ul><li><p>access_token 授权令牌<br>access_token一般在获取到之后, 第三方站点可以将其 <code>保存到用户的session中</code> , 第三方站点之后要获取用户在授权服务器上的资源的时候, 就需要带上当前session中用户的access_token去获取;</p></li><li><p>expires_in    该access token的有效期,单位为秒 (微信公众平台access_token有效期为2小时, qq互联平台为3个月 可以作为参考)<br>设置access_token有效期也是为了定期修改access_token, 以提高安全性;<br>(并且微信对获取access_token这个基础API是有限制的，每天最多请求2000次, 因为有效期为2小时, 每天2000次也足够了;)</p></li><li><p>refresh_token 授权自动续期时使用 (微信公众平台refresh_token有效期为30天, qq互联平台具体不详, 可以作为参考)</p></li></ul></li><li><p>(可选)权限自动续期问题</p><ul><li><p>注意<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信公众平台</a>:<br>  1.若access_token已超时，那么进行refresh_token会获取一个新的access_token，新的超时时间, 并且一旦使用refresh_token来刷新access_token的话, refresh_token的过期时间也会更新(自动延期) ;<br>  2.若access_token未超时，那么进行refresh_token不会改变access_token，但超时时间会刷新，相当于续期access_token ;<br>  这里说的超时时间刷新, 指的自然是第三方站点和授权服务器上的超时时间都要更新了(只不过你如果只是做对接的话, 授权服务器这部分人家已经开发好了, 如果你是授权服务器也是自己开发的话, 那你就需要注意这里了)</p></li><li><p>其实第三方站点在受到授权服务器分配给当前用户的access_token之后, 假设说授权服务器返回access_token的过期时间为7200s(2小时), 那么第三方站点将access_token保存到用户session中, 并设置过期时间为6600s(中间可以有个10分钟的服务器时间差);</p></li><li><p>如果第三方站点在使用access_token为用户获取授权服务器中的资源时, 发现session中的access_token并没有过期, 那么请求后就需要为access_token续期(第三方站点和授权服务器上都要做续期)</p></li><li><p>如果第三方站点在使用access_token为用户获取授权服务器中的资源时, 发现session中的access_token过期, 则就需要使用<code>refresh_token</code>调用<code>生成access_token的api接口</code>重新生成access_token来进行续期；<br>  qq:<br>  <img src="/img/oauth/refresh_token_qq.png" width="650" height="640" alt="github" align="center"></p></li><li><p>这样下来, 基本上第三方站点只有在大于refresh_token的过期时间都没有调用过授权服务器的话, 才需要用户重新登录;</p></li></ul></li></ol><h4 id="第三阶段-比较简单-第三方站点通过access-token获取授权平台资源服务器上的用户资源"><a href="#第三阶段-比较简单-第三方站点通过access-token获取授权平台资源服务器上的用户资源" class="headerlink" title="第三阶段(比较简单): 第三方站点通过access_token获取授权平台资源服务器上的用户资源"></a>第三阶段(比较简单): 第三方站点通过access_token获取授权平台资源服务器上的用户资源</h4><ol><li><p>获取access_token后，进行接口调用，有以下前提：</p><ul><li>access_token有效且未超时；</li><li>微信用户已授权给第三方应用帐号相应接口作用域(scope);<br>也就是在授权服务器上还会使用access_token去检测对应的scope权限是否正确;</li></ul></li><li><p>许多开放平台在申请完access_token令牌之后, 都提供了对应接口来获取用户相关信息<br><a href="http://wiki.connect.qq.com/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_server-side" target="_blank" rel="external">QQ互联</a>提供了相应的接口, 使用Access Token来获取用户的OpenID;<br><a href="http://open.weibo.com/wiki/Oauth2/get_token_info" target="_blank" rel="external">新浪开放平台</a>提供了相应的接口来获取access_token对应的用户信息;<br><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="external">而微信公众平台</a>: 在获取access_token的时候, 会同时返回<code>openid</code>表示微信用户在本公众号中的唯一标识;</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;第一阶段-第三方站点将导向授权页&quot;&gt;&lt;a href=&quot;#第一阶段-第三方站点将导向授权页&quot; class=&quot;headerlink&quot; title=&quot;第一阶段: 第三方站点将导向授权页&quot;&gt;&lt;/a&gt;第一阶段: 第三方站点将导向授权页&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;第三方
      
    
    </summary>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/OAuth2-0/"/>
    
    
      <category term="后端架构" scheme="http://blog.renyimin.com/tags/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>03 - OAuth2.0的CSRF攻击</title>
    <link href="http://blog.renyimin.com/2016/05/24/2016-05-24-OAuth-01-02/"/>
    <id>http://blog.renyimin.com/2016/05/24/2016-05-24-OAuth-01-02/</id>
    <published>2016-05-24T11:27:36.000Z</published>
    <updated>2017-10-25T08:01:49.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>假设有如下几个角色:<br>受害者 <code>lant</code> ;<br>攻击者 <code>rymuscle</code> ;<br>第三方Web应用 <code>liangren网</code> (它允许用户将其在 <code>sandiruiqi网</code> 的账号 和 <code>liangren网</code> 的账号进行绑定) ;<br>OAuth2服务提供平台 <code>sandiruiqi网</code> ;</p></li><li><p>攻击流程</p><ul><li><p><code>攻击者rymuscle</code> 登录 <code>liangren网</code> 并且选择使用自己的 <code>sandiruiqi网</code> 账号登录 ;</p></li><li><p><code>liangren网</code> 将 <code>攻击者rymuscle</code> 重定向到 <code>sandiruiqi网</code> 的授权页(这时可能需要 <code>攻击者rymuscle</code> 登录过<code>sandiruiqi网</code>), <code>sandiruiqi网</code> 的授权页向 <code>攻击者rymuscle</code> 显示 “是否授权<code>liangren网</code>访问” ;</p></li><li><p><code>攻击者rymuscle</code> 在点击”同意授权”之后, 截获 <code>sandiruiqi网</code> 服务器返回的含有 <code>Authorization Code</code> 参数的HTTP响应 ;</p></li><li><p>然后 <code>攻击者rymuscle</code> 精心构造一个Web页面, 它会触发 <code>liangren网</code> 向 <code>sandiruiqi网</code> 发起<strong>令牌申请</strong>的请求, 而这个请求中的Authorization Code参数正是上一步 <code>攻击者rymuscle</code> 截获到的code ;</p></li><li><p><code>攻击者rymuscle</code> 将这个Web页面放到互联网上, 等待或者诱骗受害者来访问 ;</p></li><li><p>假设正好一个受害者 <code>lant</code> 访问了 <code>攻击者rymuscle</code> 准备的这个Web页面后, 令牌申请流程在 <code>受害者lant</code> 的浏览器里被顺利触发, <code>laingren网</code> 从 <code>sandiruiqi网</code> 那里获取到access_token, 但是这个token以及通过它进一步获取到的用户信息却都是攻击者 <code>攻击者rymuscle</code> 的 ;</p></li><li><p>也就是最终 <code>liangren网</code> 将 <code>攻击者rymuscle</code> 的 <code>sandiruiqi</code> 账号同 <code>lant</code> 的 <code>liangren网</code> 账号关联了起来</p><p>从此以后, <code>lant</code>只要没有察觉到自己最初被悄悄使用了 <code>攻击者rymuscle</code> 的<code>sandiruiqi网</code> 账号登录, 那么他在 <code>liangren网</code> 上的所有资料, 都可以被 <code>攻击者rymuscle</code> 所看到, 并且 <code>攻击者rymuscle</code> 可能在 <code>lant</code> 的账号中做一些非法操作;</p></li></ul></li><li><p>整体时序图分析</p><ul><li><p>先看标准oauth时序图<br><img src="/img/oauth/authorization_code.png" width="635" height="600" alt="qq" align="center"></p></li><li><p>下面是从网上copy的一张图, 从整体上来看, 这次攻击的时序图类似下图:<br><img src="/img/oauth/yihuajiemu_mawei.png" width="635" height="580" alt="sina" align="center"></p></li></ul></li><li><p>可以看到, 攻击的关键点在于:<br>OAuth2的认证流程是分为好几步来完成的, 在标准oauth图的第3步, 第三方应用在收到一个GET请求时, 除了能知道当前用户的cookie, 以及URL中的Authorization Code之外, 难以分辨出这个请求到底是用户本人的意愿, 还是攻击者利用用户的身份伪造出来的请求; 于是乎, 攻击者就能使用移花接木的手段, 提前准备一个含有自己的Authorization Code的请求, 并让受害者的浏览器来接着完成后续的令牌申请流程 ;</p></li><li><p>难点(涉及到了非state参数防御):<br> 尽管这个攻击既巧妙又隐蔽, 但是要成功进行这样的CSRF攻击也是比较困难的 :    </p><ul><li><p>整个攻击必须在短时间内完成, 因为OAuth2提供者颁发的Authorization Code有效期很短, <strong>OAuth2官方推荐的时间是不大于10分钟</strong>, 而一旦Authorization Code过期那么后续的攻击也就不能进行下去了;</p></li><li><p>一个Authorization Code只能被使用一次, 如果OAuth2提供者收到重复的Authorization Code, 它会拒绝当前的令牌申请请求, 不止如此, 根据OAuth2官方推荐, 它还可以把和这个已经使用过的Authorization Code相关联的access_token全部撤销掉, 进一步降低安全风险;</p><p>其实貌似只要做到Authorization Code只能被使用一次, 就可以防止csrf在此处的攻击了, 因为 <code>rymuscle</code> 在攻击的时候, 一旦获得 <code>Authorization Code</code>, 第三方站点服务器就会使用 <code>Authorization Code</code> 去申请access_token, 然后只要标记 <code>Authorization Code</code> 为已经使用, 那么 <code>受害者lant</code> 即使点击 <code>攻击者rymuscle</code> 构造好的链接也没用, 因为连接中的 <code>Authorization Code</code> 已经被标记为使用过了;</p></li><li><p>所以不一定非要使用下面的state参数来进行防御<br><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">比如微信公众平台的OAuth授权: state参数就是可选的</a><br><a href="http://open.weibo.com/wiki/Oauth2/authorize" target="_blank" rel="external">新浪开放平台的OAuth授权, state参数也是可选的</a><br>当然, 他们不一定做的是和此处一样的防御方案, 但明显不依赖于state参数来解决问题;</p></li></ul></li><li><p>state参数防御: 要防止这样的攻击其实很容易, 作为第三方应用的开发者, 只需在OAuth认证过程中加入 <code>state</code> 参数, 并验证它的参数值即可;</p><ul><li><p>在将用户重定向到OAuth2的Authorization Endpoint去的时候, 为用户生成一个随机的字符串, 并作为state参数加入到URL中 ;</p></li><li><p>在收到OAuth2服务提供者返回的Authorization Code请求的时候, 验证接收到的state参数值, 如果是正确合法的请求, 那么此时接受到的参数值应该和上一步提到的为该用户生成的state参数值完全一致, 否则就是异常请求;</p><p>但需要注意 <code>state参数</code> 需要具备下面几个特性:</p></li><li><p>不可预测性: 足够的随机, 使得攻击者难以猜到正确的参数值 ;<br>如果你每次生成的state都被放在一起, 比如一个库/缓存中存在很多state;<br>那么问题就是攻击者还是可以拿着自己的code再加上一个state, 来构造一个链接欺骗用户来点击;(假设state正好就在你的库/缓存中);</p></li><li><p>重点是关联性: state参数值可以和当前用户会话(user session)相互关联的<br>所以应该让state和具体的用户关联起来, 虽然用户还没有登录, 但是也可以让state放到session中 ;<br>然后攻击者要猜测出来一个state的话, 即便是已经生成过了, 但是也得正好攻击的是这个用户;</p></li><li><p>唯一性: 每个用户每次请求生成的state参数值都是唯一的 ;</p></li><li><p>时效性: state参数一旦被使用则立即失效 ;</p></li><li><p>参考 蚂蚁金服开放平台:<br><img src="/img/oauth/state_alipay.png" width="600" height="550" alt="wechat" align="center"></p></li></ul></li><li><p>其实可以结合以上各种方法一起来进行防御!</p></li></ol><blockquote><p><a href="http://insights.thoughtworkers.org/attack-aim-at-oauth2/" target="_blank" rel="external">参考 移花接木</a><br><a href="http://blog.sina.com.cn/s/blog_56b798f801018jyb.html" target="_blank" rel="external">参考 state参数漏洞</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">参考 阮一峰</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;假设有如下几个角色:&lt;br&gt;受害者 &lt;code&gt;lant&lt;/code&gt; ;&lt;br&gt;攻击者 &lt;code&gt;rymuscle&lt;/code&gt; ;&lt;br&gt;第三方Web应用 &lt;code&gt;liangren网&lt;/code&gt; (它允许用户将其在 &lt;code&gt;sandirui
      
    
    </summary>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/OAuth2-0/"/>
    
    
      <category term="后端架构" scheme="http://blog.renyimin.com/tags/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>02 - 授权码模式</title>
    <link href="http://blog.renyimin.com/2016/05/22/2016-05-22-OAuth-01-01/"/>
    <id>http://blog.renyimin.com/2016/05/22/2016-05-22-OAuth-01-01/</id>
    <published>2016-05-22T12:27:36.000Z</published>
    <updated>2017-10-25T08:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="授权码模式运行过程"><a href="#授权码模式运行过程" class="headerlink" title="授权码模式运行过程"></a>授权码模式运行过程</h2><ol><li>运行图<br><img src="/img/oauth/authorization_code.png" width="535" height="500" alt="qq" align="center"></li></ol><h2 id="运行过程分析"><a href="#运行过程分析" class="headerlink" title="运行过程分析"></a>运行过程分析</h2><p>1.向用户取得授权许可<br>对应图中的第1、2、3步;</p><p>2.申请访问令牌<br>access_token令牌的申请<br>对应图中的第4、5步;</p><p>3.使用令牌获取用户数据<br>开放平台在申请完access_token令牌之后, 都提供了对应接口来获取用户相关信息, 比如:<br><a href="http://wiki.connect.qq.com/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_server-side" target="_blank" rel="external">QQ互联</a>: 提供了相应的接口, 使用Access Token来获取用户的OpenID;<br><a href="http://open.weibo.com/wiki/Oauth2/get_token_info" target="_blank" rel="external">新浪开放平台</a>: 提供了相应的接口来获取access_token对应的用户信息;<br><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="external">而微信公众平台</a>: 在获取access_token的时候, 会同时返回<code>openid</code>表示微信用户在本公众号中的唯一标识;</p><p>这一过程中涉及了不少敏感参数和数据, 例如client_secret相当于是第三方应用自己的密码, access_token某种程度上来讲就是用户的session id, 由于这些参数以及数据极其特殊, 我们当然得确保它们的安全性, HTTPS加密传输以及安全存储是必不可少的防护手段, <strong>不过仅仅做到这些是远远不够的, 因为其实在这个流程里存在一个弱点， 容易被攻击者利用进行CSRF攻击, <a href="http://blog.renyimin.com/2016/05/24/2016-05-24-OAuth-01-02/">下一篇笔记将会详细分析</a> ; </strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;授权码模式运行过程&quot;&gt;&lt;a href=&quot;#授权码模式运行过程&quot; class=&quot;headerlink&quot; title=&quot;授权码模式运行过程&quot;&gt;&lt;/a&gt;授权码模式运行过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;运行图&lt;br&gt;&lt;img src=&quot;/img/oauth/authoriz
      
    
    </summary>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/OAuth2-0/"/>
    
    
      <category term="后端架构" scheme="http://blog.renyimin.com/tags/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>01 - OAuth(Open Authorization)开放式授权协议</title>
    <link href="http://blog.renyimin.com/2016/05/19/2016-05-19-OAuth-00/"/>
    <id>http://blog.renyimin.com/2016/05/19/2016-05-19-OAuth-00/</id>
    <published>2016-05-19T03:05:00.000Z</published>
    <updated>2017-10-27T02:19:29.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版"><a href="#OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版" class="headerlink" title="OAuth是一个关于授权(authorization)的开放网络标准, 目前的版本是2.0版"></a>OAuth是一个关于授权(authorization)的开放网络标准, 目前的版本是2.0版</h4><ul><li><p>OAuth之前的传统”授权”比较 简单, 直接, 暴力, 一般是直接提供自己资源服务器的账号和密码给第三方站点, 要知道这种做的法弊端太多:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1.如果用户在每个第三方站点都这样做, 那将会存在严重安全隐患:</div><div class="line">很多第三方网站为了后续的服务, 会保存用户资源服务器的账号和密码, 这样很不安全, </div><div class="line">因为难免有些第三方平台会由于自己的安全问题而导致用户的账号和密码泄露, 从而导致用户大量信息泄露 ;</div><div class="line"></div><div class="line">2.用户无法设定第三方站点的权利范围:</div><div class="line">第三方网站拥有了获取用户某个资源服务器的账号和密码后, 就拥有了资源服务器上的所有的资料, 用户没法限制第三方站点获取资源服务器上资源的权利范围和有效期 ;</div><div class="line"></div><div class="line">3.用户想收回第三方站点的权利不太方便:</div><div class="line">用户只有修改密码, 才能收回赋予第三方网站的权力, 否则第三方网站将会永久拥有用户资源服务器上资源的权利，但是这样做, 又会使得其他所有获得用户授权的第三方应用程序全部失效 ;</div><div class="line"></div><div class="line">或者, 一些良心第三方可以设置 用户账号 和 资源服务器账号的绑定和解绑, 但不一定所有第三方都会给你做, 如果不做解绑的话, 你还真就只有前一种方法能够收回权利 ;</div></pre></td></tr></table></figure></li><li><p>而OAuth的授权不会让 <code>第三方站点</code> 触及到用户在 <code>资源服务器</code> 上的帐号信息(如用户名与密码), 即第三方站点无需使用用户资源服务器上的账号与密码, 就可以获得该用户在 <code>资源服务器</code> 上的资源, 因此 OAuth 是安全的 ;</p></li></ul><h4 id="OAuth2-0协议定义了用于获得授权的”四种主要授权类型”"><a href="#OAuth2-0协议定义了用于获得授权的”四种主要授权类型”" class="headerlink" title="OAuth2.0协议定义了用于获得授权的”四种主要授权类型”"></a>OAuth2.0协议定义了用于获得授权的”四种主要授权类型”</h4><h5 id="1-授权码-Authorization-code-模式"><a href="#1-授权码-Authorization-code-模式" class="headerlink" title="1.授权码(Authorization code)模式"></a>1.<a href="http://localhost:4000/2016/03/19/OAuth-authorization-code01/" target="_blank" rel="external">授权码(Authorization code)模式</a></h5><ul><li>授权码模式是功能最完整、流程最严密的授权模式(标准的Server授权模式, 非常适合Server端的Web应用);</li><li>它的特点是: <code>通过客户端的后台服务器, 与&quot;服务提供商&quot;的认证服务器进行互动</code>;<br><img src="/img/oauth/oauth_authorization_code_01.png" width="711" height="514" alt="authorization_code_01" align="center"></li><li><p>运行流程图解</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">用户打开客户端以后，客户端要求用户给予授权。</div><div class="line">用户同意给予客户端授权。</div><div class="line">客户端使用上一步获得的授权，向认证服务器申请令牌。</div><div class="line">认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</div><div class="line">客户端使用令牌，向资源服务器申请获取资源。</div><div class="line">资源服务器确认令牌无误，同意向客户端开放资源</div></pre></td></tr></table></figure></li><li><p>场景:<br>  比如公司需要对接 QQ, 微博, 微信(网页授权) 等登录授权;<br>  或者公司达到可以做自己对外的开放平台;<br>  当然, 公司如果要做对外开放平台, 可能不止使用这一种模式:</p><pre><code>像微信网页授权使用的就是`授权码模式`； 但是微信的基础功能接口和开发者服务器交互的时候, 就使用到了`客户端模式`；而微信服务器涉及到和开发者服务器进行消息交互的时候, 还使用了类似`JWT`的签名校验来保证数据传输的安全;</code></pre></li></ul><h5 id="2-隐式授权模式-Implicit-Grant"><a href="#2-隐式授权模式-Implicit-Grant" class="headerlink" title="2.隐式授权模式(Implicit Grant)"></a>2.隐式授权模式(Implicit Grant)</h5><ul><li>也叫简化模式, 该模式<code>不通过第三方应用程序的服务器</code>, 而是直接在浏览器中向认证服务器申请令牌, 跳过了”授权码”这个步骤, 因此得名;</li><li>它的特点是: 所有步骤在浏览器中完成, 令牌对访问者是可见的;</li><li>流程图:<br><img src="/img/oauth/oauth_implict_01.png" width="660" height="570" alt="oauth_implict_01" align="center"></li><li>场景:</li></ul><h5 id="3-密码模式-Resource-Owner-Password-Credentials"><a href="#3-密码模式-Resource-Owner-Password-Credentials" class="headerlink" title="3.密码模式(Resource Owner Password Credentials)"></a>3.密码模式(Resource Owner Password Credentials)</h5><ul><li>用户向客户端提供自己的用户名和密码, 客户端使用这些信息，向”服务商提供商”索要授权 ;</li><li>这种模式要求用户提供用户名和密码来交换访问令牌access_token ;</li><li>它的特点是:<br>客户端仍然是以单个用户的名义向”服务提供商”进行认证;<br>在这种模式中, 用户必须把自己的密码给客户端, 但是客户端不得储存密码, 这通常用在 <code>用户对客户端高度信任的情况下</code>, 比如客户端也是系统的一部分;</li><li>流程图:<br><img src="/img/oauth/password_credentials_01.png" width="750" height="387" alt="password_credentials_01" align="center"></li><li><p>下图也可参考:<br><img src="/img/oauth/password_credentials_02.png" width="527" height="218" alt="password_credentials_02" align="center"></p></li><li><p>场景:<br>比如当third party application、authorization server、resource owner都是自己公司内的系统, Resource owner对third party application足够信任，所以我们就能采取这种模式来实现;<br>就像: 公司如果有多套内部后台系统, 开发人员和公司管理员可能就要准备多套账号, 比较麻烦, 为了解决这个问题, 可以做一个<code>账号中心</code>系统, 用户在登录各个系统后台的时候, 会先跳转到用户中心进行登录, 一旦登录成功之后, 就会给用户分发一个access_token, 用来在各个系统间作为登录认证 (这也实现了<code>SSO单点登录</code>);<br>(参考: <a href="http://www.cnblogs.com/richieyang/p/4918819.html" target="_blank" rel="external">http://www.cnblogs.com/richieyang/p/4918819.html</a>)</p></li></ul><h5 id="4-客户端模式-Client-Credentials"><a href="#4-客户端模式-Client-Credentials" class="headerlink" title="4.客户端模式(Client Credentials)"></a>4.客户端模式(Client Credentials)</h5><ul><li><p>客户端模式指客户端<code>以客户端自己的名义, 而不是以单个用户的名义</code>，向”服务提供商”进行认证;<br>严格地说, 客户端模式并不属于OAuth框架所要解决的问题;</p></li><li><p>流程图:<br><img src="/img/oauth/oauth_client_credentials_01.png" width="760" height="165" alt="oauth_client_credentials_01" align="center"></p></li><li><p>服务器 <code>不提供像用户数据这样的重要资源</code>，仅仅是一些开放的功能性API;<br>例如微信公众平台, Google Storage或Amazon S3 等开放平台提供的基础服务接口;</p></li><li><p>场景:<br>1.你自己实现了一套基础服务的Api(都是些基础功能接口, 并不涉及用户数据这种重要资源), <code>提供给内部其他系统通过认证的方式来调用</code>;<br>2.公司如果实力强悍的话, 也可以将公司开发的基础服务Api公开出来 <code>供外部其他第三方站点服务器</code> 来调用, 比如: <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183" target="_blank" rel="external">微信公众平台的开放接口其实就是使用这种方式</a>(但微信的网页授权采用的就是授权码模式):<br><img src="/img/oauth/oauth_client_credentials_02.png" width="699" height="475" alt="oauth_client_credentials_02" align="center"></p></li></ul><h4 id="客户端模式-Client-Credentials-和-用户密码模式-有时候比较容易混淆"><a href="#客户端模式-Client-Credentials-和-用户密码模式-有时候比较容易混淆" class="headerlink" title="客户端模式(Client Credentials) 和 用户密码模式 有时候比较容易混淆"></a>客户端模式(Client Credentials) 和 用户密码模式 有时候比较容易混淆</h4><p>1.客户端模式: 如果客户端以自己的身份向服务提供商进行认证, 那需要授权中心给各个应用(不管是内部系统还是第三方站点服务器)分配对应的AppID和AppSecret, 然后第三方应用使用这两个信息来向”认证服务器”申请access_token, 这种场景下, 认证服务器一般提供的接口都是功能性的基础服务接口;<br>2.用户密码模式: 如果客户端以单个用户身份向服务提供商进行认证, 只要用户账号密码能通过认证服务器, 认证服务器就会发放access_token, 当然这种场景需要的是<code>几方角色都属于本公司内部</code>;</p><p>当然这里所聊的是授权相关的知识, 并没有涉及数据传输的加密及签名校验, 但其实像微信公众平台这样开放平台, 除了基础服务接口供给开发者服务器调用时不需要做数据传输的加密和签名校验; 当微信服务器和开发者服务器涉及到用户消息数据的收发时, 会推荐对数据进行加密和签名校验;</p><blockquote><p>参考: <a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a><br>参考: <a href="http://www.cnblogs.com/richieyang/p/4918819.html" target="_blank" rel="external">http://www.cnblogs.com/richieyang/p/4918819.html</a><br>参考: <a href="http://www.dannysite.com/blog/176/" target="_blank" rel="external">http://www.dannysite.com/blog/176/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版&quot;&gt;&lt;a href=&quot;#OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版&quot; class=&quot;headerlink&quot; title=&quot;OA
      
    
    </summary>
    
      <category term="后端架构" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/OAuth2-0/"/>
    
    
      <category term="后端架构" scheme="http://blog.renyimin.com/tags/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>Laravel-install-01</title>
    <link href="http://blog.renyimin.com/2016/04/15/Laravel-install-01/"/>
    <id>http://blog.renyimin.com/2016/04/15/Laravel-install-01/</id>
    <published>2016-04-15T08:34:13.000Z</published>
    <updated>2017-09-19T04:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="通过Composer下载安装"><a href="#通过Composer下载安装" class="headerlink" title="通过Composer下载安装"></a>通过Composer下载安装</h4><p>可以在终端中通过Composer的==create-project==命令来创建一个新的Laravel项目:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">composer create-project laravel/laravel [项目目录名] [项目版本号] --prefer-dist</div><div class="line"></div><div class="line">如果不写laravel下载下来后放置项目的目录名, 则默认为laravel;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">比如要下载Laravel的LTS版本(目前是Laravel5.1), 操作如下:</div><div class="line"></div><div class="line">composer create-project laravel/laravel vip 5.1.33 --prefer-dist</div><div class="line"></div><div class="line">或者</div><div class="line"></div><div class="line">composer create-project laravel/laravel vip 5.1.* --prefer-dist</div></pre></td></tr></table></figure><h4 id="应用Key的设置"><a href="#应用Key的设置" class="headerlink" title="应用Key的设置"></a>应用Key的设置</h4><p>如果你是通过Composer或者Laravel安装器安装的话, 该key的值已经通过key:generate命令生成好了;</p><p>(通常, 该字符串应该是32位长, 该key被配置在.env环境文件中(APP_KEY), 如果你还没有将.env.example文件重命名为.env, 现在立即这样做;如果应用key没有被设置, 用户sessions和其它加密数据将会有安全隐患!)</p><p>如果你不是通过composer安装的laravel, 生成key的方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">先创建一个.env文件</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">然后生成应用key:</div><div class="line"></div><div class="line">bogon:laravel renyimin$ php artisan key:generate</div><div class="line">Application key [7a7rsPOdMubimWYQRddpxEiTRuoQMScE] set successfully.</div><div class="line">bogon:laravel renyimin$</div></pre></td></tr></table></figure><p>你如果是使用Composer安装的话, 可以看到:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-06c8fbb330d8f53f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-740d1978831266b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><h4 id="nginx的设置"><a href="#nginx的设置" class="headerlink" title="nginx的设置:"></a>nginx的设置:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$uri $uri/ /index.php?$query_string</div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-2045d4084f87333c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">项目根目录配置到: 项目目录的 public 目录下;</div></pre></td></tr></table></figure><h4 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功:"></a>安装成功:</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-1d49b5e644607509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;通过Composer下载安装&quot;&gt;&lt;a href=&quot;#通过Composer下载安装&quot; class=&quot;headerlink&quot; title=&quot;通过Composer下载安装&quot;&gt;&lt;/a&gt;通过Composer下载安装&lt;/h4&gt;&lt;p&gt;可以在终端中通过Composer的==cre
      
    
    </summary>
    
      <category term="PHP框架" scheme="http://blog.renyimin.com/categories/PHP%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Laravel" scheme="http://blog.renyimin.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>PHP的Closure学习整理</title>
    <link href="http://blog.renyimin.com/2016/03/10/clusore-introduction/"/>
    <id>http://blog.renyimin.com/2016/03/10/clusore-introduction/</id>
    <published>2016-03-10T06:30:15.000Z</published>
    <updated>2017-09-19T04:55:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要是对网上现存的一些资料做了一些简单地整理, 一方面让自己对基础知识加深印象, 一方面便于日后自己随时回顾!</p><h4 id="JavaScript中的闭包"><a href="#JavaScript中的闭包" class="headerlink" title="JavaScript中的闭包"></a>JavaScript中的闭包</h4><p>在了解PHP的闭包之前, 我们可以先简单了解一下JavaScript的闭包是怎样的?</p><h5 id="Js的作用域"><a href="#Js的作用域" class="headerlink" title="Js的作用域"></a>Js的作用域</h5><p>1.要理解闭包，首先必须理解Javascript的 <strong>变量作用域</strong> ;</p><p>2.变量的作用域无非就是两种: <strong>全局变量</strong> 和 <strong>局部变量</strong> ;</p><p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量:<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var n=999;</div><div class="line">function f1()&#123;</div><div class="line">    alert(n);</div><div class="line">&#125;</div><div class="line">f1(); // 999</div></pre></td></tr></table></figure></p><p>另一方面, 在函数外部自然无法读取函数内的局部变量:<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function f1()&#123;</div><div class="line">    var n=999;  //这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</div><div class="line">&#125;</div><div class="line">alert(n); // error</div></pre></td></tr></table></figure></p><h5 id="如何从外部读取局部变量？"><a href="#如何从外部读取局部变量？" class="headerlink" title="如何从外部读取局部变量？"></a>如何从外部读取局部变量？</h5><p>出于种种原因, 我们有时候需要得到函数内的局部变量, 但是, 前面已经说过了, 正常情况下，这是办不到的, 只有通过变通方法才能实现;</p><p>于是, 我们可以在函数的内部, 再定义一个函数:<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function f1()&#123;</div><div class="line">    var n = 999;</div><div class="line">    function f2()&#123;</div><div class="line">        alert(n); // 999</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在上面的代码中, 函数f2就被包括在函数f1内部, 这时, f1内部的所有局部变量, 对f2都是可见的;<br>但是反过来就不行, f2内部的局部变量, 对f1就是不可见的; </p><p>这就是Javascript语言特有的”链式作用域”结构(chain scope), 子对象会一级一级地向上寻找所有父对象的变量; 所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function f1(a)&#123;</div><div class="line">    var n = &apos;局部变量&apos;;</div><div class="line">    function f2(c)&#123;</div><div class="line">       console.log(n);</div><div class="line">       console.log(a);</div><div class="line">       console.log(c);</div><div class="line">    &#125;</div><div class="line">    return f2;</div><div class="line">&#125;</div><div class="line">var result = f1(&apos;传递给函数的参数,也成了一个局部值&apos;);</div><div class="line">result(&apos;传递给闭包的参数1&apos;);</div><div class="line">console.log(&apos;&apos;);</div><div class="line">result(&apos;传递给闭包的参数2&apos;);</div><div class="line">//结果: </div><div class="line">局部变量    //可以看到我们就从外部取到了函数内部的局部变量</div><div class="line">传递给函数的参数,也成了一个局部值</div><div class="line">传递给闭包的参数1</div><div class="line"></div><div class="line">局部变量    //可以看到我们就从外部取到了函数内部的局部变量</div><div class="line">传递给函数的参数,也成了一个局部值</div><div class="line">传递给闭包的参数2</div></pre></td></tr></table></figure></p><h5 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h5><p>上一节代码中的f2函数, 就是闭包;</p><p>各种专业文献上对 “闭包”（closure）定义非常抽象，很难看懂;</p><p>我的理解是，闭包就是能够读取其他函数内部变量的函数;</p><p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量, 因此可以把闭包简单理解成 <strong>“定义在一个函数内部的函数”</strong> ;</p><p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁;</p><h5 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h5><p>1.闭包可以用在许多地方, 它的最大用处有两个:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">一个是前面提到的可以读取函数内部的变量; </div><div class="line">另一个就是让这些变量的值始终保持在内存中;</div></pre></td></tr></table></figure></p><p>2.怎么来理解上面的话呢？</p><p>之前的代码中, result 这个变量其实就是闭包函数f2, 它一共运行了两次;</p><p>而函数f1中的局部变量一直保存在内存中, 并没有在f1调用后被自动清除;</p><p><strong>原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后被垃圾回收机制（garbage collection）回收;</strong></p><h5 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h5><p>1.由于闭包会使得函数中的变量都被保存在内存中, 内存消耗很大, 所以不能滥用闭包, 否则会造成网页的性能问题, 在IE中可能导致内存泄露, 解决方法是, 在退出函数之前, 将不使用的局部变量全部删除;</p><p>2.闭包会在父函数外部改变父函数内部变量的值; 所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method）, 把内部变量当作它的私有属性（private value）, 这时一定要小心, 不要随便改变父函数内部变量的值;</p><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line">var object = &#123;</div><div class="line">    name : &quot;My Object&quot;,</div><div class="line">    getNameFunc : function()&#123;</div><div class="line">        return function()&#123;</div><div class="line">            return this.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">console.log(object.getNameFunc()());     // The Window</div></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line">var object = &#123;</div><div class="line">    name : &quot;My Object&quot;,</div><div class="line">    getNameFunc : function()&#123;</div><div class="line">        var that = this;</div><div class="line">        return function()&#123;</div><div class="line">            return that.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">console.log(object.getNameFunc()());    // My Object</div></pre></td></tr></table></figure><p>以上参考<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">阮一峰的博客</a>, 阮一峰大哥真的写的很好了, 本人这里只是过一遍, 然后稍微简化了一点点, 修改了一点列子, 便于自己理解;</p><h4 id="PHP的闭包"><a href="#PHP的闭包" class="headerlink" title="PHP的闭包"></a>PHP的闭包</h4><p>1.PHP的<code>闭包</code> 和 <code>匿名函数</code> 是在PHP5.3.0中引入, 这两个特性非常有用, 每个PHP开发者都应该掌握;</p><p>2.闭包是指在创建时, <strong>封装周围状态的函数</strong>, 即便闭包所在的环境不存在了, 闭包中封装的状态依然存在, 这个概念如果你看了之前的JavaScript相关闭包的概念, 应该理解起来不是太难;</p><p>3.匿名函数是没有名称的的函数, 匿名函数可以赋值给变量, 还能像其他任何PHP变量那样传递, 不过匿名函数仍是函数, 因此可以调用, 还可以传入参数, 匿名函数特别适合作为函数或方法的回调;</p><p>4.理论上讲, 闭包和匿名函数是不同的概念, 不过, PHP将其视为相同的概念, 所以一般在PHP中说闭包就是匿名函数, 说匿名函数也是指闭包;</p><p>5.PHP闭包和匿名函数使用的句法虽然和普通函数相同, 但是需要注意的是, 闭包和匿名函数其实是<strong>伪装成函数的对象</strong>, 如果审查PHP闭包或匿名函数, 会发现阀门是Closure类的实例; 闭包和字符串或证书一样, 也是<strong>一等值类型</strong> ;</p><h5 id="创建闭包"><a href="#创建闭包" class="headerlink" title="创建闭包"></a>创建闭包</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$closure = <span class="function"><span class="keyword">function</span> <span class="params">($name)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sprintf(<span class="string">'Hello %s'</span>, $name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var_dump($closure); <span class="comment">//object(Closure)#1 (1) &#123; ["parameter"]=&gt; array(1) &#123; ["$name"]=&gt; string(10) "" &#125; &#125;</span></div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;br/&gt;'</span>;</div><div class="line"><span class="keyword">echo</span> $closure(<span class="string">'Josh'</span>);  <span class="comment">//Hello Josh</span></div></pre></td></tr></table></figure><p>闭包对象的创建就这么简单;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">建议: 之所以能调用$closure变量, 是因为这个变量的值是一个闭包, 而且闭包对象实现了__invoke()魔术方法;</div><div class="line">只要变量名后面有(), PHP就会查找并调用__invoke()方法;</div></pre></td></tr></table></figure><p>通常情况下, 我们会把PHP的闭包对象当做函数和方法的回调来使用; 很多PHP的函数都会用到回调函数, 例如 array_map()和preg_replace_callback();<br>这是使用PHP匿名函数的绝佳时机! 记住, 闭包和其他值一样, 可以作为参数出传入其他PHP函数;</p><h5 id="PHP中闭包的-附加状态"><a href="#PHP中闭包的-附加状态" class="headerlink" title="PHP中闭包的 附加状态"></a>PHP中闭包的 <code>附加状态</code></h5><p>1.之前我们说的 array_map()和preg_replace_callback() 对闭包的使用, 主要是把匿名函数当做回调来使用;<br><strong>下面我们讨论的是如何为PHP闭包附加并封装状态;</strong></p><p><strong>2</strong>.JavaScript开发者可能对PHP的闭包感到奇怪, 因为通过之前对JavaScript中闭包的了解, <strong>它的闭包会自动封装应用的状态</strong>; 而PHP的闭包不会像真正的JS闭包那样自动封装应用的状态;<br><strong>在PHP中, 我们必须手动调用闭包对象的 <code>use关键字</code> , 或者闭包对象的 <code>bindTo()方法</code> 来把状态附加到PHP闭包上;</strong></p><h5 id="use关键字"><a href="#use关键字" class="headerlink" title="use关键字"></a>use关键字</h5><p>使用use关键字附加闭包状态比较常见, 我们先看这种方式;</p><p>使用use关键字把变量附加到闭包上时, 附加的变量会记住附加时赋给它的值:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enclosePerson</span><span class="params">($name)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">($doCommand)</span> <span class="title">use</span> <span class="params">($name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sprintf(<span class="string">'%s, %s'</span>, $name, $doCommand);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$clay = enclosePerson(<span class="string">'Clay'</span>);</div><div class="line"></div><div class="line"><span class="keyword">echo</span> $clay(<span class="string">'get me sweet tea!'</span>);</div></pre></td></tr></table></figure></p><p>在例子中, 具名函数enclosePerson()有个名为$name参数, 这个函数返回一个闭包对象, 而且这个闭包对象封装了$name参数;<br>即便返回的闭包对象已经跳出了enclosePerson()函数的作用域, 闭包对象也会记住$name参数的值, 因为$name变量仍在闭包中;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">使用<span class="keyword">use</span>关键字可以把多个参数传入闭包, 此时要像<span class="title">php</span>函数或方法的参数一样, 使用都好分割多个参数;</div></pre></td></tr></table></figure><h5 id="Closure对象的bindTo-方法"><a href="#Closure对象的bindTo-方法" class="headerlink" title="Closure对象的bindTo()方法"></a>Closure对象的bindTo()方法</h5><p>1.别忘了, php闭包是个对象(Closure对象), 与任何其他PHP对象类似, 每个闭包都可以使用$this关键字获取闭包的内部状态; </p><p>虽然闭包对象的默认状态没什么用, 只不过是有一个__invoke魔术方法和bindTo()方法而已; 但是bindTo()方法为闭包增加了一些有趣的潜力, 我们可以使用这个方法把closure对象内部的状态绑定到其他对象上;</p><p>2.<strong>bindTo()方法的第二个参数很重要, 其作用是指定绑定闭包的那个对象所属的PHP类; 因此, 闭包可以访问绑定闭包的对象中受保护和似有的成员变量;</strong></p><p>3.其实如果经常看一些php框架源码, 你会发现, PHP框架经常使用bindTo()方法把 <code>路由URL所映射的匿名回调函数</code> 绑定到 <code>应用对象上</code>, 这么做可以在这个匿名函数中使用$this关键字引用重要的应用对象:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">protected</span> $routes = [];</div><div class="line">    <span class="keyword">protected</span> $responseStatus = <span class="string">'200 OK'</span>;</div><div class="line">    <span class="keyword">protected</span> $responseContentType = <span class="string">'text/html'</span>;</div><div class="line">    <span class="keyword">protected</span> $responseBody = <span class="string">'Hello world'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addRoute</span><span class="params">($routePath, $routeCallback)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;routes[$routePath] = $routeCallback-&gt;bindTo(<span class="keyword">$this</span>, <span class="keyword">__CLASS__</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">($currentPath)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">foreach</span>(<span class="keyword">$this</span>-&gt;routes <span class="keyword">as</span> $routePath =&gt; $callBack)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> ($routePath === $currentPath) &#123;</div><div class="line">                $callBack();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        header(<span class="string">'HTTP/1.1 '</span> . <span class="keyword">$this</span>-&gt;responseStatus);</div><div class="line">        header(<span class="string">'Content-type: '</span> . <span class="keyword">$this</span>-&gt;responseContentType);</div><div class="line">        header(<span class="string">'Content-length: '</span> . mb_strlen(<span class="keyword">$this</span>-&gt;responseBody));</div><div class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;responseBody;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$app = <span class="keyword">new</span> App();</div><div class="line">$app-&gt;addRoute(<span class="string">'/user/getName'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;responseContentType = <span class="string">'application/json;charset=utf8'</span>;</div><div class="line">    <span class="keyword">$this</span>-&gt;responseBody = <span class="string">'&#123;"name": "renyimin"&#125;'</span>;</div><div class="line">&#125;);</div><div class="line">$app-&gt;dispatch(<span class="string">'/user/getName'</span>);</div><div class="line"></div><div class="line"><span class="comment">//结果返回: &#123;"name": "renyimin"&#125;</span></div></pre></td></tr></table></figure></p><p>上面例子其实就是通过在App应用类中, 使用匿名函数的bindTo()方法将匿名函数绑定到了App对象上, 所以你就可以在绑定路由与其匿名函数的时候, 在匿名函数中来通过$this来调用App对象中的一些受保护的属性, 从而设定本路由的返回信息;</p><blockquote><p>《Modern PHP》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要是对网上现存的一些资料做了一些简单地整理, 一方面让自己对基础知识加深印象, 一方面便于日后自己随时回顾!&lt;/p&gt;
&lt;h4 id=&quot;JavaScript中的闭包&quot;&gt;&lt;a href=&quot;#JavaScript中的闭包&quot; class=&quot;headerlink&quot; title=&quot;J
      
    
    </summary>
    
      <category term="PHP New Features" scheme="http://blog.renyimin.com/categories/PHP-New-Features/"/>
    
      <category term="PHP" scheme="http://blog.renyimin.com/categories/PHP-New-Features/PHP/"/>
    
    
      <category term="Closure(闭包)" scheme="http://blog.renyimin.com/tags/Closure-%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>01 - 认识JWT</title>
    <link href="http://blog.renyimin.com/2016/01/07/JWT-01/"/>
    <id>http://blog.renyimin.com/2016/01/07/JWT-01/</id>
    <published>2016-01-07T02:05:00.000Z</published>
    <updated>2017-10-19T10:11:09.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="JWT" scheme="http://blog.renyimin.com/categories/JWT/"/>
    
    
      <category term="JWT" scheme="http://blog.renyimin.com/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>网络数据通信方式</title>
    <link href="http://blog.renyimin.com/2015/07/10/Data-communication-method01/"/>
    <id>http://blog.renyimin.com/2015/07/10/Data-communication-method01/</id>
    <published>2015-07-10T05:20:16.000Z</published>
    <updated>2017-10-16T03:46:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络中传输的信息都是数字数据, <strong>按照数据在线路上的传输方向</strong>，<code>通信方式</code> 可分为：</p><h2 id="单工通信-Simplex"><a href="#单工通信-Simplex" class="headerlink" title="单工通信(Simplex)"></a>单工通信(Simplex)</h2><h3 id="单向信道-信息流是单方向的"><a href="#单向信道-信息流是单方向的" class="headerlink" title="单向信道,信息流是单方向的"></a>单向信道,信息流是单方向的</h3><p>发送端和接收端的身份是固定的, 发送端只能发送信息, 不能接收信息; 接收端只能接收信息, 不能发送信息 ;</p><h3 id="常见通信"><a href="#常见通信" class="headerlink" title="常见通信"></a>常见通信</h3><p>遥控、遥测, 就是单工通信方式</p><h2 id="半双工通信-Half-Duplex"><a href="#半双工通信-Half-Duplex" class="headerlink" title="半双工通信(Half Duplex)"></a>半双工通信(Half Duplex)</h2><h3 id="双向信道-信息流是双向的"><a href="#双向信道-信息流是双向的" class="headerlink" title="双向信道, 信息流是双向的"></a>双向信道, 信息流是双向的</h3><p>没有固定发送端和接收端, 任何一端都可以发送消息给另一端 ;</p><h3 id="同一时刻只能发送或只能接收数据"><a href="#同一时刻只能发送或只能接收数据" class="headerlink" title="同一时刻只能发送或只能接收数据"></a>同一时刻只能发送或只能接收数据</h3><p>所谓半双工就是指一个时间段内只有一个动作发生 ;</p><h3 id="常见通信-1"><a href="#常见通信-1" class="headerlink" title="常见通信"></a>常见通信</h3><p>对讲机, 微信语音</p><h2 id="全双工通信-Full-Duplex"><a href="#全双工通信-Full-Duplex" class="headerlink" title="全双工通信(Full Duplex)"></a>全双工通信(Full Duplex)</h2><h3 id="双向信道-信息流是双向的-1"><a href="#双向信道-信息流是双向的-1" class="headerlink" title="双向信道, 信息流是双向的"></a>双向信道, 信息流是双向的</h3><p>没有固定发送端和接收端, 任何一端都可以发送消息给另一端 ;</p><h3 id="发送和接收数据可以同时进行"><a href="#发送和接收数据可以同时进行" class="headerlink" title="发送和接收数据可以同时进行"></a>发送和接收数据可以同时进行</h3><p>是指在发送数据的同时也能够接收数据, 可以同时进行 ;<br>(目前的网卡一般都支持全双工)</p><h3 id="常见通信-2"><a href="#常见通信-2" class="headerlink" title="常见通信"></a>常见通信</h3><p>我们平时的打电话通信就是全双工通信，你在说话的同时也能够听到对方的声音 ;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机网络中传输的信息都是数字数据, &lt;strong&gt;按照数据在线路上的传输方向&lt;/strong&gt;，&lt;code&gt;通信方式&lt;/code&gt; 可分为：&lt;/p&gt;
&lt;h2 id=&quot;单工通信-Simplex&quot;&gt;&lt;a href=&quot;#单工通信-Simplex&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="网络" scheme="http://blog.renyimin.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://blog.renyimin.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>polling--&gt;服务推技术--&gt;websocket</title>
    <link href="http://blog.renyimin.com/2015/07/10/websocket01/"/>
    <id>http://blog.renyimin.com/2015/07/10/websocket01/</id>
    <published>2015-07-10T04:40:16.000Z</published>
    <updated>2017-10-16T03:04:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1.传统Web开发下, 我们都是使用http协议在服务器和客户端之间进行通信, 要知道http协议是一种单向的网络协议, 在建立连接之后, 只能是浏览器向服务器发出请求资源后, 服务器才能响应 ; </p><p>注意: <code>服务器是无法主动的推送数据给客户端的</code>, 这也是为了<code>安全</code>起见 ;</p><p>2.既然传统的http请求有上述问题, 那么如下一些现代web开发的场景该如何应对?<br>即时通信系统；<br>即时报价系统；<br>股票的实时行情;</p><p>3.要应对上述应用场景, 目前有很多方案可供选择, 下面将一一介绍;</p><h2 id="传统Ajax短轮训-Polling"><a href="#传统Ajax短轮训-Polling" class="headerlink" title="传统Ajax短轮训(Polling)"></a>传统Ajax短轮训(Polling)</h2><p>1.这种方案主要就是通过浏览器<code>每隔一定时间就去向服务器发送http请求</code>, 服务器受到请求后, 就把最新的数据返回给客户端(浏览器), 浏览器再将数据显示出来 ;</p><p>2.虽然这种方案可以满足需求, 但是却存在很多问题:<br>(1) 可能在一段时间内的多次请求中, 服务器端的数据根本就没有更新过, 这样就导致客户端一直在空转, 这样既浪费了网络带宽, 又浪费了COU的利用率 ;</p><p>(2) 针对第一个问题, 可能有人会觉得, 将客户端请求服务器的时间间隔做适当的调整就可以, 比如调整大一点, 但这样的话, 如果服务器端的数据更新很快的时候, 又不能保证客户端获取数据的实时性 ;</p><h2 id="解决方案-–-服务器推技术"><a href="#解决方案-–-服务器推技术" class="headerlink" title="解决方案 – 服务器推技术"></a>解决方案 – 服务器推技术</h2><h3 id="服务器推技术分两类"><a href="#服务器推技术分两类" class="headerlink" title="服务器推技术分两类"></a>服务器推技术分两类</h3><p>面对上面提到的实时性较高的web应用场景, “服务器推”技术有一些解决方案, 本文将这些解决方案分为两类 :<br>(1)一类需要在浏览器端安装插件,基于套接口传送信息,或是使用 RMI、CORBA 进行远程调用 ;<br>基于客户端套接口的 “服务器推” 技术</p><p>(2)而另一类则无须浏览器安装任何插件、基于 HTTP 长连接 ;<br>Comet </p><h2 id="基于客户端套接口的”服务器推”技术"><a href="#基于客户端套接口的”服务器推”技术" class="headerlink" title="基于客户端套接口的”服务器推”技术"></a>基于客户端套接口的”服务器推”技术</h2><h3 id="Flash-XMLSocket"><a href="#Flash-XMLSocket" class="headerlink" title="Flash XMLSocket"></a>Flash XMLSocket</h3><p>如果你的Web应用的用户可以接受 <code>只有在安装了 Flash 播放器</code> 应用才能正常运行, 那么使用 Flash 的 <code>XMLSocket</code> 就是一个可行的方案:</p><p>这种方案实现的基础是:<br>1.Flash 提供了 XMLSocket 类 ;<br>2.JavaScript 和 Flash 的紧密结合: 在 JavaScript 可以直接调用 Flash 程序提供的接口;</p><p>具体实现方法: 在 HTML 页面中内嵌入一个使用了 XMLSocket 类的 Flash 程序, JavaScript 通过调用此 Flash 程序提供的套接口接口与服务器端的套接口进行通信, JavaScript 在收到服务器端以 XML 格式传送的信息后可以很容易地控制 HTML 页面的内容显示 ;</p><p><strong><em>关于如何去构建充当了 JavaScript 与 Flash XMLSocket 桥梁的 Flash 程序，以及如何在 JavaScript 里调用 Flash 提供的接口，我们可以参考 AFLAX（Asynchronous Flash and XML）项目提供的 Socket Demo 以及 SocketJS（请参见 参考资源）</em></strong></p><p>Javascript 与 Flash 的紧密结合，极大增强了客户端的处理能力。从 Flash 播放器 V7.0.19 开始，已经取消了 XMLSocket 的端口必须大于 1023 的限制。Linux 平台也支持 Flash XMLSocket 方案。但此方案的 <strong>缺点</strong> 在于：<br>(1)客户端必须安装 Flash 播放器；<br>(2)因为 XMLSocket 没有 HTTP 隧道功能，XMLSocket 类不能自动穿过防火墙；<br>(3)因为是使用套接口，需要设置一个通信端口，防火墙、代理服务器也可能对非 HTTP 通道端口进行限制；</p><p>不过这种方案在一些网络聊天室，网络互动游戏中已得到广泛使用。</p><h3 id="Java-Applet-套接口"><a href="#Java-Applet-套接口" class="headerlink" title="Java Applet 套接口"></a>Java Applet 套接口</h3><p>在客户端使用 Java Applet，通过 java.net.Socket 或 java.net.DatagramSocket 或 java.net.MulticastSocket 建立与服务器端的套接口连接, 从而实现”服务器推” ;</p><p>这种方案最大的不足在于 <code>Java applet 在收到服务器端返回的信息后, 无法通过 JavaScript 去更新 HTML 页面的内容</code> ;</p><h2 id="基于HTTP长连接的”服务器推”技术"><a href="#基于HTTP长连接的”服务器推”技术" class="headerlink" title="基于HTTP长连接的”服务器推”技术"></a>基于HTTP长连接的”服务器推”技术</h2><h3 id="Comet-简介"><a href="#Comet-简介" class="headerlink" title="Comet 简介"></a>Comet 简介</h3><p>1.”服务器推” 是一种很早就存在的技术,以前在实现上主要是通过客户端的套接口或是服务器端的远程调用, 因为浏览器技术的发展比较缓慢,没有为”服务器推”的实现提供很好的支持,在纯浏览器的应用中很难有一个完善的方案去实现”服务器推”并用于商业程序; </p><p>2.最近几年, 因为 <code>AJAX 技术的普及</code>, 以及 <code>把 IFrame 嵌在 &quot;htmlfile&quot; 的 ActiveX 组件中可以解决 IE 的加载显示问题</code>，一些受欢迎的应用如 meebo，gmail+gtalk 在实现中使用了这项技术;</p><p>3.Alex Russell(Dojo Toolkit 的项目 Lead)称 <code>基于 HTTP 长连接、无须在浏览器端安装插件的</code> “服务器推”技术为 “Comet”;</p><p>4.目前已经出现了一些成熟的 Comet 应用以及各种开源框架, 一些 Web 服务器如Jetty也在为支持大量并发的长连接进行了很多改进; 关于 Comet 技术最新的发展状况请参考关于 Comet 的 wiki。</p><h3 id="Comet的实现模型有两类"><a href="#Comet的实现模型有两类" class="headerlink" title="Comet的实现模型有两类"></a>Comet的实现模型有两类</h3><p>下面将介绍两种 Comet 应用的实现模型 (都是基于http长连接) :<br>基于 AJAX 的长轮询（long-polling）方式</p><p>基于 Iframe 及 htmlfile 的流(streaming)方式</p><h3 id="基于-AJAX-的长轮询（long-polling）方式"><a href="#基于-AJAX-的长轮询（long-polling）方式" class="headerlink" title="基于 AJAX 的长轮询（long-polling）方式"></a>基于 AJAX 的长轮询（long-polling）方式</h3><p>1.AJAX 的出现使得 JavaScript 可以调用 XMLHttpRequest 对象发出 HTTP 请求，JavaScript 响应处理函数根据服务器返回的信息对 HTML 页面的显示进行更新;</p><p>2.使用 AJAX 实现”服务器推” 与 传统的 AJAX 应用不同之处在于：<br>(1)服务器端会阻塞请求直到有数据传递或超时才返回;<br>(2)客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后,再次发出请求,重新建立连接;<br>(3)当客户端处理接收的数据、重新建立连接时, 服务器端可能有新的数据到达, 这些信息会被服务器端保存直到客户端重新建立连接, 客户端会一次把当前服务器端所有的信息取回;</p><p>3.基于长轮询的服务器推模型如下:<br><img src="/img/websocket/comet_ajax_longpolling.png" width="350" height="280" alt="comet_ajax_longpolling" align="center"></p><p>相对于”短轮询”(poll), 这种长轮询方式也可以称为”拉”(pull);</p><p>这种方案<code>基于 AJAX</code>，具有以下一些优点:<br>请求异步发出;<br>无须安装插件;<br>IE、Mozilla FireFox 都支持 AJAX;</p><h3 id="基于-Iframe-及-htmlfile-的流-streaming-方式"><a href="#基于-Iframe-及-htmlfile-的流-streaming-方式" class="headerlink" title="基于 Iframe 及 htmlfile 的流(streaming)方式"></a>基于 Iframe 及 htmlfile 的流(streaming)方式</h3><p>1.iframe 是很早就存在的一种 HTML 标记, 通过在 HTML 页面里嵌入一个隐蔵帧,然后将这个隐蔵帧的 SRC 属性设为对一个长连接的请求, 服务器端就能源源不断地往客户端输入数据;</p><p>2.基于流方式的服务器推模型<br><img src="/img/websocket/comet_iframe_streaming.png" width="350" height="280" alt="comet_iframe_streaming" align="center"><br>上节提到的 AJAX 方案是在 JavaScript 里处理 XMLHttpRequest 从服务器取回的数据，然后 Javascript 可以很方便的去控制 HTML 页面的显示;</p><p>同样的思路用在 iframe 方案的客户端，iframe 服务器端并不返回直接显示在页面的数据，而是返回对客户端 Javascript 函数的调用，如<code>&lt;script type=&quot;text/javascript&quot;&gt;js_func(&#39;data from server&#39;)&lt;/script&gt;;</code> 服务器端将返回的数据作为客户端 JavaScript 函数的参数传递, 客户端浏览器的 Javascript 引擎在收到服务器返回的 JavaScript 调用时就会去执行代码;</p><p>从图中可以看到,每次数据传送不会关闭连接,连接只会在通信出现错误时或是连接重建时关闭(一些防火墙常被设置为丢弃过长的连接,服务器端可以设置一个超时时间,超时后通知客户端重新建立连接,并关闭原来的连接);</p><p>使用 iframe 请求一个长连接有一个很明显的不足之处:IE、Morzilla Firefox 下端的进度栏都会显示加载没有完成,而且 IE 上方的图标会不停的转动,表示加载正在进行;<br>Google 的天才们使用一个称为“htmlfile”的 ActiveX 解决了在 IE 中的加载显示问题，并将这种方法用到了 gmail+gtalk 产品中。Alex Russell 在 “What else is burried down in the depth’s of Google’s amazing JavaScript?”文章中介绍了这种方法。Zeitoun 网站提供的 comet-iframe.tar.gz，封装了一个基于 iframe 和 htmlfile 的 JavaScript comet 对象，支持 IE、Mozilla Firefox 浏览器，可以作为参考。（请参见 参考资源）</p><h2 id="解决方案-–-WebSocket"><a href="#解决方案-–-WebSocket" class="headerlink" title="解决方案 – WebSocket"></a>解决方案 – WebSocket</h2><p>1.websocket是HTML5中定义的新协议, 它实现了<strong>真正的</strong>长连接, 实现了浏览器与服务器的全双工通信;<br>WebSocket是为解决客户端与服务端实时通信而产生的技术, websocket协议本质上是一个基于tcp的协议，是先通过HTTP/HTTPS协议发起一条特殊的http请求进行握手后, 创建一个用于交换数据的TCP连接, 此后服务端与客户端通过此TCP连接进行实时通信 ;<br>注意:此时不再需要原HTTP协议的参与了 ;</p><p>2.<br><a href="https://www.ibm.com/developerworks/cn/web/wa-lo-comet/#icomments" target="_blank" rel="external">摘自</a><br><a href="http://blog.csdn.net/fhzaitian/article/details/51691946" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;1.传统Web开发下, 我们都是使用http协议在服务器和客户端之间进行通信, 要知道http协议是一种单向的网络协议, 在建立连接之后, 
      
    
    </summary>
    
      <category term="WebSocket" scheme="http://blog.renyimin.com/categories/WebSocket/"/>
    
    
      <category term="WebSocket" scheme="http://blog.renyimin.com/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>XSS (Cross Site Scripting)</title>
    <link href="http://blog.renyimin.com/2015/05/09/safe-xss01/"/>
    <id>http://blog.renyimin.com/2015/05/09/safe-xss01/</id>
    <published>2015-05-09T12:15:47.000Z</published>
    <updated>2017-10-16T09:52:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XSS-Cross-Site-Scripting-跨站脚本攻击"><a href="#XSS-Cross-Site-Scripting-跨站脚本攻击" class="headerlink" title="XSS (Cross Site Scripting 跨站脚本攻击)"></a>XSS (Cross Site Scripting 跨站脚本攻击)</h2><p>为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，所以将跨站脚本攻击缩写为XSS;</p><p>XSS是一种网站应用程序的安全漏洞攻击, 是代码注入的一种, 它允许恶意用户将代码注入到网页上, 其他用户在观看网页时就会受到影响, 这类攻击通常包含了HTML以及用户端脚本语言;</p><p>XSS与SQL注入攻击类似, SQL注入攻击是以SQL语句作为用户输入, 从而达到查询/修改/删除数据的目的; 而在xss攻击中, 是通过插入恶意脚本, 实现对用户浏览器的控制;</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>盗取cookie, 获取敏感信息;</p><p>利用植入Flash，通过crossdomain权限设置进一步获取更高权限; 或者利用Java等得到类似的操作;</p><p>利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击者）用户的身份执行一些管理动作，或执行一些如:发微博、加好友、发私信等常规操作，前段时间新浪微博就遭遇过一次XSS ;</p><p>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动;</p><p>在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果;</p><h2 id="总体分为三类"><a href="#总体分为三类" class="headerlink" title="总体分为三类"></a>总体分为三类</h2><p>Dom-Based（Dom式）<br>Stroed-Based（存储式/持久型）<br>Reflex-Based（反射式/非持久型）</p><p>##场景1<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">setcookie(<span class="string">'name'</span>, <span class="string">'renyimin'</span>);</div><div class="line">setcookie(<span class="string">'age'</span>, <span class="number">300</span>);</div><div class="line"><span class="meta">?&gt;</span></div><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;Document&lt;/title&gt;</div><div class="line">    &lt;script src=<span class="string">"http://libs.baidu.com/jquery/2.1.1/jquery.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"address1"</span> value=<span class="string">""</span> onfocus=<span class="string">"console.log(document.cookie);"</span>&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p><p><a href="http://blog.csdn.net/kwame211/article/details/76479293?locationNum=5&amp;fps=1" target="_blank" rel="external">参考</a><br><a href="http://blog.csdn.net/sjn0503/article/details/73176092?locationNum=2&amp;fps=1" target="_blank" rel="external">参考httponly</a><br><a href="http://www.cnblogs.com/h4ck0ne/p/5154622.html" target="_blank" rel="external">http://www.cnblogs.com/h4ck0ne/p/5154622.html</a></p><p><a href="http://blog.csdn.net/zhx278171313/article/category/2208273" target="_blank" rel="external">信息安全</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;XSS-Cross-Site-Scripting-跨站脚本攻击&quot;&gt;&lt;a href=&quot;#XSS-Cross-Site-Scripting-跨站脚本攻击&quot; class=&quot;headerlink&quot; title=&quot;XSS (Cross Site Scripting 跨站脚本
      
    
    </summary>
    
      <category term="Safe" scheme="http://blog.renyimin.com/categories/Safe/"/>
    
    
      <category term="Safe" scheme="http://blog.renyimin.com/tags/Safe/"/>
    
  </entry>
  
  <entry>
    <title>CSRF (Cross-site request forgery)</title>
    <link href="http://blog.renyimin.com/2015/05/05/safe-csrf01/"/>
    <id>http://blog.renyimin.com/2015/05/05/safe-csrf01/</id>
    <published>2015-05-05T02:20:16.000Z</published>
    <updated>2017-10-16T06:53:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们知道浏览器的同源策略对用户请求的资源是有一些行为限制的:</p><ol><li><code>Cookie</code>、<code>LocalStorage</code> 和 <code>IndexDB</code> 无法读取</li><li><code>DOM</code> 无法获得 </li><li><code>AJAX</code> 请求不能发送</li></ol><p>但也有一些就是不在同源策略的限制范围之内;</p><h2 id="CSRF-跨站点请求伪造"><a href="#CSRF-跨站点请求伪造" class="headerlink" title="CSRF 跨站点请求伪造"></a>CSRF 跨站点请求伪造</h2><p>CSRF跨站点请求伪造(Cross—Site Request Forgery)跟XSS攻击一样, 存在巨大的危害性, 你可以这样来理解:</p><p>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的;<br>但是却完成了攻击者所期望的一个操作, 比如以你的名义发送邮件、发消息, 盗取你的账号, 添加系统管理员, 甚至于购买商品、虚拟货币转账等;<br>如:</p><pre><code><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Web A为存在CSRF漏洞的网站;</div><div class="line">Web B为攻击者构建的恶意网站;</div><div class="line">User C为Web A网站的合法用户;</div></pre></td></tr></table></figure></code></pre><p>CSRF攻击攻击原理及过程如下:</p><pre><code><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</div><div class="line">在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功, 可以正常发送请求到网站A;</div><div class="line">用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B;</div><div class="line">网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A;</div><div class="line">浏览器在接收到这些攻击性代码后,根据网站B的请求,在用户不知情的情况下携带Cookie信息,向网站A发出请求;</div><div class="line">网站A并不知道该请求其实是由B发起的,所以会根据用户C的Cookie信息以C的权限处理该请求,导致来自网站B的恶意代码被执行。</div></pre></td></tr></table></figure></code></pre><h2 id="CSRF攻击实例"><a href="#CSRF攻击实例" class="headerlink" title="CSRF攻击实例"></a>CSRF攻击实例</h2><p>受害者 <code>maomao</code> 在银行有一笔存款，通过对银行的网站发送请求 <code>http://bank.example/withdraw?account=maomao&amp;amount=1000000&amp;for=gougou</code> 可以使 <code>maomao</code> 把自己的 1000000 的存款转到 <code>gougou</code> 的账号下;</p><p>通常情况下, 该请求发送到网站后, 服务器会先验证该请求是否来自一个合法的 session, 并且该 session 的用户 <code>maomao</code> 已经成功登陆 ;</p><p>黑客 <code>feiying</code> 自己在该银行也有账户, 他知道银行网站中的上述 URL 可以对钱进行转帐操作, 于是 <code>feiying</code> 自己发送一个请求给银行: <code>http://bank.example/withdraw?account=maomao&amp;amount=1000000&amp;for=feiying</code>, 但是这个请求来自 <code>feiying</code> 而非 <code>maomao</code>, 他不能通过安全认证，因此该请求不会起作用 ;</p><p>但是此时，<code>feiying</code> 想到使用 CSRF 的攻击方式, 他先自己做一个网站, 在网站中放入如下代码: <code>src=&quot;http://bank.example/withdraw?account=maomao&amp;amount=1000000&amp;for=feiying&quot;</code>，并且通过广告等诱使 <code>maomao</code> 来访问他的网站, 当 <code>maomao</code> 访问该网站时, 上述 url 就会从 <code>maomao</code> 的浏览器发向银行, 而这个请求会附带 <code>maomao</code> 浏览器中的 cookie 一起发向银行服务器, 大多数情况下，该请求会失败，<strong>因为他要求 maomao 的认证信息</strong>, 但是，如果 maomao 当时恰巧刚访问他的银行后不久, 他的浏览器与银行网站之间的 session 尚未过期, 浏览器的 cookie 之中含有 maomao 的认证信息;</p><p>这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 <code>maomao</code> 的账号转移到 <code>feiying</code> 的账号, 而 <code>maomao</code> 当时毫不知情, 等以后 <code>maomao</code> 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 <code>feiying</code> 则可以拿到钱后逍遥法外;</p><h2 id="CSRF漏洞检测"><a href="#CSRF漏洞检测" class="headerlink" title="CSRF漏洞检测"></a>CSRF漏洞检测</h2><p>检测CSRF漏洞是一项比较繁琐的工作, 最简单的方法就是抓取一个正常请求的数据包, 去掉Referer字段后再重新提交, 如果该提交还有效, 那么基本上可以确定存在CSRF漏洞 ;</p><p>随着对CSRF漏洞研究的不断深入, 不断涌现出一些专门针对CSRF漏洞进行检测的工具, 如<code>CSRFTester</code>, <code>CSRF Request Builder</code>等 ;</p><p>以<code>CSRFTester</code>工具为例，CSRF漏洞检测工具的测试原理如下:<br>使用CSRFTester进行测试时, 首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息, 然后通过在CSRFTester中修改相应的表单等信息, 重新提交, 这相当于一次伪造客户端请求;<br>如果修改后的测试请求成功被网站服务器接受, 则说明存在CSRF漏洞, 当然此款工具也可以被用来进行CSRF攻击;</p><h2 id="防御CSRF攻击"><a href="#防御CSRF攻击" class="headerlink" title="防御CSRF攻击"></a>防御CSRF攻击</h2><p>目前防御 CSRF 攻击主要有三种策略</p><h3 id="验证-HTTP-Referer-字段"><a href="#验证-HTTP-Referer-字段" class="headerlink" title="验证 HTTP Referer 字段"></a>验证 HTTP Referer 字段</h3><p>根据 HTTP 协议, 在 HTTP 头中有一个字段叫 Referer, 它记录了该 HTTP 请求的来源地址;</p><p>在通常情况下, 访问一个安全受限页面的请求来自于同一个网站, 比如需要访问 <a href="http://bank.example/withdraw?account=maomao&amp;amount=1000000&amp;for=gougou" target="_blank" rel="external">http://bank.example/withdraw?account=maomao&amp;amount=1000000&amp;for=gougou</a>, 用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件, 这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL, 通常是以 bank.example 域名开头的地址; </p><p>而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的, 如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求;</p><p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷;</p><p>然而，<strong>这种方法并非万无一失</strong>, Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞, 使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全, 事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值, 如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击 ;<br>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题, 因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中, 因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer, 当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问;</p><h3 id="在请求地址中添加-token-并验证"><a href="#在请求地址中添加-token-并验证" class="headerlink" title="在请求地址中添加 token 并验证"></a>在请求地址中添加 token 并验证</h3><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证;</p><p>要抵御 CSRF, 关键在于<strong>在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中</strong>, 可以在 HTTP 请求中以参数的形式加入一个随机产生的 token, 并在服务器端建立一个拦截器来验证这个 token, 如果请求中没有 token 或者 token 内容不正确, 则认为可能是 CSRF 攻击而拒绝该请求;</p><p>这种方法要比检查 Referer 要安全一些, token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求, 对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url?csrftoken=tokenvalue" target="_blank" rel="external">http://url?csrftoken=tokenvalue</a>, 而对于 POST 请求来说，要在 form 的最后加上 <code>&lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;tokenvalue&quot;/&gt;</code>, 这样就把 token 以参数的形式加入请求了, 但是, 在一个网站中, 可以接受请求的地方非常多, 要对于每一个请求都加上 token 是很麻烦的, 并且很容易漏掉, 通常使用的方法就是在每次页面加载时, 使用 javascript 遍历整个 dom 树, 对于 dom 中所有的 a 和 form 标签后加入 token, 这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token ;</p><p>该方法还有一个缺点是难以保证 token 本身的安全, 特别是在一些论坛之类支持用户自己发表内容的网站, 黑客可以在上面发布自己个人网站的地址, 由于系统也会在这个地址后面加上 token, 黑客可以在自己的网站上得到这个 token, 并马上就可以发动 CSRF 攻击, 为了避免这一点, 系统可以在添加 token 的时候增加一个判断, 如果这个链接是链到自己本站的, 就在后面添加 token, 如果是通向外网则不加;<br><strong>不过，即使这个 csrftoken 不以参数的形式附加在请求之中, 黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击, 这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因 ;</strong></p><h3 id="在-HTTP-头中自定义属性并验证"><a href="#在-HTTP-头中自定义属性并验证" class="headerlink" title="在 HTTP 头中自定义属性并验证"></a>在 HTTP 头中自定义属性并验证</h3><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里;<br>通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中, 这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去;</p><p>然而这种方法的局限性非常大, XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便;<br>另外, 对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的;</p><p><a href="http://blog.csdn.net/stpeace/article/details/53512283" target="_blank" rel="external">原文</a><br><a href="http://blog.csdn.net/qdx411324962/article/details/50235253" target="_blank" rel="external">参考</a>(并行会话的兼容)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们知道浏览器的同源策略对用户请求的资源是有一些行为限制的:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Cookie&lt;/code&gt;、&lt;code&gt;
      
    
    </summary>
    
      <category term="Safe" scheme="http://blog.renyimin.com/categories/Safe/"/>
    
    
      <category term="Safe" scheme="http://blog.renyimin.com/tags/Safe/"/>
    
  </entry>
  
  <entry>
    <title>WEB安全之Token浅谈</title>
    <link href="http://blog.renyimin.com/2015/04/12/web-safe-token/"/>
    <id>http://blog.renyimin.com/2015/04/12/web-safe-token/</id>
    <published>2015-04-12T06:21:16.000Z</published>
    <updated>2017-10-16T06:47:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Token一般用在两个地方: 防止表单重复提交, csrf攻击(跨站点请求伪造); 两者在原理上都是通过session token来实现的;</p><p>当客户端请求页面时, 服务器会生成一个随机数Token, 并且将Token放置到session当中, 然后将Token发给客户端(一般通过构造hidden表单), 下次客户端提交请求时, Token会随着表单一起提交到服务器端, 然后，服务器端会对Token值进行验证，判断是否和session中的Token值相等, 若相等则证明请求有效，不是伪造的, 否则, 则证明请求是非法的; </p><p>不过, 如果应用于”防止表单重复提交”，服务器端第一次验证相同过后, 会将session中的Token值更新下, 若用户重复提交, 第二次的验证判断将失败, 因为用户提交的表单中的Token没变, 但服务器端session中Token已经改变了;<br>上面的session应用相对安全，但也较繁琐，同时当多页面多请求时，必须采用多Token同时生成的方法，这样占用更多资源，执行效率会降低。因此，也可用cookie存储验证信息的方法来代替session Token, 比如，应对”重复提交”时, 当第一次提交后便把已经提交的信息写到cookie中，当第二次提交时，由于cookie已经有提交记录，因此第二次提交会失败;<br>不过,cookie存储有个致命弱点，如果cookie被劫持(xss攻击很容易得到用户cookie), 那么又一次gameover, 黑客将直接实现csrf攻击;</p><p>所以，安全和高效相对的;</p><p><a href="http://blog.csdn.net/qdx411324962/article/details/50235253" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Token一般用在两个地方: 防止表单重复提交, csrf攻击(跨站点请求伪造); 两者在原理上都是通过session token来实现的;&lt;/p&gt;
&lt;p&gt;当客户端请求页面时, 服务器会生成一个随机数Token, 并且将Token放置到session当中, 然后将Token
      
    
    </summary>
    
      <category term="Safe" scheme="http://blog.renyimin.com/categories/Safe/"/>
    
    
      <category term="Safe" scheme="http://blog.renyimin.com/tags/Safe/"/>
    
  </entry>
  
</feed>
