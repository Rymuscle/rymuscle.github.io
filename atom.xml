<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rymuscle&#39;s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2018-09-01T14:02:52.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Rymuscle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>28. 隔离级别 与 锁</title>
    <link href="http://blog.renyimin.com/2017/09/03/mysql/2017-09-03-mysql-28/"/>
    <id>http://blog.renyimin.com/2017/09/03/mysql/2017-09-03-mysql-28/</id>
    <published>2017-09-03T06:20:52.000Z</published>
    <updated>2018-09-01T14:02:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>之前几篇博文已经介绍了Mysql事务, 高并发下事务将会面对的问题 及 MySQL的解决方案; MySQL主要采用 事务隔离性中的<strong>4种隔离级别</strong> 结合 <strong>MVCC机制</strong> 来进行解决;</p></li><li><p>而事务隔离级别的核心就是锁, 各隔离级别使用了不同的加锁策略; 接下来看一下各隔离级别是如何实现及如何解决高并发事务问题的;</p></li></ol><h2 id="READ-UNCOMMITTED-未提交读"><a href="#READ-UNCOMMITTED-未提交读" class="headerlink" title="READ UNCOMMITTED 未提交读"></a><a href="/2017/09/21/mysql/2017-09-21-mysql-24/">READ UNCOMMITTED 未提交读</a></h2><h2 id="READ-COMMITTED-提交读"><a href="#READ-COMMITTED-提交读" class="headerlink" title="READ COMMITTED 提交读"></a><a href="/2017/09/22/mysql/2017-09-22-mysql-25/">READ COMMITTED 提交读</a></h2><h2 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a><a href="/2017/09/22/mysql/2017-09-22-mysql-26/">MVCC 多版本并发控制</a></h2><h2 id="REPEATABLE-READ-可重复读"><a href="#REPEATABLE-READ-可重复读" class="headerlink" title="REPEATABLE READ 可重复读"></a><a href="/2017/09/17/mysql/2017-09-17-mysql-27/">REPEATABLE READ 可重复读</a></h2><p>参考资料</p><ul><li>《高性能MySQL》</li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html" target="_blank" rel="noopener">MySQL官方文档</a></li><li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="noopener">美团技术博客</a></li></ul><p>最后更新时间 2018/09/01</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;之前几篇博文已经介绍了Mysql事务, 高并发下事务将会面对的问题 及 MySQL的解决方案; MySQL主要采用 事务隔
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="事务" scheme="http://blog.renyimin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>27. 幻读, 快照读(snapshot read), 当前读 (current read)</title>
    <link href="http://blog.renyimin.com/2017/09/02/mysql/2017-09-02-mysql-27/"/>
    <id>http://blog.renyimin.com/2017/09/02/mysql/2017-09-02-mysql-27/</id>
    <published>2017-09-02T11:25:07.000Z</published>
    <updated>2018-09-01T14:02:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>RR + MVCC</strong> 虽然解决了 <code>幻读</code> 问题, 但要注意, 幻读针对的是读操作(对于其他操作就不一样了);</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ol><li><p>打开 两个客户端 1,2 确保隔离级别为默认级别RR, 提供语句:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@SESSION.tx_isolation;</span><br><span class="line">+------------------------+</span><br><span class="line">| @@SESSION.tx_isolation |</span><br><span class="line">+------------------------+</span><br><span class="line">| REPEATABLE-READ        |</span><br><span class="line">+------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from test_transaction;</span><br><span class="line">+----+-----------+-----+--------+--------------------+</span><br><span class="line">| id | user_name | age | gender | desctiption        |</span><br><span class="line">+----+-----------+-----+--------+--------------------+</span><br><span class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</span><br><span class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</span><br><span class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</span><br><span class="line">+----+-----------+-----+--------+--------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></li><li><p>在客户端2中 <strong>开启事务</strong>, 然后查询数据</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from test_transaction;</span><br><span class="line">+----+-----------+-----+--------+--------------------+</span><br><span class="line">| id | user_name | age | gender | desctiption        |</span><br><span class="line">+----+-----------+-----+--------+--------------------+</span><br><span class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</span><br><span class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</span><br><span class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</span><br><span class="line">+----+-----------+-----+--------+--------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></li><li><p>在客户端1中插入一条id为4的新数据 (未开启事务, 所以会自动提交)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test_transaction (`id`,`user_name`,`age`,`gender`,`desctiption`) values (4, &apos;死侍&apos;, 18, 0, &apos;A bad boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from test_transaction;</span><br><span class="line">+----+-----------+-----+--------+--------------------+</span><br><span class="line">| id | user_name | age | gender | desctiption        |</span><br><span class="line">+----+-----------+-----+--------+--------------------+</span><br><span class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</span><br><span class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</span><br><span class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</span><br><span class="line">|  4 | 死侍    |  18 |      0 | A bad boy          |</span><br><span class="line">+----+-----------+-----+--------+--------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>回到 客户端2 的事务中再次查询数据, 发现数据没有变化(表示<strong>可以重复读, 并且克服了 <code>select</code> 幻读</strong>)!! </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from test_transaction;</span><br><span class="line">+----+-----------+-----+--------+--------------------+</span><br><span class="line">| id | user_name | age | gender | desctiption        |</span><br><span class="line">+----+-----------+-----+--------+--------------------+</span><br><span class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</span><br><span class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</span><br><span class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</span><br><span class="line">+----+-----------+-----+--------+--------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test_transaction;</span><br><span class="line">+----+-----------+-----+--------+--------------------+</span><br><span class="line">| id | user_name | age | gender | desctiption        |</span><br><span class="line">+----+-----------+-----+--------+--------------------+</span><br><span class="line">|  1 | 金刚狼 | 127 |      1 | 我有一双铁爪 |</span><br><span class="line">|  2 | 钢铁侠 | 120 |      1 | 我有一身铁甲 |</span><br><span class="line">|  3 | 绿巨人 |   0 |      2 | 我有一身肉    |</span><br><span class="line">+----+-----------+-----+--------+--------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>但如果尝试在客户端2的事务中执行 <code>insert/delete/update</code> , 却会发现此类操作都可以感知到客户端1提交的新数据</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test_transaction (`id`,`user_name`,`age`,`gender`,`desctiption`) values (4, &apos;死侍&apos;, 18, 0, &apos;A bad boy&apos;);</span><br><span class="line">1062 - Duplicate entry &apos;4&apos; for key &apos;PRIMARY&apos;    //( 后面会看到: 其实是因为insert是当前读)</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>虽然发现已经克服了幻读问题; 但当 在客户端2事务中 <code>insert</code> 插入一条id为4的新数据, 却发现提示数据已经存在, 那么这是什么问题呢?</p><ul><li>可以参考<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="noopener">MySQL官方文档 — 一致性非阻塞读</a>中的一段介绍<blockquote><p>The snapshot of the database state applies to SELECT statements within a transaction, not necessarily to DML statements. If you insert or modify some rows and then commit that transaction, a DELETE or UPDATE statement issued from another concurrent REPEATABLE READ transaction could affect those just-committed rows, even though the session could not query them. If a transaction does update or delete rows committed by a different transaction, those changes do become visible to the current transaction.<br>个人认为应该翻译为: 数据库的快照适用于事务中的SELECT语句, 而不一定适用于所有DML语句。 如果插入或修改某些行, 然后提交该事务, 则从另一个并发REPEATABLE READ事务发出的DELETE或UPDATE语句就可能会影响那些刚刚提交的行, 即使该事务无法查询到它们。<br>如果一个事务去更新或删除其他事务提交的行, 则那些更改对当前事务就变得可见;<br>但是如果事务select由不同事务提交的行, 则那些更改对当前事务就不可见(此时算是rr的可重复读);</p></blockquote></li></ul></li><li><p>也就是RR隔离级别, 在同一事务中多次读取的话, 对 <code>select</code> 克服了 <code>幻读</code>; 但是对其他DML并没有做到(其他DML能察觉到数据被别的事务提交过了)!</p></li><li><p>这就引出了新的两个概念: 当前读 和 快照读</p></li></ol><h2 id="当前读-和-快照读"><a href="#当前读-和-快照读" class="headerlink" title="当前读 和 快照读"></a>当前读 和 快照读</h2><p>通常在RC,RR隔离级别下, 不做特殊处理, 使用的 <code>select</code> 都是快照读, 其他dml就算是当前读; (MVCC写阻塞写)</p><ol><li><p>其实, MVCC并发控制中的读操作分为两类: <code>快照读 (snapshot read)</code> 与 <code>当前读 (current read)</code>; <a href="https://www.cnblogs.com/cat-and-water/p/6427612.html" target="_blank" rel="noopener">参考</a></p></li><li><p>快照读： 是通过MVVC(多版本控制)和 <code>undo log</code> 来实现的, 常见语句如下(貌似就是常见的悲观锁么):</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单的select操作 (不包括: `select ... lock in share mode`, `select ... for update`)</span><br></pre></td></tr></table></figure></li><li><p>而 <code>当前读</code> 根本不会创建任何快照, insert, update, delete都是当前读, 所以这几个操作会察觉到其他事务对数据做的更改(而普通select是察觉不到的):                      </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select ... lock in share mode</span><br><span class="line">select ... for update</span><br><span class="line">insert</span><br><span class="line">update</span><br><span class="line">delete</span><br></pre></td></tr></table></figure></li></ol><p>最后更新时间 2018/09/01</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;RR + MVCC&lt;/strong&gt; 虽然解决了 &lt;code&gt;幻读&lt;/code&gt; 问题, 但要注意, 幻读针对的是读操作(对于其他操作就不一样了);&lt;/p&gt;
&lt;h2 id=&quot;演示&quot;&gt;&lt;a href=&quot;#演示&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="事务" scheme="http://blog.renyimin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>26. MySQL 高并发下常见的事务问题</title>
    <link href="http://blog.renyimin.com/2017/09/02/mysql/2017-09-02-mysql-26/"/>
    <id>http://blog.renyimin.com/2017/09/02/mysql/2017-09-02-mysql-26/</id>
    <published>2017-09-02T06:56:32.000Z</published>
    <updated>2018-09-01T14:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇<a href="/2017/09/16/mysql/2017-09-16-mysql-20/">MySQL事务简介</a>中对MySQL事务的 基本概念 及 特性 做了简单介绍; 接下来会分析在实际生产环境中面对高并发场景时, 事务会出现的一些常见问题; </p><h2 id="高并发事务问题"><a href="#高并发事务问题" class="headerlink" title="高并发事务问题"></a>高并发事务问题</h2><p>在并发量比较大的时候, 很容易出现 <strong>多个事务并行</strong> 的情况; 假设有两个事务正在同时进行, 值得注意的是: 它们两者之间是互相不知道对方的存在的, 各自都对自身所处的环境 <strong>过分乐观</strong>, 从而并没有对自己所操作的数据做一定的保护处理, 所以 <strong>最终导致了一些问题的出现</strong>;</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><ol><li><p>如果 事务A 读取了另一个并行 事务B <strong>未最终提交的写数据</strong>, 那事务A的这次读取操作就叫 <strong>脏读</strong></p><ul><li>因为 事务A 此时读取到的是 并行事务B 尚未最终持久化的数据 (该数据还不具备事务的 持久性)</li><li>事务B 最终可能会因为其事务单元内部其他后续操作的失败 或者 系统后续突然崩溃等原因, 导致事务B最终整体提交失败而回滚, 那么最终 事务A 之前拿到就是 <strong>脏的数据</strong> 了<br>(当然, 如果 事务A 在后续操作中继续读取的话, 无论事务B是否结束, 其每次的更新操作, 事务A都会及时读到新数据, 只不过这同时涉及到了下一个讨论的 不可重复读问题, 暂时可以不了解)</li></ul></li><li><p>图示:<br> <img src="/img/mysql/transaction/dirty_read.png" width="550/"></p></li><li><p><strong>解决方案</strong> : <code>RC+</code></p><ul><li>在MySQL中, 事务已经用自身隔离性解决了脏读问题 : <strong>READ COMMITED</strong> 或 <strong>以上隔离级别</strong>(RC+);</li><li>READ COMMITED 隔离级别保证了: 在事务单元中, 某条语句执行时, 只有已经被其他事务提交的持久性落地数据, 才对该语句可见;</li></ul></li></ol><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><ol><li><p>之前 脏读问题 的解决了, 仅仅只意味着事务单元中的每条语句读取到的数据都是 具备持久性的落地数据<strong>而已</strong>; </p><ul><li>之前在讨论脏读问题时, 有个问题也同时存在着, 那就是一个事务单元中 <strong>不可重复读</strong> 的问题; </li><li>显然, RC 隔离级别只解决了 脏读的问题</li></ul></li><li><p>如果在一个事务中多次读取同一个数据, 正好在两次读取之间, 另外一个事务已经完成了对该数据的修改并提交, 那问题就来了: <strong>两次读取的结果不一样了</strong><br> <img src="/img/mysql/transaction/unReRead.png" width="550/"></p></li><li><p><strong>解决方案</strong> : <code>RR+</code></p><ul><li>在MySQL中, 事务已经用自身隔离性解决了 不可重复读 问题  — <strong>REPEATABLE READ</strong> 或 <strong>以上隔离级别</strong>(RR+);</li><li>REPEATABLE READ 级别保证了:<br>在事务中, 某条语句执行前, 已经被其他事务 提交/回滚 的落地数据, 对该语句都是可见的; ( <code>READ COMMITED</code> )<br>在事务中, 多次读取同一个数据(在两次读取操作之间, 无论数据被 提交 多少次(即无论落地过多少遍), 每次读取的结果都应该是和事务中第一次读取的结果一样;  </li></ul></li></ol><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><ol><li><p>可以参考 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html" target="_blank" rel="noopener">MySQL官方文档对 Phantom Rows 的介绍</a> )</p></li><li><p>不可重复读 和 幻读 这两个概念容易搞混</p><ul><li>不可重复读 主要是说多次读取同一条记录, 发现该记录中某些列值被其他事务修改过; </li><li>而 幻读 主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计), 发现结果不一致(比如发现增加/减少了一条记录);</li></ul></li><li><p><strong>解决方案</strong>: <code>RR + MVCC</code></p><ul><li>其实对于 幻读 问题, 在Mysql的InnoDB存储引擎中, 是通过事务的 <code>RR + MVCC机制</code> 进行解决的;<br>当然, 这里的幻读不涉及 具有当前读能力的那些语句; (也就是说只是解决幻读, 所谓幻写之类的就不在范围内了)</li><li>另外可以参考《高性能MySQL》对 <code>RR</code> 隔离级别的描述 <blockquote><p>理论上, RR级别是无法解决幻读的问题, 但是由于InnoDB引擎的RR级别还使用了MVCC, 所以也就避免了幻读的出现!</p></blockquote></li></ul></li><li><p>之所以 不可重复读 和 幻读 容易搞混, 可能是因为:</p><ul><li>在mysql中, 由于默认就是RR隔离级别下, 该隔离级别已经解决了幻读, 所以无法模拟出幻读的场景; </li><li>而 退回到 RC隔离级别 的话, 虽然 幻读 和 不可重复读 都会出现, 但由于现象都是两次读取结果不一样, 容易分辨不出! </li></ul></li><li><p>想了解更多, 可以参考下一篇<a href="/2017/09/16/mysql/2017-09-16-mysql-22/">幻读的延伸</a></p></li></ol><h2 id="高并发事务问题-之-更新丢失"><a href="#高并发事务问题-之-更新丢失" class="headerlink" title="高并发事务问题 之 更新丢失"></a>高并发事务问题 之 更新丢失</h2><p>最后聊一下高并发事务的另一个问题, 也是最常遇到的问题: <strong>丢失更新问题</strong>; 该问题和之前几个问题需要区分开: 该问题需要我们自己来解决;<br>更新丢失问题分为两类</p><h3 id="第一类丢失更新-回滚覆盖"><a href="#第一类丢失更新-回滚覆盖" class="headerlink" title="第一类丢失更新(回滚覆盖)"></a>第一类丢失更新(回滚覆盖)</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ol><li><p>事务A 回滚时, 将 事务B 已经提交的数据覆盖了<br> <img src="/img/mysql/transaction/loss-update-01.png"></p></li><li><p>需要注意的是: 这种情况在Mysql中不会出现;</p></li></ol><h4 id="RU-级别演示"><a href="#RU-级别演示" class="headerlink" title="RU 级别演示"></a>RU 级别演示</h4><ol><li><p>对于InnoDB事务的最低隔离级别 <code>READ UNCOMMITED</code>, 并行事务B的未提交数据都可以读到, 更别说已提交数据了 (所以回滚也会回滚到事务B提交的最新数据)<br> <img src="/img/mysql/transaction/lose_update_01_r_u.png"></p></li><li><p>语句如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@SESSION.tx_isolation;</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line">SELECT @@SESSION.tx_isolation;</span><br><span class="line">begin;</span><br><span class="line">select * from test_transaction where id=2;</span><br><span class="line">select * from test_transaction where id=2;</span><br><span class="line">update test_transaction set age = age-10 where id=2;</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@SESSION.tx_isolation;</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line">SELECT @@SESSION.tx_isolation;</span><br><span class="line">begin;</span><br><span class="line">select * from test_transaction where id=2;</span><br><span class="line">update test_transaction set age = age - 15 where id=2;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></li></ol><h4 id="RC-级别演示"><a href="#RC-级别演示" class="headerlink" title="RC 级别演示"></a>RC 级别演示</h4><ol><li><p>对于 <code>READ COMMITTED</code>: 在事务B提交之后, 事务A在T3阶段是可以select(<strong>快照读</strong>)到事务B最终提交的数据的, 更别说update(<strong>当前读</strong>)到了, 所以事务A最终的Rollback其实也是基于事务B提交后的数据的 (关于这里提到的快照读和当前读, 下一篇会介绍)<br> <img src="/img/mysql/transaction/lose_update_01_r_c.png"></p></li><li><p>语句如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@SESSION.tx_isolation;</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">SELECT @@SESSION.tx_isolation;</span><br><span class="line">begin;</span><br><span class="line">select * from test_transaction where id=2;</span><br><span class="line">select * from test_transaction where id=2;</span><br><span class="line">update test_transaction set age = age-10 where id=2;</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@SESSION.tx_isolation;</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">SELECT @@SESSION.tx_isolation;</span><br><span class="line">begin;</span><br><span class="line">select * from test_transaction where id=2;</span><br><span class="line">update test_transaction set age = age - 15 where id=2;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></li></ol><h4 id="RR-级别演示"><a href="#RR-级别演示" class="headerlink" title="RR 级别演示"></a>RR 级别演示</h4><ol><li><p>对于 <code>REPEATABLE READ</code> 可重复读, 事务A在T3阶段虽然select不到事务B最终提交的数据(<strong>快照读</strong>), 但是可以update(<strong>当前读</strong>)到事务B最终提交的数据的<br> <img src="/img/mysql/transaction/lose_update_01_r_r.png"><br> (注意: RR与RC虽然都会有快照读, 但是快照读的结果却不一致, 其实是因为两者的MVCC机制快找时机不同导致的, 后面会讲解)</p></li><li><p>语句如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@SESSION.tx_isolation;</span><br><span class="line">begin;</span><br><span class="line">select * from test_transaction where id=2;</span><br><span class="line"></span><br><span class="line">select * from test_transaction where id=2;</span><br><span class="line">update test_transaction set age = age+10 where id=2;</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@SESSION.tx_isolation;</span><br><span class="line">begin;</span><br><span class="line">select * from test_transaction where id=2;</span><br><span class="line">update test_transaction set age = age-15 where id=2;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></li></ol><h4 id="SERIALIZABLE-演示"><a href="#SERIALIZABLE-演示" class="headerlink" title="SERIALIZABLE 演示"></a>SERIALIZABLE 演示</h4><ol><li><p><code>SERIALIZABLE</code> 串行化: <strong>读写都加锁</strong>, 最容易出现死锁, 所以也不会出现第一类丢失更新的问题, 直接就死锁了<br> <img src="/img/mysql/transaction/lose_update_01_s.png"></p></li><li><p>语句如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@SESSION.tx_isolation;</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">SELECT @@SESSION.tx_isolation;</span><br><span class="line">begin;</span><br><span class="line">update test_transaction set age = age-10 where id=2;</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@SESSION.tx_isolation;</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line">SELECT @@SESSION.tx_isolation;</span><br><span class="line">begin;</span><br><span class="line">select * from test_transaction where id=2;</span><br><span class="line">update test_transaction set age = age -15 where id=2;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></li></ol><h3 id="第二类丢失更新-提交覆盖"><a href="#第二类丢失更新-提交覆盖" class="headerlink" title="第二类丢失更新(提交覆盖)"></a>第二类丢失更新(提交覆盖)</h3><ol><li><p>直接上图<br> <img src="/img/mysql/transaction/lose_update-02.png"></p></li><li><p><strong>另外, 这里可以解释一下为什么 SERIALIZABLE级别 通常不会不被采用</strong></p><ul><li>其实 SERIALIZABLE 虽然做了串行化, 其实也就是对读写都加了锁, 但一旦事务并行, 如果将判断库存的读操作放在事务内就很容易会死锁<br>而放在事务外, 由于更新操作仍然会依据上一个查询的结果, 所以仍然是避免不了第二类丢失更新问题的, 会造成<strong>超卖</strong>等问题;</li><li>SERIALIZABLE 的串行化本身也太低效</li><li>另外, 可以参考: <a href="https://segmentfault.com/q/1010000010353164/a-1020000010353684" target="_blank" rel="noopener">https://segmentfault.com/q/1010000010353164/a-1020000010353684</a></li></ul></li><li><p>解决第二类丢失更新的方案:</p><ul><li><code>乐观锁</code> (在修改时, where判断数据是否为你读取时的数据; 或者提供数据版本字段来控制)</li><li><code>悲观锁</code> </li></ul></li></ol><p>参考资料:</p><ul><li>《高性能MySQL》</li><li><a href="http://mysql.taobao.org/monthly/2017/06/07/" target="_blank" rel="noopener">淘宝数据库内核6月报</a></li><li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="noopener">美团技术博客</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/" target="_blank" rel="noopener">MySQL官方文档</a></li></ul><p>最后更新时间 2018/09/01</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇&lt;a href=&quot;/2017/09/16/mysql/2017-09-16-mysql-20/&quot;&gt;MySQL事务简介&lt;/a&gt;中对MyS
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="事务" scheme="http://blog.renyimin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>25. MySQL 事务简介</title>
    <link href="http://blog.renyimin.com/2017/08/27/mysql/2017-08-27-mysql-25/"/>
    <id>http://blog.renyimin.com/2017/08/27/mysql/2017-08-27-mysql-25/</id>
    <published>2017-08-27T11:31:07.000Z</published>
    <updated>2018-09-01T14:02:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h2><ol><li><p>事务：可以理解为一个 <strong>独立的工作单元</strong>, 在这个独立的工作单元中, 可以有一组操作;<br> 放在这个独立工作单元中的一组操作, <strong>要么全部执行成功, 要么全部执行失败</strong></p></li><li><p>随处可见的例子: 假设有两个角色 ‘Iron Man’(余额500), ‘Wolverine’(余额15), 现在 ‘Iron Man’ 通过银行应用给 ‘Wolverine’ 转账100元, 那么本次转账操作至少需要三个步骤</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查`Iron Man`余额`&gt;=100`元</span><br><span class="line">从`Iron Man`余额中`-100`元</span><br><span class="line">给`Wolverine`余额`+100`元</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>: 上面的三个步操作，就需要打包在一个事务中作为 <strong>独立的工作单元</strong> 来执行。并且在 这个独立工作单元中的三个操作, 只要有任何一个操作失败, 则整体就应该是失败的, 那就必须回滚所有已经执行了的步骤;<br> 假设第二步操作成功, 但是第三步操作失败, 那么整个事务就应该是失败的, 就必须将第二步的操作回滚 (这也体现了事务最基本的一个特性: <strong>保证数据的一致性</strong>)</p></li></ol><h2 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h2><p>一个运行良好的事务处理系统必须具备下面这些标准特性(高并发离不开事务的这几个标准特性) </p><h3 id="Atomicity-原子性"><a href="#Atomicity-原子性" class="headerlink" title="Atomicity 原子性"></a>Atomicity 原子性</h3><p>一个事务必须被视为一个不可分割的最小工作单元;<br>对于一个事务来说, 不能只成功执行其中的一部分操作, 整个事务中的所有操作要么全部成功提交, 要么有操作失败导致所有操作全部回滚, 这就是事务的原子性。</p><h3 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h3><p>此一致性非彼一致性</p><p>你大概可以这样来理解: 虽然数据表中的数据可能一直在变化, 但是事务的一致性特性保证的是 <strong>数据库总是从一个数据一致性的状态 转换到 另一个数据一致性的状态</strong>, 而不是分布式中提到的数据一致性; </p><p>比如之前转账的例子:</p><ul><li>转账前的数据一致性状态是: ‘Iron Man’(余额500), ‘Wolverine’(余额15)</li><li>转账成功后的数据一致性状态是: ‘Iron Man’(余额400), ‘Wolverine’(余额115)</li><li>转账如果失败的话, 数据的一致性的状态应该回滚到转账前的状态: ‘Iron Man’(余额500), ‘Wolverine’(余额15)</li></ul><h3 id="Isolation-隔离性"><a href="#Isolation-隔离性" class="headerlink" title="Isolation 隔离性"></a>Isolation 隔离性</h3><ol><li><p><strong>通常来说</strong>, 一个事务所做的修改在最终提交以前, 对其他事务是不可见的<br>比如在之前的转账例子中, 在执行完成最后一步(第三步), 事务还没来得及最终提交之前, 此时有另一个程序去读取 Iron Man账户 的余额, 那么这个程序读到的应该是500才对</p></li><li><p>上面为什么说 <strong>通常来说</strong>, 难道还有其他情况 ?<br>后面会详细讨论事务 隔离性 的四个 <strong>隔离级别</strong>, 到时候就知道这里为什么说 通常来说 ; (确实有特例, 比如最低隔离级别 <code>READ UNCOMMITTED</code>, 对其他事务的可见就造成了 <code>脏读问题</code> 的出现)</p></li><li><p>事务有四种隔离级别(从低到高)</p><ul><li><code>READ UNCOMMITTED</code>    (未提交读)</li><li><code>READ COMMITTED</code>      (提交读)<br>(注意: 和RR一样都采用了MVCC机制, 但与RR级别主要区别是快照时机不同, 暂时可不必了解, 后面文章会详解)</li><li><code>REPEATABLE READ</code>     (可重复读)</li><li><code>SERIALIZABLE</code>        (可串行化) <strong>注意: 只有该隔离级别才会读写都加锁</strong></li></ul></li></ol><h3 id="Durability-持久性"><a href="#Durability-持久性" class="headerlink" title="Durability 持久性"></a>Durability 持久性</h3><ol><li>一旦事务被最终提交后, 在这个独立单元中的所有操作所做的修改将会 永久保存到数据库中; </li><li><strong>所谓永久, 也只是主观上的永久, 可以理解为被事务修改的数据是真正存放到了表中, 而不是存放在了诸如临时表之类的地方</strong>;</li></ol><p>最后更新时间 2018/09/01</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事务的概念&quot;&gt;&lt;a href=&quot;#事务的概念&quot; class=&quot;headerlink&quot; title=&quot;事务的概念&quot;&gt;&lt;/a&gt;事务的概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;事务：可以理解为一个 &lt;strong&gt;独立的工作单元&lt;/strong&gt;, 在这个独立的工作单元中,
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="事务" scheme="http://blog.renyimin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
</feed>
