<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2018-06-30T05:52:46.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>22. Priority Queues - queue(x-max-priority) + message(priority)</title>
    <link href="http://blog.renyimin.com/2018/06/19/rabbitmq/2018-06-19-rabbitmq-22/"/>
    <id>http://blog.renyimin.com/2018/06/19/rabbitmq/2018-06-19-rabbitmq-22/</id>
    <published>2018-06-19T11:21:32.000Z</published>
    <updated>2018-06-30T05:52:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Priority-Queues"><a href="#Priority-Queues" class="headerlink" title="Priority Queues"></a>Priority Queues</h2><ol><li><p>官网文档: <a href="https://www.rabbitmq.com/priority.html" target="_blank" rel="external">https://www.rabbitmq.com/priority.html</a></p></li><li><p>译文</p><ul><li><p>从3.5.0版本开始, RabbitMQ已经在核心中实现了 <strong>优先级队列</strong><br>任何队列都可以使用客户端提供的可选参数 <code>$arguments</code> 变成优先的 (但与其他功能不同, 此处可以使用可选参数 <code>$arguments</code>, 但是不支持使用 <code>策略</code>)<br>该实现支持有限的优先级数量: 255, 建议1至10之间的值;</p></li><li><p>使用客户端提供的可选参数 <code>$arguments</code><br>要声明优先级队列, 请使用queue的可选参数 <code>$arguments</code> 的 <code>x-max-priority</code> 选项, 该参数应该是1到255之间的正整数, 表示队列应该支持的最大优先级;</p></li><li><p>AMQP 0-9-1规范对于优先级的工作方式有些模糊, 它认为所有的队列中必须至少有两个是支持优先级的, 并且可以支持多达10个, 它没有定义 “没有优先级属性的消息该如何被处理”;</p></li><li><p>与AMQP 0-9-1规格相比, 默认情况下, RabbitMQ队列不支持优先级, 在创建优先级队列时, 您可以根据需要指定任意数量的优先级别, 不过需要注意:<br>队列的每个优先级会有一些 内存 和 磁盘 方面的成本, 还会有额外的CPU成本, 特别是在消费时, 所以你可能不希望创建大量的优先级别;</p></li><li><p>消息的 <code>priority</code> 字段被定义为无符号字节, 所以实际上优先级应该在0到255之间;<br>没有 <code>priority</code> 属性的消息被视为优先级为0, 优先级高于队列最大值的消息被视为以最高优先级发布;</p></li><li><p>资源使用注意事项<br><strong>如果需要优先级队列, 建议使用1到10之间的级别, 目前使用更多优先级将消耗更多资源(Erlang进程)</strong>;</p></li><li><p>与消费者互动<br>理解消费者在处理优先级队列时的工作方式非常重要, 默认情况下, 消费者在做任何应答之前, 可能已经被发送了大量的消息;<br>因此, 如果一个饥饿的消费者连接一个消息稍后才会被发布到的空队列, 这样, <strong>消息可能不会在队列中等待任何时间, 在这种情况下, 优先队列将不会有机会对它们做优先级</strong>;<br>在大多数情况下, 你会希望在消费者手动确认模式下使用 <code>basic.qos</code>, 以限制可以随时发送的消息数量, 从而允许优先化消息;</p></li><li><p>其他功能的互动<br>通常, 优先级队列具有标准RabbitMQ队列的所有功能: 它们支持持久性, 分页, 镜像等; 有几点需要注意的互动:<br>应该过期的消息仍然只会从队列的头部过期, 这些消息将永远不会传递, 但它们将显示在队列统计信息中;<br>设置了 <code>max-length</code> 的Queues, 通常情况下, 将从队列头部丢弃消息以强制执行限制, 这意味着<strong>可能会丢弃更高优先级的消息, 为低优先级的消息让路</strong>, 这可能不是你所期望的;</p></li><li><p>为什么 策略 定义是不可能的<br>为队列定义可选参数最方便的方法是通过策略, 策略是配置队列长度限制, TTL等的推荐方式;<br>但是, 策略不能用于配置优先级, 因为策略是动态的, 并且可以在声明队列后进行更改, 优先级队列在队列声明之后永远不会改变它们支持的优先级的数量, 因此策略不是一个安全的选项;</p></li></ul></li><li><p>Rabbit中的消息可以按 <strong>发送顺序</strong>, <strong>优先级高低</strong> 被依次消费</p><ul><li>默认不设置 队列,消息 优先级 的情况下, 如果只有一个消费者, 消息会按照其发送顺序被依次消费</li><li>如果设置了 队列,消息 优先级, 如果只有一个消费者, 消息会按照 <code>全部按照发送顺序</code>, <code>发送顺序+优先级顺序</code>, <code>全部按照优先级顺序</code> 3种顺序依次被消费;<br>下面会有案例展示;</li></ul></li><li><p>要想使用优先级, 需要使用 队列的 $arguments的 <code>x-max-priority</code> 选项 和 消息的 $arguments的 <code>priority</code> 选项;</p></li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>当有多个consumer时, 是无法保证消息按发送顺序或者优先级顺序被消费的, 因为每个consumer视自身能力, 都有自己的消费速度, 而且也不一定稳定;</p><ol><li><p>当queue只有一个consumer时, 如果producer先发送msg到queue, 然后再启动consumer, 此时和consumer的Qos是否设置或者设置大小无关, msg会按照优先级由高到低依次输出 (不会按照producer的发送顺序输出)<br> 像之前译文中 <code>与消费者互动</code> 中提到的, 这是因为 msg 有足够的时间(消费者启动后连接到server的时间), 在Rabbit Server中按照优先级做好排序;</p></li><li><p>当queue只有一个consumer时, 如果先启动consumer, 然后producer再发送msg到queue</p><ul><li><p>如果没有设置Qos, 即便consumer处理每条消息的速度很慢, 但是由于运行producer之后, 消息会在第一时间被尽可能全量发送到consumer, 所以queue中貌似没什么时间对msg按照优先级进行排序, 所以consumer拿到的msg只是按照发送顺序排列的消息;<br>先启动consumer的情况下, 消费者是处于饥饿状态;</p></li><li><p>如果设置了Qos的prefetch_count=1, 先启动consumer:<br>理论上, 第一个msg是按照发送顺序, 但是之后的9个msg都会按照优先级顺序;<br>但实际测试发现, 有时候msg还会全部按照优先级顺序来, 这是个比较疑惑的问题, 后来通过观察WebUI管理界面可以发现, 在启动消费者之后, 并不一定队列可以立马识别到该consumer (因为队列的 Consumers 这列显示还是0), 如果你此时运行了producer, 那么相当于先运行了producer, 然后再启动了消费者, 所以msg将会全部按照优先级循序被消费; 所以要为了确保消费者被先启动, 最好确保队列的Consumers这列显示为1, 表示消费者已经连接上来了;<br>并且即使你prefetch_count=1的同时设置了 sleep(5), 还是会出现上面的问题(也是由于虽然你先执行了consumer, 但其实producer先被执行的原因)! </p></li><li><p>如果设置了Qos, 但是设置的prefetch_count&gt;1(比如为2)<br>理论上也是前两个msg按照发送顺序, 而后面8个按照优先级顺序;<br>实际测试发现, 如果出现上面的意外, 也会导致10条消息全部按照优先级顺序被消费;</p></li></ul></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>先运行生产者生产消息, 然后再启动消费者, 消息会有时间按照优先级在queue中做好排序, 然后发送给消费者; (这种条件类似消费能力不足的情况, 类似于consumer消费过慢并产生很多unack, 导致queue中的msg有时间按照优先级排序)</p></li><li><p>先启动消费者, 然后运行生产者生产消息, 消息会根据消费者设置的Qos, 优先会有prefetch_count数量的消费者被直接发送到consumer, 这些msg会按照发送先后顺序被消费, 之后的剩余消费者则会按照优先级顺序被消费; </p></li><li><p>总之, 消息想要按照设置的优先级别来被消费, 在将消息发出去之前, Server必须有足够的时间对Queue中的消息按照优先级高低做好排序;    </p></li><li><p>所以消息优先级貌似对应用场景比较苛刻(消费者貌似要唯一, 而且需要消费者阻塞产生unacked之后, server中的消息貌似才有时间排序), 所以这个优先级感觉挺鸡肋, 如果需要消息有顺序, 还不如就 保证消费者唯一, 然后按照发送顺序消费即可! </p></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li><p>针对上面的分析进行测试</p><ul><li>在生产者中准备好10条优先级为0-10的消息, 然后乱序发送, 代码参考<a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Http/Controllers/Demo/MsgPriorityController.php" target="_blank" rel="external">此处</a></li><li><p>消费者使用三种Qos做测试 1. 默认Qos, 不做限制 2. Qos设置为1, 3. Qos设置为2, 代码参考<a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Console/Commands/msgPriorityConsumer.php" target="_blank" rel="external">此处</a></p></li><li><p>先运行生产者, 然后启动消费者, 会发现乱序的消息会按照优先级高低依次输出</p></li><li>而如果先启动消费者, 之后再运行生产者, 你会发现, 由于会有prefetch_count的msg被发送给消费者, 所以这部分消息会按照发送先后顺序被消费, 而其余消息会按照优先级高低依次输出;<br>如果没有设置Qos, 或者Qos设置的数量大于消息条数, 那么msg都会按照发送的先后顺序被消费, 不会按照优先级顺序被消费;</li></ul></li><li><p>如果消息设置了选项 <code>priority</code>, 而队列没有设置 <code>x-max-priority</code>, 效果会怎样?</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:Rabbit renyimin$ php artisan msgPriorityConsumer</div><div class="line"></div><div class="line">In AMQPChannel.php line 188:</div><div class="line">                                                                                                                                                                     </div><div class="line">PRECONDITION_FAILED - inequivalent arg &apos;x-max-priority&apos; for queue &apos;msgPrioityQueue&apos; in vhost &apos;/&apos;: received none but current is the value &apos;10&apos; of type &apos;signedint&apos;  </div><div class="line">                                                                                                                                                                     </div><div class="line">renyimindeMacBook-Pro:Rabbit renyimin$</div></pre></td></tr></table></figure></li><li><p>队列设置了优先级选项 <code>x-max-priority</code>, 如果消息不设置优先级选项 <code>priority</code>, 效果会怎样?<br> 无论设置适当的Qos先启动消费者, 还是先运行生产者生产消息, msg都是按照发送顺序被消费的!</p></li><li><p>如果有多个消费者, 消息被发送给不同的消费者, 这样还会按照优先级顺序进行么?<br> 多个消费者是无法保证Msg被消费的顺序的;</p></li><li><p>集群模式下, 发送顺序和优先级顺序如何保证?<br> ~~ 待续</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Priority-Queues&quot;&gt;&lt;a href=&quot;#Priority-Queues&quot; class=&quot;headerlink&quot; title=&quot;Priority Queues&quot;&gt;&lt;/a&gt;Priority Queues&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;官网文档: &lt;a 
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>21. Consumer Priorities 消费者优先级</title>
    <link href="http://blog.renyimin.com/2018/06/15/rabbitmq/2018-06-15-rabbitmq-21/"/>
    <id>http://blog.renyimin.com/2018/06/15/rabbitmq/2018-06-15-rabbitmq-21/</id>
    <published>2018-06-15T05:04:26.000Z</published>
    <updated>2018-06-20T04:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Consumer-Priorities"><a href="#Consumer-Priorities" class="headerlink" title="Consumer Priorities"></a><a href="https://www.rabbitmq.com/consumer-priority.html" target="_blank" rel="external">Consumer Priorities</a></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li><p>消费者优先级允许你确保高优先级的消费者在活跃时接收消息, 并且消息只有在高优先级消费者阻塞时才会转向低优先级的消费者;</p></li><li><p>通常, 连接到队列的活跃消费者, 是以循环方式接收来自它的消息; 当使用 “消费者优先级” 时, 如果存在多个活跃的消费者具有相同的高优先级, 消息也会被循环传送给它们;</p></li></ol><h3 id="定义活跃消费者"><a href="#定义活跃消费者" class="headerlink" title="定义活跃消费者"></a>定义活跃消费者</h3><ol><li><p>活跃的消费者是可以无需等待就能收到消息的消费者. 假如一个消费者无法接收消息, 它就会变成阻塞状态: 因为它的 channel 在发布 basic.qos 之后已达到 unack消息的最大数量, 或者仅仅是因为网络拥塞;</p></li><li><p>当消费者的 “优先级” 被使用时, 你可以期望你的最高优先级的消费者接收所有的消息, <strong>直到它们被阻塞</strong>, 然后较低优先级的消费者才将开始接收一些消息;</p></li><li><p>理解RabbitMQ仍然会优先传递消息是很重要的: 如果有一个活跃着的低优先级消费者已经准备好了, Rabbitmq是不会等待高优先级的阻塞消费者变成非阻塞的(它会将消息发送给已经准备好的低优先级的活跃消费者);</p></li></ol><h3 id="使用消费者-优先级别"><a href="#使用消费者-优先级别" class="headerlink" title="使用消费者 优先级别"></a>使用消费者 优先级别</h3><ol><li><p>将 <code>basic.consume()</code> 方法中的 <code>$arguments</code> 参数的 <code>x-priority</code> 属性设置为整数值, 未指定值的消费者优先级为0, 更大的数字表示更高的优先级, 并且可以使用正数和负数;</p></li><li><p>注意事项: </p><ul><li><p>多个消费者共同绑定同一个队列时, 可以给消费者设置优先级, 这样, 优先级高的消费者会优先拿到消息并进行处理, <strong>除非优先级高的都处于阻塞状态(unack达到Qos设置的上限值)</strong>, 否则优先级低的消费者不会拿到消息;<br>通过运行下面示例(没有设置Qos时)可以发现, 同时启动两个消费者, 然后刷新生产者, 会发现在高优先级的消费者在默认不设置Qos时, 即不阻塞的情况下, 低优先级消费者一条消息也不会收到(没有消费结果);</p></li><li><p>接下来可以模拟高优先级的Consumer阻塞, 会发现, 高优先级的Consumer在拿到第一条消息之后, 优先级低的Consumer会立刻开始进行处理<br>注意, 模拟消费者阻塞时, 不能只通过比如 <code>sleep(50)</code> 这种方式, 因为这样只是消费者的处理速度变慢, 但是<strong>消费者的预取量还是默认的(即不受限制)</strong>, 所以消息还是会被发送给优先级高的消费者, 这样造成的结果就是 优先级高的消费者一直在缓慢地消费, 而优先级低的消费者一直在闲置;<br>所以还需要给优先级高的消费者设定 <code>Qos=1</code> 来进行测试(设定为1是为了测试方便, 也可以设置其他值, 不过这样的话, 就会有qos所设置的数量的消息被优先推送给高优先级的consumer, 直到达到qos量之后才会阻塞), 这样才能使得优先级高的消费者在没有急时ack的情况下被阻塞, 从而让优先级低的Consumer进行消费<br>实例运行(刷新生产者10次尝试一下)可以发现, 高优先级的消费者在拿到第一条消息后, 后面的消息都给了 低优先级的消费者, 但随着高优先级的消费者进行ack而恢复活跃状态, 又会优先拿到消息</p></li></ul></li><li><p>示例可查看: </p><ul><li><a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Http/Controllers/Demo/TestPriorityConsumerController.php" target="_blank" rel="external">生产者 TestPriorityConsumerController.php </a>    </li><li><a href="https://github.com/rymuscle/Laravel-RabbitMQ/tree/master/app/Console/Commands" target="_blank" rel="external">消费者 priorityConsumer1.php, priorityConsumer2.php</a></li></ul></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><a href="https://www.rabbitmq.com/blog/2013/12/16/using-consumer-priorities-with-rabbitmq/" target="_blank" rel="external">https://www.rabbitmq.com/blog/2013/12/16/using-consumer-priorities-with-rabbitmq/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Consumer-Priorities&quot;&gt;&lt;a href=&quot;#Consumer-Priorities&quot; class=&quot;headerlink&quot; title=&quot;Consumer Priorities&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.rabbitmq
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>20. 消费者预取 Consumer Prefetch</title>
    <link href="http://blog.renyimin.com/2018/06/13/rabbitmq/2018-06-13-rabbitmq-20/"/>
    <id>http://blog.renyimin.com/2018/06/13/rabbitmq/2018-06-13-rabbitmq-20/</id>
    <published>2018-06-13T11:23:36.000Z</published>
    <updated>2018-06-21T07:33:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Consumer-Prefetch"><a href="#Consumer-Prefetch" class="headerlink" title="Consumer Prefetch"></a>Consumer Prefetch</h2><p>1.官方文档: <a href="https://www.rabbitmq.com/consumer-prefetch.html" target="_blank" rel="external">https://www.rabbitmq.com/consumer-prefetch.html</a></p><p>2.译文:<br>限制 unack 消息数量的更自然有效的方法;<br>AMQP 0-9-1 指定了 basic.qos 方法, 以便你在消费者进行消费时, 可以限制channel(或connection)上未确认消息的数量; </p><p>不幸的是, channel 并不是理想的范围 - 因为单个channel可能从多个队列进行消费, channel和queue需要为每个发送的消息相互协调, 以确保它们不会超出限制, 这在单台机器上会慢, 而在整个集群中使用时会非常慢;<br>此外, 对于许多用途, 指定<strong>适用于每个消费者的预取计数</strong>更会简单一些;</p><p>因此, RabbitMQ在basic.qos方法中重新定义了<strong>全局标志</strong>的含义 (在php-amqplib中basic_qos()的第三个参数a_global):</p><table><thead><tr><th>global</th><th style="text-align:right">Meaning of prefetch_count in AMQP 0-9-1</th><th style="text-align:center">Meaning of prefetch_count in RabbitMQ</th></tr></thead><tbody><tr><td>false</td><td style="text-align:right">shared across all consumers on the channel(在channel中的所有消费者中分享)</td><td style="text-align:center">applied separately to each new consumer on the channel(在频道上分别应用于每个新消费者)</td></tr><tr><td>true</td><td style="text-align:right">shared across all consumers on the connection(在连接上的所有消费者中共享)</td><td style="text-align:center">shared across all consumers on the channel(在渠道中的所有消费者中分享)</td></tr></tbody></table><p>请注意, 在大多数API中, 全局标志的默认值为false; (php-amqplib的basic_qos()方法的第三个参数a_global参数需要手动设置为false)</p><p>官网中有关于Java的相关示例可以参考;</p><h2 id="简要分析"><a href="#简要分析" class="headerlink" title="简要分析"></a>简要分析</h2><ol><li><p>在使用RabbitMQ时, 如果完全不配置QoS, RabbitMQ会将队列中的所有消息轮发到与队列绑定的consumers端; 而consumer会在本地缓存所有的message, 这样的话, 如果某个消费者的业务逻辑处理比较复杂, 那么将会在较长时间之后才会操作完成并ack;</p><ul><li>如果RabbitMQ并不考虑Consumer端的感受, 而采用默认的轮发方式, 消费慢的Consumer将会在本地堆积很多消息, 从而导致内存不足或者对其他进程造成影响;</li></ul></li><li><p>只有在手动ack的时候会生效 (prefetch_count在no_ask=false的情况下生效，在自动应答的情况下这两个值是不生效的)</p></li><li><p>你在Rabbit有一个队列, 然后一些消费者从这个队列中消费, 如果你根本没有设置QoS(basic.qos), 那么Rabbit会把所有的队列消息都按照网络和客户端允许的速度推送给客户端, 消费者将会飞速增加它们的内存占用, 因为它们将所有消息都缓存在自己的RAM中</p><ul><li>如果您添加新的消费者, 队列中也不会有消息发送给新的消费者;<br>即使有其他消费者可用于更快地处理这样的消息, 但由于消息已经被现有的客户端缓存，并且可能在那里很长一段时间</li><li>这种方式是相当次优的</li></ul></li></ol><h2 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h2><ol><li><p>本测试比较简单, 主要测试在默认不设置Qos的情况下, 两个不同消费能力的消费者(比如机器配置有差异)在处理时, 消费能力高的消费者可能很快消费完消息并处于闲置状态, 而消费能力低的消费者却在很慢地进行消费, <strong>这样就造成了限制资源的浪费</strong></p><ul><li>创建消费者1 ‘testQosCustomer1’ (简单打印消息内容) , 代码参考, <a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Console/Commands/testQosConsumer1.php" target="_blank" rel="external">此处</a>, <strong>启动消费者</strong> <code>php artisan testQosConsumer1</code></li><li>创建消费者1 ‘testQosCustomer2’ (sleep 5秒, 模拟处理能力比较差) , 代码参考, <a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Console/Commands/testQosConsumer2.php" target="_blank" rel="external">此处</a>, <strong>启动消费者</strong>  <code>php artisan testQosConsumer1</code></li><li>创建一个生产者 ‘testQosProducer’, 一次向队列 ‘qosTestQueue’ 中推送10条消息 , 代码参考, <a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Http/Controllers/Demo/TestQosController.php" target="_blank" rel="external">此处</a>, <strong>请求一次生产者</strong> <a href="http://www.rabbit.com/testQos" target="_blank" rel="external">http://www.rabbit.com/testQos</a></li><li>注意需要先启动消费者, 再请求生产者; (如果先请求了生产者, 可能在启动第一个消费者之后, 其会迅速消费完10条消息, 这样就无法模拟效果了)</li></ul></li><li><p>测试发现</p><ul><li>testQosCustomer1 : 迅速打印出结果(1,3,5,7,9), 然后就处于闲置状态了</li><li>testQosCustomer2 : 还在缓慢打印(2,4,6,8,10)</li></ul></li><li><p>所以: 为了避免这种浪费资源的情况, 你可能就需要根据上一篇讲解的 prefetch_count 来针对不同消费者进行设置; (当然, 一般如果, 消费者都在同一台机器的话, 而且处理同一个业务, 消费能力不会差异太大, 但仍需要根据网络和处理能力给消费者设置合理的prefetch_count)</p></li></ol><h2 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h2><ol><li><p>根据上面的描述, 有如下疑问 </p><ul><li>在默认模式下, 这难道意味着, 生产者发布的消息会尽可能全部推送给消费者进程, 队列中会尽可能将消息全部推出? 全部缓存在消费者本地? 那当消费者断开时, 消息是如何恢复到队列中的? 或者不会恢复到队列中?<br>为了答疑, 下面进行测试 </li></ul></li><li><p>准备测试代码</p><ul><li>创建消费者1 ‘testQosConsumerPrefetchCount1’ (sleep 5秒, 模拟耗时业务需求; prefetch=100; 简单输出消息), 代码参考, <a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Console/Commands/testQosConsumerPrefetchCount1.php" target="_blank" rel="external">此处</a></li><li>创建消费者1 ‘testQosConsumerPrefetchCount2’ (sleep 5秒, 模拟耗时业务需求; prefetch=100; 简单输出消息), 代码参考, <a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Console/Commands/testQosConsumerPrefetchCount2.php" target="_blank" rel="external">此处</a></li><li>使用之前测试的生产者 ‘testQosProducer’, 一次向队列 ‘qosTestQueue’ 中推送100条消息 , 代码参考, <a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Http/Controllers/Demo/TestQosController.php" target="_blank" rel="external">此处</a></li></ul></li><li><p>运行实例:</p><ul><li>请求一次生产者 <a href="http://www.rabbit.com/testQos" target="_blank" rel="external">http://www.rabbit.com/testQos</a></li><li>启动消费者1 <code>php artisan testQosConsumerPrefetchCount1</code></li></ul></li><li><p>测试效果:</p><ul><li>在运行生产者之后, <code>ready : 100, unack: 0, total : 100</code>, 表示队列中已经有100条消息已经就绪, 等待发出<br><img src="/img/rabbitmq/qos-test01.png" width="450"></li><li>运行第一个<code>php artisan testQosConsumerPrefetchCount1</code>之后, <code>ready : 0, unack : 100, total : 100</code> (也就是说, queue中已经没有 ready状态, 即准备好待发送的消息了, 消息都传递给消费者1了)<br><img src="/img/rabbitmq/qos-test02.png" width="450"></li><li><p>随着消费者的缓慢消费, <code>ready : 0, unack : 97, total : 97</code>  ()<br><img src="/img/rabbitmq/qos-test03.png" width="450"></p></li><li><p>如果模拟 挂掉第一个消费者之后, 会发现, <code>ready : 88， unack : 0, total : 88</code> (<strong>也就是说消费者意外宕掉之后, 队列中的消息会重新处于就绪状态</strong>, 等待着新的消费者来消费)<br><img src="/img/rabbitmq/qos-test03.png" width="450"></p></li><li><p>再次启动消费者2 <code>php artisan testQosConsumerPrefetchCount2</code>之后, <code>ready : 0, unack : 88, total : 88</code> (消息又会被全量发送给消费者2)</p><p>注意: 如果此时启动消费者1, 你会发现, 它是无法帮助消费者1进行消费的, 因为它还活着, 并且消息都在消费者2的本地, 所以队列中是没有 ready状态的就绪消息的;</p></li></ul></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>消费者的unack消息数量如果未达到, Qos设置的 prefetch_count 量, <strong>Rabbit不会顾及消费者的消费能力, 会尽可能将queue中的消息全部推送出去给消费者</strong>;</p></li><li><p>因此, 当你发现消费者消费缓慢, 产生大量 unack 消息时, 即便增加新的消费者, 也无法帮助之前的消费者分担消息(除非消费者1的 unack达到了 prefetch_count 限制), 并且队列中此时并无 ready 状态的消息;</p></li><li><p>除非你断开之前的消费者, 然后启动一个新的消费者, 它才会重新开始处理 (因为之前的消费者挂掉之后, 其处理后的剩余消息在 queue中会恢复为 ready 状态)<br> 但是注意: 新启动的这个消费者如果设置额prefetch_count不合理的话, 假设与之前消费者的 预取值 设置一样大, 它很快也会产生大量 unack 消息<br> 所以, 在新启消费者的时候, 需要设计好 prefetch_count 的大小, 然后可以启动多个消费者来共同进行消费;</p></li><li><p>RabbitMQ服务器会在短时间内发送大量的消息给Consumer，而消费者处理能力有限, 没有来得及Ack的话, 那么服务端会积压大量的UnAcked消息, 而Consumer也可能会处于假死(可能引起程序崩溃);</p></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li><p>rabbitmq对basic.qos信令的处理</p><ul><li>首先, basic.qos 是针对channel进行设置的, 也就是说只有在channel建立之后才能发送basic.qos信令; RabbitMQ只支持通道级的预取计数, 而不是connection级的 或者 基于大小的预取;<br><a href="http://www.bubuko.com/infodetail-1955647.html" target="_blank" rel="external">预取</a></li><li>在rabbitmq的实现中, 每个channel都对应会有一个rabbit_limiter进程, 当收到basic.qos信令后, 在rabbit_limiter进程中记录信令中prefetch_count的值, 同时记录的还有该channel未ack的消息个数;</li></ul></li><li><p>在<code>php-amqplib</code>中, 可以使用信道的 <code>basic_qos()</code> 来进行控制, <code>basic_qos()</code> 有三个参数:</p><ul><li>prefetch_size : 限制预取的消息大小的参数, rabbitmq暂时没有实现 (如果prefetch_size字段不是默认值0, 则会通知客户端出错, 通知客户端<strong>RabbitMQ系统没有实现该参数的功能</strong>, 还可以参考<a href="https://github.com/sky-big/RabbitMQ/blob/d7a773e11f93fcde4497c764c9fa185aad049ce2/src/rabbit_channel.erl" target="_blank" rel="external">此文</a>)<br>当你设置prefetch_size大于0的时候, 会出现如下报错<br><img src="/img/rabbitmq/qos-prefetch-size-error.png" width="400"></li><li>prefetch_count : 预取消息数量</li><li>global, 但是RabbitMQ没有实现prefetch_size, 并在3.3.0版本中对global这个参数的含义进行了重新定义, 即glotal=true时表示在当前channel上所有的consumer都生效, 否则只对设置了之后新建的consumer生效;</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Consumer-Prefetch&quot;&gt;&lt;a href=&quot;#Consumer-Prefetch&quot; class=&quot;headerlink&quot; title=&quot;Consumer Prefetch&quot;&gt;&lt;/a&gt;Consumer Prefetch&lt;/h2&gt;&lt;p&gt;1.官方文档: &lt;a
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>11. Dead Letter Exchanges 死信交换机</title>
    <link href="http://blog.renyimin.com/2018/06/12/rabbitmq/2018-06-07-rabbitmq-11/"/>
    <id>http://blog.renyimin.com/2018/06/12/rabbitmq/2018-06-07-rabbitmq-11/</id>
    <published>2018-06-12T06:36:51.000Z</published>
    <updated>2018-06-30T05:50:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于死信"><a href="#关于死信" class="headerlink" title="关于死信"></a>关于死信</h2><ol><li><p>官网文档: <a href="https://www.rabbitmq.com/dlx.html" target="_blank" rel="external">https://www.rabbitmq.com/dlx.html</a></p></li><li><p>译文 (死信貌似是个动词)</p><ul><li><p>来自队列的消息可能被 “死信”, 即, 在如下任何事件发生的情况下, 消息被重新发布到另一个Exchange:<br>该消息被拒绝(<code>basic.reject</code> 或 <code>basic.nack</code> ), 其中 <code>requeue = false</code><br>消息的TTL过期<br>要么队列长度限制已超出</p></li><li><p>死信Exchange(DLX)其实也是标准的Exchange, 它们可以是任何常见的type, 并且可以像通常那样进行声明;</p></li><li><p>对于任何给定的队列, 客户端可以使用 <strong>队列的$arguments</strong> 或 在服务器中使用<strong>策略</strong> 来定义DLX; 在 策略 和 $arguments 都指定的情况下, $arguments 将覆盖 策略!</p></li><li><p>使用 队列的 $arguments 配置 DLX<br>要为队列设置死信交换, 需要设置队列 <code>$arguments</code> 参数的 <code>x-dead-letter-exchange</code> 选项为交换机的名称:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$channel-&gt;exchange_declare(&apos;testDlxExchange&apos;, &apos;direct&apos;, false, true, false, false, false);</div><div class="line">$arguments = new AMQPTable([</div><div class="line">    // 指定死信交换机</div><div class="line">    &apos;x-dead-letter-exchange&apos; =&gt; &apos;testDlxExchange&apos;,</div><div class="line">    // 指定死信路由键</div><div class="line">    &apos;x-dead-letter-routing-key&apos; =&gt; &apos;testDlxRoutingKey&apos;</div><div class="line">]);</div><div class="line">$channel-&gt;queue_declare(&apos;testDlxQueue&apos;, false, true, false, false, false, $arguments);</div></pre></td></tr></table></figure><p>上面的代码声明了一个名为 <code>testDlxExchange</code> 的Exchange, 并将这个新Exchange设置为新创建的队列的 <strong>死信Exchange</strong>;<br><strong>请注意</strong>: 在声明queue时不必声明exchange, 但是在消息需要被死信时它应该存在, 如果它不存在, 那么这些消息将被无声地丢弃;<br>想上面那样, 你也可以指定一个routingkey, 以便在死信消息时使用, 如果没有设置, 则会使用消息自己的routingkey</p></li><li><p>当一个死信exchange被指定时, 除了声明队列上的通常配置权限之外, 用户还需要对该队列具有读权限, 并对死信exchange有写入权限, 权限在队列声明时被验证</p></li><li><p>使用<code>策略</code>配置DLX可参考<a href="https://www.rabbitmq.com/dlx.html" target="_blank" rel="external">官网文档</a></p></li><li><p>路由死信消息<br>死信的消息被路由到他们的死信exchange: 可以使用它们所在的队列所指定的routingkey 或者 如果队列没有设置routingkey, 则使用最初发布的routingkey; ??<br>例如:<br>假如你使用 <code>routingkey=foo</code> 将消息发布到交换机, 然后该消息被 dead-lettered, 它将被发布到routingkey为 <code>foo</code> 的 死信exchange;<br>而如果消息最初着陆的队列已声明了 <code>x-dead-letter-routing-key=bar</code>, 则该消息将被发布到它的(routingkey为 “bar”)死信exchange;<br>???<br>请注: 如果没有为该队列设置特定的routingkey, 则其上的消息将用其原始routingkey被dead-lettered, 这包括由CC和BCC标题添加的路由键(有关这两个标题的详细信息，请参阅发件人选择的发行版)<br>死信消息重新发布，发布者确认已在内部启用，因此消息最终着陆的“死信队列”（DLX路由目标）必须在消息从原始队列中删除之前确认消息。换句话说，“发布”（邮件过期的队列）队列不会在死信队列确认接收邮件之前删除邮件（请参阅确认以了解有关所做保证的详细信息）。请注意，如果代理程序不正常关闭，则可能会在原始队列和死文字目标队列上复制相同的消息。<br>有可能形成消息死书的循环。例如，当一个队列在没有指定死信路由密钥的情况下将消息发送到默认交换机时，会发生这种情况。如果在整个周期内没有拒绝，这些周期中的消息（即达到相同队列两次的消息）将被丢弃。</p></li><li><p>Dead-Lettered Messages<br>死信被re-publish后, 会在消息的header中增加一个叫做<code>x-death</code>的数组内容, 包含了以下字段内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">queue 消息被重新路由前所在的queue的名称</div><div class="line">reason 消息成为死信的原因，有如下几种: 消息被拒绝并且requeue=false, message的TTL过期, 超过了queue允许的最大消息长度</div><div class="line">time 消息成为死信的日期时间</div><div class="line">exchange 消息被重新路由到exchange的名称</div><div class="line">routing-keys 消息被发布时的 routing-keys</div><div class="line">original-expiration 消息的原始expiration属性</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><a href="https://www.cnblogs.com/wei-feng/p/6599419.html" target="_blank" rel="external">常见问题</a></li><li>如果queue既设置了 <code>x-dead-letter-exchange</code>, 也设置了 <code>routingKey</code>, 那么消息会如何路由?<br> <a href="https://www.cnblogs.com/williamwsj/p/8108970.html" target="_blank" rel="external">https://www.cnblogs.com/williamwsj/p/8108970.html</a> 可以设置消息的存活时间;</li></ol><p>## </p><p><a href="https://my.oschina.net/u/3015099/blog/781970" target="_blank" rel="external">https://my.oschina.net/u/3015099/blog/781970</a></p><p><a href="https://blog.csdn.net/qq_29778131/article/details/52536965" target="_blank" rel="external">https://blog.csdn.net/qq_29778131/article/details/52536965</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于死信&quot;&gt;&lt;a href=&quot;#关于死信&quot; class=&quot;headerlink&quot; title=&quot;关于死信&quot;&gt;&lt;/a&gt;关于死信&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;官网文档: &lt;a href=&quot;https://www.rabbitmq.com/dlx.html&quot; tar
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>19. 消费者预取 Consumer Prefetch - RabbitMQ关于 吞吐量, 延迟 和 带宽 的一些理论</title>
    <link href="http://blog.renyimin.com/2018/06/12/rabbitmq/2018-06-12-rabbitmq-19/"/>
    <id>http://blog.renyimin.com/2018/06/12/rabbitmq/2018-06-12-rabbitmq-19/</id>
    <published>2018-06-12T03:26:55.000Z</published>
    <updated>2018-06-30T05:51:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ关于吞吐量-延迟和带宽的一些理论"><a href="#RabbitMQ关于吞吐量-延迟和带宽的一些理论" class="headerlink" title="RabbitMQ关于吞吐量,延迟和带宽的一些理论"></a><a href="https://www.rabbitmq.com/blog/2012/05/11/some-queuing-theory-throughput-latency-and-bandwidth/" target="_blank" rel="external">RabbitMQ关于吞吐量,延迟和带宽的一些理论</a></h2><ol><li><p>译文: 网上虽然有很多版本的译文, 在此处还是重新做了翻译</p><ul><li><p>你在Rabbit中有一个队列, 然后有一些客户端从这个队列中进行消费;<br>如果你根本没有设置QoS(basic.qos), 那么Rabbit将尽可能快地按照网络和客户端允许的速度将所有队列的消息推送到客户端; 因此, 消费者所占用的内存将会激增, 因为它们将所有消息都缓存在自己的RAM中;<br>同时, 值得注意的是: 此时如果你询问Rabbit, <strong>队列可能会显示为空</strong>, 但是会有大量的未确认消息在客户端中, 准备被客户端应用程序处理;<br>并且此时如果你添加新的消费者, 由于没有消息留在队列中, 所以队列也无法将消息发送给新的消费者的;<br>尽管有其他消费者可用于更快地处理消息, 但由于消息已经在现有的客户端中缓存, 并且可能在那里很长一段时间, 所以这是相当次优的!</p></li><li><p>所以，默认的QoS预取给客户端(consumer)设置了无限的缓冲区, 这可能导致不良的行为和性能; 那么, 应该将QoS预取缓冲区大小设置为多少呢?<br>目标是让消费者保持工作饱和状态, <strong>但要尽量减少客户端的缓冲区大小, 以便让更多的消息保留在Rabbit的队列中, 这样就可以供新消费者来消费</strong>;</p></li><li><p>比方说, Rabbit从这个队列中拿出一条消息, 把它放到网络上，然后到达消费者, 需要50ms; 客户端处理消息需要4ms;<br>一旦消费者处理了消息, 它就会发送一个ack给Rabbit, 这将再次花费50ms发送给Rabbit并被Rabbit进行处理; 所以我们总共有104ms的往返时间。<br>如果我们消息设置了QoS预取值为1, 那么直到这个往返行程完成之前, Rabbit是不会发送下一个消息给客户端的;<br>因此, <strong>每次往返的104ms中, 客户端只有4ms,或者说只有3.8％的时间忙碌, 而我们希望百分之百的时间都在忙碌中</strong>;</p></li><li><p>如果我们在每个消息的客户端上执行 <code>总的往返时间/处理时间</code>, 会得到 <code>104/4 = 26</code><br>如果我们设置消息的QoS预取值为26, 那就解决了我们的问题: 假设客户端具有26个消息缓冲, 等待处理<br>(这是一个明智的假设:<br>一旦你设置了basic.qos, 然后从一个队列中进行消费, Rabbit将会尽可能多的将消息发送到你订阅该队列的客户端中, 直到QoS的限制;</p></li><li><p>如果你认为消息不是很大, 带宽也很高, 那么Rabbit很可能更快地发送消息到你的客户端, 因此, 从完整的客户端缓冲区的角度来做所有的数学运算是合理的(也更简单的)</p></li><li><p>如果每条消息需要4ms的处理来处理, 那么总共需要 <code>26×4 = 104ms</code> 来处理整个缓冲区(中的消息);<br>第一个4ms是第一个消息的客户端处理消息的时间, 处理完成后, 客户端然后发出一个确认(这一点需要50ms才能到达代理), 然后继续处理缓冲区中的下一条消息, 代理向客户端发出一条新消息, 这需要50ms的时间, 所以到了104ms时间, 客户端已经完成缓冲区的处理, 代理的下一条消息已经到达, 并准备好等待客户端来处理它;<br>因此, 客户端始终处于忙碌状态: 具有较大的QoS预取值也不会使其更快了, 但是我们最大限度地减少了缓冲区的大小, 并且减少了客户端消息的延迟; 事实上, <strong>客户端能够在下一条消息到达之前完全排空缓冲区, 因此缓冲区实际上保持为空</strong>;</p></li><li><p>如果处理时间和网络行为保持不变, 此解决方案绝对没问题<br>但考虑一下如果网络突然间速度减半会发生什么情况(rymuscle:显然, <strong>网络传输时间就加长了</strong>): 此时你的预取缓冲区(也就是你设置的prefetch预取值)就不够大了, 现在客户端会就会闲置, 等待新消息到达, 因为客户端能够处理消息的速度比Rabbit能够提供新消息的速度要快;</p></li><li><p>为了解决这个问题, 我们可能会决定将QoS预取大小加倍(或接近两倍), 如果我们从26开始将它推到51, 那么如果客户端处理保持在每个消息4ms, 我们现在在缓冲区中会有51 <em> 4 = 204ms的消息处理时间, 其中4ms将用于处理消息, 而200ms用于发送消息回复rabbit并收到下一条消息, 因此, 我们现在可以应对网络速度的减半;<br>但是, 如果网络正常运行, 现在将QoS预取加倍, 意味着每个消息都会驻留在客户端缓冲区中一段时间​​, 而不是在到达客户端时立即处理;<br>再次分析: 从现在51条消息的完整缓冲区开始, 我们知道新消息将在客户端完成处理第一条消息之后的100ms处开始出现在客户端, 但在这100毫秒内, 客户只能处理100/4 = 25个消息, 这意味着当新消息到达客户端时, 它会在客户端从缓冲区头部移除时被添加到缓冲区的末尾;<br>而缓冲区将始终保持(50 - 25 = 25)个消息长度, 因此每个消息将在缓冲区中保持 25 </em> 4 = 100ms<br><strong>所以有时候你会看到你的消费者虽然活着没有假死, 但是却有大量的unacked!</strong> 可以考虑一下这个原因!!</p></li><li><p>因此, 我们看到, <strong>增加预取缓冲区大小, 以便客户端可以应对恶化的网络性能, 同时保持客户端繁忙, 大大增加网络正常运行时的延迟!!</strong></p></li><li><p>同样, 如果不是网络性能的恶化, 而是客户端开始花费40ms来处理每条消息而不是之前的4ms, 会发生什么情况?<br>假设原始的预取缓冲区大小设置的是26条消息, 客户端现在需要花40ms处理第一条消息, 然后将确认消息发送回Rabbit并移至下一条消息;<br>ack仍然需要50ms才能到达Rabbit, 而Rabbit发出一条新的消息需要50ms, 但在100ms内, 客户端只处理了 100/40 = 2.5 条消息, 而不是剩余的25条消息;<br>因此当新消息到来时, 缓冲区在这一点上仍然是有 25 - 3 = 22 个消息, 这样的话, 来自Rabbit的新消息就不会被立即处理, 而是位于第23位, 落后于其他22条仍在等待处理的消息;<br>客户端(Consumer)将会有 22 * 40 = 880ms 的时间都不会触及到那个新到的消息, 鉴于从Rabbit到客户端的网络延迟仅为50ms, 这个额外的880ms延迟现在为延迟的95％ (880 / (880 + 50) = 0.946);</p><p><strong>当你决定尝试通过添加更多消费者来处理这种增长的积压时, 需要注意, 现在有消息正在被现有客户端缓冲, 并不是说你增加消费者就能缓解这部分的压力!</strong></p></li><li><p>更糟糕的是, 如果我们将缓冲区大小设置为可以预取51条消息以应对网络性能下降,会发生什么?<br>处理第一条消息后, 将在客户端缓冲另外50条消息, 100ms后(假设网络运行正常), 一条新消息将从Rabbit到达客户端, consumer在100ms中只能处理这50条消息中的两条消息(缓冲区现在为47条消息长),<br>因此新消息将会在缓冲区中是第48位, 这样的话, 知道 47 <em> 40 = 1880ms 之后, 消费者才会开始处理新来的消息, 同样, 考虑到向客户端发送消息的网络延迟仅为50ms, 现在这个1880ms的延迟意味着客户端缓冲占延迟的97％(1880/(1880 + 50)= 0.974);<br>这可能是不可接受的: 数据只能在客户端收到后2秒内立即处理, 才能有效且有用！<br><em>*如果其他消费客户端空闲, 他们无能为力</em></em>: 一旦Rabbit向客户端发送消息, 消息就是客户端的责任, 直到他们拒绝或拒绝消息; 消息发送到客户端后，客户端不能窃取彼此的消息;<br>您希望客户端保持繁忙状态, 但客户端尽可能少地缓存消息, 以便客户端缓冲区不会延迟消息, 因此新消费客户端可以快速接收来自Rabbit队列的消息;</p></li><li><p>因此, 如果网络变慢, 缓冲区太小会导致客户端空闲; 但如果网络正常运行, 缓冲区太大会导致大量额外的延迟;<br>如果客户端突然开始花费更长时间来处理每个缓冲区, 则会导致大量额外的延迟;<br>很明显, 你真正想要的是可以变化的缓冲区大小, 这些问题在网络设备中很常见, 并且一直是很多研究的主题;<br>主动队列管理算法试图尝试放弃或拒绝消息，以避免消息长时间处于缓冲区。当缓冲区保持空闲时（每条消息只遭受网络延迟，并且根本不在缓冲区中），缓冲区在那里吸收峰值，从而实现最低延迟。从网络路由器的角度来看，Jim Gettys一直在研究这个问题：局域网和广域网性能之间的差异会遇到完全相同的问题。实际上，无论何时，在生产者（在我们的例子中为Rabbit）和消费者（客户端应用程序逻辑）之间都有一个缓冲区，双方的性能可以动态变化，您将会遇到这些问题。最近发布了一种名为Controlled Delay的新算法，该算法似乎在解决这些问题方面效果很好。</p></li><li><p>…  未完待续</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RabbitMQ关于吞吐量-延迟和带宽的一些理论&quot;&gt;&lt;a href=&quot;#RabbitMQ关于吞吐量-延迟和带宽的一些理论&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ关于吞吐量,延迟和带宽的一些理论&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>13. Queue Length Limit (队列长度限制) - x-max-length, x-max-length-bytes, x-overflow</title>
    <link href="http://blog.renyimin.com/2018/06/09/rabbitmq/2018-06-09-rabbitmq-13/"/>
    <id>http://blog.renyimin.com/2018/06/09/rabbitmq/2018-06-09-rabbitmq-13/</id>
    <published>2018-06-09T07:26:36.000Z</published>
    <updated>2018-06-21T07:36:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><ol><li><p>官方文档: <a href="https://www.rabbitmq.com/maxlength.html" target="_blank" rel="external">https://www.rabbitmq.com/maxlength.html</a></p></li><li><p>译文:</p><ul><li><p>一个队列的最大长度可以通过设置 <code>消息的数量</code> 或者 <code>消息的字节数</code>(所有消息体长度的总和, 忽略消息属性 和 任何杂项开销), 或者两者都设置, 来限制;</p></li><li><p>对于任何给定的队列, 其最大长度(包括以上说的两种类型), 可以使用队列的<code>$arguments</code>参数, 或者在服务器端使用<code>policies策略</code>来进行定义;<br>在 <code>policies策略</code> 和 <code>$arguments</code> 都指定最大长度的情况下, 会应用这两个值中的最小值;</p></li><li><p>在所有情况下, 使用就绪(<code>Ready</code>状态)消息的数量, 未确认的(<code>Unacked</code>)消息不计入限制的数量, 如下简单展示了 queue中的几种消息状态:<br><img src="/img/rabbitmq/queue-length-limit-01.png"><br>从 <code>rabbitmqctl list_queues</code> 中的 <code>messages_ready</code> 和 <code>message_bytes_ready</code> 字段 以及 管理API 会展示受到限制的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl list_queues</div><div class="line">Timeout: 60.0 seconds ...</div><div class="line">Listing queues for vhost / ...</div><div class="line">testQosQueue162</div><div class="line">msgPrioityQueue0</div><div class="line">renyimindeMacBook-Pro:~ renyimin$</div></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- 默认最大队列长度行为当设置最大队列 长度 或 大小 并达到最大值时, RabbitMQ的默认行为是将 队列前面(即队列中最早的消息) **丢弃** 或 **死信** 消息;要修改此行为, 请使用下面描述的溢出设置;- 队列溢出行为使用 `overflow`溢出设置 来配置队列溢出行为, 如果 `overflow` 设置为`reject-publish`, 则最近发布的消息将被丢弃;否则, 如果publisher confirms(发布者确认)被启用, 则会通过 `basic.nack` 消息向发布者通知 reject拒绝;如果一条消息被路由到多个队列并被至少一个队列拒绝, 该channel将通过 `basic.nack` 通知发布者, 该消息仍然会发布到所有其他可以入队的队列中;- 使用 策略 定义最大队列长度要使用`策略`指定最大长度, 需要添加key `max-length` 和/或 `max-length-bytes` 到策略定义, 例如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">rabbitmqctl : rabbitmqctl set_policy my-pol &quot;^one-meg$&quot; &apos;&#123;&quot;max-length-bytes&quot;:1048576&#125;&apos; --apply-to queues</div><div class="line">rabbitmqctl (Windows) : rabbitmqctl.bat set_policy my-pol &quot;^one-meg$&quot; &quot;&#123;&quot;&quot;max-length-bytes&quot;&quot;:1048576&#125;&quot; --apply-to queues</div><div class="line">``` </div><div class="line">&quot;my-pol&quot;策略确保 `one-meg` 队列包含不超过1MiB的消息数据, 达到1MiB限制时, 最旧的消息将从队列头部丢弃;</div><div class="line"></div><div class="line">- 要定义溢出行为 - 是从头删除消息还是拒绝新发布, 请将`overflow` key 添加到策略定义, 例如:</div></pre></td></tr></table></figure>rabbitmqctl    : rabbitmqctl set_policy my-pol &quot;^two-messages$&quot; &apos;{&quot;max-length&quot;:2,&quot;overflow&quot;:&quot;reject-publish&quot;}&apos; --apply-to queuesrabbitmqctl (Windows) : rabbitmqctl.bat set_policy my-pol &quot;^two-messages$&quot; &quot;{&quot;&quot;max-length&quot;&quot;:2,&quot;&quot;overflow&quot;&quot;:&quot;&quot;reject-publish&quot;&quot;}&quot; --apply-to queues```&quot;my-pol&quot;策略确保 &quot;two-messages&quot; 队列包含不超过2条消息, 并且只要队列中包含2条消息并启用发布商确认, 所有其他发布都会发送 `basic.nack` 响应;还可以使用管理插件定义策略, 有关更多详细信息，请参阅[策略文档](https://www.rabbitmq.com/parameters.html#policies)- 使用 $arguments 定义最大队列长度通过提供带有非负整数值的 `x-max-length`($ageuments中的选项) 队列声明参数, 可以设置最大消息数; 非负整数值的 `x-max-length-bytes` 则可以设置字节的最大长度;如果两个参数都设置了, 那么两者都适用, 无论哪个限制首先被实施;通过为队列声明参数$arguments的 `x-overflow` 选项提供一个字符串值, 可以设置溢出行为, 可能的值有 `drop-head`(默认) 或 `reject-publish`;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li><p>默认溢出行为下, 当队列中消息放满时, 消息什么时候丢弃, 什么时候被死信? </p></li><li><p>测试代码参考<a href=""></a>;</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;理论&quot;&gt;&lt;a href=&quot;#理论&quot; class=&quot;headerlink&quot; title=&quot;理论&quot;&gt;&lt;/a&gt;理论&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;官方文档: &lt;a href=&quot;https://www.rabbitmq.com/maxlength.html&quot; targe
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>12. Lazy Queues 惰性队列(x-queue-mode) + 持久化</title>
    <link href="http://blog.renyimin.com/2018/06/09/rabbitmq/2018-06-09-rabbitmq-12/"/>
    <id>http://blog.renyimin.com/2018/06/09/rabbitmq/2018-06-09-rabbitmq-12/</id>
    <published>2018-06-09T02:14:30.000Z</published>
    <updated>2018-06-30T06:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lazy-Queues"><a href="#Lazy-Queues" class="headerlink" title="Lazy Queues"></a><a href="https://www.rabbitmq.com/lazy-queues.html" target="_blank" rel="external">Lazy Queues</a></h2><ol><li><p>从RabbitMQ 3.6.0开始m, Broker有了 <code>Lazy Queues</code> 的概念 – queues尽可能早地将其内容移动到磁盘的队列, 并且只在消费者请求时将其加载到RAM中, 因此命名为 <code>Lazy Queues</code>;</p></li><li><p>Lazy Queues的主要目标之一是能够支持非常长的队列(数百万条消息), 出于各种原因, 队列可能变得很长:</p><ul><li>消费者脱机/已经崩溃/因维护而停机</li><li>突然有消息进入高峰, 生产者超过消费者</li><li>消费者比平时慢</li></ul></li><li><p>默认情况下, 消息被发布到RabbitMQ时, 队列将其保存在内存缓存中, <strong>这能够尽可能快地向消费者传递消息</strong>; </p><ul><li>请注意, 持久性消息可以在进入RabbitMQ时写入磁盘, 并同时保存在RAM中;</li><li>每当代理认为需要释放内存时, 缓存中的消息将被分页到磁盘; 将一批消息分页到磁盘会花费时间并阻塞队列进程, 从而无法在分页时收到新消息, 尽管最近版本的RabbitMQ改进了分页算法, 但对于队列中有数百万条消息可能需要分页的用例, 情况仍然不理想;<br>而懒惰队列会尝试将消息尽可能早地移动到磁盘上, 这意味着在正常操作的大多数情况下, RAM中的消息数量明显减少, 这是以增加磁盘I / O为代价的;</li></ul></li><li><p>队列具备两种模式: <strong>default</strong> 和 <strong>lazy</strong></p><ul><li>默认的为default模式, 在3.6.0之前的版本无需做任何变更</li><li>lazy模式即为惰性队列的模式, 可以通过调用 channel.queueDeclare 方法的时候在参数中设置 <code>x-queue-mode</code> 为 <code>lazy</code> 或者 <code>default</code> 来指明队列为惰性或者正常</li><li>也可以通过Policy的方式设置, 如果一个队列同时使用这两种方式设置的话, 那么队列参数优先于策略值</li><li>只能通过删除队列, 重新创建队列并使用不同的参数重新声明它, 来更改队列模式</li></ul></li><li><p>当你想要优先保持节点内存使用率较低, 而较高的磁盘I/O和磁盘利用率可以接收时，所以惰性队列就比较合适;</p></li><li><p><strong>惰性队列和持久化消息可谓是最佳拍档</strong></p><ul><li>如果消息是持久化的, 那么这样的I/O操作不可避免, 同时内存也会过高;</li><li>注意如果 惰性队列 中存储的是 非持久化 的消息, 内存的使用率会一直很稳定, 但是重启之后消息又会丢失;</li><li>所以如果惰性队列结合持久化消息, 这就比较合适了<br>要持久化, 磁盘I/O是无法避免的, 但可以通过惰性队列保证内存降低!</li></ul></li><li><p><a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Http/Controllers/Demo/LazyQueueController.php" target="_blank" rel="external">代码参考</a></p></li><li><p>未完待续~~</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Lazy-Queues&quot;&gt;&lt;a href=&quot;#Lazy-Queues&quot; class=&quot;headerlink&quot; title=&quot;Lazy Queues&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.rabbitmq.com/lazy-queues.html&quot; t
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>08. Publisher Confirms 发布者确认机制</title>
    <link href="http://blog.renyimin.com/2018/06/05/rabbitmq/2018-06-05-rabbitmq-08/"/>
    <id>http://blog.renyimin.com/2018/06/05/rabbitmq/2018-06-05-rabbitmq-08/</id>
    <published>2018-06-05T11:20:56.000Z</published>
    <updated>2018-06-30T05:50:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>在RabbitMQ中, 为了 <strong>保证消息能安全发布到Broker</strong>, <strong>保证消息被消费者成功处理</strong>, 因此, publishers 和 conmusers 需要有用于 <code>delivery(交付)确认</code> 和 <code>处理确认</code> 的机制;</p><ul><li>从 consumers 到 RabbitMQ 的递送处理确认被称为 <code>AMQP 0-9-1中的确认</code>;</li><li>从 broker 到 publishers 的确认是一个扩展协议, 被称为 <code>publisher confirms</code>;</li></ul></li><li><p>这两个功能都<strong>基于相同的想法</strong>, 并受TCP的启发; 它们对于 <strong>从publishers到RabbitMQ节点</strong> 以及 <strong>从RabbitMQ节点到consumers</strong> 的可靠传送都是至关重要的;</p></li><li><p>之前已经介绍了 consumers ack, 下面介绍 publisher confirm</p></li></ol><h2 id="Publisher-Confirms"><a href="#Publisher-Confirms" class="headerlink" title="Publisher Confirms"></a><a href="https://www.rabbitmq.com/confirms.html#publisher-confirms" target="_blank" rel="external">Publisher Confirms</a></h2><ol><li><p>当你向Broker(Rabbit Server)发布消息时, 由于网络常出现的不确定因素, 客户端(Publisher)需要有机制来确认该消息已到达服务器;</p><ul><li>使用标准的AMQP 0-9-1, 保证消息不会丢失的唯一方法是使用<strong>事务</strong> – 使channel事务化, 然后为 每个消息 或 消息集 发布和提交; </li><li><strong>不过, 由于事务非常重量级, 会将吞吐量降低250倍;</strong></li><li>为了解决这个问题, 引入了 <strong>Publisher Confirms</strong>, 它模仿协议中已经存在的 <strong>消费者确认机制</strong>;</li></ul></li><li><p>要启用这个确认机制，客户端可以通过使用channel的 <code>confirm.select</code> 方法</p><ul><li>如果设置了 <code>confirm.select</code> 方法的 <code>no-wait</code>, 代理会用 <code>confirm.select-ok</code> 进行响应, 不过这点你貌似也只能通过抓包来观察:<br><img src="/img/rabbitmq/wireshark-Confirm.Select-ok.png"></li><li>这里说的 <code>confirm.select</code> 和 php-amqplib包中的 <code>confirm_select_ok()</code> 方法可不是一个意思, 而且php-amqplib也没对confirm_select_ok做实现</li></ul></li><li><p>上面也提到了, 该确认机制是模仿已经存在的 消费者确认机制, 所以, Broker也会使用类似 <strong>ack</strong>, <strong>nack</strong> 来响应Publisher: </p><ul><li>可以通过为 <code>set_ack_handler</code> , <code>set_nack_handler</code> 设置回调, 来监测消息是否成功到达服务器, 成功则会触发 <code>set_ack_handler</code>, 失败则会触发 <code>set_nack_handler</code></li><li><strong>只有在负责队列的Erlang进程中发生内部错误时才会回应nack</strong>, 所以这个在测试中也一直没有使用set_nack_handler捕获到错误, 但是对于nack的消息, 可以设置进行重发;</li><li>注意: <strong>这两监听函数是监听 publisher confirm 应答的, 可不是监听 consumer ack 应答的</strong>;</li></ul></li><li><p>一旦在channel上使用 <code>confirm.select</code> 方法, 就说它处于<strong>确认模式</strong>, <strong>事务通道不能进入确认模式</strong>, 一旦通道处于确认模式, 就不能进行事务处理; 也就是说 <strong>事务 和 Publisher Confirm 不能同时使用</strong>;<br> 一旦通道处于确认模式, 代理和客户端都会对消息进行计数(在第一次confirm.select时从1开始计数), 然后, broker通过在相同channel上发送 <code>basic.ack</code> 来处理它们, 从而确认消息;<br> <code>delivery-tag</code> 字段包含确认消息的序列号;<br> 最大 Delivery Tag, 递送标签是一个64位长的值，因此其最大值为9223372036854775807.由于递送标签的范围是按每个通道划分的，因此发布商或消费者在实践中不太可能运行该值</p></li><li><p>Publisher Confirms 的顺序考虑</p><ul><li>在大多数情况下, RabbitMQ将按发布顺序向publisher确认消息(这适用于在单个频道上发布的消息); 但是, 发布者确认是异步发出的, 并且可以确认一条消息或一组消息;<br>由于消息确认可以以不同的顺序到达, 所以, 应用程序应尽可能不取决于确认的顺序;</li></ul></li><li><p>未完~~~</p><ul><li><a href="https://yq.aliyun.com/articles/42206" target="_blank" rel="external">https://yq.aliyun.com/articles/42206</a></li></ul></li></ol><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>publisher confirm 不需要消费者参与, <a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Http/Controllers/Demo/PublisherConfirmController.php" target="_blank" rel="external">代码参考</a></p><h2 id="预习"><a href="#预习" class="headerlink" title="预习"></a>预习</h2><p>本篇还涉及到了 Qos预取相关的内容:</p><ol><li><p>针对Qos的提前预习(译文)</p><ul><li><p><a href="https://www.rabbitmq.com/confirms.html#channel-qos-prefetch" target="_blank" rel="external">信道预取设置(QoS)</a><br>由于消息是异步发送(推送)给客户端的, 因此在任何给定时刻通常都有不止一条消息在信道上运行; 此外, 客户的手动确认本质上也是异步的, 所以有一个 未确认的交付标签的滑动窗口, 开发人员通常会倾向于限制此窗口的大小, <strong>以避免消费者端无限制的缓冲区问题</strong>。<br>这是通过使用 <code>basic.qos</code> 方法设置 <code>预取计数</code> 值完成的, 该值定义了<strong>channel上允许的最大未确认递送数量</strong>, 一旦数字达到配置的计数, RabbitMQ将停止在通道上传送更多消息, 除非至少有一个未确认的消息被确认;<br>例如, 假设在通道 “Ch” 上有未确认的交付标签5,6,7和8, 并且通道 “Ch” 的预取计数(后面会学到是<code>prefetch_count</code>)设置为4, 则RabbitMQ将不会在 “Ch” 上推送更多交付, 除非至少有一个未完成的交付被确认(当确认帧在 <code>delivery_tag=8</code> 的频道上到达时, <strong>RabbitMQ将会注意到并再发送一条消息</strong>)</p></li><li><p>QoS预取设置对使用 <code>basic.get</code>(<code>pull API</code>) 获取的消息没有影响, 即使在手动确认模式下也是如此;</p></li></ul></li><li><p><strong>消费者确认模式, 预取和吞吐量(译文)</strong><br> 确认模式 和 QoS预取值 对消费者吞吐量有显着影响, 一般来说, <strong>增加预取值将提高向消费者传递消息的速度, 当然, 自动确认模式可以产生最佳的传送速率</strong><br> 但是, 在上面两种情况下, 尚未完成交付处理的消息(unacked)数量也会增加, 从而增加消费者RAM消耗;<br> <strong>自动确认模式或带无限预取的手动确认模式应谨慎使用</strong>, 消费者在没有确认的情况下消耗大量消息将导致其所连接的节点上的内存消耗增长;<br> 预取值1是最保守的, 但这将显着降低吞吐量, 特别是在消费者连接延迟较高的环境中, 对于许多应用来说, 更高的价值是合适和最佳的;<br> 100到300范围内的Qos(<code>prefetch_count</code>)预取值通常提供最佳的吞吐量, 并且不会面临压垮consumer的重大风险, 而更高的值往往会遇到效率递减的规律; </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在RabbitMQ中, 为了 &lt;strong&gt;保证消息能安全发布到Broker&lt;/strong&gt;, &lt;strong&gt;保证消
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>07. Consumer Acknowledgements 消费者确认机制</title>
    <link href="http://blog.renyimin.com/2018/06/05/rabbitmq/2018-06-03-rabbitmq-07/"/>
    <id>http://blog.renyimin.com/2018/06/05/rabbitmq/2018-06-03-rabbitmq-07/</id>
    <published>2018-06-05T09:45:51.000Z</published>
    <updated>2018-06-30T05:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>在RabbitMQ中, 为了 <strong>保证消息能安全发布到Broker</strong>, <strong>保证消息被消费者成功处理</strong>, 因此, publishers 和 conmusers 需要有用于 <code>delivery(交付)确认</code> 和 <code>处理确认</code> 的机制;</p><ul><li>从 consumers 到 RabbitMQ 的递送处理确认被称为 <code>AMQP 0-9-1中的确认</code>;</li><li>从 broker 到 publishers 的确认是一个扩展协议, 被称为 <code>publisher confirms</code>;</li></ul></li><li><p>这两个功能都<strong>基于相同的想法</strong>, 并受TCP的启发; 它们对于 <strong>从publishers到RabbitMQ节点</strong> 以及 <strong>从RabbitMQ节点到consumers</strong> 的可靠传送都是至关重要的;</p></li></ol><h2 id="Consumer-Acknowledgements"><a href="#Consumer-Acknowledgements" class="headerlink" title="Consumer Acknowledgements"></a><a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="external">Consumer Acknowledgements</a></h2><ol><li><p>Delivery Identifiers: Delivery Tags(交付标签)</p><ul><li>当消费者(订阅)被注册时, 消息将被RabbitMQ使用 <code>basic.deliver</code> 方法递送(推送), 该方法带有一个 <code>delivery tag</code>, 它唯一标识 channel 上的一个delivery(投递); 由于投放标签的范围是按每个channel划分的, 因此交付必须在同一channel上被确认;</li><li>确认交付的客户端库方法将交付标签作为参数, 如下, 可以在consumer中使用如下几种消息应答<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$channel-&gt;basic_ack(8, false);  // 有2个参数可用 delivery_tag, multiple</div><div class="line">$channel-&gt;basic_nack(8, false, true);   // 有4个参数可用 delivery_tag, multiple, requeue</div><div class="line">$channel-&gt;basic_reject(8, false);   // 有3个参数可用 delivery_tag, requeue</div></pre></td></tr></table></figure></li></ul></li><li><p>消费者确认模式和数据安全注意事项</p><ul><li>当节点向consumer投递消息时, 它必须确定消息是被消费者处理(或至少是被接收到了); 由于这个过程中会有很多导致失败的情况, 比如consumer应用程序失败, 网络原因等;</li><li>消息传递协议通常提供一种确认机制, 允许消费者给他们所连接的节点发送 确认应答, 该机制是否被使用, <strong>是在消费者订阅时决定的</strong>;</li></ul></li><li><p>RabbitMQ可以在消息被发出去之后立即就认为它已成功投递, 也可以在客户端手动发送确认之后才认为消息被成功投递, 可以使用以下协议方法之一来手动发送确认, 确认可以是 <code>positive</code>正面 或 <code>negative</code>负面:</p><ul><li><code>basic.ack</code> is used for positive acknowledgements</li><li><code>basic.nack</code> is used for negative acknowledgements (note: this is a RabbitMQ extension to AMQP 0-9-1)</li><li><code>basic.reject</code> is used for negative acknowledgements 但是与 <code>basic.nack</code> 相比有一个限制</li></ul></li><li><p>Positive acknowledgements 是告诉Rabbitmq消息已被成功投递并处理, 并且消息可以被丢弃了; 使用 <code>basic.reject</code> 的 Negative acknowledgements 也是相同的效果, 它与 Positive acknowledgements 主要是<strong>语义上的差异</strong></p><ul><li><code>positive acknowledgements</code> 假定一条消息已被成功处理; </li><li>而 <code>negative acknowledgements</code> 则暗示交付未被处理, 但消息仍应被删除; (不过, negative acknowledgements 的两个方法, 都有个 <code>requeue</code> 参数可以将消息重新放到队列中)<br><img src="/img/rabbitmq/negative-ack.png" width="500/"></li></ul></li></ol><h2 id="发后即忘模式"><a href="#发后即忘模式" class="headerlink" title="发后即忘模式"></a>发后即忘模式</h2><ol><li><p>而在 <code>自动确认模式</code> 下, 消息在发送后会立即被认为已成功delivery(投递), 这种模式可以实现更高的吞吐量(只要消费者能够跟上), 但会降低 <code>delivery(交付)</code> 和 <code>消费者处理</code> 的安全性; (无法保证消息能真正到达, 也无法保证被消费)<br> 这种模式通常被称为 <strong>发后即忘模式</strong>, 与手动确认模式不同, 如果消费者的TCP连接或通道在成功交付之前关闭, 则服务器发送的消息将丢失, 因此, 自动消息确认应被视为不安全的;</p></li><li><p>使用自动确认模式时需要考虑的另一件事是消费者过载, <strong>手动确认模式通常与 有限的通道预取(Qos-prefetch_count,后面会讲到)一起使用</strong>, 这限制了通道上<code>unacked</code>消息的数量;</p><ul><li>然而, 对于自动确认, 根据定义默认没有Qos限制的, 消费者因此可能被delivery(投递)速度所压垮, 可能导致内存积压, 或者操作系统终止进程;</li><li>因此, 仅建议可以高效且稳定处理消息的消费者使用 发后即忘 模式;</li></ul></li></ol><h2 id="Negative-Ack"><a href="#Negative-Ack" class="headerlink" title="Negative Ack"></a>Negative Ack</h2><h3 id="Negative-Ack-和-requeue"><a href="#Negative-Ack-和-requeue" class="headerlink" title="Negative Ack 和 requeue"></a>Negative Ack 和 requeue</h3><ol><li><p>有时候, Consumers 并不能立即处理投递来的消息, 但其他实例可能能够处理, 在这种情况下, 你可能就需要重新安排并让其他消费者接收并处理它, <code>basic.reject()</code> 和 <code>basic.nack()</code> 是两种用于这种场景的方法;</p><ul><li>这些方法通常用于 negatively ack (应答)一个投递, 这个投递可以被broker丢弃或重新入队列(默认是被丢弃的), 此行为由 <code>requeue</code> 字段控制(如 <code>$channel-&gt;basic_nack(8, false, true);</code>);</li><li>当该字段设置为true时, 代理将使用指定的 delivery tag 重新进行交付</li></ul></li><li><p>如果可能, 当消息被 <code>requeue</code>(重排)时, <strong>它将被放置在其队列中的原始位置</strong>, 如果不是(由于多个消费者共享队列时来自其他消费者的并发递送和确认), 则该消息将被重新排队到更接近队列头的位置;<br> 已重排的消息可能会立即准备好重新发送, 具体取决于它们在队列中的位置, 以及具有活跃consumer的channel使用的预取值, 这意味着, 如果所有消费者都因为暂时状况 requeue 时, 它们将创建一个 requeue/redelivery(重新发货/重新递送)的<strong>循环</strong>, 就网络带宽和CPU资源而言, 这样的循环可能是昂贵的;</p></li></ol><h3 id="Nack-和-Reject"><a href="#Nack-和-Reject" class="headerlink" title="Nack 和 Reject"></a>Nack 和 Reject</h3><ol><li><p><strong>消费者实现可以跟踪重新传送的次数并拒绝消息(丢弃它们)或延迟计划重新计划;</strong></p><ul><li>可以使用 <code>basic.nack()</code> 方法可以一次性 拒绝 或 requeue 多个消息, 这是区别于 <code>basic.reject()</code>的;</li><li><code>basic.nack()</code> 接受一个额外的参数 <code>multiple</code>, 这两个方法的所有参数对比之前也已经介绍过了, 如下:<br><img src="/img/rabbitmq/negative-ack.png" width="500/"></li></ul></li><li><p><strong>消费者失败或失去连接时: 自动requeue</strong></p><ul><li>使用手动确认时, 任何未收到应答的投递将在发送递送的通道(或连接)关闭时自动requeue (**这包括客户端的TCP连接丢失, 消费者应用程序(进程)失败…)</li><li>由于这种行为, 消费者必须做好准备来处理重新来的投递，否则就得考虑到<strong>幂等性</strong>;</li><li><strong>请注意, 因为有requeue机制, 所以消费者可以收到先前传送给其他消费者的消息</strong>。  </li></ul></li></ol><h3 id="一次确认多次交付"><a href="#一次确认多次交付" class="headerlink" title="一次确认多次交付"></a>一次确认多次交付</h3><ol><li>可以批量手动确认以减少网络流量, 这是通过将确认方法的 <code>multiple</code> 字段设置为true来完成的; <strong>请注意</strong>: <code>basic.reject()</code> 在历史上并没有这个字段, 这就是为什么 <code>basic.nack()</code> 被RabbitMQ作为协议扩展引入的原因;<ul><li>当 <code>multiple</code> 字段设置为true时, RabbitMQ将确认 到本次确认中指定的标签为止 所有未完成交付的标签 (如 <code>$channel-&gt;basic_ack(8, true);</code>) ; 与其他确认相关的内容一样, 这是在每个channel的范围的;<br>例如, 假设在通道 “Ch” 上有未确认的交付标签 5,6,7,8, 当设置确认方法的 <code>delivery_tag</code> 为8并且 <code>multiple</code> 设置为true的情况下到达该channel时, 将确认从5到8的所有标签; 如果 <code>multiple</code> 设置为false, 那么值确认标签8;</li></ul></li></ol><h2 id="客户端错误-双重ack-和-未知Tags"><a href="#客户端错误-双重ack-和-未知Tags" class="headerlink" title="客户端错误: 双重ack 和 未知Tags"></a>客户端错误: 双重ack 和 未知Tags</h2><ol><li><p>如果消费者不止一次确认同一个递送标签, RabbitMQ将会出现channel错误, 例如 <code>PRECONDITION_FAILED - unknown delivery tag 100</code>, 如果使用未知的delivery tag(投递标签), 则会抛出同样的通道异常;<br> <img src="/img/rabbitmq/unknown-delivery-tag.png" width="500/"></p></li><li><p>Broker报出 “unknown delivery tag” 的另一种情况是, 无论是positive 还是negative 的应答, 在与收到投递的channel不同的channel上尝试确认;  (不过这个一般我们都是使用当前channel应答当前channel)</p></li></ol><h2 id="扩展-Negative-Ack"><a href="#扩展-Negative-Ack" class="headerlink" title="扩展 - Negative Ack"></a>扩展 - <a href="https://www.rabbitmq.com/nack.html" target="_blank" rel="external">Negative Ack</a></h2><ol><li><p>AMQP 0-9-1 中的消费者可以选择使用 手动确认机制;</p></li><li><p>AMQP 0-9-1 规范定义了 <code>basic.reject()</code> 方法, 该方法允许consumer应答单条negatively确认消息，指示broker丢弃或重新发送消息; 不幸的是，basic.reject 不支持批量应答 negatively确认消息;</p></li><li><p>为了解决这个问题, RabbitMQ支持了 <code>basic.nack()</code> 方法, 该方法提供了 <code>basic.reject</code> 的所有功能, 同时也允许<strong>批量应答消息</strong><br> 要批量拒绝消息, 客户端将 <code>basic.nack()</code> 方法的 <code>multiple</code> 标志设置为true; 在这方面, <code>basic.nack</code> 补充了 <code>basic.ack</code> 的批量确认语义;</p></li></ol><h2 id="扩展-consumer-cancle"><a href="#扩展-consumer-cancle" class="headerlink" title="扩展 - consumer-cancle"></a>扩展 - <a href="https://www.rabbitmq.com/consumer-cancel.html" target="_blank" rel="external">consumer-cancle</a></h2><ol><li><p>当Consumer通过channel从queue中消费消息时, 有很多原因会导致消费停止; 其中一个很明显的原因是, consumer在该channel中发出 <code>basic.cancel</code>, 这将导致consumer被取消, 并且 Rabbit Server 回应 <code>basic.cancel-ok</code>;</p></li><li><p>其他事件(如queue被删除)或集群场景中队列所在的节点失败, 将导致消费被取消, 但不会通知客户端通道, 这通常是无益的;</p></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li>消费者代码<a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Console/Commands/consumerConfirm.php" target="_blank" rel="external">参考</a></li><li>生产者代码<a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Http/Controllers/Demo/ConsumerConfirmController.php" target="_blank" rel="external">参考</a>    </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在RabbitMQ中, 为了 &lt;strong&gt;保证消息能安全发布到Broker&lt;/strong&gt;, &lt;strong&gt;保证消
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Restful</title>
    <link href="http://blog.renyimin.com/2018/03/16/http/2018-03-06-restful/"/>
    <id>http://blog.renyimin.com/2018/03/16/http/2018-03-06-restful/</id>
    <published>2018-03-16T11:36:23.000Z</published>
    <updated>2018-05-09T06:31:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>REST本身并没有创造新的技术, 组件或服务, 主要指的是一组<strong>架构约束条件和原则</strong>, 隐藏在RESTful背后的理念就是<strong>使用Web的现有特征和能力, 更好地使用现有Web标准中的一些准则和约束</strong>; 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。</p><p>虽然REST本身受Web技术的影响很深, 但是理论上REST架构风格并不是绑定在HTTP上, 只不过目前HTTP是唯一与REST相关的实例;</p><p>所以通常描述的REST也是通过HTTP实现的REST;</p><h2 id="URI的设计"><a href="#URI的设计" class="headerlink" title="URI的设计"></a>URI的设计</h2><ol><li><p>URI的设计应该遵循可寻址性原则, 具有<strong>自描述性</strong>, 需要在形式上给人以直觉上的关联; 比如:</p><ul><li><p>用<code>_</code>或<code>-</code>来让URI可读性更好<br>例如国内比较出名的开源中国社区, 它上面的新闻地址就采用这种风格, 如 <a href="http://www.oschina.net/news/38119/oschina-translate-reward-plan" target="_blank" rel="external">http://www.oschina.net/news/38119/oschina-translate-reward-plan</a></p></li><li><p>使用<code>/</code>来表示资源的层级关系<br>例如 <a href="https://github.com/rymuscle/chat/issues" target="_blank" rel="external">https://github.com/rymuscle/chat/issues</a> 就表示了一个多级的资源, 指的是rymuscle用户的chat项目的issues列表</p></li><li><p>使用<code>?</code>用来过滤资源 (如果记录数量很多，服务器不可能都将它们返回给用户, 比如分页等筛选条件)<br>很多人只是把<code>?</code>简单的当做是参数的传递, 很容易造成URI过于复杂、难以理解; 其实可以把<code>?</code>用于对资源的过滤;<br>例如 <code>https://github.com/rymuscle/chat/pulls</code> 用来表示git项目的所有推入请求;<br>而 <code>/pulls?state=closed</code> 用来表示git项目中已经关闭的推入请求, 这种URL通常对应的是一些特定条件的查询结果或算法运算结果;</p></li><li><p><code>,</code>或<code>;</code>可以用来表示同级资源的关系</p></li></ul></li><li><p>URI里带上版本号, 如 <code>https://api.example.com/v1/</code> (Github就是这样做的)<br> 另一种做法是, 将版本号放在HTTP头信息中, 但不如放入URL方便和直观;</p></li><li><p><strong>URI中只应该描述清楚资源的名称</strong>, 而不应该包括资源的操作(因为统一资源接口要求使用标准的HTTP方法对资源进行操作, 方法都是有语义的, 所以已经明确描述了这次的操作含义)</p><ul><li>URI不应该再使用动作来描述, 如下就是一些不符合统一接口要求的URI (它们都在URI中对操作进行了描述):<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET /getUser/1</div><div class="line">POST /createUser</div><div class="line">PUT /updateUser/1</div><div class="line">DELETE /deleteUser/1</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2><p>接口应该使用标准的HTTP方法如GET，PUT和POST，并<strong>遵循这些方法的语义</strong>(通过明确的方法来描述操作), 可以参考博文 <a href="/2016/11/30/http/2016-11-30-HTTP-03/">HTTP各请求方法详解</a> 或者 <a href="http://www.runoob.com/w3cnote/restful-architecture.html" target="_blank" rel="external">Restful架构详解</a></p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>状态码应该使用HTTP标准状态码 可以参考博文 <a href="/2016/11/30/http/2016-11-30-HTTP-01/#状态码详解">HTTP协议预览</a></p><p>更多<a href="http://cizixs.com/2016/12/12/restful-api-design-guide" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;REST本身并没有创造新的技术, 组件或服务, 主要指的是一组&lt;strong&gt;架构约束条件和原则&lt;/strong&gt;, 隐藏在RESTful背
      
    
    </summary>
    
      <category term="Restful" scheme="http://blog.renyimin.com/categories/Restful/"/>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/Restful/HTTP/"/>
    
    
      <category term="Restful" scheme="http://blog.renyimin.com/tags/Restful/"/>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>08. 并行连接, 持久连接</title>
    <link href="http://blog.renyimin.com/2017/12/06/http/2017-12-06-HTTP-08/"/>
    <id>http://blog.renyimin.com/2017/12/06/http/2017-12-06-HTTP-08/</id>
    <published>2017-12-06T12:10:11.000Z</published>
    <updated>2018-05-09T06:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常被误解的Connection首部"><a href="#常被误解的Connection首部" class="headerlink" title="常被误解的Connection首部"></a>常被误解的<code>Connection</code>首部</h2><ol><li><p>HTTP允许在客户端和最终的源端服务器之间存在一串HTTP中间实体(代理, 高速缓存等)。可以从客户端开始, 逐跳地将HTTP报文经过这些中间设备, 转发到源端服务器上去(或者进行反向传递)。</p></li><li><p>HTTP的 <code>Connection</code> 首部字段中有一个由<code>,</code>分隔的连接标签列表;</p></li><li><p>Connection首部可以承载3种不同类型的标签, 因此非常令人费解:</p><ul><li>HTTP首部字段名, 列出了只与此链接有关的首部; </li><li>任意标签值, 用于描述此链接的非标准选项;</li><li>close, 说明操作完成之后需要关闭这条持久连接;</li></ul></li><li><p>如果连接标签中包含了一个HTTP首部字段的名称, 那么这个首部字段就包含了一些连接有关的信息, 不能将其转发出去, 在将报文转发出去之前, 必须删除Connection首部列出的所有首部字段。</p><ul><li>由于Connection首部可以防止无意中对本地首部的转发, 因此将逐跳字首部名放入Connection首部被称为”对首部的保护”。<br>(<strong>Connection首部是个逐跳首部, 只适用于单条传输链路, 不应该沿着传输链路向下传输</strong> (参考P101))<br><img src="/img/http/connection-not-field.png" width="550/"></li></ul></li></ol><h2 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h2><ol><li><p>在串行请求时, 浏览器可以先完整地请求原始的HTML页面, 然后请求第一个嵌入对象, 然后请求第二个嵌入对象等, 以这种简单的方式对每个嵌入式对象进行串行处理, 很明显这样处理很慢!!</p></li><li><p>HTTP允许客户端打开多条连接, 并行地执行多个HTTP事务, 如下图, 并行加载了四幅嵌入式图片, 每个事务都有自己的TCP连接:<br> <img src="/img/http/http-concurrence-request-01.png" width="550/"></p></li><li><p>并行连接可能会提高页面的加载速度</p><ul><li>包含嵌入对象的组合页面如果能通过并行连接克服单条连接的空载时间和带宽限制, 加载速度也会有所提高。时延可以重叠起来, 而且如果单条连接没有充分利用客户端的因特网带宽, 可以将为用带宽分配来装载其他对象。</li><li>如下图, 串行和并行的对比, 并行情况下, 先装载的是封闭的HTML页面, 然后并行处理其余3个事务, 每个事务都有自己的连接。(图片的装载是并行的, 连接的时延也是重叠的)<br><img src="/img/http/chuanxing-01.png" width="550/"><br><img src="/img/http/http-concurrence-request-02.png" width="550/"></li><li>由于软件开销的存在, 每个连接请求之间总会有一些小的时延, 但连接请求和传输时间<strong>基本上</strong>都是重叠起来的!</li></ul></li><li><p>并行连接不一定更快<br> <strong>即使并行连接的速度可能会更快, 但是并不一定总是更快</strong></p><blockquote><p>因为在客户端的网络带宽如果不足时, 大部分的时间可能都是用来传送数据的。在这种情况下, 一个连接到速度较快服务器上的HTTP事务就会很容易耗尽所有可用的Modem带宽。<br> 如果并行加载多个对象, 每个对象都会去竞争这有限的带宽, 每个对象都会以较慢的速度按比例加载, 这样带来的性能提升就很小, 甚至没什么提升。<br> 而且打开大量连接会消耗很多内存资源, 从而引发自身性能问题。<br> 复杂的Web有可能会有数十或数百个内嵌对象, 客户端可能可以打开数百个连接, 但Web服务器通常要同时处理很多其他用户的请求, 所以很少有Web服务器希望出现这样的情况。<br> 一百个用户同时发出申请, 每个用户打开100个连接, 服务器就要负责处理1W个连接, 这会造成服务器性能的严重下降。对高负荷的代理来说也同样如此。<br> 实际上, 浏览器确实使用了并行连接, 但它们会将并行连接的总数限制为一个较小的值(通常是四个)。服务器可以随意关闭来自特定客户端的超量连接。</p></blockquote></li><li><p><strong>并行连接可能让人”感觉”更快一些</strong><br>通过上面的介绍, 我们知道并行连接并不总是能使页面加载更快, 但即使实际上没有加快页面的传输速度, 并行连接通常也会让用户<code>觉得</code>页面加载的更快了,<br>因为多个组件对象同时出现屏幕上时, 用户能够看到加载的进展。如果整个屏幕上有很多动作在进行, 即使实际上整个页面的下载时间更长, 用户也会认为Web页面加载得更快一些。</p></li></ol><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><ol><li><p>HTTP/1.1(以及HTTP/1.0的各种增强版本)允许HTTP设备在事务处理结束之后将TCP连接保持在打开状态, 以便未来的HTTP请求能够重用现存的连接。在事务处理结束之后仍然保持在打开状态的TCP连接被称为<strong>持久连接</strong>。</p></li><li><p>非持久连接会在每个事务结束之后关闭, 持久连接会在不同事务之间保持打开状态, 直到客户端或服务器其决定将其关闭为止。</p></li><li><p>重用已对目标服务器打开的空闲持久连接, 就可以避开缓慢的连接建立阶段。而且已经打开的连接还可以避免慢启动的拥塞使用阶段, 以便更快速地进行数据的传输。</p></li><li><p>持久连接和并行连接</p><blockquote><p>之前已经了解过”并行连接可以提高复合页面的传输速度, 但并行连接也有一些缺点”;<br>而持久连接有一些比并行连接更好的地方,持久连接降低了时延和连接建立的开销, 将连接保持在已调谐状态, 而且减少了打开连接的潜在数量。<br>但是, 管理持久连接时要特别小心, 不然就会积累大量的空闲连接, 耗费本地以及远程客户端和服务器上的资源。</p></blockquote><p> 持久连接与并行连接配合使用可能是更高效的方式。现在, 很多Web应用程序都会打开少量的并行连接, 其中的每一个都是持久连接。</p></li><li><p>持久连接有两种类型: 比较老的 <code>HTTP/1.0+&quot;keep-alive&quot;</code> 连接, 以及现代的 <code>HTTP/1.1 &quot;persistent&quot;</code> 连接。</p></li></ol><h2 id="HTTP-1-0-keep-alive连接"><a href="#HTTP-1-0-keep-alive连接" class="headerlink" title="HTTP/1.0+keep-alive连接"></a>HTTP/1.0+keep-alive连接</h2><ol><li><p>前言:<br>大约从1996年开始, 很多HTTP/1.0浏览器和服务器都进行了扩展, 以支持一种被称为keep-alive连接的早期实验型持久连接。<br>这些早期的持久连接收到了一些互操作性设计方面问题的困扰, 这些问题在后期的HTTP/1.1版本中都得到了修正, 但很多客户端和服务器仍然在使用这些早期的keep-alive连接。</p></li><li><p>下图在”串行连接上实现了4个HTTP事务的时间线” 与 “在一条持久连接上实现同样事务” 所需的时间线进行了比较, <strong>显示了keep-alive连接的一些性能优点</strong><br> <strong>由于去除了创建连接和关闭连接的开销, 所以时间线有所缩减</strong><br> <img src="/img/http/keep-alive-vs-chuanxing.png" width="500/"></p></li></ol><h3 id="Keep-Alive操作"><a href="#Keep-Alive操作" class="headerlink" title="Keep-Alive操作"></a><strong>Keep-Alive操作</strong></h3><p>客户端和服务器要配合</p><ol><li><p>keep-alive已经不再使用了, 而且在当前的HTTP/1.1规范中也已经没有了对它的说明了。但浏览器和服务器对keep-alive握手的使用仍然相当广泛, 因此HTTP的实现者应该做好与之进行交互操作的准备.</p></li><li><p>实现HTTP/1.0 keep alive连接的客户端可以通过包含<code>Connection: Keep-Alive</code>首部请求将一条连接保持在打开状态。</p></li><li><p>如果服务器愿意为下一条请求将连接保持在打开状态, 就在响应中包含相同的首部。如果响应中没有<code>Connection: Keep-Alive</code>首部, 客户端就认为服务器不支持keep-alive, 会在发回响应报文之后关闭连接。</p></li></ol><h3 id="还有keep-alive首部"><a href="#还有keep-alive首部" class="headerlink" title="还有keep-alive首部"></a>还有keep-alive首部</h3><ol><li><p>注意, keep-Alive首部只是请求将连接保持在活跃状态。发出keep-alive请求之后, 客户端和服务器并不一定会同意进行keep-alive会话。<br> 它们可以在任意时刻关闭空闲的keep-alive连接, 并可随意限制keep-alive连接所处理事务的数量。</p></li><li><p>可以用<code>Keep-Alive通用首部字段</code>中指定的, 有逗号分隔的选项来调节keep-alive的行为:</p><ul><li>参数timeout: 是在Keep-Alive响应首部发送的, 它估计了服务器希望将连接保持在活跃状态的时间。这并不是一个承诺值。</li><li>参数max: 是在Keep-Alive响应首部发送的, 它估计了服务器还希望为多少个事务保持此连接的活跃状态。这并不是一个承诺值。</li><li>Keep-Alive首部还可以支持任意未经处理的属性, 这些属性主要用于诊断和调试。语法为 <code>name [=value]</code>。</li></ul></li><li><p>Keep-Alive首部完全是可选的, 但只有在提供了 Connection:Keep-Alive 时才能使用它。<br> 下面这个例子说明服务器最多还会为另外5个事务保持连接的打开状态, 或者将打开状态保持到连接空闲了2分钟之后。</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Connection: Keep-Alive</div><div class="line">Keep-Alive: max=<span class="number">5</span>, timeout=<span class="number">120</span></div></pre></td></tr></table></figure></li></ol><h3 id="keep-alive连接的限制和规则"><a href="#keep-alive连接的限制和规则" class="headerlink" title="keep-alive连接的限制和规则"></a>keep-alive连接的限制和规则</h3><ol><li><p>在HTTP/1.0中, keep-alive并不是默认使用的。客户端必须发送一个 <code>Connection: Keep-Alive</code> 请求首部来激活keep-alive连接。</p></li><li><p>Connection: Keep-Alive 首部必须随所有希望保持持久连接的报文一起发送。<br> 如果客户端没有发送Connection: Keep-Alive首部, 服务器就会在那条请求之后关闭连接。</p></li><li><p>客户端如果探明响应中没有Connection: Keep-Alive响应首部, 就可以知道服务器发出响应之后是否会关闭连接了。</p></li><li><p>一般都是在检测到连接关闭之后, 就可以确定报文实体主体部分的长度。如果想”无需检测到连接关闭 就能确定报文实体主体部分的长度”,<br> 那你的响应报文的实体主体部分必须有正确的Connect-Length, 有多部件媒体类型, 或者用分块传输编码的方式进行了编码。<br> 在一条keep-alive信道中回送错误的 Connection-Length 是很糟糕的事, 这样的话, 事务处理的另一端就无法精确地检测出一条报文的结束和另一条报文的开始了。</p></li><li><p>代理和网关必须执行Connection首部的规则, 代理或网关必须在将报文转发出去或将其高速缓存之前, 删除在Connection首部中命名的所有首部字段以及Connection首部本身。</p></li><li><p>严格来说, 不应该与无法确定是否支持Connection首部的代理服务器建立keep-alive连接, 以防止出现下面要介绍的<code>哑代理</code>问题, 在实际应用中不是总能做到这一点的。 </p></li><li><p>从技术上来讲, 应该忽略所有来自HTTP/1.0设备的Connection首部字段(包括Connection:Keep-Alive), 因为他们可能是由比较老的代理服务器误转发的。<br>但是实际上, 尽管可能会有在老代理上挂起的危险, 有些客户端和服务器还是会违反这条规则。</p></li><li><p>除非重复发送请求会产生其他副作用, 否则 “如果在客户端受到完整响应之前连接就关闭了, 那么客户端一定要做好重试请求的准备”。 </p></li></ol><h3 id="Keep-Alive和哑代理"><a href="#Keep-Alive和哑代理" class="headerlink" title="Keep-Alive和哑代理"></a>Keep-Alive和哑代理</h3><ol><li><p>正常情况下, 如果客户端与一台服务器对话, 客户端可以发送一个 Connection:Keep-Alive 首部来告知服务器它希望保持连接的活跃状态, 如果服务器支持keep-alive, 就回送一个 Connection:Keep-Alive 首部, 否则就不回送。</p></li><li><p>问题是出在代理上 — 尤其是那些不理解Connection首部, 而且不知道在沿着转发链路将报文转发出去之前应该将Connection首部删除的代理。<br> 很多老式或简单的代理都是<code>盲中继(blind relay)</code>, 他们只是将字节从一个连接转发到两一个连接中去, 不对Connection首部进行特殊处理。</p></li><li><p>下图就是一个Web客户端通过一个作为盲中继使用的哑代理与Web服务器进行对话的例子:<br> <img src="/img/http/blind-relay.png" width="500/"><br> 更多参考: P101<br> 盲中继的更多问题参考 4.5.7 (??)</p></li><li><p>为了防止此类代理通信问题的发生, 现在的代理都决不能转发Connection首部和所有名字出现在Connection值中的首部。<br> 另外还有几个不能作为Connection首部的值, 并且也不能被代理转发或作为缓存响应使用的首部:<br> Proxy-Authenticate, Proxy-Connection, Transfer-Encoding 和 Upgrade;</p></li></ol><h2 id="HTTP-1-1-persistent连接"><a href="#HTTP-1-1-persistent连接" class="headerlink" title="HTTP/1.1 persistent连接"></a>HTTP/1.1 persistent连接</h2><ol><li>HTTP/1.1主键停止了对keep-alive连接的支持, 用一种名为持久连接(persistent connection)的改进型设计取代了它。<br> 持久连接的目的与keep-alive连接的目的相同, 但机制更优一些。</li><li><p>与HTTP/1.0的keep-alive连接不同, HTTP/1.1持久连接在默认情况下是激活的。除非特别指明, 否则HTTP/1.1假定所有连接都是持久的。<br> 要在事务处理结束之后将连接关闭, HTTP/1.1应用程序必须向报文中显示地添加一个<code>Connection:close</code>首部。<br> 这是与以前的HTTP协议很重要的区别, 在以前的版本中, keep-alive连接要么是可选的, 要么根本就不支持。</p></li><li><p>HTTP/1.1客户端假定在收到响应后, 除非响应中包含了 <code>Connection:close</code>首部, 不然HTTP/1.1连接就仍维持在打开状态。<br> 但是, 客户端和服务器仍然可以随时关闭空闲的连接。 不发送 <code>Connection:close</code> 并不以为这服务器承诺永远将连接保持在打开状态。</p></li></ol><h3 id="persistent连接的限制和规则"><a href="#persistent连接的限制和规则" class="headerlink" title="persistent连接的限制和规则 (??)"></a>persistent连接的限制和规则 (??)</h3><ol><li>发送了 <code>Connection:close</code> 请求首部之后, 客户端就无法在那条连接上发送更多的请求了。</li><li>如果客户端不想在连接上发送其他请求了, 就应该在最后一条请求中发送一个 <code>Connection:close</code>  请求首部。</li><li>只有当连接上所有的报文都有正确的, 自定义报文长度时 – 也就是, 实体主体部分的长度都和响应 Connect-Length 一致, 或者是用分块传输编码方式编码的 — 连接才能持久保持。</li><li>HTTP/1.1的代理必须能够分别管理与客户端和服务器的持久连接 — 每个持久连接都值适用于一跳传输。</li><li>(由于较老的代理会转发Connection首部, 所以)HTTP/1.1的代理服务器不应该与HTTP/1.0客户端建立持久连接, 除非他们了解客户端的处理能力。<br> 实际上, 这一点是很难做到的, 很多厂商都违背了这一原则。</li><li>尽管服务器不应该试图在传输报文的过程中关闭连接, 而且在关闭连接之前至少应该响应一条请求, 但不管Connection首部取了什么值, HTTP/1.1设备都可以在任意时刻关闭连接。</li><li>HTTP/1.1应用程序必须能够从异步的关闭中恢复出来, 只要不存在可能会累积起来的副作用, 客户端都应该重试这条请求。(??)</li><li>除非重复发送请求会产生其他副作用, 否则 “如果在客户端收到完整响应之前连接就关闭了, 那么客户端必须要重新发送请求”</li><li>一个用户客户端对任何服务器或代理, 最多只能维护两条持久连接, 以防服务器过载。<br> 代理可能需要更多到服务器的连接来支持并发用户的通信, 所以如果有N个用户试图访问服务器的话, 代理最多要维持2N条到任意服务器或父代理的连接。</li></ol><h2 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h2><ol><li>HTTP/1.1允许在持久连接上可选地会用<strong>请求管道</strong>。这是在keep-alive连接上的进一步性能优化。在相应到达之前, 可以将多条请求放入队列。<br> 当第一条请求通过网络流向地球另一端的服务器时, 第二条和第三条也可以开始发送了。<br> 在高时延网络条件下, 这样做可以降低网络的回环时间, 提高性能。</li><li>如下图:<br> <img src="/img/http/pipeline-persistent-connections.png" width="550/"><h3 id="对管道化连接的限制"><a href="#对管道化连接的限制" class="headerlink" title="对管道化连接的限制"></a>对管道化连接的限制</h3></li><li><strong>如果HTTP客户端无法确认连接是持久的, 就不应该使用管道</strong>。</li><li>必须按照与请求相同的顺序回送HTTP响应。<strong>HTTP报文中没有序列号标签, 因此如果收到的响应失序了, 就没办法将其与请求匹配起来了</strong>。</li><li>HTTP客户端必须做好连接会在任意时刻关闭的准备, 还要准备好重发所有未完成的管道化请求。<br> 如果客户端打开了一条持久连接, 并立即发出了10条请求, 服务器可能在只处理了5条请求后关闭了连接, 剩下的5条请求会失败, 客户端必须能够应对这些过早关闭连接的情况, 重新发出这些请求。</li><li>HTTP客户端不应该用管道化的方式发送回产生副作用的请求(比如POST)。<br> 总之, 出错的时候, 管道化方式会阻塞客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全地重试<strong>POST这样的非幂等请求</strong>, 所以出错时, 就存在某些方法永远不会被执行的风险。</li></ol><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><h3 id="“任意”解除连接"><a href="#“任意”解除连接" class="headerlink" title="“任意”解除连接"></a>“任意”解除连接</h3><p>所有HTTP客户端, 服务器或代理都可以在任意时刻关闭一条TCP传输连接, 通常会在一条报文结束时关闭连接, 但出错的时候, 也可能在首部行中间, 或其他奇怪的地方关闭连接。<br>对管道化持久连接来说, 这种情形是很常见的。HTTP应用程序可以在经过任意一段时间之后，关闭持久连接。比如，在持久连接空闲一段时间之后，服务器可能会决定将其关闭。<br>但是，服务器永远都无法确定在它关闭”空闲”连接的那一刻，在线路的那一头的客户端有没有数据要发送。如果出现这种情况，客户端就会在写入半截请求报文时发现出现了连接错误。</p><h3 id="Conetent-Length-及-截尾操作"><a href="#Conetent-Length-及-截尾操作" class="headerlink" title="Conetent-Length 及 截尾操作"></a>Conetent-Length 及 截尾操作</h3><p>每条HTTP响应都应该有精确的Content-Length首部，用来描述响应主体的尺寸。<strong>如果老的HTTP服务器省略了Content-Length或者包含错误的长度指示，这样就要一来服务器发出连接关闭来说明数据的真是末尾</strong>。</p><h3 id="连接关闭容限-重试及幂等性"><a href="#连接关闭容限-重试及幂等性" class="headerlink" title="连接关闭容限,重试及幂等性"></a>连接关闭容限,重试及幂等性</h3><p>即使在非错误情况下,连接也可以在任意时刻关闭。<br>HTTP应用程序要做好正确处理非预期关闭的准备。<br>如果在客户端执行事务的过程中, 传输连接关闭了, 那么, 除非事务处理会带来一些副作用, 否则客户端就应该重新打开连接, 并重试一次。<br>对管道化连接来说, 这种情况更加严重一些。客户端可以将大量请求放入队列中排队, 但源端服务器可以关闭连接, 这样就会留下大量未处理的请求, 需要重新调度。</p><p>副作用是很重要的问题, 如果在发送出一些请求数据之后, 收到返回结果之前, 连接关闭了, 客户端就无法百分之百地确定服务器端实际激活了多少事务。<br>有些事务, 比如GET一个静态的HTML页面, 可以反复执行多次, 也不会有什么变化。而其他一些事务, 比如向一个在线书店POST一张订单, 就不能重复执行, 不然会有下多张订单的危险。</p><p>如果一个事务， 不管是执行一次还是很多次，得到的结果都相同, <strong>这个事务就是幂等的</strong>。实现者们可以认为GET、HEAD、PUT、DELETE、TRACE和OPTIONS方法都共享这一特性。客户端不应该以管道化方式传送非幂等请求(比如POST)。<br>否则，传输连接的过早终止就会造成一些不确定的后果。要发送一条非幂等请求，就需要等待来自前一条清求的响应状态。</p><p>尽管用户Agent代理可能会让操作员来选择是否对请求进行重试，但一定不能自动重试非幂等方法或序列。<br><strong>比如，大多数浏览器都会在重载一个缓存的POST响应时提供一个对话框，询问用户是否希望再次发起事务处理</strong>。</p><h3 id="正常关闭连接"><a href="#正常关闭连接" class="headerlink" title="正常关闭连接"></a>正常关闭连接</h3><ol><li><p>正常关闭连接<br>TCP连接是双向的。TCP连接的每一端都有一个输入队列和一个输出队列, 用于数据的读或写。放入一端输出队列中的数据最终会出现在另一端的输入队列中。</p></li><li><p>完全关闭与半关闭<br>应用程序可以关闭TCP输入和输出信道中的任意一个, 或者将两者都关闭了。<br>套接字调用close()会将TCP连接的输入和输出信道都关闭了, 这被称作 “完全关闭”。<br>还可以用套接字调用shutdown()单独关闭输入或输出信道。这被称为”半关闭”。<br><img src="/img/http/close-shutdown-pipeline.png" width="350/"></p></li><li><p>TCP关闭及重置错误<br>….</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《HTTP权威指南》– 第四章<br>《图解HTTP协议》<br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/HTTP</a><br><a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">https://tools.ietf.org/html/rfc2616</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常被误解的Connection首部&quot;&gt;&lt;a href=&quot;#常被误解的Connection首部&quot; class=&quot;headerlink&quot; title=&quot;常被误解的Connection首部&quot;&gt;&lt;/a&gt;常被误解的&lt;code&gt;Connection&lt;/code&gt;首部&lt;/h2&gt;
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>11. 内容协商与转码</title>
    <link href="http://blog.renyimin.com/2017/12/06/http/2017-12-06-HTTP-11/"/>
    <id>http://blog.renyimin.com/2017/12/06/http/2017-12-06-HTTP-11/</id>
    <published>2017-12-06T10:50:27.000Z</published>
    <updated>2018-05-09T06:26:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>一个URL常常需要代表若干不同的资源</p><blockquote><p>例如那种需要以多种语言提供其内容的网站站点。<br> 如果某个站点有 ‘说法语的’ 和 ‘说英语的’ 两种用户, 它可能想用这两种语言提供网站站点信息;<br> 理想情况下，服务器应当向英语用户发送英文版，向法语用户发送法文版; 而用户只要访问网站主页就可以得到相应语言的内容。</p></blockquote></li><li><p>HTTP提供了 <code>内容协商</code> 方法，允许客户端和服务器作这样的决定。<br> 通过这些方法，单一的URL就可以代表不同的资源(比如，同一个网站页面的法语版和英语版)，这些不同的版本称为<code>变体</code>。</p></li><li><p>除了根据 <code>内容协商</code> 来决定URL代表的是那种版本的资源。另外, 对于有些特定的URL来说, 服务器还可以根据一些<strong>其他原则</strong>来决定发送什么内容给客户端最合适。在有些场合下, 服务器甚至可以自动生成定制的页面。比如，服务器可以为手持设备把HTML页面转换成WML页面，这类动态内容变换被称为<strong>转码</strong>。这些变换动作是HTTP客户端和服务器之间进行内容协商的结果。</p></li></ol><h2 id="内容协商技术"><a href="#内容协商技术" class="headerlink" title="内容协商技术"></a>内容协商技术</h2><ol><li><p>共有3种不同的方法可以决定服务器上哪个页面最适合客户端: <code>让客户端来选择</code>, <code>服务器自动判定</code>, 或 <code>让中间代理来选</code>。这3种技术分别称为<code>客户端驱动的协商</code>、<code>服务器驱动的协商</code> 以及 <code>透明协商</code></p></li><li><p>内容协商技术摘要如下:<br><img src="/img/http/内容协商.png" width="600"></p></li></ol><h3 id="客户端驱动-300"><a href="#客户端驱动-300" class="headerlink" title="客户端驱动 (300)"></a>客户端驱动 (300)</h3><p>1.对于服务器来说，收到客户端请求时只是发回响应，在其中列出可用的页面，让客户端决定要看哪个，这是最容易的事情。</p><ul><li>很显然，这是服务器最容易实现的方式，而且客户端很可能选择到最佳的版本(只要列表中有让客户端选择的足够信息)。</li><li>不利之处是<strong>每个页面都需要两次请求</strong>: <strong>第一次获取列表</strong>，<strong>第二次获取选择的副本</strong>。<br>这种技术速度很慢且过程枯燥乏味，让用户厌烦。</li></ul><p>2.从实现原理上来说，服务器实际上有两种方法为客户端提供选项:</p><ul><li>一是发送回一个HTML文档，里面有到该页面的各种版本的链接和每个版本的描述信息;</li><li>另一种方法是发送回HTTP/1.1响应时，使用 <code>300 Multiple Choices</code> 响应代码。客户端浏览器收到这种响应时，在前一种情况下(发回html文档的情况)，会显示一个带有链接的页面; 在后一种情况下，可能会弹出对话窗口，让用户做选择。不管怎么样，决定是由客户端的浏览器用户作出的</li></ul><p>3.除了增加时延并且对每个页面都要进行繁琐的多次请求之外, 这种方法<strong>还有一个缺点</strong>: 它需要多个URL, 公共页面要一个, 其他每种特殊页面也都要一个。</p><h3 id="服务器驱动"><a href="#服务器驱动" class="headerlink" title="服务器驱动"></a>服务器驱动</h3><p>1.之前已经知道了客户端驱动的协商存在的若干缺点。大部分缺点都涉及客户端和服务器之间通信量的增长, 这些通信量用来决定什么页面才是对请求的最佳响应。</p><p>2.而减少额外通信量的一种方法是<strong>让服务器来决定发送哪个页面回去</strong>，但为了做到这一点，<strong>客户端必须发送有关客户偏好的足够信息</strong>，以便服务器能够作出准确的决策。服务器通过 <code>客户端请求的首部集</code> 来获得这方面的信息(客户偏好)!! 有以下两种机制可供HTTP服务器评估发送什么响应给客户端比较合适：</p><ul><li>检査 客户端请求中的<code>内容协商首部集</code>: 服务器察看客户端发送的 <code>Accept内容协商首部集</code>, 设法用相应的响应首部与之匹配;</li><li>根据其他(非内容协商)首部进行变通, 例如，服务器可以根据客户端发送的 <code>User-Agent</code> 首部来发送响应</li></ul><h4 id="客户端内容协商首部集"><a href="#客户端内容协商首部集" class="headerlink" title="客户端内容协商首部集"></a>客户端内容协商首部集</h4><p>1.客户端可以用下面列出的HTTP首部集发送用户的偏好信息</p><blockquote><p>Accept : 告知服务器发送何种媒体类型<br>Accept-Language : 告知服务器发送何种语言<br>Accept-Charset : 告知服务器发送何种字符集<br>Accept-Encoding : 告知服务器采用何种编码</p></blockquote><p>2.<strong>实体首部集</strong> 和 <strong>内容协商首部集</strong></p><ul><li><strong>注意</strong>: 内容协商首部集与实体首部非常类似(比如 <code>Accept-Encoding</code> 和 <code>Content-Encoding</code>)。不过, 这两种首部的用途截然不同:</li><li><p><code>实体首部集</code>,像运输标签,它们描述了把报文从服务器传输给客户端的过程中必须的各种报文主体属性; 如下列出的实体首部集来匹配客户端的<code>Accept内容协商首部集</code></p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Accet首部            实体首部</div><div class="line">Accept    　　　　　　Content-Type</div><div class="line">Accept-Language     Content-Language</div><div class="line">Accept-Charset      Content-Type</div><div class="line">Accept-Encoding     Content-Encoding</div></pre></td></tr></table></figure><p>  （由于HTTP是无状态的协议，表示服务器不会在不同的请求之间追踪客户端的偏好，所以客户端必须在每个请求中都发送其偏好信息）</p></li><li><p>而<code>内容协商首部集</code>是由客户端发送给服务器用来告知其偏好信息的, 以便服务器可以从文档的不同版本中选择出最符合客户端偏好的那个来提供服务;</p></li></ul><h4 id="内容协商首部中的质量值"><a href="#内容协商首部中的质量值" class="headerlink" title="内容协商首部中的质量值"></a>内容协商首部中的质量值</h4><p>1.HTTP协议中定义了质量值，允许客户端为每种偏好类别列出多种选项，并为每种偏好选项关联一个优先次序。<br>    例如，客户端可以发送下列形式的<code>Accept-Language</code>首部：<code>Accept-Language: en; q=0.5, fr; q=0.0 , nl; q=1.0, tr; q=0.0</code><br>    其中q值的范围从0.0-1.0(0.0是优先级最低的，而1.0是优先级最高的)。<br>    上面列出的那个首部，说明该客户端最愿意接收荷兰语(缩写为nl)文档，但英语(缩写为en)文档也行; 无论如何，这个客户端都不愿意收到法语(缩写为fr)或土耳 其语(缩写为tr)的版本;</p><p>2.<strong>注意</strong>: 偏好的排列顺序并不重要，只有与偏好相关的<code>q值</code>才是重要的;</p><h4 id="客户端其它请求首部集"><a href="#客户端其它请求首部集" class="headerlink" title="客户端其它请求首部集"></a>客户端其它请求首部集</h4><p>1.服务器也可以根据客户端其他请求首部集来匹配响应, 比如 <code>User-Agent</code> 首部。例如, 服务器知道老版本的浏览器不支持JavaScript语言，这样就可以向其发送不含有JavaScript的页面版本。</p><p>2.由于缓存需要尽力提供所缓存文档中正确的”最佳”版本，HTTP协议定义了服务器在响应中发送的 <code>Vary</code> 首部。<br>    这个首部告知<strong>缓存</strong>, <strong>客户端</strong>, 和<strong>所有下游的代理</strong>, 服务器根据哪些首部来决定发送响应的最佳版本。</p><h3 id="透明协商-vary首部"><a href="#透明协商-vary首部" class="headerlink" title="透明协商(vary首部)"></a>透明协商(vary首部)</h3><p>1.了支持<strong>透明内容协商</strong>，服务器必须有能力告知代理，服务器需要检査哪些请求首部，以便对客户端的请求进行最佳匹配。但是HTTP/1.1规范中没有定义任何透明协商机制, 不过却定义了 <code>Vary</code> 首部。服务器在响应中发送了Vary首部，以告知中间节点需要使用哪些请求首部进行内容协商</p><p>2.代理缓存可以为通过单个URL访问的文档保存不同的副本, <strong>如果服务器把它们的决策过程传给代理,这些代理就能代表服务器与客户端进行协商</strong>。<br>（缓存同时也是进行内容转码的好地方，因为部署在缓存里的通用转码器能对任意服务器，而不仅仅是一台服务器传来的内容进行转码）</p><p>3.对内容进行缓存的时候是假设内容以后还可以重用。然而，为了确保对客户端请求回送的是正确的已缓存响应, 缓存必须应用服务器在回送响应时所用到的大部分决策逻辑;</p><p>4.之前我们已经了解了客户端发送的<code>Accept内容协商首部集</code>; 也了解到, 为了给每条请求选择最佳的响应, 服务器使用了哪些与这些首部集匹配的相应<code>实体首部集</code>。其实, 代理缓存也必须使用相同的首部集来决定回送哪个已缓存的响应。</p><p>5.<strong>下图展示了涉及缓存的正确及错误的操作序列</strong>。</p><ul><li>缓存把第一个请求转发给服务器，并存储其响应。</li><li>对于第二个请求，缓存根据URL査找到了匹配的文档。但是，这份文档是法语版的，而请求者想要的是西班牙语版的。如果缓存只是把文档的法语版本发给请求者的话，它就犯了错误;</li><li>像上面2中提到的, 代理缓存也必须要根据客户端发送来的<code>内容协商首部</code>来给客户端返回正确的响应<br>  <img src="/img/http/cache-beiyong-error.png" width="550"></li></ul><h4 id="Vary首部"><a href="#Vary首部" class="headerlink" title="Vary首部"></a>Vary首部</h4><p>1.下面是浏览器和服务器发送的一些典型的请求及响应首部:<br>    <img src="/img/http/vary-01.png" width="490"></p><p>2.然而, 如果服务器的决策不是依据<code>Accept</code>首部集，而是比如<code>User-Agent</code>首部的话，情况会如何？<br>例如, 服务器可能知道老版本的浏览器不支持JavaScript语言, 因此可能会回送不包含JavaScript的页面版本。<br>如果服务器是根据其他首部来决定发送哪个页面的话, <strong>和Accept首部集一样, 缓存也必须知道这些首部是什么, 这样才能在选择回送的页面时做出同样的逻辑判断</strong>。</p><p>3.HTTP的 <code>Vary</code> 响应首部中列出了所有客户端请求首部, 服务器可用这些首部来选择文档或产生定制的内容(在常规的内容协商首部集之外的内容)。例如, 若所提供的文档取决于<code>User-Agent</code>首部, <code>Vary首部</code>就必须包含<code>User-Agent</code>;</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>当新的请求到达时, 代理缓存会根据<code>内容协商首部集</code>来寻找最佳匹配。但在把文档提供给客户端之前, <strong>它还必须检査服务器有没有在已缓存响应中发送Vary首部</strong>。</li><li>如果有Vary首部, 那么新请求中那些首部的值必须与旧的已缓存的响应的请求首部相同。(也就是说,代理缓存也会保存旧的请求的请求首部和响应首部, 下面一句话更加肯定这一点)</li><li>因为服务器可能会根据客户端请求的首部来改变响应, 为了实现透明协商, 代理缓存就必须为每个已缓存变体保存<strong>客户端请求首部</strong>和<strong>相应的服务器响应首部</strong>)<br> <img src="/img/http/vary-02.png" width="650"></li><li>如果某服务器的Vary首部看起来像 <code>Vary: User-Agent, Cookie</code> 这样，大量不同的User-Agent和Cookie值将会产生非常多的变体, 而代理缓存必须为每个变体保存其相应的文档版本。当缓存执行査找时，首先会对内容协商首部集进行内容匹配，然后比较请求的变体与缓存的变体。如果无法匹配，缓存就从原始服务器获取文档</li></ol><h2 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h2><ol><li><p>我们已经讨论了一个机制, 该机制可以让客户端和服务器从某个URL的一系列文档中挑选出最适合客户端的文档。但是, 实现这些机制的前提是，存在一些满足客户端需求的文档—不管是完全满足还是在一定程度上满足;</p></li><li><p>然而, 如果服务器没有能满足客户端需求的文档会怎么样呢？服务器可以给出一个错误响应。但理论上，服务器可以把现存的文档转换成某种客户端可用的文档, 这种选项称为<strong>转码</strong>;</p></li><li><p>下面列出了一些假设的转码</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">转换之前 　　　　　　　　　　　　转换之后</div><div class="line">HTML文档    　　　　　　　　　　WML文档</div><div class="line">高分辨率图像    　　　　　　　　低分辨率图像</div><div class="line">彩色图像    　　　　　　　　　　黑白图像</div><div class="line">有多个框架的复杂页面    　　　　没有很多框架或图像的简单文本页面</div><div class="line">有Java小应用程序的HTML页面    没有Java小应用程序的HTML页面</div><div class="line">有广告的页面    　　　　　　　　去除广告的页面</div></pre></td></tr></table></figure></li><li><p>有3种类别的转码: <strong>格式转换</strong>、<strong>信息综合</strong>以及<strong>内容注入</strong></p></li></ol><h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><ol><li><p>格式转换是指将数据从一种格式转换成另一种格式, 使之可以被客户端査看。通过HTML到WML的转换, 无线设备就可以访问通常供桌面客户端査看的文档了。通过慢速连接访问Web页面的客户端并不需要接收高分辨率图像, 如果通过格式转换降低图像分辨率和颜色来减小图像文件大小的话, 这类客户端就能更容易地査看图像比较丰富的页面了。</p></li><li><p>格式转换可以由如下<code>内容协商首部集</code>来驱动, 但也能由 <code>User-Agent</code> 首部来驱动。注意: <code>内容转换或转码</code> 与 <code>内容编码</code> 或 <code>传输编码</code> 是不同的, 后两者一般用于更高效或安全地传输内容, 而前两者则可使访问设备能够査看内容;</p><pre><code class="php">Accet首部            实体首部Accept    　　　　　　Content-TypeAccept-Language     Content-LanguageAccept-Charset      Content-TypeAccept-Encoding     Content-Encoding</code></pre></li></ol><h3 id="信息综合"><a href="#信息综合" class="headerlink" title="信息综合"></a>信息综合</h3><ol><li><p>从文档中提取关键的信息片段称为信息综合(information synthesis), 这是一种有用的转码操作。这种操作的例子包括根据小节标题生成文档的大纲，或者从页面中删除广告和商标</p></li><li><p>根据内容中的关键字对页面分类是更精细的技术, 有助于总结文档的精髓。这种技术常用于Web页面分类系统中，比如门户网站的Web页面目录</p></li></ol><h3 id="内容注入"><a href="#内容注入" class="headerlink" title="内容注入"></a>内容注入</h3><p>参见P423</p><h3 id="转码与静态预生成的对比"><a href="#转码与静态预生成的对比" class="headerlink" title="转码与静态预生成的对比"></a>转码与静态预生成的对比</h3><ol><li><p>转码的替代做法是在Web服务器上建立Web页面的不同副本, 例如一个是HTML, 一个是WML, 一个图像分辨率高，一个图像分辨率低；一个有多媒体内容，一个没有。</p></li><li><p>但是，这种方法不是很切合实际，原因很多：</p><ul><li>某个页面中的任何小改动都会牵扯很多页面，需要很多空间来存储各页面的不同版本，而且使页面编目和Web服务器编程(以提供正确的版本)变得更加困难。</li><li>有些转码操作，比如广告插入(尤其是定向广告插入)，就不能静态实现, 因为插入什么广告和请求页面的用户有关</li></ul></li><li><p>对单一的根页面进行即时转换，是比静态的预生成更容易的解决方案。<br> 但这样会在提供内容时增加时延。不过有时候其中一些计算可以由第三方进行，这样就减少了Web服务器上的计算负荷——比如可以由代理或缓存中的外部Agent完成转换</p></li><li><p>下图显示了在代理缓存中进行的转码<br> <img src="/img/http/zhuanma-01.png" width="430"></p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><http权威指南></http权威指南>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个URL常常需要代表若干不同的资源&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如那种需要以多种语言提供其内容的网站站点。
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>05. 缓存</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-05/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-05/</id>
    <published>2017-11-30T13:27:36.000Z</published>
    <updated>2018-05-15T09:20:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>关于缓存的概念本文就不详细展开说明了, 这里所说的web缓存其实就是: 为了降低服务器端的访问频率, 减少通信数量, 一些缓存设备, 如客户端或一些中继代理服务器将获取的数据保存下来, 当再次需要时, 就使用所保存的数据; (当请求抵达缓存设备时, 如果缓存设备本地有”已缓存的”副本, 就可以从本地设备而不是原始服务器中提取这个文档)</p><p>使用缓存的优点</p><ul><li>减少了服务器端的通信数量, 可以提升用户访问速度</li><li>在网络断开的状态下, 也可以在某种程度上继续向用户提供服务</li><li>减少了冗余的数据传输, 节省了你的网络费用</li><li>缓解了网络本身的瓶颈问题, 不需要更多的带宽就能够更快地加载页面</li><li>降低了<strong>距离时延</strong>, 因为从较远的地方加载页面会更慢一些<br>(即使带宽不是问题, 距离也可能成为问题。<strong>每台网络路由器都会增加因特网流量的时延</strong>。即使客户端和服务器之间没有太多的路由器, <strong>光速自身也会造成显著的时延</strong>。)</li></ul><p>综上所述, 缓存对用户体验和通信成本都会造成很大的影响, 所以我们要尽可能地去灵活使用缓存机制。</p><h3 id="缓存命中"><a href="#缓存命中" class="headerlink" title="缓存命中"></a>缓存命中</h3><p>如果一些请求到达缓存设备时, 缓存设备可以用本地已有的副本为这些请求提供服务, 就被称为<strong>缓存命中</strong>;</p><h3 id="缓存未命中"><a href="#缓存未命中" class="headerlink" title="缓存未命中"></a>缓存未命中</h3><p>如果一些请求到达缓存设备时, 缓存设备本地没有副本提供给这些请求(或者由于某些策略需要无法将副本提供给请求), 而将请求转发给原始服务器, 这就被称为<strong>缓存未命中</strong>;</p><h3 id="缓存再验证"><a href="#缓存再验证" class="headerlink" title="缓存再验证"></a>缓存再验证</h3><p>文档过期后, 缓存设备并不是直接去原始服务器重新请求文档, 而是尽可能先去原始服务器查看其缓存文档有没有发生变化, 这种 <code>新鲜度检测</code> 被称为 <code>HTTP缓存再验证</code>;</p><h3 id="再验证命中"><a href="#再验证命中" class="headerlink" title="再验证命中"></a>再验证命中</h3><p>参看下文</p><h3 id="再验证未命中"><a href="#再验证未命中" class="headerlink" title="再验证未命中"></a>再验证未命中</h3><p>参看下文</p><h3 id="公有缓存和私有缓存"><a href="#公有缓存和私有缓存" class="headerlink" title="公有缓存和私有缓存"></a>公有缓存和私有缓存</h3><p>通用首部字段(general header fields)<code>Cache-Control</code>有两个缓存响应指令: <code>public</code> 和 <code>private</code> </p><p>缓存可以是<code>单个用户专用的</code>, 也可以是<code>数千名用户共享的</code></p><ul><li>专用缓存被称为<code>私有缓存(private cache)</code>, 私有缓存是个人的缓存, 包含了单个用户最常用的页面 ;</li><li>共享缓存被称为<code>公有缓存(public cache)</code>, 公有缓存包含了某个用户团体常用页面 ;</li></ul><p>私有缓存<br>私有缓存不需要很大的动力或存储空间, 这样就可以将其做的很小, 很便宜;<br>Web浏览器中就有内建的私有缓存—大多数浏览器都会将常用文档缓存在你个人电脑的磁盘和内存中, 并且允许用户去配置缓存的大小和各种设置;</p><p>公有缓存</p><ol><li>公有缓存是特殊的共享代理服务器, 被称为缓存代理服务器(caching proxy server), 或者更常见地被称为代理缓存(proxy cache);</li><li>代理缓存会从自己本地缓存中给用户提供缓存资源, 或者代表用户与服务器进行联系。公有缓存会接受来自多个用户的访问, 所以通过它可以更好地减少冗余流量</li><li>如下图: <ul><li>每个客户端都会重复地访问一个(还不在私有缓存中的)新的”热门”文档。每个私有缓存都要获取同一份文档, 这样它就会多次穿过网络。</li><li>而使用共享的公有缓存时, 对于这个流行的对象, 缓存只要取一次就行了, 它会用共享的副本为所有的请求服务, 以降低网络流量。<br><img src="/img/http/private-public-cache-01.png" width="400/"></li></ul></li></ol><h2 id="缓存模型"><a href="#缓存模型" class="headerlink" title="缓存模型"></a>缓存模型</h2><p>原始服务器的内容不可能是一成不变的, 所以缓存服务器还需要不时地去进行检测, 看看它们保存的副本是否是服务器上最新的副本;</p><p>HTTP的缓存机制在RFC7234中进行了详细的定义, 分为<strong>过期模型(Expiration Model)</strong> 和 <strong>验证模型(Validation Model)</strong> 两类;</p><p>在HTTP协议中, 缓存处于可用状态时称为 <code>fresh(新鲜)</code> 状态, 而处于不可用的状态时则称为 <code>stale(不新鲜)</code> 状态;</p><h3 id="过期模型"><a href="#过期模型" class="headerlink" title="过期模型"></a>过期模型</h3><ol><li><p>过期模型是指预先决定响应数据的保存期限, 当到达期限后, 就会再次访问原始服务器端来重新获得所需的数据;</p></li><li><p>过期模型可以通过在服务器的响应消息里包含何时过期的信息来实现, HTTP1.1中定义了两种实现方法:</p><ul><li><code>Cache-Control:max-age</code> 响应消息首部<blockquote><p>Cache-control 表示从当前时刻开始所经过的秒数; 该首部常用于控制各类缓存, 除了 max-age 外, 还可以进行各种指定; 稍后会进行介绍</p></blockquote></li><li><p><code>Expires</code> 响应消息首部</p><blockquote><p>老式的HTTP/1.0的实体首部字段, <code>Expires</code> 是使用绝对时间, 并使用RFC 1123中定义的时间格式, 依赖于计算机时钟的正确设置</p></blockquote></li><li><p>它们都可以给响应内容加一个过期时间, <code>Cache-Control</code> 首部能使用相对时间, 所以更倾向与使用比较新的 <code>Cache-Control</code> 首部</p></li><li><p>当以上两者同时使用的时候, <code>Cache-Control</code> 将获得优先</p></li></ul></li><li><p><strong>注意</strong>: </p><ul><li>有些服务器会回送一个 <code>Expires:0</code> 响应头, 试图将文档置于永远过期的状态, <strong>但这种语法是非法的</strong>, 可能给某个软件带来问题, 应该试着支持这种结构的输入, 但是不应该产生这种结构的输出;</li><li>而 <code>Cache-Control</code> 的 <code>max-age</code> 则可以设置 <code>Cache-Control: max-age=0</code>;</li></ul></li><li><p>Date 首部</p><ul><li><code>max-age</code>的计算会用到名为<code>Date</code>的首部, 该首部用来显示服务器端生成响应消息的时间信息, 从该时间开始计算, 当经过的时间超过 <code>max-age</code> 值时, 则可以认为缓存已过期;</li><li>文档过期算法为: <code>expirationTime</code>(过期时间) = <code>responseTime(Date头)</code> + <code>freshnessLifetime(max-age/Exprie值)</code> - <code>currentAge(Age头)</code></li></ul></li></ol><h3 id="验证模型"><a href="#验证模型" class="headerlink" title="验证模型"></a>验证模型</h3><ol><li><p>文档过期后, 缓存设备并不是直接去服务器重新请求文档, 而是尽可能先去原始服务器查看其缓存文档有没有发生变化, 这种 <code>新鲜度检测</code> 被称为 <code>HTTP缓存再验证</code>;<br> 当然, 在服务器没有返回”将缓存数据保存多久”的信息, 服务器就需要通过验证模型的两个响应首部字段(<code>Last-Modified</code> 和 <code>ETag</code>)来告知客户端更新相关的信息, 努力减少客户端不必要的访问;</p></li><li><p>所以说, 仅仅是已缓存文档过期了, 还不能说明该过期文档和原始服务器上的文档有实际的区别, 这只是意味着 <strong>到时间进行再验证了</strong> ; 因为客户端还可以设置一些缓存控制项来进行影响;</p></li><li><p>在缓存文档过期之前, 缓存设备可以随意使用这些副本, 而且无需与服务器做任何联系, 除非</p><ul><li>客户端请求中包含 “阻止提供缓存” 的首部 <code>Cache-Control:no-store</code> ;</li><li>或者客户端请求中包含 “只有经过验证才能返回缓存副本”的首部 <code>Cache-Control:no-cache</code> ; </li></ul></li><li><p>但是一旦已缓存文档过期, 缓存设备就必须与服务器进行再验证核对, 除非你设置了 <code>Cache-Control:only-if-cached</code>, 要求只使用缓存;</p></li></ol><h3 id="再验证依据"><a href="#再验证依据" class="headerlink" title="再验证依据"></a>再验证依据</h3><ol><li><p>为了有效地进行再验证, HTTP定义了一些特殊的请求, 不用从服务器上获取整个对象, 就可以快速检测出内容是否是最新的, HTTP的<code>条件方法</code>可以高效地实现再验证;</p></li><li><p>HTTP定义了5个条件请求首部, 对 <code>缓存再验证</code> 来说有用的2个首部是 <code>If-Mofified-Since</code> 和 <code>If-None-Match</code>, 所有的条件首部都以前缀<code>If-</code>开头。<br> <img src="/img/http/revalidate-01.png" width="500/"></p></li><li><p>再验证 请求首部字段 <code>If-Modified-Since</code></p><ul><li>如果自<code>If-Modified-Since</code>指定日期之后, 文档被修改了, <code>If-Modified-Since</code> 条件就为真, 通常GET就会成功执行, 携带新首部的新文档会被返回给缓存, 新首部除了其他信息之外, 还包含了一个新的过期日期;</li><li>如果自<code>If-Modified-Since</code>指定日期之后, 文档没被修改, <code>If-Modified-Since</code> 条件就为假, 会向客户端<strong>返回一个小的 304 Not Modified响应报文</strong>, 为了提高有效性, <strong>不会返回文档主体</strong>; 否则, 如果文档发生了变化, 就返回带有新主体的200响应;</li><li>请求首部字段 <code>If-Modified-Since</code> 和 实体首部字段 <code>Last-Modified</code> 配合工作;</li></ul></li><li><p>再验证 请求首部字段 <code>If-None-Match</code></p><ul><li>有些文档可能会被周期性地重写, 但实际包含的数据常常却是一样的。<strong>尽管内容没有发生变化, 但是修改日期会发生变化</strong>;</li><li>有些文档可能内容被修改了, 但是<strong>所做的修改并不重要</strong>, 不需要让世界范围内的缓存都重装数据(比如对拼写或注释的修改), 涉及到弱验证器;</li><li>有些服务器无法准确地判定其页面的最后修改日期;</li><li><p>有些服务器提供的文档会在亚秒间隙发生变化(比如,实时监视器), 对这些服务器来说, <strong>以秒为粒度的修改日期可能就不够用了</strong>;</p></li><li><p>为了解决上述问题, HTTP有一个被称为 <code>实体标签(ETag)</code> 的 <code>版本标识符</code>, 这个实体标签是附加到文档上的任意标签, 标签可能可能包含了文档序列号或版本名, 或是文档内容的校验及其他指纹信息。<br>当对文档进行修改时, 可以修改文档的实体标签来说明这个新的版本。这样, 如果实体标签被修改了, 缓存就可以用 <code>If-None-Match</code> 条件首部来GET文档的新副本了;</p></li><li><p>如果<code>If-None-Match</code> 与 <code>If-Modified-Since</code> 同时存在, 两个都要进行验证;</p></li><li><p>请求首部字段 <code>If-None-Match</code> 和 响应首部字段 <code>ETag</code> 配合工作;</p></li></ul></li><li><p>再验证命中: 缓存到期后, 在对副本进行再验证时, 会向原始服务器发送一个小的再验证请求。如果发现内容没有变化, 服务器会以一个小的 <code>304 Not Modified</code> 进行响应;</p><ul><li>只要缓存设备知道副本仍然有效, 就会再次将副本标识为暂时新鲜的, 并将副本提供给客户端, 而不用原始服务器重新返回文档, 这被称为<strong>再验证命中(revalidate hit)</strong> 或 <strong>缓慢命中(slow hit)</strong>;<br><img src="/img/http/revalidate-hit-01.png" width="350/"></li><li>缓存再验证命中还是需要与原始服务器进行核对, 所以会比单纯的缓存命中要慢, 但是它并没有从服务器中获取对象数据, 所以要比缓存未命中要快一些。</li></ul></li><li><p>再验证未命中: 如果缓存发现原始服务器对象与已缓存副本不同, 则服务器会向客户端发送一条普通的, 带有完整内容的 <code>HTTP 200 OK</code> 响应;<br> <img src="/img/http/revalidate-not-hit-01.png" width="350/"></p><ul><li>这种方式 不仅需要与原始服务器进行核对, 而且会从服务器中获取对象数据, 所以理论上貌似要比缓存未命中要慢一些;</li><li>如果再验证发现服务器对象已经被删除, 服务器就回送一个 <code>404 Not Found</code> 响应, <strong>缓存也会将其本地副本删除</strong>;</li></ul></li><li><p>弱验证器</p><ul><li>只要原始服务器内容发生变化, 则实体标签就会变化, 正常情况下, 强验证器就会对比失败, 导致服务器会在一个 <code>200 OK</code> 响应中返回新的内容以及新的<code>Etag</code>标签;</li><li>有时, 服务器希望对文档进行一些不重要的修改, 并且不需要使所有已缓存副本都失效<br>HTTP1.1支持的”弱验证器”, 就允许对一些内容做修改, 此时服务器会用前缀 <code>W/</code> 来标识弱验证器</li><li>不管相关的实体值以何种方式发生了变化, 强实体标签都要发生变化, 而相关实体在语义上发生了比较重要的变化时, 弱实体标签页应该发生变化</li></ul></li></ol><h2 id="vary"><a href="#vary" class="headerlink" title="vary"></a>vary</h2><p>//todo</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>再验证命中 比 缓存未命中 要快</strong><br><strong>再验证未命中 几乎和 缓存未命中 速度一样</strong></p><h2 id="Cache-Control-缓存控制字段详解"><a href="#Cache-Control-缓存控制字段详解" class="headerlink" title="Cache-Control 缓存控制字段详解"></a>Cache-Control 缓存控制字段详解</h2><p>1.之前在<a href="/2017/11/30/http/2017-11-30-HTTP-04/">各通用首部字段详解</a>已经对各选项进行了说明;</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>(<a href="https://stackoverflow.com/questions/33818854/what-is-difference-between-max-age-and-max-stale-in-cache-control-mechanism" target="_blank" rel="external">HTTP Cache-Control: max-age和max-stale=s的区别</a>)</li><li><code>immutable</code> : 属于缓存控制的一个扩展属性, <a href="http://www.jdon.com/performance/cache-control-immutable.html" target="_blank" rel="external">参考</a><blockquote><p>当一个支持immutable的客户端浏览器看到这个属性时, 它应该知道, 如果没有超过过期时间，那么服务器端该页面内容将不会改变, 这样浏览器就不应该再发送有条件的重新验证请求(比如通过If-None-Match 或 If-Modified-Since等条件再向服务器端发出更新检查);<br>也就是说, 通常过去我们使用304回复客户端该页面内容没有变化，但是如果用户按浏览器的刷新或F5键，浏览器会再次向服务器端发出该页面内容请求，服务器端如果确认该页面没有变化，那么发回304给客户端，不再发送该页面的实体内容，虽然这样节省了来回流量，但是如果大型网站的很多用户为了得到及时信息，经常会刷新浏览器，这就造成了大量刷新请求，向服务器端求证该页面是否改变，这会影响网站的带宽，也增加服务器端验证压力。<br><strong>而新的选项immutable可以杜绝这种现象</strong>。<br>immutable可以节省HTTP请求,缩短请求时间,这是因为服务器不必再处理304响应了。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存&quot;&gt;&lt;/a&gt;缓存&lt;/h2&gt;&lt;p&gt;关于缓存的概念本文就不详细展开说明了, 这里所说的web缓存其实就是: 为了降低服务器端的访问频率, 减少通信数量, 一些缓存设备, 如客户
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>04. 各通用首部字段详解</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-04/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-04/</id>
    <published>2017-11-30T11:50:02.000Z</published>
    <updated>2018-05-09T06:26:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cache-Control-缓存能力控制"><a href="#Cache-Control-缓存能力控制" class="headerlink" title="Cache-Control 缓存能力控制"></a>Cache-Control 缓存能力控制</h2><p>1.Cache-Control 缓存指令是单向的, 即请求中存在一个指令并不意味着响应中将存在同一个指令;</p><ul><li>该指令是可选的;</li><li>指令可以有多个选项, 选项之间通过 <code>,</code> 分隔;</li></ul><p>2.可以按请求和响应分为(P377)</p><ul><li>缓存请求指令(选项如下)<br><img src="/img/http/cache-control-request.png" width="500/"></li><li>缓存响应指令(选项如下)<br><img src="/img/http/cache-control-response.png" width="500/"></li></ul><p>3.注意 <code>no-cache</code> 和 <code>must-revalidate</code> 的区别</p><ul><li>no-cache: 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验;</li><li>must-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去原始服务器进行有效性校验。(这应该是缓存系统的默认行为, 但must-revalidate指令使得这个要求是明确的<a href="https://stackoverflow.com/questions/2932890/http-cache-control-max-age-must-revalidate" target="_blank" rel="external">参考</a>;</li><li><a href="https://segmentfault.com/a/1190000007317481" target="_blank" rel="external">可参考</a></li></ul><p>更多参考后面的博文<a href="/2016/11/30/http/2016-11-30-HTTP-05-cache/">缓存相关</a>中的介绍</p><h2 id="Pragma-兼容"><a href="#Pragma-兼容" class="headerlink" title="Pragma 兼容"></a>Pragma 兼容</h2><p>Pragma是HTTP1.1之前版本的历史遗留字段, 仅作为与HTTP1.0做向后兼容;<br>除了与只理解 <code>Pragma:no-cache</code> 的HTTP/1.0应用程序进行交互时使用; HTTP/1.1应用程序都应该使用Cache-Control:no-cache;</p><h2 id="Date-当前时间"><a href="#Date-当前时间" class="headerlink" title="Date 当前时间"></a>Date 当前时间</h2><p>简单来说就是HTTP报文的创建日期, 它会参与到缓存的<code>过期时间</code>运算中;</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="external">公式</a>: <code>expirationTime = responseTime(Date头) + freshnessLifetime(max-age/Exprie值) - currentAge(Age头)</code></li><li><p>默认情况下, Date 的值为当前时间</p></li><li><p>而响应首部字段中的 <code>Age</code> 头字段, 是告诉客户端, 源服务器创建的缓存在代理服务器上已经保存了多久, 字段的单位为秒; 代理创建响应时必须加上首部字段<code>Age</code>; </p></li></ul><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><ol><li>该首部字段具备两个作用: <code>控制不再转发给代理的首部字段</code> 和 <code>管理持久连接</code>;</li><li>更多参考<a href="/2017-04-21-HTTP-Connection-Keep-Alive/">HTTP - 并行连接, 持久连接</a></li><li>未完待续…</li></ol><h2 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h2><ol><li><p>使用首部字段Via, 是为了追踪客户端与服务器之间的请求和响应报文的传输路径;<br>报文在经过代理或者网关时, 会先在首部字段Via中附加该服务器的信息, 然后再进行转发。</p><blockquote><p>Via首部是为了追踪传输路径, 所以也经常会和TRACE方法一起使用, 比如代理服务器受到由TRACE方法发送过来的请求(其中Max-Forward:0)时, 代理服务器就不能再转发该请求了,<br>这种情况下, 代理服务器会将自身的信息附加到Via首部后, 返回该请求的响应。</p></blockquote></li><li><p>未完待续…</p></li></ol><h2 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h2><p><strong>传输编码</strong></p><ol><li>该通用首部字段规定了传输报文主体时采用的编码方式;</li><li>HTTP/1.1的传输编码方式仅对分块传输编码有效, 即只能设置为 <code>Transfer-Encoding:chunked</code>;</li><li>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding" target="_blank" rel="external">MDN Doc</a>;</li><li><code>Content-Encoding</code> 和 <code>Transfer-Encoding</code> 二者经常会结合来用, 其实就是针对 Transfer-Encoding 的分块再进行 Content-Encoding 压缩;</li></ol><h3 id="对比-请求首部字段Accept-encoding"><a href="#对比-请求首部字段Accept-encoding" class="headerlink" title="对比 请求首部字段Accept-encoding"></a>对比 请求首部字段Accept-encoding</h3><p><strong>内容编码</strong> (P369)</p><ol><li><p>请求首部字段 <code>Accept-encoding</code> 是将客户端用户代理(浏览器)所<strong>支持的内容编码方式</strong>(通常是某种压缩算法) 及 <strong>内容编码方式的优先级顺序</strong>, 通知给服务器;</p><ul><li>通过内容协商, 服务端会选择一个客户端支持的方式, 使用并在 响应报文的实体首部字段 <code>Content-Encoding</code> 中通知客户端, 服务器选择了哪种内容编码方式;</li><li>另外, 可以一次性指定多种内容编码! </li><li>也可以使用权重q值来表示相对优先级;</li></ul></li><li><p>正常情况下, 主要采用4种编码方式: <code>gzip</code>, <code>compress</code>, <code>deflate</code>, <code>identity</code>;</p></li><li><p>即使客户端和服务器都支持某些相同的压缩算法，但如果<code>Accept-encoding:identity</code>, 表示客户端告诉服务器对响应主体不要进行压缩, 出现的两种情况的常见情形是：</p><ul><li>要发送的数据已经经过压缩, 再次进行压缩不会导致被传输的数据量更小, 一些图像格式的文件会存在这种情况;</li><li>服务器超载, 无法承受压缩需求导致的计算开销, 通常, 如果服务器使用超过80%的计算能力, 微软建议不要压缩;</li></ul></li><li><p>只要identity(表示不需要进行任何编码)没有被明确禁止使用(没有明确通过 <code>identity;q=0</code> 或是 <code>*;q=0</code> 指令明确设置 identity 的权重值为0), 一旦禁止就表示 服务端必须进行编码;</p><ul><li>没有禁止identity, 则服务器禁止返回表示客户端错误的 <code>406 Not Acceptable</code> 响应;</li><li>禁止identity后, 服务器才可能因为实在没有合适的内容编码类型而, 返回表示客户端错误的<code>406 Not Acceptable</code></li></ul></li><li><p>参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Encoding" target="_blank" rel="external">MDN</a></p></li></ol><h3 id="对比-实体首部字段-Content-encoding"><a href="#对比-实体首部字段-Content-encoding" class="headerlink" title="对比 实体首部字段 Content-encoding"></a>对比 实体首部字段 <code>Content-encoding</code></h3><p><strong>内容编码</strong><br>实体首部字段 <code>Content-encoding</code> 会告诉客户端, 服务器对实体的主体部分选用的内容编码方式</p><h3 id="对比-请求首部字段Accept-charset"><a href="#对比-请求首部字段Accept-charset" class="headerlink" title="对比 请求首部字段Accept-charset"></a>对比 <strong>请求首部字段<code>Accept-charset</code></strong></h3><p>请求首部字段 <code>Accept-charset</code> 会告诉服务器, 用户代理(浏览器)所支持的<code>字符集</code>和<code>字符集的相对优先顺序</code>。(P388)</p><ul><li>可以一次性指定多种字符集;</li><li>也可以使用权重q值来表示相对优先级;</li></ul><h2 id="对比-请求首部字段Accept-Language"><a href="#对比-请求首部字段Accept-Language" class="headerlink" title="对比 请求首部字段Accept-Language"></a>对比 <strong>请求首部字段<code>Accept-Language</code></strong></h2><p>请求首部字段 <code>Accept-charset</code> 会告诉服务器, 用户代理(浏览器)所支持的<code>语言</code>和<code>语言的相对优先顺序</code>。</p><ul><li>可以一次性指定多种字符集;</li><li>也可以使用权重q值来表示相对优先级;</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>请求首部字段<code>Accept-encoding</code> 和 实体首部字段<code>Content-encoding</code>来决定内容压缩方式;</li><li>通用首部字段<code>Transfer-Encoding</code>用来决定响应实体是否分块;</li><li>请求首部字段<code>Accept-charset</code>, <code>Accept-Language</code> 是客户端告诉服务端自己能支持的字符编码和语言及其中的优先顺序;</li></ol><h2 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h2><h2 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h2><h2 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h2><p>~~未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Cache-Control-缓存能力控制&quot;&gt;&lt;a href=&quot;#Cache-Control-缓存能力控制&quot; class=&quot;headerlink&quot; title=&quot;Cache-Control 缓存能力控制&quot;&gt;&lt;/a&gt;Cache-Control 缓存能力控制&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>03. HTTP状态码详解</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-03/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-03/</id>
    <published>2017-11-30T06:30:12.000Z</published>
    <updated>2018-05-23T01:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h2><ol><li><code>101</code>: 参考博文<a href="/2017/10/28/WebSocket/2017-10-28-websocket-02/">WebSocket简单示例分析</a> (做协议升级, 还会响应: <code>Connection: Upgrade</code>)<br>~~未完待续</li></ol><h2 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h2><blockquote><p><strong>Web API的设计与开发 P109</strong></p></blockquote><p><strong>200 OK</strong> : 200码非常出名, 似乎没有对它进一步说明的必要;</p><p><strong>201 Created</strong> : 当在服务器端创建数据成功时, 会返回201状态码;</p><ul><li>也就是使用 <code>POST</code> 请求方法的场景 (如:用户登录后添加了新用户, 上传了图片等新创建数据的场景)</li></ul><p><strong>202 Accepted</strong> : 在异步处理客户端请求时, 它用来表示服务器端已经接受了来自客户端的请求, 但处理尚未结束;</p><ul><li>在文件格式转换, 处理远程通知(Apple Push Notification等)这类很耗时的场景中, 如果等到所有处理都结束后才向客户端返回响应消息, 就会花费相当长的时间, 造成应用可用性不高; 这时采用的方法是服务器向客户端返回一次响应消息, 然后立刻开始异步处理。</li><li>202状态码就被用于告知客户端服务器端已经开始处理请求, 但整个处理过程尚未结束;</li><li>比如: 以LinkedIn的参与讨论的API为例<br>如果成功参与讨论并发表意见, 服务器端通常会返回201状态码;<br>但如果需要得到群主的确认, 那么所发表的意见就无法立即在页面显示出来, 这时服务器端就需要返回202状态码; 从广义上来看, 该场景也属于异步处理, 但和程序设计里的异步执行当然不同;</li></ul><p><strong><a href="http://www.laruence.com/2011/01/20/1844.html" target="_blank" rel="external">204 No Content</a></strong> : 正如其字面意思, 当响应消息为空时会返回该状态码。</p><ul><li>其实就是告诉浏览器, 服务端执行成功了, 但是没什么数据返回给你, 所以你不用刷新页面, 也不用导向新的页面; </li><li>在用<code>DELETE</code>方法删除数据时, 服务器端通常会返回204状态码(阮一峰博文也提到过, 对<code>DELETE</code>适用);</li><li>除此之外, 也有人认为在使用 <code>PATCH</code> 方法更新数据时, 因为只是更新已有数据, 所以返回204状态码更加自然;</li><li>关于204状态码的讨论可以参考 p111;</li></ul><p><strong>205 Reset Content</strong> : 告诉浏览器, 页面表单需要被重置; </p><ul><li>205的意思是服务端在接收了浏览器POST请求以后, 处理成功以后, 告诉浏览器, 执行成功了, 请清空用户填写的Form表单, 方便用户再次填写;</li></ul><p><strong>206 Partial Content</strong> : 成功执行了一个部分或Range(范围)的请求; </p><ul><li>206响应中, 必须包含 <code>Content-Range</code>, <code>Date</code> 以及 <code>ETag</code>或<code>Content-Location</code>首部;</li></ul><h2 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h2><p><strong>300 Multiple Choices</strong> : 客户端驱动方式进行内容协商时, 服务器可能返回多个连接供客户端进行选择 (比如多语言网站可能会出现);</p><p><strong>301 Moved Permanently</strong> : 在请求的URL已经被移除时使用, 响应的Location首部中应该包含资源现在所处的URL; (比较适合永久重定向)</p><ul><li>比如你从 www.test.com/location.php 中location跳转到 www.test.com/index.html 时, 如果响应的是301;</li><li><p>则即便稍后取消了location.php中的跳转(或者修改了跳转地址), 由于浏览器还是会认为你之前的跳转是永久性的, 再次访问www.test.com/location.php仍然会跳转到之前的跳转链接(除非清浏览器缓存);</p></li><li><p>另外, 假设你之前是先访问www.test.com/test.html, 然后通过<strong>post</strong>提交到www.test.com/location.php, 最后由location.php再进行跳转的话, 会转成<strong>GET</strong>;</p></li></ul><p><strong>302 Found</strong>: 与301类似, 但是客户端应该使用Location首部给出的URL来进行<strong>临时</strong>定位资源, 将来的请求仍应该使用老的URL;</p><ul><li>比如你从 www.test.com/location.php 中location跳转到 www.test.com/index.html 时, 如果响应的是302;</li><li><p>如果稍后取消了location.php中的跳转, 再次访问www.test.com/location.php, 会发现不会进行跳转, 而是访问到 location.php 修改后的代码 (不用清浏览器缓存);</p></li><li><p>另外, 假设你之前是先访问www.test.com/test.html, 然后通过<strong>post</strong>提交到www.test.com/location.php, 最后由location.php再进行跳转的话, 会转成<strong>GET</strong>;</p></li></ul><p><strong>303 See Other</strong> : HTTP/1.1使用303来实现和302一样的<strong>临时</strong>重定向;</p><p><strong>307 Temporary Redirect</strong></p><ul><li>HTTP/1.1规范要求用307来取代302进行临时重定向; (302临时重定向留给HTTP/1.0)</li><li>所以他也具备302临时重定向的特点;</li><li>但是, 与 302, 303 不同, 它会将客户端的POST请求, 发送给location的目标页; 假设你之前是先访问www.test.com/test.html, 然后通过<strong>post</strong>提交到www.test.com/location.php, 最后由location.php再进行跳转的话, 仍然是<strong>POST</strong>;</li></ul><p><strong><a href="https://tools.ietf.org/html/draft-reschke-http-status-308-07" target="_blank" rel="external">308 Permanent Redirect</a></strong></p><ul><li>貌似不是rfc2616的标准</li><li>具备和301永久重定向的特点, 需要清除浏览器缓存才行;</li><li>但是, 与 301 不同, 它会将客户端的POST请求, 发送给location的目标页; 假设你之前是先访问www.test.com/test.html, 然后通过<strong>post</strong>提交到www.test.com/location.php, 最后由location.php再进行跳转的话, 仍然是<strong>POST</strong>;</li></ul><p><strong>304 Not Modified</strong> : 参考博文<a href="/2017/11/30/http/2017-11-30-HTTP-05/">缓存相关</a></p><h2 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h2><blockquote><p><strong>Web API的设计与开发 P113</strong><br>4字头状态码主要用于描述因客户端请求的问题而引发的错误。<br>也就是说, 服务器端不存在问题, 但服务器端无法理解客户端发送的请求, 或虽然服务器端能够理解但请求却没有被执行, 当遇到这些情况引发的错误时, 服务器端便会向客户端返回这一类别的状态码。<br>因此, 当服务器端返回4字头的状态码时, 就表示客户端的访问方式发生了问题, 用户需要检查一下客户端的访问方式或访问的目标资源等。</p></blockquote><p><strong>400 Bad Request</strong> : 表示其他错误的意思, 即其他4字头状态码都无法描述的错误类型;</p><p><strong>401 Unauthorized</strong> : 表示<code>认证(Authentication)</code>类型的错误</p><ul><li>比如当需要先进行登录操作, 而却没有告诉服务器端所需的会话信息(比如token..), 服务器端就会返回401状态码, 告知客户端出错的大致原因;</li></ul><p><strong>403 Forbidden</strong> : 和401状态码比较相似, 所以也经常被混淆; 其实403表示的是<code>授权(Authotization)</code>类型的错误, 授权和认证的不同之处是:</p><ul><li><code>认证</code>表示”识别前来访问的是谁”, 而<code>授权</code>则表示”赋予特定用户执行特定操作的权限”</li><li>通俗地说: 401状态码表示”我不知道你是谁”, 403状态码表示”虽然知道你是谁, 但你没有执行该操作的权限”</li></ul><p><strong>404 Not Found</strong> : 表示访问的数据不存在, 但是</p><ul><li>例如当客户端湿度获取不存在的用户信息时, 或者试图访问原本就不存在的端点时, 服务器就会返回404状态码;</li><li>所以, 如果客户端想要获取用户信息, 却得到服务器端返回的404状态码, 客户端仅凭”404 Not Found”将难以区分究竟是用户不存在, 还是端点URI错误导致访问了原本不存在的URI;</li></ul><p><strong>405 Method Not Allowed</strong> : 表示虽然访问的端点存在, 但客户端使用的HTTP方法不被服务器端允许;</p><ul><li>比如客户端使用了POST方法来访问只支持GET方法的信息检索专用的API;</li><li>又比如客户端用了GET方法来访问更新数据专用的API等;</li></ul><p><strong>406 Not Acceptable</strong> : 服务器端API不支持客户端指定的数据格式时, 服务器端所返回的状态码; </p><ul><li>比如, 服务器端只支持JSON和XML输出的API被客户端指定返回YAML的数据格式时, 服务器端就会返回406状态码;</li></ul><p><strong>408 Request Timeout</strong> : 当客户端发送请求至服务器端所需的时间过长时, 就会触发服务器端的超时处理, 从而使服务器端返回该状态码;</p><p><strong>409 Conflict</strong>: 用于表示资源发生冲突时的错误 (est中就会有该错误码)</p><ul><li>比如通过指定ID等唯一键值信息来调用注册功能的API时, 倘若已有相同ID的数据存在, 就会导致服务器端返回409状态码;</li><li>在使用邮箱地址及Facebook ID等信息进行新用户注册时, 如果该邮箱地址或者ID已经被其他用户注册, 就会引起冲突, 这时服务器端就会返回409状态码告知客户端该邮箱地址或ID已被使用;</li></ul><p><strong>410 Gone</strong> : 和 404状态码 相同, 都表示访问资源不存在, 只是410状态码不单表示资源不存在, 还进一步告知<strong>资源曾经存在</strong>, 只是目前已经消失了;</p><ul><li>因此服务器端常在访问被删除的数据时返回该状态码, 但是为了返回该状态码, 服务器必须保存该数据已被删除的信息, 而且客户端也应该知晓服务器端保存了这样的信息;</li><li>但是在通过邮箱地址搜索用户信息的API中, 从保护个人信息的角度来说, <strong>返回410状态码的做法也会受到质疑</strong>; (所以在此种资源不存在的情况下, 为了稍微安全一些, 返回410状态码需要慎重)</li></ul><p><strong>413 Request Entity Too Large</strong> : 413也是比较容易出现的一种状态码, 表示请求实体过大而引发的错误</p><ul><li>请求消息体过长是指, 比如在上传文件这样的API中, 如果发送的数据超过了所允许的最大值, 就会引发这样的错误;</li></ul><p><strong>414 Request-URI Too Large</strong> : 414是表示请求首部过长而引发的错误</p><ul><li>如果在进行GET请求时, 查询参数被指定了过长的数据, 就会导致服务器端返回414状态码</li></ul><p><strong>415 Unsupported Media Type</strong> : 和406比较相似</p><ul><li>406我们知道是表示服务器端不支持客户端想要接收的数据格式</li><li>而415表示的是服务器端不支持客户端请求首部 <code>Content-Type</code> 里指定的数据格式, 也就是说, 当客户端通过POST,PUT,PATCH等方法发送的请求消息体的数据格式不被服务器支持时, 服务器端就会返回415状态码;</li><li>例如在只接收JSON格式的API里, 如果客户端请求时发送的是XML格式的数据去请求服务器端, 或者在 <code>Content-Type</code> 首部指定 <code>application/xml</code>, 都会导致该类型错误;</li></ul><p><strong>429 Too Many Requests</strong> : 是2012年RFC6585文档中新定义的状态码, 表示访问次数超过了所允许的范围;</p><ul><li>例如某API存在一小时内只允许访问100次的访问限制, 这种情况下入股哦客户端视图进行第101次访问, 服务器便会返回该状态码;</li><li>表示在一定的时间内用户发送了太多的请求, 即超出了”频次限制”, 在响应中，可以提供一个 <code>Retry-After</code> 首部来提示用户需要等待多长时间之后再发送新的请求;</li></ul><h2 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h2><blockquote><p>5字头状态码表示错误不发生在客户端, 而是由服务器自身问题引发的。</p></blockquote><p><strong>500 Internal Server Error</strong> : 是web应用程序开发里非常常见的错误, 当服务器代码里存在bug, 输出错误信息并停止运行等情况下, 就会返回该类型的错误;</p><ul><li>因此, 不仅限于API, 对于5字头状态码的错误, 都要认真监视错误日志, 使系统在出错时及时告知管理员, 以便在错误发生时做好应对措施, 防止再次发生。</li></ul><p><strong>501 Not Implemented</strong> : ???</p><p><strong>502 Bad GateWay</strong> : ???</p><p><strong>503 Service Unavaliable</strong> : 用来表示服务器当前处于<strong>暂</strong>不可用状态</p><ul><li>可以回送:响应首部 <code>Retry-After</code> 表示多久恢复;</li><li>不同的客户端与服务器端应用对于 Retry-After 首部的支持依然不太一致;</li><li>不过，一些爬虫程序，比如谷歌的爬虫程序Googlebot, 会遵循Retry-After响应首部的规则, 将其与503(Service Unavailable,当前服务不存在)响应一起发送有助于互联网引擎做出判断,在宕机结束之后继续对网站构建索引。</li><li>参考:<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Retry-After" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Retry-After</a></li></ul><p><strong>504 Gateway Time-out</strong>: 复现这个错误码比较简单, 让你的php程序模拟耗时请求, 如下代码<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">sleep(70);//模拟耗时，睡70秒</div><div class="line">echo &quot;睡醒了&quot;;</div></pre></td></tr></table></figure></p><pre><code>就会返回```504 Gateway Time-outnginx/1.11.4``` </code></pre><p><strong>505 HTTP Version Not Supported</strong>: 服务器收到的请求, 使用的是它无法支持的HTTP协议版本;</p><p>参考:《HTTP权威指南》、《Web API的设计与开发》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1xx&quot;&gt;&lt;a href=&quot;#1xx&quot; class=&quot;headerlink&quot; title=&quot;1xx&quot;&gt;&lt;/a&gt;1xx&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;101&lt;/code&gt;: 参考博文&lt;a href=&quot;/2017/10/28/WebSocket/2017-10
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>02. HTTP各请求方法详解</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-02/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-02/</id>
    <published>2017-11-30T03:29:12.000Z</published>
    <updated>2018-05-09T06:27:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>HTTP/1.1 中实现的method, <a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">参考RFC2616</a>, 可以看到有: <code>OPTIONS</code>, <code>GET</code>, <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>, <code>CONNECT</code></p></li><li><p>RFC2616中提到: PATCH，LINK，UNLINK方法被定义，但并不常见;(&lt;图解http协议&gt;中也提到 <code>LINK</code>, <code>UNLINK</code>已经被http1.1废弃);</p></li><li><p>不同应用各自的实现不同, 有些应用会完整实现, 有些还会扩展, 有些可能会实现一部分;</p></li></ol><h2 id="PUT-对比POST"><a href="#PUT-对比POST" class="headerlink" title="PUT(对比POST)"></a>PUT(对比POST)</h2><ol><li><p><code>PUT</code>: 对已有资源进行更新操作, 所以是 update 操作;</p></li><li><p>put和post的区别<br> 在HTTP中, PUT被定义为 <a href="https://tools.ietf.org/html/rfc2616#section-9.1.2" target="_blank" rel="external"><code>idempotent(幂等性)</code></a> 的方法，POST则不是，<strong>这是一个很重要的区别</strong></p></li><li><p>应该用PUT还是POST ？</p></li></ol><ul><li><strong>取决于这个REST服务的行为是否是idempotent(幂等)的</strong><br>  假如发送两个请求, 希望服务器端是产生两个新数据，那就说明这个服务不是idempotent的, 因为多次使用产生了副作用了, 那就应该使用<code>POST</code>方法;<br>  但如果是希望后一个请求把第一个请求覆盖掉(这不正是修改么), 那这个服务就是idempotent的, 那就应该使用<code>PUT</code>方法;</li><li>虽然POST和PUT差别不大, 用错了也没关系, 但是你的服务一放到internet上，如果不遵从HTTP协议的规范，就可能给自己带来麻烦</li></ul><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><ol><li><p><code>POST</code>: 上面已经提过了, <strong>POST是非幂等的</strong>;</p></li><li><p>POST和PUT都可以上传文件或者创建新信息, 但主要看你的REST服务行为是否是幂等的;</p></li></ol><h2 id="PATCH-对比PUT"><a href="#PATCH-对比PUT" class="headerlink" title="PATCH(对比PUT)"></a>PATCH(对比PUT)</h2><p><strong>PATCH不是HTTP标准方法的，服务端需要考虑客户端是否能够支持的问题</strong></p><ol><li><p>对已有资源的操作</p><ul><li>用于资源的<strong>部分内容</strong>进行更新 (例如更新某一个字段, 具体比如说只更新用户信息的电话号码字段);   </li><li>而<code>PUT</code>则用于更新某个资源较完整的内容, 比如说用户要重填完整表单更新所有信息, 后台处理更新时可能只是保留内部记录ID不变;</li></ul></li><li><p>当资源不存在时: PATCH 可能会去创建一个新的资源, 这个意义上像是 saveOrUpdate 操作。</p></li><li><p>参考:</p><ul><li><a href="https://segmentfault.com/q/1010000005685904/" target="_blank" rel="external">https://segmentfault.com/q/1010000005685904/</a></li><li><a href="https://unmi.cc/restful-http-patch-method/" target="_blank" rel="external">https://unmi.cc/restful-http-patch-method/</a></li><li><a href="http://restcookbook.com/HTTP%20Methods/patch/" target="_blank" rel="external">http://restcookbook.com/HTTP%20Methods/patch/</a></li><li><a href="https://tools.ietf.org/html/rfc5789" target="_blank" rel="external">https://tools.ietf.org/html/rfc5789</a></li></ul></li></ol><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD和 <code>GET</code> 本质是一样的, 区别在于如果使用HEAD, 响应体将不会被返回，而仅仅返回HTTP头信息;<br>比如: 欲判断某个资源是否存在, 我们通常使用GET, <strong>但这里用HEAD则意义更加明确</strong>。</p><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>比较简单, 直接获取资源;</p><h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><p>这个方法使用比较少, 它用于获取当前URL所支持的方法;<br>若请求成功, 则它会在HTTP头中包含一个名为 <code>Allow</code> 的头, 值是服务器所支持的方法, 如 GET, POST;<br>之前跨域相关博文 <a href="/2016/09/18/2016-09-18-sameoriginpolicy-06/">CORS方案 not-so-simple request</a> 中的”预检”请求用的请求方法就是 <code>OPTIONS</code>;</p><h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><p>要求用隧道协议连接代理, 如使用SSL</p><h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><p>~~未完待续</p><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p><a href="https://tools.ietf.org/html/rfc2616#section-9.7" target="_blank" rel="external">参考</a></p><h2 id="PURGE"><a href="#PURGE" class="headerlink" title="PURGE"></a>PURGE</h2><p>非规范中定义的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;HTTP/1.1 中实现的method, &lt;a href=&quot;https://tools.ietf.org/html/rfc
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>01. HTTP协议预览</title>
    <link href="http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-01/"/>
    <id>http://blog.renyimin.com/2017/11/30/http/2017-11-30-HTTP-01/</id>
    <published>2017-11-30T03:25:12.000Z</published>
    <updated>2018-05-09T06:27:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p><a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="external">HTTP</a>(Hypertext Transfer Protocol 超文本传输协议), 是在万维网上进行通信时所使用的协议;</p></li><li><p>协议版本</p><ul><li>HTTP/0.9 有很多设计缺, 很快就被HTTP/1.0所取代了;(…只支持GET方法…)</li><li>HTTP/1.0 第一个得到广泛应用的HTTP版本;</li><li>HTTP/1.O+ 在HTTP/1.0上扩展了很多非官方的特性, 是非正式的HTTP扩展版本;(支持持久的keep-alivel连接)</li><li><strong>HTTP/1.1</strong> 是当前使用的版本</li><li>HTTP-NG(HTTP/2.0) 关注的是性能提升, 目前还未普及</li></ul></li><li><p>用于HTTP协议交互的信息被称为<code>HTTP报文</code></p><ul><li>请求端(客户端)的报文叫 <code>请求报文</code>;</li><li>响应端(服务器端)的叫 <code>响应报文</code>;</li></ul></li></ol><h2 id="请求报文结构"><a href="#请求报文结构" class="headerlink" title="请求报文结构"></a>请求报文结构</h2><h3 id="报文首部"><a href="#报文首部" class="headerlink" title="报文首部"></a>报文首部</h3><ol><li><p><strong>请求行</strong> : 包含了 <code>请求方法</code>,  <code>请求URL</code>, <code>客户端请求报文使用的HTTP协议版本</code> (如: <code>GET / HTTP/1.1</code>)</p></li><li><p>首部块</p><ul><li><p>请求首部字段</p></li><li><p>通用首部字段</p></li><li><p>实体首部字段</p></li><li><p>其他</p></li></ul></li></ol><h3 id="空行-CRLF"><a href="#空行-CRLF" class="headerlink" title="空行(CRLF)"></a>空行(CRLF)</h3><h3 id="报文主体"><a href="#报文主体" class="headerlink" title="报文主体"></a>报文主体</h3><h2 id="响应报文结构"><a href="#响应报文结构" class="headerlink" title="响应报文结构"></a>响应报文结构</h2><h3 id="报文首部-1"><a href="#报文首部-1" class="headerlink" title="报文首部"></a>报文首部</h3><ol><li><p><strong>状态行</strong> : 包含了 <code>服务端响应报文使用的HTTP协议版本</code>, <code>状态码</code>, <code>原因短语</code> (如: <code>HTTP/1.1 200 OK</code>)</p></li><li><p>首部块</p><ul><li>响应首部字段</li><li>通用首部字段</li><li>实体首部字段</li><li>其他 </li></ul></li></ol><h3 id="空行-CRLF-1"><a href="#空行-CRLF-1" class="headerlink" title="空行(CRLF)"></a>空行(CRLF)</h3><h3 id="报文主体-1"><a href="#报文主体-1" class="headerlink" title="报文主体"></a>报文主体</h3><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a><a href="/2016/11/30/http/2016-11-30-HTTP-03/">请求方法</a></h2><p>上面已经了解到, 在 “请求报文” -&gt; “报文首部” -&gt; “请求行” 中, 包含了 <code>请求方法</code>, 具体可参考 <a href="/2016/11/30/http/2016-11-30-HTTP-03/">各请求方法详解</a></p><h2 id="首部字段"><a href="#首部字段" class="headerlink" title="首部字段"></a>首部字段</h2><p>从上面还可以看到, 报文中的首部块有如下几种<code>首部字段</code></p><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><p>Cache-Control 缓存能力控制<br>Pragma 兼容Cache-control<br>Date 当前时间<br>Transfer-Encoding 传输编码<br>Accept-encoding 内容编码  (请求首部字段) (可能会导致服务器返回 <code>406 Not Acceptable</code>)<br>Content-encoding 内容编码 (实体首部字段)<br>Accept-charset  请求首部字段<br>可参考博文：<a href="/2016/11/30/http/2016-11-30-HTTP-04/">各通用首部字段详解</a></p><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><h2 id="状态码详解"><a href="#状态码详解" class="headerlink" title="状态码详解"></a>状态码详解</h2><p>可参考博文：<a href="/2016/11/30/http/2016-11-30-HTTP-03/">HTTP状态码详解</a></p><p>~~未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.renyimin.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://blog.renyimin.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>70. 查询性能优化</title>
    <link href="http://blog.renyimin.com/2017/09/27/mysql/2017-09-27-mysql-70/"/>
    <id>http://blog.renyimin.com/2017/09/27/mysql/2017-09-27-mysql-70/</id>
    <published>2017-09-27T12:50:37.000Z</published>
    <updated>2018-03-08T06:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前已经了解了<code>索引优化</code>的相关内容, 它对于高性能是必不可少的, 但还不够, 还需要<code>合理设计查询</code>;</p><ul><li>如果查询写的很糟糕, 即使库表结构再合理, 索引再合适, 也无法实现高性能;</li><li>查询优化, 库表结构优化, 索引优化需要齐头并进, 一个不落;</li></ul><h2 id="慢查询基础"><a href="#慢查询基础" class="headerlink" title="慢查询基础"></a>慢查询基础</h2><h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><ul><li>确认应用程序是否在检索大量超过需要的数据, 你可能访问了太多的行, 也可能是太多的列;<br>比如: 总是返回全部的列; 只展示5条数据,你却查出100条;</li><li>确认<code>MySQL服务器层</code>是否在分析大量超过需要的数据行; (注意: 索引是在存储引擎层, 一旦服务器层分析的数据过多, 可能你的索引不太合适, 没有在存储引擎层过滤掉数据)<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>未完待续~~</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前已经了解了&lt;code&gt;索引优化&lt;/code&gt;的相关内容, 它对于高性能是必不可少的, 但还不够, 还需要&lt;code&gt;合理设计查询&lt;/co
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="查询性能优化" scheme="http://blog.renyimin.com/tags/%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>50. EXPLAIN 分析</title>
    <link href="http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-50/"/>
    <id>http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-50/</id>
    <published>2017-09-25T13:23:08.000Z</published>
    <updated>2018-03-16T06:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `user_info` (</div><div class="line">  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,</div><div class="line">  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">  `age`  INT(11) DEFAULT NULL,</div><div class="line">  PRIMARY KEY (`id`),</div><div class="line">  KEY `name_index` (`name`)</div><div class="line">) ENGINE = InnoDB, DEFAULT CHARSET = utf8;</div><div class="line"></div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);</div><div class="line"></div><div class="line">CREATE TABLE `order_info` (</div><div class="line">  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,</div><div class="line">  `user_id`      BIGINT(20)           DEFAULT NULL,</div><div class="line">  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">  `productor`    VARCHAR(30)          DEFAULT NULL,</div><div class="line">  PRIMARY KEY (`id`),</div><div class="line">  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</div><div class="line">)ENGINE = InnoDB,</div><div class="line">DEFAULT CHARSET = utf8;</div><div class="line"></div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);</div></pre></td></tr></table></figure></code></pre><h2 id="EXPLAIN-输出"><a href="#EXPLAIN-输出" class="headerlink" title="EXPLAIN 输出"></a>EXPLAIN 输出</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from user_info where id = 2;</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref   | rows | Extra |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">|  1 | SIMPLE      | user_info | const | PRIMARY       | PRIMARY | 8       | const |    1 | NULL  |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></code></pre><h2 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h2><ol><li><p>select_type 表示了查询的类型, 它的常用取值有:</p><ul><li><code>SIMPLE</code>, 表示此查询不包含 UNION 查询或子查询 (最常见的查询类别就是 <code>SIMPLE</code> 了)</li><li><code>PRIMARY</code>, 表示此查询是最外层的查询</li><li><code>UNION</code>, 表示此查询是 UNION 的第二或随后的查询</li><li><code>DEPENDENT UNION</code>, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li><code>UNION RESULT</code>, UNION 的结果</li><li><code>SUBQUERY</code>, 子查询中的第一个 SELECT</li><li><code>DEPENDENT SUBQUERY</code>: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li></ul></li><li><p>如果使用了<code>UNION</code>查询, 那么EXPLAIN 输出结果类似如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN ( SELECT * FROM user_info WHERE id IN ( 1, 2, 3 ) ) UNION</div><div class="line">( SELECT * FROM user_info WHERE id IN ( 3, 4, 5 ) );</div><div class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</div><div class="line">| id   | select_type  | table      | type  | possible_keys | key     | key_len | ref  | rows | Extra           |</div><div class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</div><div class="line">|    1 | PRIMARY      | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where     |</div><div class="line">|    2 | UNION        | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where     |</div><div class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | ALL   | NULL          | NULL    | NULL    | NULL | NULL | Using temporary |</div><div class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li></ol><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><ol><li>type 字段比较重要, 它<strong>提供了判断查询是否高效的重要依据依据</strong>; 通过 type 字段, 我们判断此次查询是 <strong>全表扫描</strong> 还是 <strong>索引扫描</strong> 等;</li><li><p>type 常用的取值有:</p><ul><li><p><code>system</code>: 表中只有一条数据, 这个类型是特殊的 <code>const</code> 类型; ??</p></li><li><p><code>const</code>: 针对<strong>主键</strong>或<strong>唯一索引</strong>的<strong>等值查询扫描</strong>, 最多只返回一行数据(const 查询速度非常快, 因为它仅仅读取一次即可)</p></li><li><p><code>eq_ref</code>: 此类型通常出现在多表的join查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果, 并且查询的比较操作通常是 =, <strong>查询效率较高</strong>, 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id;</div><div class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</div><div class="line">| id | select_type | table      | type   | possible_keys             | key                       | key_len | ref                     | rows | Extra                    |</div><div class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | order_info | index  | user_product_detail_index | user_product_detail_index | 254     | NULL                    |    9 | Using where; Using index |</div><div class="line">|  1 | SIMPLE      | user_info  | eq_ref | PRIMARY                   | PRIMARY                   | 8       | test.order_info.user_id |    1 | NULL                     |</div><div class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询, 例如下面这个例子中, 就使用到了 ref 类型的查询:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5;</div><div class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</div><div class="line">| id | select_type | table      | type  | possible_keys             | key                       | key_len | ref   | rows | Extra       |</div><div class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info  | const | PRIMARY                   | PRIMARY                   | 8       | const |    1 | NULL        |</div><div class="line">|  1 | SIMPLE      | order_info | ref   | user_product_detail_index | user_product_detail_index | 9       | const |    1 | Using index |</div><div class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>range: 表示使用<code>索引范围查询</code>, 通过索引字段范围获取表中部分数据记录; 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL (没用到索引), 并且 key_len 字段是此次查询中使用到的索引的最长的那个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT * FROM user_info WHERE id BETWEEN 2 AND 8;</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | range | PRIMARY       | PRIMARY | 8       | NULL |    7 | Using where |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>下面对比, 都使用了范围查询, 但是一个可以使用<strong>索引范围查询</strong>, 另一个不能使用索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name&gt;&apos;nihao&apos;;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra                    |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | user_info | range | name_index    | name_index | 152     | NULL |    1 | Using where; Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age&gt;10;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>另外, 可参考 P185: in语句虽然有时候 type结果也是range (不过, 对于真正的范围查询, 确实是无法使用范围列后面的其他索引了, 但是对于”多个等值条件查询”则没有这个限制)</p></li><li><p>index: 表示<strong>全索引扫描(full index scan)</strong>, 和 ALL 类型类似, 只不过ALL类型是全表扫描, <strong>而 index 类型则仅仅扫描所有的索引, 而不扫描数据</strong><br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据, 即 做的是<strong>覆盖索引</strong>, 当是这种情况时, Extra 字段会显示 <code>Using index</code></p><p>下面的例子中, 查询的 <code>name</code> 字段恰好是一个索引(<strong>做到了覆盖索引</strong>), 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据;<br>因此这样的情况下, type 的值是 <code>index</code>, 并且 Extra 的值是 Using index;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM user_info;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | index | NULL          | name_index | 152     | NULL |   10 | Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>下面不但使用了<code>全索引扫描</code>, 而且使用了<code>where条件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name=&apos;nihao&apos;;</div><div class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                    |</div><div class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using where; Using index |</div><div class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>但是, 如果不使用索引的话, 下面type就是<code>ALL</code>, 表示使用了<code>全表扫描</code>, 并且使用了where条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age=10;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age&gt;10;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name&gt;&apos;nihao&apos;;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra                    |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | user_info | range | name_index    | name_index | 152     | NULL |    1 | Using where; Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一, 通常来说, 我们的查询<strong>不应该出现 ALL 类型的查询</strong>, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难<br>如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</p></li><li></li></ul></li></ol><h2 id="type小结"><a href="#type小结" class="headerlink" title="type小结"></a>type小结</h2><p><strong>type 类型的性能比较</strong> : 通常来说, 不同的 type 类型的性能关系如: <code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code></p><ol><li>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的;</li><li>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快;</li><li>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了;</li></ol><h2 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h2><p>possible_keys 表示 MySQL 在查询时, 能够使用到的索引;<br>注意: 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到;(MySQL 在查询时具体使用了哪些索引, 由 key 字段决定)</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>此字段是 MySQL 在当前查询时所真正使用到的索引</p><h2 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h2><p>rows 也是一个重要的字段, MySQL 查询优化器根据统计信息, <strong>估算SQL要查找到结果集需要到表中扫描读取的数据行数</strong>(上面的例子可以看到, 基本上使用到了索引的话, 真正扫描的行数都很少); 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好</p><h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><p>Explain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ol><li><p><strong>Using filesort</strong>: 当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. </p><ul><li><p>一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</p></li><li><p>比如下面, <code>使用索引扫描做排序</code> 和 <code>不使用索引扫描做排序</code> 的效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM user_info ORDER BY name;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | index | NULL          | name_index | 152     | NULL |   10 | Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; EXPLAIN SELECT name FROM user_info ORDER BY age;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra          |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using filesort |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li></ul></li><li><p><code>Using index</code> 与 <code>Using index condition</code></p><ul><li>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li><li><p>比如下面, 第一个做到了<code>覆盖索引</code>扫描, 后面两个都没做到</p><pre><code>mysql&gt; EXPLAIN SELECT name FROM user_info where name=&apos;haha&apos;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                    |+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using where; Using index |+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+1 row in set (0.00 sec)mysql&gt; EXPLAIN SELECT name,age FROM user_info where name=&apos;haha&apos;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                 |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using index condition |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+1 row in set (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM user_info where name=&apos;haha&apos;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                 |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using index condition |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+1 row in set (0.00 sec)</code></pre></li></ul></li><li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备环境&quot;&gt;&lt;a href=&quot;#准备环境&quot; class=&quot;headerlink&quot; title=&quot;准备环境&quot;&gt;&lt;/a&gt;准备环境&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>49. 索引和锁</title>
    <link href="http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-49/"/>
    <id>http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-49/</id>
    <published>2017-09-25T13:10:40.000Z</published>
    <updated>2018-03-08T02:57:03.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>索引可以让查询锁定更少的行</strong> <blockquote><p>因为InnoDB只有在访问行的时候才会对其加锁, 而索引能够减少InnoDB访问的行数, 从而减少锁的数量;<br>但这只有当InnoDB在存储引擎层就能过滤掉所有不需要的行时才行, 如果索引(处在存储引擎层)无法过滤掉无效的行, 那么在InnoDB检索到数据并发送给服务器层以后, 服务器层才能应用where子句, 这时已经无法避免锁定行了;<br>虽然InnoDB的行锁效率很高, 内存使用也很少, 但是锁定行的时候仍然会带来额外开销;<br>锁定超过需要的行会增加锁争用并减少并发性;</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;strong&gt;索引可以让查询锁定更少的行&lt;/strong&gt; &lt;blockquote&gt;
&lt;p&gt;因为InnoDB只有在访问行的时候才会对其加锁, 而索引能够减少InnoDB访问的行数, 从而减少锁的数量;&lt;br&gt;但这只有当InnoDB在存储引擎层就能过滤掉所有不需
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
</feed>
