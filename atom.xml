<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rymuscle&#39;s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2018-08-24T08:23:14.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Rymuscle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单进程单线程高并发?</title>
    <link href="http://blog.renyimin.com/2018/08/24/redis/2018-08-24-redis-04/"/>
    <id>http://blog.renyimin.com/2018/08/24/redis/2018-08-24-redis-04/</id>
    <published>2018-08-24T08:22:51.000Z</published>
    <updated>2018-08-24T08:23:14.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Redis" scheme="http://blog.renyimin.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://blog.renyimin.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="http://blog.renyimin.com/2018/08/20/redis/2018-08-20-redis-03/"/>
    <id>http://blog.renyimin.com/2018/08/20/redis/2018-08-20-redis-03/</id>
    <published>2018-08-20T09:32:27.000Z</published>
    <updated>2018-08-20T10:42:56.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Redis" scheme="http://blog.renyimin.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://blog.renyimin.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>持久化分析</title>
    <link href="http://blog.renyimin.com/2018/08/20/redis/2018-08-20-redis-02/"/>
    <id>http://blog.renyimin.com/2018/08/20/redis/2018-08-20-redis-02/</id>
    <published>2018-08-20T09:32:27.000Z</published>
    <updated>2018-08-20T10:42:56.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Redis" scheme="http://blog.renyimin.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://blog.renyimin.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>日志</title>
    <link href="http://blog.renyimin.com/2018/08/20/redis/2018-08-20-redis-01/"/>
    <id>http://blog.renyimin.com/2018/08/20/redis/2018-08-20-redis-01/</id>
    <published>2018-08-20T09:32:11.000Z</published>
    <updated>2018-08-20T12:24:13.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Redis" scheme="http://blog.renyimin.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://blog.renyimin.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>postman 中 form-data、x-www-form-urlencoded、raw、binary的区别</title>
    <link href="http://blog.renyimin.com/2018/08/20/http/2018-08-20-postman-01/"/>
    <id>http://blog.renyimin.com/2018/08/20/http/2018-08-20-postman-01/</id>
    <published>2018-08-20T03:21:09.000Z</published>
    <updated>2018-08-21T06:09:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="form-data"><a href="#form-data" class="headerlink" title="form-data"></a>form-data</h2><ol><li><p>就是http请求中的 <code>multipart/form-data</code>, 它会将表单的数据处理为一条消息, 以标签为单元, 用分隔符分开; 既可以上传键值对, 也可以上传文件, 当上传的字段是文件时, 会有Content-Type来说明文件类型; content-disposition, 用来说明字段的一些信息;</p></li><li><p>由于有 <code>boundary</code> 隔离, 所以 <code>multipart/form-data</code> 既可以上传文件, 也可以上传键值对, 它采用了键值对的方式, 所以可以上传多个文件;</p></li><li><p>测试:</p><ul><li>发送请求<br><img src="/img/postman/form-data-01.png"></li><li>查看请求头<br><img src="/img/postman/form-data-02.png"></li></ul></li></ol><h2 id="x-www-form-urlencoded"><a href="#x-www-form-urlencoded" class="headerlink" title="x-www-form-urlencoded"></a>x-www-form-urlencoded</h2><ol><li><p>就是http请求中的 <code>application/x-www-from-urlencoded</code>, 会将表单内的数据转换为键值对, 比如, name=java&amp;age=23</p></li><li><p>测试:</p><ul><li>发送请求<br><img src="/img/postman/x-www-form-urlencoded-01.png"></li><li>查看请求头<br><img src="/img/postman/x-www-form-urlencoded-02.png"></li></ul></li><li><p>注意, url中的gender参数, 也只能用$_GET方法来获取参数(不能用$_post)</p></li></ol><h2 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h2><ol><li>可以上传任意格式的文本, 可以上传text、json、xml、html等</li></ol><h2 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h2><ol><li>相当于 <code>Content-Type:application/octet-stream</code> , 从字面意思得知, 只可以上传二进制数据, 通常用来上传文件, 由于没有键值, 所以, 一次只能上传一个文件;</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;form-data&quot;&gt;&lt;a href=&quot;#form-data&quot; class=&quot;headerlink&quot; title=&quot;form-data&quot;&gt;&lt;/a&gt;form-data&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;就是http请求中的 &lt;code&gt;multipart/form-d
      
    
    </summary>
    
      <category term="杂项" scheme="http://blog.renyimin.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="杂项" scheme="http://blog.renyimin.com/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.renyimin.com/2018/08/01/nginx/2017-04-22-03/"/>
    <id>http://blog.renyimin.com/2018/08/01/nginx/2017-04-22-03/</id>
    <published>2018-08-01T03:02:02.000Z</published>
    <updated>2018-08-01T03:02:02.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>40.  Linux 负载相关基本命令</title>
    <link href="http://blog.renyimin.com/2018/07/02/linux/2018-07-02-40/"/>
    <id>http://blog.renyimin.com/2018/07/02/linux/2018-07-02-40/</id>
    <published>2018-07-02T11:26:17.000Z</published>
    <updated>2018-08-07T03:28:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="uptime-命令"><a href="#uptime-命令" class="headerlink" title="uptime 命令"></a>uptime 命令</h2><ol><li><p>测试</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[work@trade-sandbox ~]$ uptime</span><br><span class="line"> 16:47:10 up 91 days, 23:01, 10 users,  load average: 1.55, 1.27, 1.45</span><br></pre></td></tr></table></figure></li><li><p>说明: </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">16:47:10 // 系统当前时间</span><br><span class="line">up 91 days, 23:01, // 主机已运行时间,时间越大,说明你的机器越稳定</span><br><span class="line">10 users //用户连接数, 是总连接数而不是用户数</span><br><span class="line">load average: 1.55, 1.27, 1.45 // 系统平均负载,统计最近1,5,15分钟的系统平均负载</span><br></pre></td></tr></table></figure></li></ol><h2 id="w命令"><a href="#w命令" class="headerlink" title="w命令"></a>w命令</h2><ol><li><p><code>w</code> 命令用于显示已经登陆系统的用户列表, 并显示用户正在执行的指令;</p><ul><li>执行这个命令可得知目前登入系统的用户有哪些人, 以及他们正在执行的程序;</li><li>单独执行w命令会显示所有的用户, 您也可指定用户名称, 仅显示某位用户的相关信息;</li></ul></li><li><p>选项</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-h：不打印头信息；</span><br><span class="line">-u：当显示当前进程和cpu时间时忽略用户名；</span><br><span class="line">-s：使用短输出格式；</span><br><span class="line">-f：显示用户从哪登录；</span><br><span class="line">-V：显示版本信息。</span><br></pre></td></tr></table></figure></li><li><p>测试: (第一行其实就是 <code>uptime</code> 命令的执行效果)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[work@trade-sandbox ~]$ w</span><br><span class="line"> 16:41:35 up 91 days, 22:55, 10 users,  load average: 0.36, 0.87, 1.40</span><br><span class="line">USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">work     pts/0    10.51.64.132     10:50    5:49m  0.03s  0.00s tail -f push_remind-2018-07-19.log</span><br><span class="line">work     pts/2    10.51.64.132     Wed15    0.00s  0.01s  0.00s w</span><br><span class="line">work     pts/3    10.51.64.132     Wed17   23:08m  1:39   1:39  -bash</span><br><span class="line">work     pts/4    10.51.64.132     Wed17   23:10m  3:39   3:39  top</span><br><span class="line">work     pts/5    10.51.64.132     Wed17    2:16m  0.20s  0.00s tail -f solr.request-2018-07-19.log</span><br><span class="line">work     pts/6    10.51.64.132     14:22    1:46m  0.00s  0.00s -bash</span><br><span class="line">work     pts/7    10.162.220.93    14:34   36:17   0.05s  0.05s -bash</span><br><span class="line">work     pts/8    10.162.220.93    14:42    1:51m  0.02s  0.00s tail -f AgainPushToSolr-2018-07-19.log</span><br><span class="line">work     pts/9    10.162.220.93    14:43   30:45   0.07s  0.07s -bash</span><br><span class="line">work     pts/10   10.51.64.132     15:21   34:16   0.07s  0.07s -bash</span><br></pre></td></tr></table></figure></li></ol><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><ol><li><p><code>top</code> 命令能够清晰的展现出系统的状态，而且它是实时的监控，按q退出;</p></li><li><p>测试</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[work@trade-sandbox ~]$ top</span><br><span class="line">top - 19:16:30 up 92 days,  1:30,  6 users,  load average: 0.21, 0.10, 0.09</span><br><span class="line">Tasks: 265 total,   1 running, 256 sleeping,   0 stopped,   8 zombie</span><br><span class="line">Cpu(s):  3.0%us,  1.8%sy,  0.0%ni, 94.9%id,  0.3%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Mem:   8057768k total,  5748564k used,  2309204k free,   812724k buffers</span><br><span class="line">Swap:        0k total,        0k used,        0k free,   548248k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line"> 4497 work      20   0  253m  22m  10m S  1.0  0.3   0:06.57 php</span><br><span class="line"> 3911 work      20   0  253m  22m  10m S  0.7  0.3   0:06.99 php</span><br><span class="line"> 3916 work      20   0  253m  22m  10m S  0.7  0.3   0:06.98 php</span><br><span class="line"> 6738 root      20   0  263m  16m 3624 S  0.7  0.2 163:41.71 ilogtail</span><br><span class="line">13226 work      20   0  253m  22m  10m S  0.7  0.3   0:00.77 php</span><br><span class="line">13714 work      20   0  253m  22m  10m S  0.7  0.3   0:00.30 php</span><br><span class="line">20559 work      20   0  255m  25m  10m S  0.7  0.3   1:04.16 php</span><br><span class="line">20562 work      20   0  255m  25m  10m S  0.7  0.3   1:04.10 php</span><br></pre></td></tr></table></figure></li><li><p>说明</p><ul><li><p>第一行仍然是系统运行时间</p></li><li><p>Tasks行: 展示了目前的进程总数, 处于运行状态的进程数, 处于睡眠状态的进程数, 处于停止状态的进程数, 要注意zombie,表示僵尸进程,不为0则表示有进程出现问题</p></li><li><p>Cpu(s)行:<br>3.0%us 用户空间占用CPU百分比,<br>1.0%sy 内核空间占用CPU百分比,<br>0.0%ni 用户进程空间内改变过优先级的进程占用CPU百分比,<br>94.9%id 空闲CPU百分比,<br>0.3%wa 等待输入输出的CPU时间百分比,<br>0.0%hi ,<br>0.0%si ,<br>0.1%st </p></li><li><p>Mem 行:<br>4147888k total 物理内存总量,<br>2493092k used 使用的物理内存总量,<br>1654796k free 空闲内存总量,<br>158188k buffers 用作内核缓存的内存量</p></li><li><p>Swap 行:<br>5144568k total 交换区总量 ,<br>56k used 使用的交换区总量 ,<br>5144512k free 空闲交换区总量 ,<br>2013180k cached 缓冲的交换区总量</p></li></ul></li></ol><h2 id="负载值分析"><a href="#负载值分析" class="headerlink" title="负载值分析"></a>负载值分析</h2><ol><li><p>load average: 0.21, 0.10, 0.09 表示的是 1分钟, 5分钟, 15分钟的CPU负载情况 (一般5和15分钟才具有参考意义)</p></li><li><p>对于单核处理器来说(值的大小和cpu的核数有关系), 可以把值分为3个级别</p><ul><li>小于1.0 如果值小于1, 那么说明系统cpu处理很流畅, 不会出现等待, 堵塞</li><li>等于1.0 说明cpu能力刚刚满负荷</li><li>大于1.0 说明cpu已经超负荷, 进程处理需要等待了, 效率低下</li></ul></li><li><p>对于多核处理器说(假设双核), 等于说处理能力增加了一倍, 比较的值就是2了, 小于2.0才不用担心</p><ul><li>如下是四核服务器, 所以比较的值就是4<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[work@trade-sandbox ~]$ cat /proc/cpuinfo | grep &apos;model name&apos;</span><br><span class="line">model name: Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz</span><br><span class="line">model name: Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz</span><br><span class="line">model name: Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz</span><br><span class="line">model name: Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz</span><br><span class="line">[work@trade-sandbox ~]$</span><br></pre></td></tr></table></figure></li></ul></li><li><p>也可以在运行top命令之后, 直接按 1, 查看 各cpu的负载 (再按1, 又回到现实CPU总负载)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[work@trade-sandbox ~]$ top</span><br><span class="line">top - 20:38:47 up 92 days,  2:53,  7 users,  load average: 1.31, 0.84, 0.53</span><br><span class="line">Tasks: 245 total,   1 running, 237 sleeping,   0 stopped,   7 zombie</span><br><span class="line">Cpu0  :  8.4%us,  2.0%sy,  0.0%ni, 89.0%id,  0.3%wa,  0.0%hi,  0.3%si,  0.0%st</span><br><span class="line">Cpu1  :  3.6%us,  2.3%sy,  0.0%ni, 93.7%id,  0.0%wa,  0.0%hi,  0.0%si,  0.3%st</span><br><span class="line">Cpu2  :  0.3%us,  0.7%sy,  0.0%ni, 99.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Cpu3  :  1.3%us,  0.0%sy,  0.0%ni, 98.7%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Mem:   8057768k total,  5505852k used,  2551916k free,   816568k buffers</span><br><span class="line">Swap:        0k total,        0k used,        0k free,   470568k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line"> 1091 root      20   0 2446m  65m 3200 S  4.7  0.8   1653:45 java</span><br><span class="line"> 1484 root      20   0  212m  14m 1100 S  0.7  0.2 550:15.91 supervisord</span><br><span class="line"> 3911 work      20   0  253m  22m  10m S  0.7  0.3   0:41.20 php</span><br><span class="line"> 4497 work      20   0  253m  22m  10m S  0.7  0.3   0:40.92 php</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;uptime-命令&quot;&gt;&lt;a href=&quot;#uptime-命令&quot; class=&quot;headerlink&quot; title=&quot;uptime 命令&quot;&gt;&lt;/a&gt;uptime 命令&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;测试&lt;/p&gt;
 &lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>33. 单机部署集群 -- 镜像模式 (x-ha-policy)</title>
    <link href="http://blog.renyimin.com/2018/06/29/rabbitmq/2018-06-29-rabbitmq-33/"/>
    <id>http://blog.renyimin.com/2018/06/29/rabbitmq/2018-06-29-rabbitmq-33/</id>
    <published>2018-06-29T13:28:16.000Z</published>
    <updated>2018-08-04T13:04:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>上一篇在学习普通模式的集群时, 已经知道在该模式下, 队列只存活于集群中的一个节点上(在RabbitMQ2.6.0之前, 这也是唯一的选择);<br> 在RabbitMQ2.6.0时, RabbitMQ团队带来了内建的双活冗余选项: <strong>镜像队列</strong>;</p></li><li><p>像普通队列那样, 镜像队列的主拷贝仅存在于一个节点(主队列, master)上, 但与普通队列的不同点是, 镜像节点在集群中的其他节点上拥有从队列(slave拷贝); 一旦队列主节点不可用, 最老的从队列将会被选举为新的主队列; (这貌似就是探索集群时一直寻找的高可用)</p></li></ol><h2 id="声明并使用镜像队列"><a href="#声明并使用镜像队列" class="headerlink" title="声明并使用镜像队列"></a>声明并使用镜像队列</h2><ol><li><p>你的应用程序并不使用 <code>rabbitmqctl</code> 来定义镜像(mirrored)队列; 声明镜像队列就像声明普通队列一样, 不过, 你需要传入一个额外的参数 <code>x-ha-policy</code> 参数到 <code>queue.declare</code> 调用中;</p></li><li><p>测试:</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;上一篇在学习普通模式的集群时, 已经知道在该模式下, 队列只存活于集群中的一个节点上(在RabbitMQ2.6.0之前, 
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>32. 单机部署集群 -- 普通模式</title>
    <link href="http://blog.renyimin.com/2018/06/26/rabbitmq/2018-06-26-rabbitmq-32/"/>
    <id>http://blog.renyimin.com/2018/06/26/rabbitmq/2018-06-26-rabbitmq-32/</id>
    <published>2018-06-26T07:28:16.000Z</published>
    <updated>2018-07-27T07:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当你需要在生产环境中部署RabbitMQ时, 需要注意的是, 单实例在生产环境虽然部署起来很容易, 但是当你的rabbitmq服务器遇到内存崩溃或者断电的情况时, 这款高性能的产品就要成为你的耻辱了, 将会为你造成极大的问题!<br>因此你需要将你的RabbitMQ变成高可用的才行;</p><h2 id="内建集群简介"><a href="#内建集群简介" class="headerlink" title="内建集群简介"></a>内建集群简介</h2><ol><li><p>RabbitMQ最优秀的功能之一就是其内建集群, 这款消息队列中间件产品本身是基于Erlang编写, Erlang语言天生具备分布式特性(通过同步Erlang集群各节点的magic cookie来实现), 因此, RabbitMQ天然支持Clustering, 这使得RabbitMQ本身不需要像ActiveMQ、Kafka那样通过ZooKeeper分别来实现HA方案和保存集群的元数据。</p></li><li><p>RabbitMQ内建集群用来完成两个目标:</p><ul><li>允许生产者和消费者在RabbitMQ节点崩溃的情况下继续运行;<br>你可以失去一个RabbitMQ节点, 同时客户端可以重新连接到集群中的任何其他节点并继续生产或者消费消息, 就像什么都没有发生一样;</li><li>通过增加更多的节点来线性扩展消息吞吐量;<br>如果RabbitMQ正疲于应对庞大的消息通信量的话, 那么线性地增加更多的节点则会增加更多性能;</li></ul></li></ol><h2 id="集群的类型"><a href="#集群的类型" class="headerlink" title="集群的类型"></a>集群的类型</h2><p>Rabbit集群模式大概分为两种: <strong>普通模式</strong>、<strong>镜像模式</strong>; 本篇主要介绍普通模式</p><h2 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h2><ol><li><p>普通模式(也就是默认的集群模式), 对于该集群模式, 当你将多个节点组合成集群后, 需要注意的是: <strong>不是每一个节点都有所有队列的完全拷贝</strong></p><ul><li><p>在非集群的单一节点中, 所有关于队列的信息(元数据、状态、内容)都完全存储在该节点上;</p></li><li><p>但是如果在普通集群模式下创建队列的话, 集群只会在当前节点而不是所有节点上创建完整的队列信息(元数据、状态、内容); 而其他非所有者的节点, 只知道队列的元数据和指向该队列存在的哪个节点的指针;</p></li><li><p>因此当集群中队列所有者的节点崩溃时, 该节点的队列和关联的绑定就都消失了, 并且附加在这些队列上的消费者就会无法获取其订阅的信息, 并且生产者也无法将匹配该队列绑定信息的消息发送到队列中;</p></li></ul></li><li><p><strong>接下来需要了解的一个问题是</strong>: 为什么在默认的集群模式下, RabbitMQ不将队列内容和状态复制到所有的节点上? 其实有两个原因</p><ul><li>存储空间: 如果每个集群节点都拥有所有Queue的完全数据拷贝, 那么每个节点的存储空间会非常大, 集群的消息积压能力会非常弱(无法通过集群节点的扩容提高消息积压能力);</li><li><p>性能: 消息的发布者需要将消息复制到每一个集群节点, 对于持久化消息来说, 网络和磁盘的负载都会明显增加, 最终只能保持集群性能平稳(甚至更糟);</p></li><li><p>所以, 通过设置集群中的唯一节点来负责特定队列, <strong>只有该负责节点才会因队列消息而遭受磁盘活动的影响</strong><br>所有其他节点需要将接受到的该队列的消息传递给该队列的所有者节点, 因此, 往RabbitMQ集群添加更多的节点意味着你将拥有更多的节点来传播队列, 这些新增节点为你带来了性能的提升;</p></li></ul></li><li><p>但是有人可能会想: 是否可以让消费者重新连接到集群上, 这样不就可以重新创建队列了? 但需要注意的是: </p><ul><li>因为一般如果我们的队列设置的是持久化的, 而在该队列的主节点挂掉之后, 重新连接到队列时, 一般也不会修改队列的持久化属性; </li><li>这就需要注意一个问题, 仅当你之前创建的队列为非持久化时, 你才可以重新创建该队列为持久化, 因为这是为了保证你之前的持久化队列节点在重新被恢复启动后, 其中的消息还会被恢复, 而如果你创建一个新的持久化队列, 如果覆盖之前的持久化队列, 那消息不就丢了!!<br>所以如果之前是持久化队列, 而且还是以持久化的方式创建该队列, 集群就会报错误, 后面会进行测试! </li></ul></li></ol><h2 id="了解内部元数据"><a href="#了解内部元数据" class="headerlink" title="了解内部元数据"></a>了解内部元数据</h2><p>RabbitMQ内部会始终同步四种类型的内部元数据:</p><ul><li>队列元数据: 队列名称和它的属性 (是否可持久化, 是否自动删除);</li><li>交换器元数据: 交换器名称、类型和属性 (可持久化等);</li><li>绑定元数据: 一张简单的表格展示了如何将消息路由到队列;</li><li>vhost元数据: 为vhost内的队列、交换器和绑定提供命名空间和安全属性;</li></ul><h2 id="内存or磁盘节点"><a href="#内存or磁盘节点" class="headerlink" title="内存or磁盘节点"></a>内存or磁盘节点</h2><ol><li><p>每个Rabbitmq节点, 不管是单一节点系统或者是庞大集群的一部分, 要么是内存节点(RAM node), 要么是磁盘节点(disk node):</p><ul><li>内存节点将所有的队列、交换器、绑定、用户、权限和vhost的元数据定义都仅存储在内存中;</li><li>而磁盘节点则将元数据存储在磁盘中;</li></ul></li><li><p>非集群单一节点: 在单一节点的非集群环境中, RabbitMQ默认会将元数据都存放在<strong>内存中</strong>; 但是, 会将标记为可持久化的队列和交换器(以及它们的绑定)存储到硬盘上, 存储到硬盘上可以确保队列和交换器在重启Rabbitmq节点后重新被创建;</p></li><li><p>集群节点类型 </p><ul><li>当你引入Rabbitmq集群后, RabbitMQ需要追踪的元数据类型包括: 集群节点位置, 以及节点与已记录的其他类型的元数据的关系;</li><li>集群对元数据的存储提供了选择:<br>将元数据存储到磁盘上 (集群中创建节点时的默认设置) 或者 存储到RAM内存中</li></ul></li><li><p>注意, RabbitMQ要求在集群中至少要有一个磁盘节点, 所有其他节点可以是内存节点。当节点加入或者离开集群时, 它们必须要将变更至少通知到一个磁盘节点; 如果只有一个磁盘节点, 而不凑巧的是它有刚好崩溃, 那么集群虽然可以继续路由消息, 但是不能做一下操作:</p><ul><li>创建队列</li><li>创建交换器</li><li>创建绑定</li><li>添加用户</li><li>更改权限</li><li>添加或删除集群节点</li></ul></li></ol><h2 id="集群配置钱准备"><a href="#集群配置钱准备" class="headerlink" title="集群配置钱准备"></a>集群配置钱准备</h2><ol><li><p>在开始配置集群前, 首先要确保现存的Rabbitmq没有运行, 因此需要关闭节点 (本机为mac, 关闭操作如下)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ brew services stop rabbitmq</span><br><span class="line">Stopping `rabbitmq`... (might take a while)</span><br><span class="line">==&gt; Successfully stopped `rabbitmq` (label: homebrew.mxcl.rabbitmq)</span><br></pre></td></tr></table></figure><p> 可以发现一个问题, 就是停止Rabbitmq服务之后, 貌似 RabbitMQ Management 的Web UI界面还是可以正常打开运行; 所以正确的关闭节点貌似是 <code>rabbitmqctl stop</code></p></li><li><p>开始配置集群前需要注意:</p><ul><li><p>通常来讲, 使用 <code>rabbitmq-server</code> 命令启动节点之后就大功告成了, 但是如果不用额外参数的话, 该命令会使用默认的节点名称 <code>rabbit</code> 和监听端口 <code>5672</code>;<br>所以如果你想用该命令在一台机器上同时启动3个节点的话, 那么第2，3个节点都会因为节点名称和端口号冲突而导致启动失败; </p></li><li><p>因此, 为了在本机正常启动5个节点, 可以在每次调用 <code>rabbitmq-server</code>前, 通过设置环境变量 <code>RABBITMQ_NODENAME</code>, <code>RABBITMQ_NODE_PORT</code> 来明确指定唯一的节点名称和端口号!<br>在此处做实验时, 将会采用 rabbit, rabbit_1,rabbit_2 命名节点名; 端口号为5612，5613, 5614</p></li><li><p><strong>注意</strong>, 到目前为止, 虽然尚未谈论RabbitMQ的插件, 不过你有可能已经启用了一部分插件了; 如果确实如此的话, 你需要在启动集群节点前将插件禁用!<br>这是因为像 RabbitMQ Management 这样的插件会监听专门的端口来提供服务(例如 Management 插件的 Web UI), 目前还没讲到如何设置插件监听不同的端口, 所以当第二个节点和之后的节点启动了它们的插件后, 就会和第一个启动节点的c插件相冲突, 然后节点就都崩溃了;<br>可以先不禁用插件, 这样在启动多个节点时, 可以根据报错一个个关闭插件也可以; (<code>rabbitmq-plugins disable 插件名</code>)</p></li></ul></li></ol><h2 id="RabbitMQ集群的搭建"><a href="#RabbitMQ集群的搭建" class="headerlink" title="RabbitMQ集群的搭建"></a><a href="http://www.rabbitmq.com/clustering.html#creating" target="_blank" rel="noopener">RabbitMQ集群的搭建</a></h2><ol><li><p>启动节点</p><ul><li><p>注意: 启动的时候, 直接加上 <code>-detached</code> 参数的话, 可能会有些报错信息比如 <code>error : cannot_delete_plugins_expand_dir</code>, 这就是因为需要使用root权限才可以, 你可以使用 <code>pa aux | grep rabbitmq</code> 查看是否三个进程都成功启动了</p></li><li><p>注意: 启动时, 貌似不能像书上那样, RABBITMQ_NODENAME 只设置节点名, 最好设置上节点host</p></li><li><p>如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ sudo RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit@localhost rabbitmq-server -detached</span><br><span class="line">Warning: PID file not written; -detached was passed.</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ sudo RABBITMQ_NODE_PORT=5673 RABBITMQ_NODENAME=rabbit_1@localhost rabbitmq-server -detached</span><br><span class="line">Warning: PID file not written; -detached was passed.</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ sudo RABBITMQ_NODE_PORT=5674 RABBITMQ_NODENAME=rabbit_2@localhost rabbitmq-server -detached</span><br><span class="line">Warning: PID file not written; -detached was passed.</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></li><li><p>然后可以查看个节点状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit@localhost status</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_1@localhost status</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_2@localhost status</span><br></pre></td></tr></table></figure></li></ul></li><li><p>现在启动了三个节点 rabbit, rabbit_1, rabbit_2, 并且每个节点都会有系统的主机名在@后; 但是每个节点仍然是独立节点, 拥有自己的元数据, 并且不知道其他节点的存在;</p><ul><li>集群中的第一个节点rabbit,将初始元数据带入集群, 并且无需被告知加入;</li><li>而第二个和之后的节点, 将加入第一个节点rabbit, 并获取rabbit节点的元数据;  </li></ul></li><li><p>要将rabbit_1和rabbit_2节点加入rabbit, 要停止该Erlang节点上运行的rabbitmq应用程序, 并重设它们的元数据, 这样它们才可以被加入rabbit节点并且获取rabbit节点的元数据; 可以使用 <code>rabbitmqctl</code> 来完成这些工作</p><ul><li><p>停止rabbit_1节点上的应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_1@localhost stop_app</span><br><span class="line">Stopping rabbit application on node rabbit_1@renyimindeMacBook-Pro ...</span><br></pre></td></tr></table></figure></li><li><p>重设rabbit_1节点的元数据和状态为清空状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_1@localhost reset</span><br><span class="line">Resetting node rabbit_1@renyimindeMacBook-Pro ...</span><br></pre></td></tr></table></figure></li><li><p>这样你就准备好了一个 停止运行的并且清空了的 rabbit 应用, 现在可以准备好将其加入到集群中的第一个节点rabbit中:<br>注意书上的 <code>cluster</code> 命令好像已经不用了, 换成了 <code>join_cluster</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_1@localhost join_cluster rabbit@localhost</span><br><span class="line">Clustering node rabbit_1@localhost with rabbit@localhost</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></li><li><p>最后, 可以重启第二个节点的应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_1@localhost start_app</span><br><span class="line">Starting node rabbit_1@localhost ...</span><br><span class="line"> completed with 1 plugins.</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></li><li><p>节点rabbit_2加入集群的步骤同上, 具体操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_1@localhost start_app</span><br><span class="line">Starting node rabbit_1@localhost ...</span><br><span class="line"> completed with 1 plugins.</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_2@localhost stop_app</span><br><span class="line">Stopping rabbit application on node rabbit_2@localhost ...</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_2@localhost reset</span><br><span class="line">Resetting node rabbit_2@localhost ...</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_2@localhost join_cluster rabbit@localhost</span><br><span class="line">Clustering node rabbit_2@localhost with rabbit@localhost</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_2@localhost start_app</span><br><span class="line">Starting node rabbit_2@localhost ...</span><br><span class="line"> completed with 1 plugins.</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看集群状态, 可以在任意一个节点通过 <code>rabbitmqctl cluster_status</code> 进行查看</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@localhost ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@localhost,rabbit_1@localhost,rabbit_2@localhost]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit_2@localhost,rabbit_1@localhost,rabbit@localhost]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;&quot;rabbit@renyimindeMacBook-Pro&quot;&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;rabbit_2@localhost,[]&#125;,</span><br><span class="line">          &#123;rabbit_1@localhost,[]&#125;,</span><br><span class="line">          &#123;rabbit@localhost,[]&#125;]&#125;]</span><br><span class="line"></span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_1@localhost cluster_status</span><br><span class="line">Cluster status of node rabbit_1@localhost ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@localhost,rabbit_1@localhost,rabbit_2@localhost]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit_2@localhost,rabbit@localhost,rabbit_1@localhost]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;&quot;rabbit@renyimindeMacBook-Pro&quot;&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;rabbit_2@localhost,[]&#125;,</span><br><span class="line">          &#123;rabbit@localhost,[]&#125;,</span><br><span class="line">          &#123;rabbit_1@localhost,[]&#125;]&#125;]</span><br><span class="line"></span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_2@localhost cluster_status</span><br><span class="line">Cluster status of node rabbit_2@localhost ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@localhost,rabbit_1@localhost,rabbit_2@localhost]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@localhost,rabbit_1@localhost,rabbit_2@localhost]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;&quot;rabbit@renyimindeMacBook-Pro&quot;&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;rabbit@localhost,[]&#125;,</span><br><span class="line">          &#123;rabbit_1@localhost,[]&#125;,</span><br><span class="line">          &#123;rabbit_2@localhost,[]&#125;]&#125;]</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></li><li><p>注意: </p><ul><li>上面使用比较多的 <code>rabbitmqctl</code> 命令的关键参数是 <code>-n</code>, 这会告诉rabbitmqctl命令, 你想在指定节点而非默认节点<code>rabbit@</code>上执行命令;</li><li>记住, Erlang节点间通过Erlang cookie的方式来允许互相通信。因为rabbitmqctl使用Erlang OPT通信机制来和Rabbit节点通信, 运行rabbitmqctl的机器和所要连接的Rabbit节点必须使用相同的Erlang cookie, 否则你会得到一个错误;<br>当然, 上面的集群是在本机做伪集群, Erlang cookie 自然也都是一致的!</li></ul></li><li><p>将节点从集群中删除 <code>forget_cluster_node</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl forget_cluster_node rabbit_1@localhost</span><br><span class="line">Removing node rabbit_1@localhost from the cluster</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl forget_cluster_node rabbit_2@localhost</span><br><span class="line">Removing node rabbit_2@localhost from the cluster</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl forget_cluster_node rabbit_3@localhost</span><br><span class="line">Removing node rabbit_3@localhost from the cluster</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></li></ol><h2 id="集群节点类型设置与修改"><a href="#集群节点类型设置与修改" class="headerlink" title="集群节点类型设置与修改"></a><a href="http://www.rabbitmq.com/clustering.html#change-type" target="_blank" rel="noopener">集群节点类型</a>设置与修改</h2><ol><li><p>可以在将节点加入集群时, 设定节点的类型 (<a href="http://www.rabbitmq.com/clustering.html#creating-ram" target="_blank" rel="noopener">参考</a>)<br> 比如 <code>rabbitmqctl -n rabbit_3@localhost join_cluster --ram rabbit@localhost</code></p></li><li><p>之前已经通过 <code>rabbitmqctl cluster_status</code> 查看了集群的状态, 里面比较重要的是 <code>nodes</code> 部分</p><ul><li><p>下面告诉你有三个节点加入了集群, 并且三个节点都是 disc 磁盘节点!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&#123;nodes,[&#123;disc,[rabbit@localhost,rabbit_1@localhost,rabbit_2@localhost]&#125;]&#125;,</span><br><span class="line">     &#123;running_nodes,[rabbit@localhost,rabbit_1@localhost,rabbit_2@localhost]&#125;,</span><br><span class="line">     &#123;cluster_name,&lt;&lt;&quot;rabbit@renyimindeMacBook-Pro&quot;&gt;&gt;&#125;,</span><br><span class="line">     &#123;partitions,[]&#125;,</span><br><span class="line">     &#123;alarms,[&#123;rabbit@localhost,[]&#125;,</span><br><span class="line">              &#123;rabbit_1@localhost,[]&#125;,</span><br><span class="line">              &#123;rabbit_2@localhost,[]&#125;]&#125;]</span><br></pre></td></tr></table></figure></li><li><p>running_nodes 部分告诉你集群中的哪些节点正在运行; </p></li></ul></li><li><p>现在你可以连接到这三个running_nodes中的任何一个, 并且开始创建队列, 发布消息或者执行任何其他AMQP任务; </p></li><li><p>你也可以对节点类型进行修改, 如下将rabbit_2节点类型修改为内存节点 (注意: 修改节点类型, 需要先停止节点应用)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_2@localhost stop_app</span><br><span class="line">Stopping rabbit application on node rabbit_2@localhost ...</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_2@localhost change_cluster_node_type ram</span><br><span class="line">Turning rabbit_2@localhost into a ram node</span><br><span class="line"></span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_2@localhost start_app</span><br><span class="line">Starting node rabbit_2@localhost ...</span><br><span class="line"> completed with 1 plugins.</span><br><span class="line"></span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_1@localhost cluster_status</span><br><span class="line">Cluster status of node rabbit_1@localhost ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@localhost,rabbit_1@localhost]&#125;,</span><br><span class="line">         &#123;ram,[rabbit_2@localhost]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit_2@localhost,rabbit@localhost,rabbit_1@localhost]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;&quot;rabbit@renyimindeMacBook-Pro&quot;&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;rabbit_2@localhost,[]&#125;,</span><br><span class="line">          &#123;rabbit@localhost,[]&#125;,</span><br><span class="line">          &#123;rabbit_1@localhost,[]&#125;]&#125;]</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li>运行<a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Http/Controllers/Demo/LocalClusterController.php" target="_blank" rel="noopener">生产者代码</a>, 在集群中的rabbit节点中创建持久化队列<ul><li>初始集群状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@localhost ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@localhost,rabbit_1@localhost,rabbit_2@localhost]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit_2@localhost,rabbit_1@localhost,rabbit@localhost]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;&quot;rabbit@renyimindemacbook-pro.rrcoa.com&quot;&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;rabbit_2@localhost,[]&#125;,</span><br><span class="line">          &#123;rabbit_1@localhost,[]&#125;,</span><br><span class="line">          &#123;rabbit@localhost,[]&#125;]&#125;]</span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- 运行生产者, 查看创建的队列(已经有一条msg放入队列中)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl list_queues</span><br><span class="line">Timeout: 60.0 seconds ...</span><br><span class="line">Listing queues for vhost / ...</span><br><span class="line">prefetchCountQueue0</span><br><span class="line">localClusterQueue1</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_1@localhost list_queues</span><br><span class="line">Timeout: 60.0 seconds ...</span><br><span class="line">Listing queues for vhost / ...</span><br><span class="line">prefetchCountQueue0</span><br><span class="line">localClusterQueue1</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_2@localhost list_queues</span><br><span class="line">Timeout: 60.0 seconds ...</span><br><span class="line">Listing queues for vhost / ...</span><br><span class="line">prefetchCountQueue0</span><br><span class="line">localClusterQueue1</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit@localhost list_queues</span><br><span class="line">Timeout: 60.0 seconds ...</span><br><span class="line">Listing queues for vhost / ...</span><br><span class="line">prefetchCountQueue0</span><br><span class="line">localClusterQueue1</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></code></pre><ol><li><p>kill掉该持久化队列localClusterQueue所在的主节点rabbit</p><ul><li><p>查看节点进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ ps aux | grep rabbitmq</span><br><span class="line">root              2656   0.4  0.3  4150148  58156   ??  S    三01下午   5:09.15 /usr/local/Cellar/erlang@20/20.3.8.2/lib/erlang/erts-9.3.3.1/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf -MBlmbcs 512 -MHlmbcs 512 -MMmcs 30 -P 1048576 -t 5000000 -stbt db -zdbbl 1280000 -K true -- -root /usr/local/Cellar/erlang@20/20.3.8.2/lib/erlang -progname erl -- -home /Users/renyimin -- -pa /usr/local/Cellar/rabbitmq/3.7.7/ebin -noshell -noinput -s rabbit boot -sname rabbit@localhost -boot /usr/local/opt/erlang@20/lib/erlang/bin/start_clean -conf /usr/local/Cellar/rabbitmq/3.7.5/etc/rabbitmq/rabbitmq -conf_dir /usr/local/var/lib/rabbitmq/config -conf_script_dir /usr/local/sbin -conf_schema_dir /usr/local/var/lib/rabbitmq/schema -kernel inet_default_connect_options [&#123;nodelay,true&#125;] -rabbit tcp_listeners [&#123;&quot;127.0.0.1&quot;,5672&#125;] -sasl errlog_type error -sasl sasl_error_logger false -rabbit lager_log_root &quot;/usr/local/var/log/rabbitmq&quot; -rabbit lager_default_file &quot;/usr/local/var/log/rabbitmq/rabbit@localhost.log&quot; -rabbit lager_upgrade_file &quot;/usr/local/var/log/rabbitmq/rabbit@localhost_upgrade.log&quot; -rabbit enabled_plugins_file &quot;/usr/local/etc/rabbitmq/enabled_plugins&quot; -rabbit plugins_dir &quot;/usr/local/Cellar/rabbitmq/3.7.7/plugins&quot; -rabbit plugins_expand_dir &quot;/usr/local/var/lib/rabbitmq/mnesia/rabbit@localhost-plugins-expand&quot; -os_mon start_cpu_sup false -os_mon start_disksup false -os_mon start_memsup false -mnesia dir &quot;/usr/local/var/lib/rabbitmq/mnesia/rabbit@localhost&quot; -kernel inet_dist_listen_min 25672 -kernel inet_dist_listen_max 25672 -noshell -noinput</span><br><span class="line">renyimin         28537   0.0  0.0  2423384    232 s007  R+    3:12下午   0:00.00 grep rabbitmq</span><br><span class="line">root             72516   0.0  0.5  4143168  79400   ??  S     1:03下午   0:16.71 /usr/local/Cellar/erlang@20/20.3.8.2/lib/erlang/erts-9.3.3.1/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf -MBlmbcs 512 -MHlmbcs 512 -MMmcs 30 -P 1048576 -t 5000000 -stbt db -zdbbl 1280000 -K true -- -root /usr/local/Cellar/erlang@20/20.3.8.2/lib/erlang -progname erl -- -home /Users/renyimin -- -pa /usr/local/Cellar/rabbitmq/3.7.7/ebin -noshell -noinput -s rabbit boot -sname rabbit_2@localhost -boot /usr/local/opt/erlang@20/lib/erlang/bin/start_clean -conf /usr/local/Cellar/rabbitmq/3.7.5/etc/rabbitmq/rabbitmq -conf_dir /usr/local/var/lib/rabbitmq/config -conf_script_dir /usr/local/sbin -conf_schema_dir /usr/local/var/lib/rabbitmq/schema -kernel inet_default_connect_options [&#123;nodelay,true&#125;] -rabbit tcp_listeners [&#123;&quot;127.0.0.1&quot;,5674&#125;] -sasl errlog_type error -sasl sasl_error_logger false -rabbit lager_log_root &quot;/usr/local/var/log/rabbitmq&quot; -rabbit lager_default_file &quot;/usr/local/var/log/rabbitmq/rabbit_2@localhost.log&quot; -rabbit lager_upgrade_file &quot;/usr/local/var/log/rabbitmq/rabbit_2@localhost_upgrade.log&quot; -rabbit enabled_plugins_file &quot;/usr/local/etc/rabbitmq/enabled_plugins&quot; -rabbit plugins_dir &quot;/usr/local/Cellar/rabbitmq/3.7.7/plugins&quot; -rabbit plugins_expand_dir &quot;/usr/local/var/lib/rabbitmq/mnesia/rabbit_2@localhost-plugins-expand&quot; -os_mon start_cpu_sup false -os_mon start_disksup false -os_mon start_memsup false -mnesia dir &quot;/usr/local/var/lib/rabbitmq/mnesia/rabbit_2@localhost&quot; -kernel inet_dist_listen_min 25674 -kernel inet_dist_listen_max 25674 -noshell -noinput</span><br><span class="line">root             71841   0.0  0.5  4138448  77104   ??  S     1:01下午   0:15.15 /usr/local/Cellar/erlang@20/20.3.8.2/lib/erlang/erts-9.3.3.1/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf -MBlmbcs 512 -MHlmbcs 512 -MMmcs 30 -P 1048576 -t 5000000 -stbt db -zdbbl 1280000 -K true -- -root /usr/local/Cellar/erlang@20/20.3.8.2/lib/erlang -progname erl -- -home /Users/renyimin -- -pa /usr/local/Cellar/rabbitmq/3.7.7/ebin -noshell -noinput -s rabbit boot -sname rabbit_1@localhost -boot /usr/local/opt/erlang@20/lib/erlang/bin/start_clean -conf /usr/local/Cellar/rabbitmq/3.7.5/etc/rabbitmq/rabbitmq -conf_dir /usr/local/var/lib/rabbitmq/config -conf_script_dir /usr/local/sbin -conf_schema_dir /usr/local/var/lib/rabbitmq/schema -kernel inet_default_connect_options [&#123;nodelay,true&#125;] -rabbit tcp_listeners [&#123;&quot;127.0.0.1&quot;,5673&#125;] -sasl errlog_type error -sasl sasl_error_logger false -rabbit lager_log_root &quot;/usr/local/var/log/rabbitmq&quot; -rabbit lager_default_file &quot;/usr/local/var/log/rabbitmq/rabbit_1@localhost.log&quot; -rabbit lager_upgrade_file &quot;/usr/local/var/log/rabbitmq/rabbit_1@localhost_upgrade.log&quot; -rabbit enabled_plugins_file &quot;/usr/local/etc/rabbitmq/enabled_plugins&quot; -rabbit plugins_dir &quot;/usr/local/Cellar/rabbitmq/3.7.7/plugins&quot; -rabbit plugins_expand_dir &quot;/usr/local/var/lib/rabbitmq/mnesia/rabbit_1@localhost-plugins-expand&quot; -os_mon start_cpu_sup false -os_mon start_disksup false -os_mon start_memsup false -mnesia dir &quot;/usr/local/var/lib/rabbitmq/mnesia/rabbit_1@localhost&quot; -kernel inet_dist_listen_min 25673 -kernel inet_dist_listen_max 25673 -noshell -noinput</span><br></pre></td></tr></table></figure></li><li><p><code>sudo kill 2656</code></p></li></ul></li><li><p>将生产者改连 rabbit_1 节点, 重新运行生产者</p><ul><li>报错:<br><img src="/img/rabbitmq/cluster-error01.png"></li><li>挂掉的主节点中<strong>已存在该持久化队列</strong>, 如果在主节点挂掉后, 你能直接连接其他节点创建该队列的话, 此时创建的是个新队列, 要知道, 宕机的主节点中的持久化队列还在等待恢复呢, 它内部可能让然有很多msg需要恢复并被处理;<br>所以Rabbit集群的这个问题是有原因的!!</li></ul></li><li><p>可以重新启动该节点 <code>sudo RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit@localhost rabbitmq-server -detached</code></p><ul><li>会发现之前的持久化队列会被恢复<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit@localhost list_queues</span><br><span class="line">Timeout: 60.0 seconds ...</span><br><span class="line">Listing queues for vhost / ...</span><br><span class="line">localClusterQueue1</span><br><span class="line">prefetchCountQueue0</span><br><span class="line"></span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_1@localhost list_queues</span><br><span class="line">Timeout: 60.0 seconds ...</span><br><span class="line">Listing queues for vhost / ...</span><br><span class="line">localClusterQueue1</span><br><span class="line">prefetchCountQueue0</span><br><span class="line"></span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_2@localhost list_queues</span><br><span class="line">Timeout: 60.0 seconds ...</span><br><span class="line">Listing queues for vhost / ...</span><br><span class="line">localClusterQueue1</span><br><span class="line">prefetchCountQueue0</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></li></ul></li><li><p>此时即使生产者连接着 rabbit_1 也可以创建该同名持久化队列了</p><ul><li>重新运行刚才连接到 rabbit_1 的生产者, 不会报错了, 而是正确往队列发布了一条消息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl -n rabbit_2@localhost list_queues</span><br><span class="line">Timeout: 60.0 seconds ...</span><br><span class="line">Listing queues for vhost / ...</span><br><span class="line">localClusterQueue2</span><br><span class="line">prefetchCountQueue0</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当你需要在生产环境中部署RabbitMQ时, 需要注意的是, 单实例在生产环境虽然部署起来很容易, 但是当你的rabbitmq服务器遇到内存
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>20. 消费者预取 Consumer Prefetch</title>
    <link href="http://blog.renyimin.com/2018/06/13/rabbitmq/2018-06-13-rabbitmq-20/"/>
    <id>http://blog.renyimin.com/2018/06/13/rabbitmq/2018-06-13-rabbitmq-20/</id>
    <published>2018-06-13T11:23:36.000Z</published>
    <updated>2018-07-19T02:06:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Consumer-Prefetch"><a href="#Consumer-Prefetch" class="headerlink" title="Consumer Prefetch"></a><a href="https://www.rabbitmq.com/consumer-prefetch.html" target="_blank" rel="noopener">Consumer Prefetch</a></h2><ol><li><p>作为限制 unacked 消息数量的更自然有效的方法; AMQP 0-9-1 指定了 <code>basic.qos</code> 方法, 以便你在消费者进行消费时, 可以限制channel(或connection)上未确认消息的数量; </p><ul><li>但是值得注意的是: channel 并不是理想的设定范围, 因为单个channel可能从多个队列进行消费, channel和queue需要为每个发送的消息相互协调, 以确保它们不会超出限制, 这在单台机器上会慢, 而在整个集群中使用时会非常慢;</li><li>此外, 对于许多用途, 指定<strong>适用于每个消费者的预取计数</strong>更会简单一些;</li></ul></li><li><p>因此, RabbitMQ在 <code>basic.qos</code> 方法中重新定义了<strong>全局标志</strong>的含义 (在php-amqplib中basic_qos()的第三个参数a_global):<br> <img src="/img/rabbitmq/qos-global.png"><br> 请注意, 在大多数API中, 全局标志的默认值为false; (php-amqplib的basic_qos()方法的第三个参数a_global默认也为false)</p></li></ol><h2 id="简要分析"><a href="#简要分析" class="headerlink" title="简要分析"></a>简要分析</h2><ol><li><p>在使用RabbitMQ时, 如果完全不配置QoS, RabbitMQ是不会考虑到Consumers端是否ack的情况, 而是采用默认方式, 将队列中的所有消息按照网络和客户端允许的速度<strong>尽快轮发</strong>到与队列绑定的consumers端; 而consumers会在本地缓存所有投递过来的messages, 这样的话, 就可能会导致</p><ul><li>如果某个消费者的业务逻辑处理比较复杂(将会在较长时间之后才会操作完成并进行ack), 这也就导致消费慢的Consumer将会在本地堆积很多消息, 从而导致内存不足或者对其他进程造成影响 (<strong>消费者可能被撑到假死</strong>);</li><li>而其他消费能力强的Consumers, 可能已经很快地消费完成处于闲置状态, <strong>从而造成资源浪费</strong>; </li><li>同时, 新启的消费者也无法分担已经被之前消费者缓存到其本地的消息, 所以此时即便启动更多消费者, 也<strong>无力缓解大量的 unacked 消息积压, 让你产生疑惑</strong>;</li></ul></li><li><p><strong>而当你设置了Qos之后, RabbitMQ虽然也是将队列中的消息尽快轮发到Consumers中, 但是因为消费者具有的 prefetch_count 消息预取值上限, 所以RabbitMQ在轮发消息的时候, 如果发现消费者的 unacked 消息达到了 prefetch_count 的值, 即使rabbitmq中有很多ready的就绪消息, 也不会给该Consumer继续投递消息了(只有消费者的 unacked 消息小于prefetch_count的值时, 才会继续通过轮发方式给该consumer投递ready消息), 如果此时有新的消费者加入, 它也将会拿到未投递出去的ready消息!</strong></p><ul><li>可以通过启动 prefetchCountConsumer1，prefetchCountConsumer2 两个消费者(prefetch_count 均为10), 然后使用下面测试中的生产者发送100条消息, 前期观察会发现队列中消息的最大 unacked 为20, 并且你会发现队列中处于ready状态的消息会每次2个的递减, 这就预示着, 每次这两个消费者只要 unacked 的消息书小于prefetch_count(10), Rabbitmq才会给这两个consumer各自发送一条msg;</li><li>之后如果启动了 prefetchCountConsumer3(prefetch_count为20), 此时会发现队列中消息的最大 unacked 会为40, prefetchCountConsumer3的加入会使得队列中处于ready状态的消息直接骤减20个, 最后rabbitmq中的ready消息已经为0, 每个消费者还在继续消费各自未 unacked 的消息, 最终消费完成后, 整个队列中的 unacked 消息为0;</li></ul></li><li><p>Qos的设置只有在<strong>开启手动ack</strong>后才会生效 (即, prefetch_count 在 no_ask=false 的情况下生效)</p></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li><p>一般情况下, 同一队列绑定的多个消费者都是处理同一个业务, 而且如果在同一台机器启动, 消费能力应该都差不多, 但也难免出现如: 消费者资源分配不均 或者 两个消费者在处理业务时所请求的服务端机器配置有差异(假设SLB后又2台配置不均的机器), 这种情况还是应该考虑进来的! </p></li><li><p>本测试比较简单, 主要测试在默认不设置Qos的情况下, 两个消费能力不同的消费者在处理消息时存在的问题之一: 由于这种情况下, RabbitMQ是不会考虑到Consumers端是否ack的情况, 而是只顾自己轮发消息, 这样就会导致消息被轮发完成后, 消费能力高的消费者可能很快消费完消息并处于闲置状态, 而消费能力低的消费者却在很慢地进行消费, <strong>这样就造成了资源的浪费</strong>;</p></li><li><p>准备</p><ul><li>创建消费者1 ‘qosCustomer1’ (简单打印消息内容) , <a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Console/Commands/qosConsumer1.php" target="_blank" rel="noopener">代码参考</a>, <strong>启动消费者</strong> <code>php artisan qosConsumer1</code></li><li>创建消费者2 ‘qosCustomer2’ (sleep 5秒, 模拟处理能力比较差) , <a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Console/Commands/qosConsumer2.php" target="_blank" rel="noopener">代码参考</a>, <strong>启动消费者</strong>  <code>php artisan qosConsumer2</code></li><li><p>创建生产者一次向队列 ‘qosQueue’ 中推送10条消息 , <a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Http/Controllers/Demo/QosController.php" target="_blank" rel="noopener">代码参考</a>, <strong>请求一次生产者</strong> <a href="http://www.rabbit.com/testQos" target="_blank" rel="noopener">http://www.rabbit.com/testQos</a></p></li><li><p>注意需要先启动消费者, 再请求生产者; (如果先请求了生产者, 可能在启动第一个消费者之后, 其会迅速消费完10条消息, 这样就无法模拟效果了)</p></li></ul></li><li><p>测试发现</p><ul><li>qosCustomer1 : 迅速打印出结果(1,3,5,7,9), 然后就处于闲置状态了</li><li>qosCustomer2 : 还在缓慢打印(2,4,6,8,10)</li><li>可以看到, 如果不设置Qos, Rabbitmq会尽快将消息从队列中轮发投递出去, 不会对消费者的消费能力进行任何评估! </li></ul></li><li><p>所以: 为了避免这种浪费资源的情况, 你可能就需要根据上一篇讲解的 prefetch_count 来针对不同消费者进行设置;</p></li></ol><h2 id="问题答疑测试"><a href="#问题答疑测试" class="headerlink" title="问题答疑测试"></a>问题答疑测试</h2><ol><li><p>根据上面的描述, 有个疑问: 在默认不设置Qos的情况下, 既然生产者发布的消息会尽可能全部推送给消费者进程, 队列中会尽可能将消息全部推出, 缓存在消费者本地, 那当消费者断开时, 消息是如何恢复到队列中的? 或者不会恢复到队列中? 为了答疑, 下面进行测试 </p></li><li><p>准备测试代码</p><ul><li><p>创建消费者1 ‘prefetchCountConsumer1’ (sleep 5秒, 模拟耗时业务需求; prefetch=100; 简单打印消息内容), <a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Console/Commands/prefetchCountConsumer1.php" target="_blank" rel="noopener">代码参考</a></p></li><li><p>创建消费者2 ‘prefetchCountConsumer2’ (sleep 5秒, 模拟耗时业务需求; prefetch=100; 简单打印消息内容), <a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Console/Commands/prefetchCountConsumer2.php" target="_blank" rel="noopener">代码参考</a></p></li><li><p>生产者一次向队列 ‘prefetchCountQueue’ 中推送100条消息 , <a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Http/Controllers/Demo/PrefetchCountController.php" target="_blank" rel="noopener">代码参考</a></p></li></ul></li><li><p>测试:</p><ul><li><p>在生产者请求一次之后(<a href="http://www.rabbit.com/prefetchCount" target="_blank" rel="noopener">http://www.rabbit.com/prefetchCount</a>), <code>ready : 100, unacked: 0, total : 100</code>, 表示队列中已经有100条消息已经就绪, 等待发出<br><img src="/img/rabbitmq/qos-test01.png" width="450"></p></li><li><p>运行第一个<code>php artisan prefetchCountConsumer1</code>之后, <code>ready : 0, unacked : 100, total : 100</code> (也就是说, queue中已经没有 ready状态, 即准备好待发送的消息了, 消息都传递给消费者1了)<br><img src="/img/rabbitmq/qos-test02.png" width="450"></p></li><li><p>随着消费者的缓慢消费, <code>ready : 0, unacked : 94, total : 94</code>  ()<br><img src="/img/rabbitmq/qos-test03.png" width="450"></p></li><li><p>如果模拟 挂掉第一个消费者之后, 会发现, <code>ready : 83， unacked : 0, total : 83</code> (<strong>也就是说消费者意外宕掉之后, 队列中的消息会重新处于就绪状态</strong>, 等待着新的消费者来消费)<br><img src="/img/rabbitmq/qos-test04.png" width="450"></p></li><li><p>再次启动消费者2 <code>php artisan testQosConsumerPrefetchCount2</code>之后, <code>ready : 0, unacked : 80, total : 80</code> (消息又会被全量发送给消费者2)</p></li><li><p>注意: 如果此时启动消费者1, 你会发现, 它是无法帮助消费者2进行消费的, 因为消息都在消费者2的本地, 所以队列中并没有 <strong>ready状态的就绪消息</strong>;</p></li></ul></li><li><p>测试注意: 上述测试过程如果先启动两个消费者, 然后再发布消息进行测试, 你会发现, 由于两个消费者都设置了预取值, 而且相等, 所以消息仍然会快速轮发给这两个消费者;</p><ul><li>如果将两个消费者的 prefetch_count 都设置为10, 那么你会发现, unacked 最多也就是两个消费者的prefetch_count和, 即20个<br><img src="/img/rabbitmq/qos-test05.png" width="450"></li></ul></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>消费者的 unacked 消息数量如果未达到Qos设置的 prefetch_count 量, <strong>Rabbit不会顾及消费者的消费能力, 会尽可能将queue中的消息全部推送出去给消费者</strong>;</p></li><li><p>因此, 当你发现消费者消费缓慢, 产生大量 unacked 消息时, 即便增加新的消费者, 也无法帮助之前的消费者分担消息(除非消费者1的 unacked 达到了 prefetch_count 限制), 只能分担队列中处于 ready 状态的消息;</p></li><li><p>除非你断开之前的消费者, 然后启动一个新的消费者, 消费者中积压的消息才会重新放入队列中 (因为之前的消费者挂掉之后, 其处理后的剩余消息在 queue中会恢复为 ready 状态)<br> 但是注意: 新启动的这个消费者如果设置额prefetch_count不合理的话, 假设与之前消费者的 预取值 设置一样大, 它很快也会产生大量 unacked 消息<br> 所以, 在新启消费者的时候, 需要设计好 prefetch_count 的大小, 然后可以启动多个消费者来共同进行消费;</p></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li><p>rabbitmq对 basic.qos 信令的处理</p><ul><li>首先, basic.qos 是针对 channel 进行设置的, 也就是说只有在channel建立之后才能发送basic.qos信令; RabbitMQ只支持通道级的预取计数, 而不是connection级的 或者 基于大小的预取;<br><a href="http://www.bubuko.com/infodetail-1955647.html" target="_blank" rel="noopener">预取</a></li><li>在rabbitmq的实现中, 每个channel都对应会有一个rabbit_limiter进程, 当收到basic.qos信令后, 在rabbit_limiter进程中记录信令中prefetch_count的值, 同时记录的还有该channel未ack的消息个数;</li></ul></li><li><p>在<code>php-amqplib</code>中, 可以使用 channel 的 <code>basic_qos()</code> 方法来进行控制, <code>basic_qos()</code> 有三个参数:</p><ul><li>prefetch_size : 限制预取的消息大小的参数, rabbitmq暂时没有实现 (如果prefetch_size字段不是默认值0, 则会通知客户端出错, 通知客户端<strong>RabbitMQ系统没有实现该参数的功能</strong>, 还可以参考<a href="https://github.com/sky-big/RabbitMQ/blob/d7a773e11f93fcde4497c764c9fa185aad049ce2/src/rabbit_channel.erl" target="_blank" rel="noopener">此文</a>)<br>当你设置prefetch_size大于0的时候, 会出现如下报错<br><img src="/img/rabbitmq/qos-prefetch-size-error.png" width="400"></li><li>prefetch_count : 预取消息数量</li><li>global: 在3.3.0版本中对global这个参数的含义进行了重新定义, 即glotal=true时表示在当前channel上所有的consumer都生效(包括已有的), 否则只对设置了之后新建的consumer生效;</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Consumer-Prefetch&quot;&gt;&lt;a href=&quot;#Consumer-Prefetch&quot; class=&quot;headerlink&quot; title=&quot;Consumer Prefetch&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.rabbitmq.com/c
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>19. 消费者预取 Consumer Prefetch (避免队列大量unacked积压及Consumer假死)</title>
    <link href="http://blog.renyimin.com/2018/06/12/rabbitmq/2018-06-12-rabbitmq-19/"/>
    <id>http://blog.renyimin.com/2018/06/12/rabbitmq/2018-06-12-rabbitmq-19/</id>
    <published>2018-06-12T03:26:55.000Z</published>
    <updated>2018-07-21T03:21:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ关于吞吐量-延迟和带宽的一些理论"><a href="#RabbitMQ关于吞吐量-延迟和带宽的一些理论" class="headerlink" title="RabbitMQ关于吞吐量,延迟和带宽的一些理论"></a><a href="https://www.rabbitmq.com/blog/2012/05/11/some-queuing-theory-throughput-latency-and-bandwidth/" target="_blank" rel="noopener">RabbitMQ关于吞吐量,延迟和带宽的一些理论</a></h2><ol><li><p>假设你在Rabbit中有一个队列, 并有一些客户端从这个队列中进行消费, 如果你根本没有设置QoS, 那么Rabbit将尽可能快地按照网络和客户端允许的速度将所有队列的消息推送到客户端; 因此, 消费者所占用的内存将会激增, 因为它们将所有消息都缓存在自己的RAM中; 同时, 值得注意的是: 此时如果你询问Rabbit, <strong>队列可能会显示为空</strong>, 但是会有大量的 unacked 消息; 并且此时如果你添加新的消费者, 由于消息已经在现有的客户端中缓存, 队列中并没有 ready状态的 消息, 所以即使增加更多新的消费者, 也无法缓解队列中 unacked 消息数量, 这是相当次优的!</p></li><li><p>所以，默认的QoS预取给客户端(consumer)设置了无限的缓冲区, 这可能导致不良的行为和性能; 那么, 应该将QoS预取缓冲区大小设置为多少呢? 目标是让消费者保持工作饱和状态, <strong>但要尽量减少客户端的缓冲区大小, 以便让更多的消息保留在Rabbit的队列中, 这样就可以供新消费者来消费</strong>;</p></li><li><p>比方说, Rabbit从这个队列中拿出一条消息, 把它投递给消费者, 需要50ms, 而Consumer处理消息需要4ms; 一旦消费者处理了消息, 它就会发送一个ack给Rabbit, 这将再次花费50ms发送给Rabbit并被Rabbit进行处理; 所以 消费完成并进行一次ack的时间 + 一次消息从队列到Consumer的投递时间 总共会花费104ms的往返时间。</p><ul><li><p>如果我们消息设置了QoS预取值为1, 那么直到这个往返行程完成之前, Rabbit是不会发送下一个消息给客户端的;<br>因此, 每次往返的104ms中, Consumer只有4ms, 或者说只有3.8％的时间忙碌, 而我们希望Consumer百分之百的时间都在忙碌中;</p></li><li><p>如果我们在每个消息的客户端上执行 <code>总的往返时间/处理时间</code>, 会得到 <code>104/4 = 26</code><br>如果我们设置消息的QoS预取值为26, 那就解决了我们的问题: 如果每条消息需要4ms的处理来处理, 那么总共需要 <code>26×4 = 104ms</code> 来处理整个缓冲区(中的消息);<br>第一个4ms是第一个消息的处理时间, 处理完成后, 客户端然后发出一个确认(这需要50ms才能到达代理), 然后继续处理缓冲区中的下一条消息, 一次ack时间 + 新一轮消息的投递时间 = 100s, Consumer正好完成缓冲区剩下的25条消息, 然后新的26条消息也已经到达, 并准备好等待客户端来处理它;<br>因此, 客户端始终处于忙碌状态: 具有较大的QoS预取值也不会使其更快了, 但是我们最大限度地减少了缓冲区的大小, 并且减少了客户端消息的延迟;<br><strong>客户端能够在下一条消息到达之前完全排空缓冲区, 因此缓冲区实际上保持为空</strong>;</p></li><li><p>如果处理时间和网络行为保持不变, 此解决方案绝对没问题</p></li></ul></li><li><p>但考虑一下如果网络突然间速度减半会发生什么情况?</p><ul><li><p>显然, 网络传输时间就加长了, 此时你的预取缓冲区(也就是你设置的prefetch预取值)就不够大了, 现在Consumer会就会稍有闲置, 等待新消息到达, 因为客户端能够处理消息的速度比Rabbit能够提供新消息的速度要快;</p></li><li><p>为了解决这个问题, 我们可能会决定将QoS预取大小加倍(或接近两倍), 如果我们从26开始将它推到51, 那么如果客户端处理保持在每个消息4ms, 我们现在在缓冲区中会有51 * 4 = 204ms的消息处理时间, 其中4ms将用于处理消息, 而200ms用于发送消息回复rabbit并收到下一条消息, 因此, 我们现在可以应对网络速度的减半;</p></li></ul></li><li><p>再次分析: 如果网络又恢复正常运行, 现在将QoS预取加倍, 意味着每个消息都会驻留在客户端缓冲区中一段时间​​, 而不是在到达客户端时立即处理; 从现在51条消息的完整缓冲区开始, 我们知道新消息将在客户端完成处理第一条消息之后的100ms处开始出现在客户端, 但在这100毫秒内, 客户只能处理100/4 = 25个消息, 这意味着当新消息到达客户端时, 它会在客户端从缓冲区头部移除时被添加到缓冲区的末尾;</p><ul><li><p>而缓冲区将始终保持(50 - 25 = 25)个消息长度, <strong>因此每个消息将在缓冲区中保持 25 * 4 = 100ms</strong>;</p></li><li><p>因此, <strong>增加预取缓冲区大小, 可以使consumer应对恶化的网络性能, 同时保持客户端繁忙</strong>;</p></li></ul></li><li><p>同样, 如果不是网络性能的恶化, 而是客户端开始花费40ms来处理每条消息而不是之前的4ms, 会发生什么情况?</p><ul><li><p>假设原始的预取缓冲区大小设置的是26条消息, 客户端现在需要花40ms处理第一条消息, 然后将确认消息发送回Rabbit并移至下一条消息;<br>ack仍然需要50ms才能到达Rabbit, 而Rabbit发出一条新的消息需要50ms, 但在100ms内, 客户端只处理了 100/40 = 2.5 条消息, 而不是剩余的25条消息;<br>因此当新消息到来时, 缓冲区在这一点上仍然是有 25 - 3 = 22 个消息, 这样的话, 来自Rabbit的新消息就不会被立即处理, 而是位于第23位, 落后于其他22条仍在等待处理的消息;<br>客户端(Consumer)将会有 22 * 40 = 880ms 的时间都不会触及到那个新到的消息, 鉴于从Rabbit到客户端的网络延迟仅为50ms, 这个额外的880ms延迟现在为延迟的95％ (880 / (880 + 50) = 0.946);</p></li><li><p><strong>当你决定尝试通过添加更多消费者来处理这种增长的积压时, 需要注意, 现在有消息正在被现有客户端缓冲, 并不是说你增加消费者就能缓解这部分的压力!</strong></p></li><li><p>更糟糕的是, 如果我们将缓冲区大小设置为可以预取51条消息以应对网络性能下降,会发生什么?<br>处理第一条消息后, 将在客户端缓冲另外50条消息, 100ms后(假设网络运行正常), 一条新消息将从Rabbit到达客户端, consumer在100ms中只能处理这50条消息中的两条消息(缓冲区现在为47条消息长),<br>因此新消息将会在缓冲区中是第48位, 这样的话, 知道 47 <em> 40 = 1880ms 之后, 消费者才会开始处理新来的消息, 同样, 考虑到向客户端发送消息的网络延迟仅为50ms, 现在这个1880ms的延迟意味着客户端缓冲占延迟的97％(1880/(1880 + 50)= 0.974);<br>这可能是不可接受的: 数据只能在客户端收到后2秒内立即处理, 才能有效且有用！<br><em>*如果其他消费客户端空闲, 他们无能为力</em></em>: 一旦Rabbit向客户端发送消息, 消息就是客户端的责任, 直到他们拒绝或拒绝消息; 消息发送到客户端后，客户端不能窃取彼此的消息;<br>您希望客户端保持繁忙状态, 但客户端尽可能少地缓存消息, 以便客户端缓冲区不会延迟消息, 因此新消费客户端可以快速接收来自Rabbit队列的消息;</p></li><li><p>因此, 如果网络变慢, 缓冲区太小会导致客户端空闲; 但如果网络正常运行, 缓冲区太大会导致大量额外的延迟;<br>如果客户端突然开始花费更长时间来处理每个缓冲区, 则会导致大量额外的延迟;<br>很明显, 你真正想要的是可以变化的缓冲区大小, 这些问题在网络设备中很常见, 并且一直是很多研究的主题;<br>主动队列管理算法试图尝试放弃或拒绝消息，以避免消息长时间处于缓冲区。当缓冲区保持空闲时（每条消息只遭受网络延迟，并且根本不在缓冲区中），缓冲区在那里吸收峰值，从而实现最低延迟。从网络路由器的角度来看，Jim Gettys一直在研究这个问题：局域网和广域网性能之间的差异会遇到完全相同的问题。实际上，无论何时，在生产者（在我们的例子中为Rabbit）和消费者（客户端应用程序逻辑）之间都有一个缓冲区，双方的性能可以动态变化，您将会遇到这些问题。最近发布了一种名为Controlled Delay的新算法，该算法似乎在解决这些问题方面效果很好。</p></li></ul></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>针对Qos的提前预习</p><ul><li><p><a href="https://www.rabbitmq.com/confirms.html#channel-qos-prefetch" target="_blank" rel="noopener">信道预取设置(QoS)</a><br>由于消息是异步发送(推送)给客户端的, 因此在任何给定时刻通常都有不止一条消息在信道上运行; 此外, 客户的手动确认本质上也是异步的, 所以有一个 未确认的交付标签的滑动窗口, 开发人员通常会倾向于限制此窗口的大小, <strong>以避免消费者端无限制的缓冲区问题</strong>。<br>这是通过使用 <code>basic.qos</code> 方法设置 <code>预取计数</code> 值完成的, 该值定义了<strong>channel上允许的最大未确认递送数量</strong>, 一旦数字达到配置的计数, RabbitMQ将停止在通道上传送更多消息, 除非至少有一个未确认的消息被确认;<br>例如, 假设在通道 “Ch” 上有未确认的交付标签5,6,7和8, 并且通道 “Ch” 的预取计数(后面会学到是<code>prefetch_count</code>)设置为4, 则RabbitMQ将不会在 “Ch” 上推送更多交付, 除非至少有一个未完成的交付被确认(当确认帧在 <code>delivery_tag=8</code> 的频道上到达时, <strong>RabbitMQ将会注意到并再发送一条消息</strong>)</p></li><li><p>QoS预取设置对使用 <code>basic.get</code>(<code>pull API</code>) 获取的消息没有影响, 即使在手动确认模式下也是如此;</p></li></ul></li><li><p>消费者确认模式, 预取和吞吐量<br> 确认模式 和 QoS预取值 对消费者吞吐量有显着影响, 一般来说, <strong>增加预取值将提高向消费者传递消息的速度, 当然, 自动确认模式可以产生最佳的传送速率</strong><br> 但是, 在上面两种情况下, 尚未完成交付处理的消息(unacked)数量也会增加, 从而增加消费者RAM消耗;<br> <strong>自动确认模式或带无限预取的手动确认模式应谨慎使用</strong>, 消费者在没有确认的情况下消耗大量消息将导致其所连接的节点上的内存消耗增长;<br> 预取值1是最保守的, 但这将显着降低吞吐量, 特别是在消费者连接延迟较高的环境中, 对于许多应用来说, 更高的价值是合适和最佳的;<br> 100到300范围内的Qos(<code>prefetch_count</code>)预取值通常提供最佳的吞吐量, 并且不会面临压垮consumer的重大风险, 而更高的值往往会遇到效率递减的规律; </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RabbitMQ关于吞吐量-延迟和带宽的一些理论&quot;&gt;&lt;a href=&quot;#RabbitMQ关于吞吐量-延迟和带宽的一些理论&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ关于吞吐量,延迟和带宽的一些理论&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>08. 事务 VS Publisher Confirms(发布者确认机制)</title>
    <link href="http://blog.renyimin.com/2018/06/05/rabbitmq/2018-06-05-rabbitmq-08/"/>
    <id>http://blog.renyimin.com/2018/06/05/rabbitmq/2018-06-05-rabbitmq-08/</id>
    <published>2018-06-05T11:20:56.000Z</published>
    <updated>2018-07-20T11:29:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题的出现"><a href="#问题的出现" class="headerlink" title="问题的出现"></a>问题的出现</h2><ol><li><p>和消息持久化相关的一个概念是 AMQP 的事务(transaction)机制;</p></li><li><p>到目前为止, 我们讨论的是将 <code>消息</code>, <code>队列</code> 和 <code>交换器</code> 设置为持久化; 这一切都工作的很好, 并且RabbitMQ也负责保证消息的安全, 但是由于 <strong>发布消息的操作并不会反回任何信息给生产者</strong>, 所以你也无法得知是否消息已经到达了服务器并且服务器是否已经将消息持久化到了硬盘;</p><ul><li>服务器可能会在把消息写入到硬盘前就宕机了, 或者消息压根就还没有发送到服务器, 服务器就宕机了, 消息会因此而丢失, 而你却不知道; </li><li>另外, 你可能是发送多条消息, 如果部分发送成功, 部分失败呢? 这你也无法得知;</li></ul></li></ol><h2 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h2><ol><li><p>为了确保消息能够被安全发布到Broker, 如果使用标准的AMQP 0-9-1, 保证消息不会丢失的唯一方法是使用 <strong>事务机制</strong> (将channel事务化)</p></li><li><p>php-amqplib 中与事务机制有关的方法有三个, 分别是Channel里面的 <code>txSelect()</code>, <code>txCommit()</code> 以及 <code>txRollback()</code>;</p><ul><li>txSelect(): 用于将当前Channel设置成是transaction模式</li><li>txCommit(): 用于提交事务</li><li>txRollback(): 用于回滚事务</li></ul></li><li><p>但是值得注意的是事务存在的问题: </p><ul><li>AMQP 0-9-1 中的事务几乎吸干了RabbitMQ的性能, 会导致事务吞吐量严重下降;</li><li>事务会使得生产者应用程序变成同步的, 而你使用消息通信就是为了避免同步;</li></ul></li><li><p>鉴于上面的问题, 你可能不会在生产中使用事务机制, 此处只做了个简单的事务测试, <a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Http/Controllers/Demo/TxController.php" target="_blank" rel="noopener">测试代码</a></p></li></ol><h2 id="Publisher-Confirms"><a href="#Publisher-Confirms" class="headerlink" title="Publisher Confirms"></a><a href="https://www.rabbitmq.com/confirms.html#publisher-confirms" target="_blank" rel="noopener">Publisher Confirms</a></h2><ol><li><p>既然事务存在的问题让你拒绝使用它, 但是<code>确保消息被成功投递到服务器</code>这个问题仍需要解决; 为了避免事务机制在解决问题时导致的新问题, RabbitMQ团队拿出了更好的方案来保证消息的投递: <strong>发送方确认模式</strong></p></li><li><p>它模仿协议中已经存在的 <strong>消费者确认机制</strong></p></li><li><p>要启用这个确认机制，客户端可以通过使用 channel 的 <code>confirm.select</code> 方法</p><ul><li><p>如果设置了 <code>confirm.select</code> 方法的 <code>no-wait</code>, 代理会用 <code>confirm.select-ok</code> 进行响应, 不过这点你貌似也只能通过抓包来观察:<br><img src="/img/rabbitmq/wireshark-Confirm.Select-ok.png"></p></li><li><p>这里说的 <code>confirm.select-ok</code> 是代理对发布者的响应信息 (和 php-amqplib包中的 <code>confirm_select_ok()</code> 方法可不是一个意思, 而且php-amqplib也没对confirm_select_ok做实现)</p></li></ul></li><li><p>上面也提到了, 该确认机制是模仿已经存在的 消费者确认机制, 所以, Broker也会使用类似 <strong>ack</strong>, <strong>nack</strong> 来响应Publisher: </p><ul><li><p>可以通过为 <code>set_ack_handler</code> , <code>set_nack_handler</code> 设置回调, 来监测消息是否成功到达服务器, 成功则会触发 <code>set_ack_handler</code>, 失败则会触发 <code>set_nack_handler</code></p></li><li><p><strong>只有在负责队列的Erlang进程中发生内部错误时才会回应nack</strong>, 所以这个在测试中也一直没有使用 set_nack_handler 捕获到错误 (是对于nack的消息, 可以设置进行重发);</p></li><li><p>注意: <strong>这两监听函数是监听服务器对 publisher 的应答的, 可不是监听 consumer 对服务器的应答的</strong>;</p></li></ul></li><li><p>一旦在channel上使用 <code>confirm.select</code> 方法, 就说 channel 处于 <strong>确认模式</strong>, 一旦通道处于确认模式, 就不能进行事务处理; 也就是说 <strong>事务 和 Publisher Confirm 不能同时使用</strong>;  </p><ul><li>一旦通道处于确认模式, 代理和客户端都会对消息进行计数(在第一次confirm.select时从1开始计数), 然后, broker通过在相同channel上发送 <code>basic.ack</code> 来处理它们, 从而确认消息; </li><li><code>delivery-tag</code> 字段包含确认消息的序列号;<br>最大 Delivery Tag, 递送标签是一个64位长的值，因此其最大值为9223372036854775807.由于递送标签的范围是按每个通道划分的，因此发布商或消费者在实践中不太可能运行该值</li></ul></li><li><p>Publisher Confirms 的顺序考虑</p><ul><li>在大多数情况下, RabbitMQ将按发布顺序向publisher确认消息(这适用于在单个频道上发布的消息); 但是, 发布者确认是异步发出的, 并且可以确认一条消息或一组消息;<br>由于消息确认可以以不同的顺序到达, 所以, 应用程序应尽可能不取决于确认的顺序;</li></ul></li></ol><h2 id="发布者确认存在的问题"><a href="#发布者确认存在的问题" class="headerlink" title="发布者确认存在的问题"></a>发布者确认存在的问题</h2><ol><li><a href="https://yq.aliyun.com/articles/42206" target="_blank" rel="noopener">mandatory 属性问题</a></li></ol><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>publisher confirm 不需要消费者参与, <a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Http/Controllers/Demo/PublisherConfirmController.php" target="_blank" rel="noopener">代码参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题的出现&quot;&gt;&lt;a href=&quot;#问题的出现&quot; class=&quot;headerlink&quot; title=&quot;问题的出现&quot;&gt;&lt;/a&gt;问题的出现&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;和消息持久化相关的一个概念是 AMQP 的事务(transaction)机制;&lt;/p&gt;
&lt;/li&gt;
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>06. 持久化策略</title>
    <link href="http://blog.renyimin.com/2018/05/28/rabbitmq/2018-05-28-rabbitmq-06/"/>
    <id>http://blog.renyimin.com/2018/05/28/rabbitmq/2018-05-28-rabbitmq-06/</id>
    <published>2018-05-28T09:32:11.000Z</published>
    <updated>2018-07-20T09:43:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="持久化原理"><a href="#持久化原理" class="headerlink" title="持久化原理"></a>持久化原理</h2><ol><li><p>RabbitMQ 默认情况下, <code>Exchange</code>, <code>队列</code>, <code>消息</code> 都是非持久的, 这意味着一旦消息服务器重启, 所有已声明的 <code>Exchange</code>, <code>队列</code>, 以及 <code>队列中的消息</code> 都会丢失;</p></li><li><p>RabbitMQ确保持久化的消息能在服务器重启之后恢复的方式是, 将它们写入磁盘上的一个持久化日志文件。当发布一条持久性消息到一个持久交换机上时, Rabbit会在消息提交到日志文件中之后才发送响应; </p><ul><li>还需要注意的是, 如果之后这条消息被路由到一个非持久化队列, 则消息又会从上面的日志文件中删除, 并且无法从服务器重启中恢复;</li><li>一旦你从持久化队列中消费了一条持久性消息(并且进行了确认), RabbitMQ会在持久化日志中把这条消息标记为等待垃圾收集;</li></ul></li></ol><h2 id="持久化方案"><a href="#持久化方案" class="headerlink" title="持久化方案"></a>持久化方案</h2><ol><li><p>要做到消息持久化, 必须保证如下三点设置正确:</p><ul><li>exchange交换器: durable属性为true;</li><li>queue队列: durable属性为true;</li><li>除了上述两点之外, 还需要在投递消息时候, 设置message的 <code>delivery_mode</code> 模式为<code>2</code>来标识消息为持久化消息;</li></ul></li><li><p>另外: 一个包含持久化消息的非持久化队列, 在Rabbit Server重启之后, 该队列将会不复存在, 消息就会变成孤儿;</p></li><li><p><a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Http/Controllers/Demo/ParamsDetailController.php" target="_blank" rel="noopener">具体代码</a></p></li></ol><h2 id="持久化的问题"><a href="#持久化的问题" class="headerlink" title="持久化的问题"></a>持久化的问题</h2><ol><li><p>持久化由于会写磁盘, 所以会极大降低RabbitMQ每秒处理的消息总数, 降低吞吐量;</p></li><li><p>持久化在Rabbit内建集群环境下工作的并不好, 虽然RabbitMQ集群允许你和集群中的任何节点的任一队列进行通信, 但是如果队列所在的节点崩溃后, 如果队列是持久化的, 那么直到这个节点恢复之前, 这个队列都不会在整个集群中被创建出来;<br> 后面在学习集群时, 会给出相应的解决方案;</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;持久化原理&quot;&gt;&lt;a href=&quot;#持久化原理&quot; class=&quot;headerlink&quot; title=&quot;持久化原理&quot;&gt;&lt;/a&gt;持久化原理&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;RabbitMQ 默认情况下, &lt;code&gt;Exchange&lt;/code&gt;, &lt;code&gt;队列&lt;/
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>56. awk</title>
    <link href="http://blog.renyimin.com/2018/05/18/linux/2018-05-18-56/"/>
    <id>http://blog.renyimin.com/2018/05/18/linux/2018-05-18-56/</id>
    <published>2018-05-18T02:03:51.000Z</published>
    <updated>2018-08-14T06:20:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>Awk是一种便于使用且表达能力强的程序设计语言, 它拥有数组, 支持<code>if-else</code>控制语句, <code>for/while</code>循环语句, 内置函数等功能; 同时, 它是一个强大的文本分析工具;</p></li><li><p>之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的Family Name的首字符;</p></li><li><p>awk 命令的执行过程</p><ul><li>awk是逐行处理的, 当处理一个文本时, 会一行一行进行处理, 处理完当前行, 再处理下一行, awk默认以 <strong>换行符</strong> 为标记来识别每一行, 每次遇到”回车换行”, 就认为是当前行的结束, 新的一行的开始;</li><li>awk在逐行处理文本时, 会搜索能够匹配程序中任意模式(也就是在awk命令中的’program’中可以有多个模式)的行, 每个模式依次测试每个输入行, 对于匹配到模式的行, 会执行awk命令中模式后面的动作(也许包含多步), 然后读取下一行并继续匹配, 直到所有的输入读取完毕;</li><li>同时, awk会按照用户指定的分割符去分割当前行为多个字段(每个字段分别被标识为 <code>$1</code> 一直到 <code>$NF</code>, <code>$NF</code>为awk中的变量, 表示当前行被分隔出的最大字段数), 如果没有指定分割符, 默认使用空格作为分隔符, 另外, 默认会将空格符和制表符都视为空格, 而且多个连续的空格都视为一个;</li></ul></li><li><p>作为一个PHP开发人员, 在工作中, 可能经常需要对开发, 沙盒, 预发, 线上等各环境的日志做分析工作;</p></li></ol><h2 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h2><p>基本语法结构为: <code>awk [options] &#39;program&#39; file1 , file2 ...</code>, 其中, <code>&#39;program&#39;</code> 又可以细分为 <code>pattern</code>模式 和 <code>action</code>动作; 也就是说, awk的完整语法其实为 <code>awk [options] &#39;pattern {action}&#39; file1 , file2 ...</code></p><h3 id="option选项"><a href="#option选项" class="headerlink" title="option选项"></a>option选项</h3><ol><li><p><code>-F fs</code> or <code>--field-separator fs</code> : 指定分隔符, fs可以是一个字符串或是一个正则表达式</p><ul><li><p>也可以使用参数 <code>-v</code> 设置内置变量<code>FS</code>的值来指定分隔符, 如 <code>-v FS=&#39;分隔符&#39;</code><br>其实还有输出分隔符, 可以使用 <code>-v OFS=&#39;分隔符&#39;</code>, 来定义输出分隔符 (一般你会使用<code>,</code>来分隔各字段, 会发现输出分隔符会是 <code>空格</code>, 没有逗号则各字段会紧连着)</p></li><li><p><code>-F</code> 指定多个分隔符: 可以使用 <code>[]</code> 来放多个分隔字符, 只要遇到<code>[]</code>中的一个分隔符, 就会进行分隔</p></li><li><p>例子: nginx的access日志使用 <code>[</code> 或者 <code>]</code> 来分隔, 不过, 对于包裹字符串集合的<code>[]</code>, 分隔字符<code>[</code>就显得比较特殊, 所以<code>[</code>字符的顺序需要注意; 或者可以使用 <code>tail -10 c2b_oms.2018-03-30-access.log | awk -F&#39;[\\[\\]]&#39; &#39;{print $2}&#39;</code>, 就不用在意 <code>[</code> 字符和包裹字符的 <code>[]</code> 之间会出现的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tail -2 c2b_oms.2018-03-30-access.log</span><br><span class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:16:43:17 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[200] byte=[884] elapsed=[2.189] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[7.55]</span><br><span class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:17:11:45 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[500] byte=[22005] elapsed=[0.136] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[-]</span><br><span class="line">$ tail -2 c2b_oms.2018-03-30-access.log | awk -F &apos;[][]&apos; &apos;&#123;print $8, $7&#125;&apos;</span><br><span class="line">GET /api/v1/car_dealer/list HTTP/1.1  request=</span><br><span class="line">GET /api/v1/car_dealer/list HTTP/1.1  request=</span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- 可以按照任意一段字符串进行分隔<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@VM_0_206_centos nginx_log]$ tail -1 c2b_oms.2018-03-30-access.log</span><br><span class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:11:26:09 +0800] request=[GET /api/v1/car_dealer/list?car_dealer_name_or_phone=18625036504 HTTP/1.1] status=[200] byte=[276] elapsed=[0.005] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[0.61]</span><br><span class="line">[work@VM_0_206_centos nginx_log]$ tail -1 c2b_oms.2018-03-30-access.log | awk -F&apos;+0800&apos; &apos;&#123;print $2&#125;&apos;</span><br><span class="line">] request=[GET /api/v1/car_dealer/list?car_dealer_name_or_phone=18625036504 HTTP/1.1] status=[200] byte=[276] elapsed=[0.005] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[0.61]</span><br></pre></td></tr></table></figure></code></pre><ol><li><p><code>-v</code> 变量赋值选项: 该选项将一个值赋予一个变量(变量可以是awk内置的, 也可以是自定义的), 它会在程序开始之前进行赋值</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk -v name=Rymuscle &apos;BEGIN&#123;printf &quot;Name = %s\n&quot;, name&#125;&apos;</span><br><span class="line">Name = Jerry</span><br></pre></td></tr></table></figure></li><li><p><code>-f scriptfile 或者 --file scriptfile</code> : 从脚本文件中读取awk命令</p></li></ol><h3 id="pattern模式"><a href="#pattern模式" class="headerlink" title="pattern模式"></a>pattern模式</h3><ol><li><p>用来匹配awk命令所处理的文本中的每一行内容; </p></li><li><p><strong>注意模式匹配字符串时, 需要使用双引号</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:Desktop renyimin$ cat awk.log</span><br><span class="line">renyimin   200 1200W 男</span><br><span class="line"></span><br><span class="line">renfumin 500 200W  男</span><br><span class="line">renjuanfang          1000 900W 女</span><br><span class="line"></span><br><span class="line">renyimindeMacBook-Pro:Desktop renyimin$ awk &apos;$1==&quot;renyimin&quot; &#123;print $1,$2,$3&#125;&apos; awk.log</span><br><span class="line">renyimin 200 1200W</span><br><span class="line">// 下面单引号就不行</span><br><span class="line">renyimindeMacBook-Pro:Desktop renyimin$ awk &apos;$1==&apos;renyimin&apos; &#123;print $1,$2,$3&#125;&apos; awk.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">renyimindeMacBook-Pro:Desktop renyimin$ awk &apos;$1==renyimin &#123;print $1,$2,$3&#125;&apos; awk.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">renyimindeMacBook-Pro:Desktop renyimin$</span><br></pre></td></tr></table></figure></li></ol><ol><li>模式可以组合(可以使用括号和逻辑操作符与 <code>&amp;&amp;</code>、<code>||</code>、<code>!</code> 对模式进行组合) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:Desktop renyimin$ awk &apos;$1==&quot;renyimin&quot; &amp;&amp; $2&gt;20 &#123;print $1,$2,$3&#125;&apos; awk.log</span><br><span class="line">renyimin 200 1200W</span><br><span class="line">renyimindeMacBook-Pro:Desktop renyimin$ awk &apos;$1==&quot;renyimin&quot; &amp;&amp; $2&gt;200 &#123;print $1,$2,$3&#125;&apos; awk.log</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>模式可以使用<code>运算符</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:linux renyimin$ cat test1.log</span><br><span class="line">Beth4.000</span><br><span class="line">Dan3.750</span><br><span class="line">kathy4.0010</span><br><span class="line">Mark5.0020</span><br><span class="line">Mary5.5022</span><br><span class="line">Susie4.2518</span><br><span class="line">renyimindeMacBook-Pro:linux renyimin$ awk &apos;$2*$3&gt;50 &#123;print $0&#125;&apos; test1.log</span><br><span class="line">Mark5.0020</span><br><span class="line">Mary5.5022</span><br><span class="line">Susie4.2518</span><br><span class="line">renyimindeMacBook-Pro:linux renyimin$</span><br></pre></td></tr></table></figure></li><li><p>模式也可以使用<code>正则表达式</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:linux renyimin$ awk &apos;/Susie/ &#123;print $0&#125;&apos; test1.log</span><br><span class="line">Susie4.2518</span><br><span class="line">renyimindeMacBook-Pro:linux renyimin$</span><br></pre></td></tr></table></figure></li></ol><h3 id="action动作"><a href="#action动作" class="headerlink" title="action动作"></a>action动作</h3><ol><li><p>awk 擅长文本格式化并将格式化后的文本<strong>输出</strong>, 所以它比较常用的 action 是 <code>print</code> 和 <code>printf</code>;</p></li><li><p>‘模式+动作’ 语句中的 模式 或 动作都可以省略, 但不是同时省略</p><ul><li>有的awk命令有 一个模式 + 动作</li><li>有的awk命令只有一个模式, 没有动作(如果没有动作, 那么模式匹配到的每一行都会被完整打印出来, 相当于动作是<code>{print}</code> 或者 <code>{print $0}</code>)</li><li>有的awk命令只有多个模式, 没有动作(同上) </li><li>有的awk命令可以有多个模式 + 一个动作</li></ul></li><li><p>多文件处理, 用到了再补充~~</p></li></ol><h2 id="内置的一些变量"><a href="#内置的一些变量" class="headerlink" title="内置的一些变量"></a>内置的一些变量</h2><p>变量可以在 <code>BEGIN</code> 语句块中声明, 也可以在 <code>program</code> 中声明, 也可以使用参数 <code>-v</code> 声明</p><ol><li><p><code>NF</code>: <strong>行的字段数量</strong>, 你可以在awk命令的program中使用action, Awk会对当前输入的行有多少个字段进行计数, 并且将当前行的字段数量存储在一个内建的称作 <code>NF</code> 的变量中<br> 因此, 程序 <code>{ print NF, $1, $NF }</code> 会依次打印出每一行的字段数量, 第一个字段的值, 最后一个字段的值;</p></li><li><p><code>NR</code>: 它会存储当前已经读取了多少行的计数, 可以使用 <code>$NR</code> 给结果的每一行加上行号</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:linux renyimin$ awk &apos;&#123;print NR,$0&#125;&apos; awk.log</span><br><span class="line">1 renyimin   &quot;200&quot; 1200W 男</span><br><span class="line">2</span><br><span class="line">3 renfumin 500 &quot;200W&quot;  男</span><br><span class="line">4 renjuanfang          1000 900W &quot;女&quot;</span><br><span class="line">5</span><br><span class="line">renyimindeMacBook-Pro:linux renyimin$</span><br></pre></td></tr></table></figure></li><li><p><code>FS</code>: 除了使用 <code>-F</code>参数指定字段分隔符, 也可以通过 -v 设定 <code>FS</code> 内置变量来指定字段分隔符 (或者在<code>BEGIN</code>中指定<code>FS</code>变量)</p></li><li><p><code>OFS</code> : 上面介绍了如何设定输入分隔符, 其实还有输出分隔符, 可以使用 <code>-v OFS=&#39;分隔符&#39;</code>(或者在<code>BEGIN</code>中指定<code>OFS</code>变量), 来定义输出分隔符</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[work@VM_0_206_centos nginx_log]$ tail -3 c2b_oms.2018-03-30-access.log | awk -F[][] -v OFS=&apos;---&apos; &apos;&#123;print $2,$3&#125;&apos;</span><br><span class="line">172.16.254.2--- http_x_forward=</span><br><span class="line">172.16.254.2--- http_x_forward=</span><br><span class="line">172.16.254.2--- http_x_forward=</span><br><span class="line">[work@VM_0_206_centos nginx_log]$ tail -3 c2b_oms.2018-03-30-access.log | awk -F[][] &apos;BEGIN&#123;OFS=&quot;---&quot;&#125; &#123;print $2,$3&#125;&apos;</span><br><span class="line">172.16.254.2--- http_x_forward=</span><br><span class="line">172.16.254.2--- http_x_forward=</span><br><span class="line">172.16.254.2--- http_x_forward=</span><br><span class="line">[work@VM_0_206_centos nginx_log]$</span><br></pre></td></tr></table></figure></li><li><p>另外声明变量也可以直接在 <code>program</code> 中进行</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[work@VM_0_206_centos nginx_log]$ tail -3 c2b_oms.2018-03-30-access.log | awk &apos;FS=&quot;[][]&quot;,OFS=&quot;---&quot; &#123;print $2,$3&#125;&apos;</span><br><span class="line">http_x_forward=[-]---time=[30/Mar/2018:11:26:09</span><br><span class="line">172.16.254.2--- http_x_forward=</span><br><span class="line">172.16.254.2--- http_x_forward=</span><br><span class="line">172.16.254.2--- http_x_forward=</span><br><span class="line">[work@VM_0_206_centos nginx_log]$</span><br></pre></td></tr></table></figure></li><li><p>其余的, 用到了再补充~~</p></li></ol><h2 id="BEGIN-语句块"><a href="#BEGIN-语句块" class="headerlink" title="BEGIN 语句块"></a>BEGIN 语句块</h2><ol><li><p><code>BEGIN</code> 语句块的语法: 在awk的program中 <code>BEGIN {awk-commands}</code>: BEGIN语句块在程序开始的使用执行, 它只执行一次, 在这里可以初始化变量或者打印一个开头什么的;</p></li><li><p><code>BEGIN</code> 是AWK的关键字, 因此它必须为大写, 注意, 这个语句块是可选的;</p></li><li><p>测试:</p><ul><li>可以使用 <code>print &quot;&quot;</code> 在输出之前先打印一个空行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:linux renyimin$ awk &apos;BEGIN &#123;print &quot;&quot;&#125; &#123;print NR,$0&#125;&apos; awk.log</span><br><span class="line"></span><br><span class="line">1 renyimin   &quot;200&quot; 1200W 男</span><br><span class="line">2</span><br><span class="line">3 renfumin 500 &quot;200W&quot;  男</span><br><span class="line">4 renjuanfang          1000 900W &quot;女&quot;</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="END-语句块"><a href="#END-语句块" class="headerlink" title="END 语句块"></a>END 语句块</h2><p>END 则用于处理匹配过的最后一个文件的最后一行之后的位置;</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>下面根据nginx的access.log日志来做一些练习 (这个日志还是挺大量的)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wc c2b_bid.2018-04-23-access.log</span><br><span class="line">   65608  1501442 29580860 c2b_bid.2018-04-23-access.log</span><br></pre></td></tr></table></figure></p><ol><li><p>统计独立ip的访问量 - 共有多少独立IP访问过本站点</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ awk &apos;&#123;print $1&#125;&apos; c2b_bid.2018-04-23-access.log | sort -n | uniq | wc -l</span><br><span class="line">240</span><br></pre></td></tr></table></figure><p> 表示共有240个不同ip访问过站点</p></li><li><p>统计独立ip的访问情况 - 每个独立ip的访问次数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bash-4.2$ awk &apos;&#123;print $1&#125;&apos; c2b_bid.2018-04-23-access.log | sort -n | uniq -c</span><br><span class="line">    190 remote_addr=[100.116.226.0]</span><br><span class="line">    195 remote_addr=[100.116.226.1]</span><br><span class="line">    176 remote_addr=[100.116.226.10]</span><br><span class="line">    176 remote_addr=[100.116.226.100]</span><br><span class="line">    .....</span><br><span class="line">    就不全部列出了</span><br></pre></td></tr></table></figure></li><li><p>统计访问最频繁的前10个ip</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ awk &apos;&#123;print $1&#125;&apos; c2b_bid.2018-04-23-access.log | sort -n | uniq -c | sort -rn | head -10</span><br><span class="line">    407 remote_addr=[100.116.251.123]</span><br><span class="line">    399 remote_addr=[100.116.251.65]</span><br><span class="line">    394 remote_addr=[100.116.251.56]</span><br><span class="line">    390 remote_addr=[100.116.251.97]</span><br><span class="line">    388 remote_addr=[100.116.251.11]</span><br><span class="line">    387 remote_addr=[100.116.251.110]</span><br><span class="line">    384 remote_addr=[100.116.251.98]</span><br><span class="line">    383 remote_addr=[100.116.251.83]</span><br><span class="line">    382 remote_addr=[100.116.251.8]</span><br><span class="line">    381 remote_addr=[100.116.251.40]</span><br><span class="line">-bash-4.2$</span><br></pre></td></tr></table></figure></li><li><p>查看访问380次以上的ip</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ awk &apos;&#123;print $1&#125;&apos; c2b_bid.2018-04-23-access.log | sort -n | uniq -c | awk &apos;$1 &gt; 380 &#123;print&#125;&apos; | sort -rn</span><br><span class="line">    407 remote_addr=[100.116.251.123]</span><br><span class="line">    399 remote_addr=[100.116.251.65]</span><br><span class="line">    394 remote_addr=[100.116.251.56]</span><br><span class="line">    390 remote_addr=[100.116.251.97]</span><br><span class="line">    388 remote_addr=[100.116.251.11]</span><br><span class="line">    387 remote_addr=[100.116.251.110]</span><br><span class="line">    384 remote_addr=[100.116.251.98]</span><br><span class="line">    383 remote_addr=[100.116.251.83]</span><br><span class="line">    382 remote_addr=[100.116.251.8]</span><br><span class="line">    381 remote_addr=[100.116.251.40]</span><br><span class="line">    381 remote_addr=[100.116.251.38]</span><br><span class="line">    381 remote_addr=[100.116.251.118]</span><br><span class="line">-bash-4.2$</span><br></pre></td></tr></table></figure></li><li><p>这是平时日常的日志分析命令</p><ul><li><p>日志为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tail -5 c2b_oms.2018-03-29-access.log</span><br><span class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[29/Mar/2018:18:37:48 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[200] byte=[19305] elapsed=[0.002] refer=[-] body=[-] ua=[Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36] cookie=[-] gzip=[3.19]</span><br><span class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[29/Mar/2018:18:41:24 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[200] byte=[24131] elapsed=[0.004] refer=[-] body=[-] ua=[Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36] cookie=[-] gzip=[3.96]</span><br><span class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[29/Mar/2018:18:42:06 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[200] byte=[24130] elapsed=[0.004] refer=[-] body=[-] ua=[Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36] cookie=[-] gzip=[3.96]</span><br><span class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[29/Mar/2018:18:42:40 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[200] byte=[786] elapsed=[1.078] refer=[-] body=[-] ua=[Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36] cookie=[-] gzip=[8.27]</span><br><span class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[29/Mar/2018:18:42:57 +0800] request=[GET /favicon.ico HTTP/1.1] status=[404] byte=[9879] elapsed=[0.010] refer=[http://172.16.0.206:8888/] body=[-] ua=[Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36] cookie=[-] gzip=[2.27]</span><br></pre></td></tr></table></figure><p>分析为: 全都是action, 没有匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ awk -F&apos;] &apos; &apos;&#123;status=substr($5,9);elapsed=substr($7,10);if(elapsed &gt;= 2 || status &gt;=500)print NR,&quot;:&quot;,$4,status,elapsed;  &#125;&apos; /home/work/nginx_log/c2b_bid.2018-08-14-access.log</span><br><span class="line">72700 : request=[PUT /api/v1/bid?car_id=5696964&amp;bid_id=2613419&amp;car_dealer_id=26690&amp;bid_status=0&amp;operation_type=0 HTTP/1.1 200 3.253</span><br><span class="line">85585 : request=[PUT /api/v1/bid?car_id=5673673&amp;bid_id=2614287&amp;car_dealer_id=9264&amp;bid_status=0&amp;operation_type=0 HTTP/1.1 200 5.162</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Awk是一种便于使用且表达能力强的程序设计语言, 它拥有数组, 支持&lt;code&gt;if-else&lt;/code&gt;控制语句, &lt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>50. sort, uniq, wc</title>
    <link href="http://blog.renyimin.com/2018/05/16/linux/2018-05-16-50/"/>
    <id>http://blog.renyimin.com/2018/05/16/linux/2018-05-16-50/</id>
    <published>2018-05-16T07:28:21.000Z</published>
    <updated>2018-08-07T03:29:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><ol><li>Linux <code>sort</code>命令用于将文本文件内容以 <code>行</code> 为单位进行排序; </li><li><p>语法: <code>sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][--help][--verison][文件]</code><br> <code>sort</code> 命令既可以从特定的文件, 也可以从 stdin 中获取输入;</p></li><li><p>选项</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-b：忽略每行前面开始出的空格字符；</span><br><span class="line">-c：检查文件是否已经按照顺序排序；</span><br><span class="line">-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符；</span><br><span class="line">-f：排序时，将小写字母视为大写字母；</span><br><span class="line">-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；</span><br><span class="line">-m：将几个排序号的文件进行合并；</span><br><span class="line">-M：将前面3个字母依照月份的缩写进行排序；</span><br><span class="line">-n：依照数值的大小排序；</span><br><span class="line">-o&lt;输出文件&gt;：将排序后的结果存入制定的文件；</span><br><span class="line">-r：以相反的顺序来排序；</span><br><span class="line">-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符；</span><br><span class="line">+&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</span><br></pre></td></tr></table></figure></li><li><p>目前常用的选项有 <code>-nr</code></p></li></ol><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><ol><li><p><code>uniq</code> 命令用于报告或忽略文件中的重复行，一般与sort命令结合使用; </p><ul><li>之所以要和sort命令结合使用, 是因为<code>uniq</code>命令值只可以删除相邻的重复行;</li><li>如果一文本中有重复却不相邻的行, 单独使用<code>uniq</code>命令则无法删除, 需要结合sort命令;</li></ul></li><li><p>语法: <code>uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--help][--version][输入文件][输出文件]</code></p></li><li><p>选项:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c或——count：在每列旁边(貌似是左边)显示该行重复出现的次数；</span><br><span class="line">-d或--repeated：仅显示重复出现的行列；</span><br><span class="line">-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;：忽略比较指定的栏位；</span><br><span class="line">-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;：忽略比较指定的字符；</span><br><span class="line">-u或——unique：仅显示出一次的行列；</span><br><span class="line">-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;：指定要比较的字符。</span><br></pre></td></tr></table></figure></li><li><p>目前常用的选项有 <code>-c</code></p></li><li><p>参数介绍</p><ul><li>输入文件: 指定要去除的重复行文件, 如果不指定此项, 则从标准读取数据; </li><li>输出文件: 指定要去除重复行后的内容要写入的输出文件, 如果不指定此选项, 则将内容显示到标准输出设备(显示到终端);</li></ul></li><li><p>实例</p><ul><li><p>uniq <strong>无法去除不相邻的重复行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:linux renyimin$ cat uniq.log</span><br><span class="line">renyimin is a it man</span><br><span class="line">he has many article</span><br><span class="line">renyimin comes from shanxi province</span><br><span class="line">he has many article</span><br><span class="line"></span><br><span class="line">// 可以看到uniq并没有对不相邻的重复行进行去重操作</span><br><span class="line">renyimindeMacBook-Pro:linux renyimin$ uniq uniq.log</span><br><span class="line">renyimin is a it man</span><br><span class="line">he has many article</span><br><span class="line">renyimin comes from shanxi province</span><br><span class="line">he has many article</span><br><span class="line">renyimindeMacBook-Pro:linux renyimin$</span><br><span class="line">   </span><br><span class="line">// 如下进行排序后即可</span><br><span class="line">renyimindeMacBook-Pro:linux renyimin$ sort uniq.log | uniq</span><br><span class="line">he has many article</span><br><span class="line">renyimin comes from shanxi province</span><br><span class="line">renyimin is a it man</span><br><span class="line">renyimindeMacBook-Pro:linux renyimin$</span><br></pre></td></tr></table></figure></li><li><p><code>-c</code> 参数, 对文件相同行进行去重, 并统计每行重复出现的次数 (类似于mysql的groupby分组统计)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:linux renyimin$ sort uniq.log | uniq -c</span><br><span class="line">2 he has many article</span><br><span class="line">1 renyimin comes from shanxi province</span><br><span class="line">1 renyimin is a it man</span><br></pre></td></tr></table></figure></li><li><p>当然, 还可以继续结合sort来按照重复条数最多的来排序 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:linux renyimin$ sort uniq.log | uniq -c | sort</span><br><span class="line">1 renyimin comes from shanxi province</span><br><span class="line">1 renyimin is a it man</span><br><span class="line">2 he has many article</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><ol><li><p>利用<code>wc</code>指令我们可以计算文件的 行数、Byte数、字数、或是列数, 若不指定文件名称、或是所给予的文件名为”-“, 则wc指令会从标准输入设备读取数据;</p></li><li><p>语法: <code>wc [-clw][--help][--version][文件...]</code></p></li><li><p>选项</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-c或--bytes或--chars 只显示Bytes数</span><br><span class="line"></span><br><span class="line">-l或--lines 只显示行数</span><br><span class="line"></span><br><span class="line">-w或--words 只显示字数</span><br><span class="line"></span><br><span class="line">--help 在线帮助</span><br><span class="line"></span><br><span class="line">--version 显示版本信息</span><br></pre></td></tr></table></figure></li><li><p>目前常用的选项有 <code>-lwc</code> (貌似也是默认的选项, 而且无论选项的顺序是怎样的, 结果总是: “行数, 字数, 字节数, 文件名”)</p></li><li><p>实例</p><ul><li><p>基本用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:linux renyimin$ cat uniq.log</span><br><span class="line">renyimin is a it man</span><br><span class="line">he has many article</span><br><span class="line">renyimin comes from shanxi province</span><br><span class="line">he has many article</span><br><span class="line">renyimindeMacBook-Pro:linux renyimin$ wc uniq.log</span><br><span class="line">       4      18      97 uniq.log</span><br><span class="line">renyimindeMacBook-Pro:linux renyimin$</span><br></pre></td></tr></table></figure></li><li><p>统计多文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:linux renyimin$ wc -l uniq.log uniq.log</span><br><span class="line">       4 uniq.log       // 第一个文件行数为4</span><br><span class="line">       4 uniq.log       // 第二个文件行数为4</span><br><span class="line">       8 total          // 两个文件总的行数为8</span><br><span class="line">renyimindeMacBook-Pro:linux renyimin$</span><br></pre></td></tr></table></figure></li><li><p>结合之前的 <code>uniq</code>, <code>sort</code> 命令, 统计去重后的行数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:linux renyimin$ cat uniq.log</span><br><span class="line">renyimin is a it man</span><br><span class="line">he has many article</span><br><span class="line">renyimin comes from shanxi province</span><br><span class="line">he has many article</span><br><span class="line"></span><br><span class="line">// 总共有4行</span><br><span class="line">renyimindeMacBook-Pro:linux renyimin$ sort uniq.log | wc -l</span><br><span class="line">          4</span><br><span class="line">// 去重后有3行</span><br><span class="line">renyimindeMacBook-Pro:linux renyimin$ sort uniq.log | uniq -c | wc -l</span><br><span class="line">          3</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h2><p>nl命令在linux系统中用来计算文件中行号, nl 可以将输出的文件内容自动的加上行号, 其默认的结果与 <code>cat -n</code> 有点不太一样, nl 可以将行号做比较多的显示设计, 包括位数与是否自动补齐 0 等等的功能<br>1.命令格式 : <code>nl [选项]... [文件]...</code></p><p>2.命令参数:<br>-b  ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；<br>-n  ：列出行号表示的方法，主要有三种:<br>-n ln ：行号在萤幕的最左方显示<br>-n rn ：行号在自己栏位的最右方显示，且不加 0<br>-n rz ：行号在自己栏位的最右方显示，且加 0<br>-w  ：行号栏位的占用的位数<br>-p 在逻辑定界符处不重新开始计算</p><p>3.试用<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ nl -ba Test.class.php</span><br><span class="line"> 1&lt;?php</span><br><span class="line"> 2interface Huma</span><br><span class="line"> 3&#123;</span><br><span class="line"> 4     public static function say();</span><br><span class="line"> 5&#125;</span><br><span class="line"> 6</span><br><span class="line"> 7class Male implements Huma</span><br><span class="line"> 8&#123;</span><br><span class="line"> 9    private static function say()</span><br><span class="line">10    &#123;</span><br><span class="line">11        echo &quot;I am a Male&quot;;</span><br><span class="line">12    &#125;</span><br><span class="line">13&#125;</span><br><span class="line">14</span><br><span class="line">15class Female implements Huma</span><br><span class="line">16&#123;</span><br><span class="line">17    public static function say()</span><br><span class="line">18    &#123;</span><br><span class="line">19        echo &quot;I am a Female&quot;;</span><br><span class="line">20    &#125;</span><br><span class="line">21&#125;</span><br></pre></td></tr></table></figure></p><h2 id="其他案例"><a href="#其他案例" class="headerlink" title="其他案例"></a>其他案例</h2><p>在多个文件中匹配某个字符串(比如 ‘&lt;?php’), 并列出文件名: <code>grep &#39;&lt;?php&#39; *.php</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sort&quot;&gt;&lt;a href=&quot;#sort&quot; class=&quot;headerlink&quot; title=&quot;sort&quot;&gt;&lt;/a&gt;sort&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Linux &lt;code&gt;sort&lt;/code&gt;命令用于将文本文件内容以 &lt;code&gt;行&lt;/code&gt; 为单位进行
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>30. 开机启动相关</title>
    <link href="http://blog.renyimin.com/2018/05/16/linux/2018-03-18-23/"/>
    <id>http://blog.renyimin.com/2018/05/16/linux/2018-03-18-23/</id>
    <published>2018-05-16T07:28:21.000Z</published>
    <updated>2018-08-13T02:21:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p>加入systemctl, 设置开机启动<br>设置环境变量, 设置开机启动</p><p>init 开机启动</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;init&quot;&gt;&lt;a href=&quot;#init&quot; class=&quot;headerlink&quot; title=&quot;init&quot;&gt;&lt;/a&gt;init&lt;/h2&gt;&lt;h2 id=&quot;systemctl&quot;&gt;&lt;a href=&quot;#systemctl&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>PHP 性能追踪及分析工具(XHPROF)</title>
    <link href="http://blog.renyimin.com/2018/05/02/php/2018-05-02-Xhprof/"/>
    <id>http://blog.renyimin.com/2018/05/02/php/2018-05-02-Xhprof/</id>
    <published>2018-05-02T14:26:39.000Z</published>
    <updated>2018-08-17T12:16:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>Xhprof 是facebook开源出来的一个php轻量级的性能分析工具, 跟Xdebug类似, 但性能开销更低, 还可以用在生产环境中, 也可以由程序开关来控制是否进行profile;</p></li><li><p>XHProf的一些特性:</p><ul><li><p>Flat Profile: 提供函数级的汇总信息, 比如调用次数、执行时间、内存使用、CPU占用等;</p></li><li><p>Hierarchical Profile: 对每个程序, 进行了父级调用和子级调用的分解;</p></li><li><p>Diff Reports(差异报告)<br>有很多种情况, 我们希望能够对比, 比如新版本比旧版本提升了多少速度, 两个版本的差距究竟在哪里;<br>Diff Report 就是这样的工具, 接收两个输入, 并且分别给出各自的 Flat Profile 和 Hierarchical Profile 报告;</p></li><li><p>Callgraph View(调用视图): 性能监测的数据可以绘制成调用视图, 方便我们查看;</p></li><li><p>Memory Profile(内存监控): 这个特性帮助我们了解PHP如何分配和释放内存, 值得注意的是, XHProf并不是严格的监测内存的分配和释放动作, 而是计算每个函数进入和退出时的内存状况, 这是一个相对简单的实现方式, 但是基本上也能够满足我们日常的监控需求;</p></li><li><p>如何处理外部文件?<br>XHProf将 include,require,include_once,require_once进来的文件视作是一个 function;<br>XHProf目前只支持一个级别的函数追踪, 但是貌似也没有特别大的影响;</p></li></ul></li><li><p>对比Xdebug: Xdebug 是一个开放源代码的PHP程序调试器; 对于本地开发环境来说, 进行性能分析 Xdebug 是够用了; 但如果是线上环境的话, Xdebug 消耗较大, 配置也不够灵活;</p></li></ol><h2 id="XHProx的安装配置"><a href="#XHProx的安装配置" class="headerlink" title="XHProx的安装配置"></a>XHProx的安装配置</h2><ol><li><p>注意pecl和github上star比较多的xhprof有如下问题</p><ul><li>php5.4及以上版本, pecl不支持安装xhprof, 需要通过phpize编译;</li><li><a href="http://pecl.php.net/package/xhprof上的代码包" target="_blank" rel="noopener">http://pecl.php.net/package/xhprof上的代码包</a>, xhprof最后一次更新是在2013年;</li><li>但是两种都不支持php7; </li></ul></li><li><p>如果需要支持php7, 需要到<a href="https://github.com/longxinH/xhprof" target="_blank" rel="noopener">此处</a>下载</p><ul><li><a href="https://laravel-china.org/articles/6474/custom-sampling-method-for-xhprof" target="_blank" rel="noopener">https://laravel-china.org/articles/6474/custom-sampling-method-for-xhprof</a></li><li><a href="https://github.com/tideways/php-xhprof-extension" target="_blank" rel="noopener">https://github.com/tideways/php-xhprof-extension</a> </li></ul></li><li><p>动态编译安装扩展过程:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">git clone https://github.com/longxinH/xhprof.git</span><br><span class="line">cd xhprof/extension</span><br><span class="line">/usr/local/php/bin/phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php/bin/php-config </span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">....</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build complete.</span><br><span class="line">Don&apos;t forget to run &apos;make test&apos;.</span><br><span class="line"></span><br><span class="line">Installing shared extensions:     /usr/local/php/lib/php/extensions/no-debug-non-zts-20151012/</span><br><span class="line">[root@lant extension]#</span><br></pre></td></tr></table></figure></li><li><p>配置php.ini</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/php/etc/php.ini</span><br><span class="line">// 添加如下配置块</span><br><span class="line">[xhprof]</span><br><span class="line">extension=xhprof.so;</span><br><span class="line">xhprof.output_dir=/tmp/xhprof   // 注意提前创建好该目录</span><br></pre></td></tr></table></figure><p> 成功后, 访问phpinfo, 会发现xhprof模块<br> <img src="/img/PHP/xhprof/install-success.png"><br> 或者可以如下检测:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@lant extension]# /usr/local/php/sbin/php-fpm -m | grep xhprof</span><br><span class="line">xhprof</span><br><span class="line">[root@lant extension]#</span><br></pre></td></tr></table></figure></li><li><p>测试xhprof提供的示例</p><ul><li><p>复制clone下的xhprof目录下的 examples,xhprof_html,xhprof_lib 到网站目录/html下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@lant html]# cp -r /usr/local/src/xhprof/examples/ /html</span><br><span class="line">[root@lant html]# cp -r /usr/local/src/xhprof/xhprof_html/ /html</span><br><span class="line">[root@lant html]# cp -r /usr/local/src/xhprof/xhprof_lib/ /html</span><br></pre></td></tr></table></figure></li><li><p>访问虚拟站点: <a href="https://www.vhostnginx.com/examples/sample.php" target="_blank" rel="noopener">https://www.vhostnginx.com/examples/sample.php</a>, 得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array ( [foo==&gt;bar] =&gt; Array ( [ct] =&gt; 5 [wt] =&gt; 19 ) [bar==&gt;bar@1] =&gt; Array ( [ct] =&gt; 4 [wt] =&gt; 8 ) [bar@1==&gt;bar@2] =&gt; Array ( [ct] =&gt; 3 [wt] =&gt; 5 ) [bar@2==&gt;bar@3] =&gt; Array ( [ct] =&gt; 2 [wt] =&gt; 2 ) [bar@3==&gt;bar@4] =&gt; Array ( [ct] =&gt; 1 [wt] =&gt; 0 ) [main()==&gt;foo] =&gt; Array ( [ct] =&gt; 1 [wt] =&gt; 34 ) [main()==&gt;xhprof_disable] =&gt; Array ( [ct] =&gt; 1 [wt] =&gt; 0 ) [main()] =&gt; Array ( [ct] =&gt; 1 [wt] =&gt; 43 ) ) --------------- Assuming you have set up the http based UI for XHProf at some address, you can view run at http:///index.php?run=5b751a19786eb&amp;source=xhprof_foo ---------------</span><br></pre></td></tr></table></figure></li><li><p>UI界面可以访问: <a href="https://www.vhostnginx.com/xhprof_html/index.php?**run=5b751a19786eb&amp;source=xhprof_foo**" target="_blank" rel="noopener">https://www.vhostnginx.com/xhprof_html/index.php?**run=5b751a19786eb&amp;source=xhprof_foo**</a> (为上一步访问结果中给出的参数)<br><img src="/img/PHP/xhprof/install-success-01.png"></p></li><li><p>点击 [View Full Callgraph] 如果报错, 那是因为系统需要安装graphviz, graphviz是一个绘制图形的工具, 可以更为直观的让你查看性能的瓶颈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install libpng</span><br><span class="line">yum -y install graphviz</span><br></pre></td></tr></table></figure><p><img src="/img/PHP/xhprof/install-success-02.png"></p></li></ul></li><li><p>编写代码测试</p><ul><li><p>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">xhprof_enable();</span><br><span class="line">function test1()</span><br><span class="line">&#123;</span><br><span class="line">        foreach ($i=0; $i &lt; 100; $i++) &#123;</span><br><span class="line">                foreach ($j=0; $j &lt; 10; $j++)&#123;</span><br><span class="line">                        if ($i==99 &amp;&amp; $j==9) &#123;</span><br><span class="line">                                echo &apos;test1&apos;;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test2()</span><br><span class="line">&#123;</span><br><span class="line">        foreach ($i=0; $i &lt; 10; $i++) &#123;</span><br><span class="line">                foreach ($j=0; $j &lt; 10; $j++)&#123;</span><br><span class="line">                        if ($i==9 &amp;&amp; $j==9) &#123;</span><br><span class="line">                                test1();</span><br><span class="line">&lt;?php</span><br><span class="line">xhprof_enable();</span><br><span class="line">// 测试代码</span><br><span class="line">function test1()</span><br><span class="line">&#123;</span><br><span class="line">        for ($i=0; $i &lt; 100; $i++) &#123;</span><br><span class="line">                for ($j=0; $j &lt; 10; $j++)&#123;</span><br><span class="line">                        if ($i==99 &amp;&amp; $j==9) &#123;</span><br><span class="line">                                echo &apos;test1&apos;;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test2()</span><br><span class="line">&#123;</span><br><span class="line">        for ($i=0; $i &lt; 10; $i++) &#123;</span><br><span class="line">                for ($j=0; $j &lt; 10; $j++)&#123;</span><br><span class="line">                        if ($i==9 &amp;&amp; $j==9) &#123;</span><br><span class="line">                                test1();</span><br><span class="line">test2();</span><br><span class="line"></span><br><span class="line">// 测试代码结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$xhprof_data = xhprof_disable();</span><br><span class="line">print_r($xhprof_data);</span><br><span class="line">$XHPROF_ROOT = realpath(dirname(__FILE__));</span><br><span class="line">include_once $XHPROF_ROOT . &quot;/xhprof_lib/utils/xhprof_lib.php&quot;;</span><br><span class="line">include_once $XHPROF_ROOT . &quot;/xhprof_lib/utils/xhprof_runs.php&quot;;</span><br><span class="line">$xhprof_runs = new XHProfRuns_Default();</span><br><span class="line">$run_id = $xhprof_runs-&gt;save_run($xhprof_data, &quot;xhprof_foo&quot;);</span><br><span class="line">echo &quot;http://&lt;xhprof-ui-address&gt;/index.php?run=$run_id&amp;source=xhprof_foo&quot;;</span><br></pre></td></tr></table></figure></li><li><p>访问: <a href="https://www.vhostnginx.com/test.php" target="_blank" rel="noopener">https://www.vhostnginx.com/test.php</a><br><img src="/img/PHP/xhprof/install-success-test-01.png"></p></li><li>访问: <a href="http://www.vhostnginx.com/xhprof_html/index.php?run=5b751ee6d1da8&amp;source=xhprof_foo" target="_blank" rel="noopener">http://www.vhostnginx.com/xhprof_html/index.php?run=5b751ee6d1da8&amp;source=xhprof_foo</a><br><img src="/img/PHP/xhprof/install-success-test-02.png"></li></ul></li><li><p>XHProf报告字段含义</p><ul><li>Function Name: 方法名称;</li><li>Calls: 方法被调用的次数;</li><li>Calls%: 方法调用次数在同级方法总数调用次数中所占的百分比;</li><li>Incl.Wall Time(microsec): 方法执行花费的时间, 包括子方法的执行时间(单位:微秒)</li><li>IWall%: 方法执行花费的时间百分比;</li><li>Excl. Wall Time(microsec): 方法本身执行花费的时间, 不包括子方法的执行时间(单位:微秒)</li><li>EWall%: 方法本身执行花费的时间百分比;</li><li>Incl. CPU(microsecs): 方法执行花费的CPU时间, 包括子方法的执行时间(单位:微秒)</li><li>ICpu%: 方法执行花费的CPU时间百分比;</li><li>Excl. CPU(microsec): 方法本身执行花费的CPU时间, 不包括子方法的执行时间(单位:微秒)</li><li>ECPU%: 方法本身执行花费的CPU时间百分比;</li><li>Incl.MemUse(bytes): 方法执行占用的内存, 包括子方法执行占用的内存(单位:字节)</li><li>IMemUse%: 方法执行占用的内存百分比。</li><li>Excl.MemUse(bytes): 方法本身执行占用的内存, 不包括子方法执行占用的内存(单位:字节)</li><li>EMemUse%: 方法本身执行占用的内存百分比。</li><li>Incl.PeakMemUse(bytes): Incl.MemUse峰值(单位:字节)</li><li>IPeakMemUse%: Incl.MemUse峰值百分比;</li><li>Excl.PeakMemUse(bytes): Excl.MemUse峰值(单位:字节)</li><li>EPeakMemUse%: Excl.MemUse峰值百分比;</li></ul></li></ol><h2 id="实际项目测试"><a href="#实际项目测试" class="headerlink" title="实际项目测试"></a>实际项目测试</h2><ol><li><p>以公司目前的lumen项目为例, 可以将xhprof_html和xhprof_lib目录拷贝到/public下, 然后在入口文件加上</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhprof_enable( XHPROF_FLAGS_NO_BUILTINS | XHPROF_FLAGS_CPU | XHPROF_FLAGS_MEMORY);</span><br></pre></td></tr></table></figure></li><li><p>然后在程序最后输出之前加上</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//在程序结束后收集数据</span><br><span class="line">$xhprof_data = xhprof_disable();</span><br><span class="line">print_r($xhprof_data);</span><br><span class="line">$XHPROF_ROOT = &quot;/wwwroot/oms/public&quot;;//realpath(dirname(__FILE__));</span><br><span class="line">echo $XHPROF_ROOT . &quot;/xhprof_lib/utils/xhprof_lib.php&quot;;</span><br><span class="line">include_once $XHPROF_ROOT . &quot;/xhprof_lib/utils/xhprof_lib.php&quot;;</span><br><span class="line">include_once $XHPROF_ROOT . &quot;/xhprof_lib/utils/xhprof_runs.php&quot;;</span><br><span class="line">$xhprof_runs = new XHProfRuns_Default();</span><br><span class="line">$run_id = $xhprof_runs-&gt;save_run($xhprof_data, &quot;xhprof_foo&quot;);</span><br><span class="line">echo &quot;http://&lt;xhprof-ui-address&gt;/index.php?run=$run_id&amp;source=xhprof_foo&quot;;</span><br></pre></td></tr></table></figure></li><li><p>另外, 其实网上还有资料介绍了php.ini中的两个配置项 <code>auto_prepend_file</code> 和 <code>auto_append_file</code> 可以用来在所有php程序运行前和运行后设置对应的运行文件; 不过在公司lumen项目测试后发现auto_append_file可能并不生效; 不过自己写一些简单的代码例子做测试, 倒是可以尝试配置使用;</p></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>可以看到xhprof作为年久失修的性能分析工具, 也只能下载一些不知名的包才能在php7上成功使用;</p></li><li><p>而且目前很多项目都是使用了PHP框架的, 要做性能分析, 其实对于xhprof输出的结构图来说, 有很多都是框架本身的性能分析结果, 也无法直观看到开发人员编写部分的代码性能问题;</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://haofly.net/xhprof/" target="_blank" rel="noopener">https://haofly.net/xhprof/</a></li><li><a href="https://www.cnblogs.com/cocowool/archive/2010/06/02/1750198.html" target="_blank" rel="noopener">https://www.cnblogs.com/cocowool/archive/2010/06/02/1750198.html</a></li><li><a href="https://mp.weixin.qq.com/s/VQ5F_-09EAaJePe5o1Bedg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/VQ5F_-09EAaJePe5o1Bedg</a></li><li><a href="https://www.jianshu.com/p/8fb9ad0719c2" target="_blank" rel="noopener">https://www.jianshu.com/p/8fb9ad0719c2</a></li><li><a href="https://www.jianshu.com/p/c69e368de756" target="_blank" rel="noopener">https://www.jianshu.com/p/c69e368de756</a></li><li><a href="https://blog.csdn.net/qq_28602957/article/details/72697901" target="_blank" rel="noopener">https://blog.csdn.net/qq_28602957/article/details/72697901</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Xhprof 是facebook开源出来的一个php轻量级的性能分析工具, 跟Xdebug类似, 但性能开销更低, 还可以
      
    
    </summary>
    
      <category term="PHP" scheme="http://blog.renyimin.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.renyimin.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.renyimin.com/2018/05/02/php/2018-05-06-opcache/"/>
    <id>http://blog.renyimin.com/2018/05/02/php/2018-05-06-opcache/</id>
    <published>2018-05-02T14:26:39.000Z</published>
    <updated>2018-08-15T10:23:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.abcdocker.com/abcdocker/2151" target="_blank" rel="noopener">https://www.abcdocker.com/abcdocker/2151</a><br><a href="https://www.cnblogs.com/wajika/p/6249003.html" target="_blank" rel="noopener">https://www.cnblogs.com/wajika/p/6249003.html</a></p><p><a href="http://gywbd.github.io/posts/2016/1/best-config-for-zend-opcache.html" target="_blank" rel="noopener">http://gywbd.github.io/posts/2016/1/best-config-for-zend-opcache.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.abcdocker.com/abcdocker/2151&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.abcdocker.com/abcdocker/2151&lt;/a&gt;&lt;br&gt;&lt;a href
      
    
    </summary>
    
      <category term="PHP" scheme="http://blog.renyimin.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.renyimin.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.renyimin.com/2018/04/11/guzzle/2018-04-11/"/>
    <id>http://blog.renyimin.com/2018/04/11/guzzle/2018-04-11/</id>
    <published>2018-04-11T05:16:21.000Z</published>
    <updated>2018-08-21T02:11:37.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="杂项" scheme="http://blog.renyimin.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="杂项" scheme="http://blog.renyimin.com/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>JWT(JSON Web Token)</title>
    <link href="http://blog.renyimin.com/2018/04/07/jwt/2018-04-07/"/>
    <id>http://blog.renyimin.com/2018/04/07/jwt/2018-04-07/</id>
    <published>2018-04-07T11:23:57.000Z</published>
    <updated>2018-08-21T03:25:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/af8360b83a9f" target="_blank" rel="noopener">https://www.jianshu.com/p/af8360b83a9f</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/af8360b83a9f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/af8360b83a9f&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="杂项" scheme="http://blog.renyimin.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="杂项" scheme="http://blog.renyimin.com/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
</feed>
