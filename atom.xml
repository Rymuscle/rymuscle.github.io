<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2018-05-31T06:04:49.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>06. 持久化策略</title>
    <link href="http://blog.renyimin.com/2018/05/28/rabbitmq/2018-05-28-rabbitmq-06/"/>
    <id>http://blog.renyimin.com/2018/05/28/rabbitmq/2018-05-28-rabbitmq-06/</id>
    <published>2018-05-28T09:32:11.000Z</published>
    <updated>2018-05-31T06:04:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="持久化方案"><a href="#持久化方案" class="headerlink" title="持久化方案"></a>持久化方案</h2><p>RabbitMQ 默认情况下, <code>Exchange</code>, <code>队列</code>, <code>消息</code> 都是非持久的, 这意味着一旦消息服务器重启, 所有已声明的 <code>Exchange</code>, <code>队列</code>, 以及 <code>队列中的消息</code> 都会丢失;   </p><p>要做到消息持久化, 必须保证如下三点设置正确:</p><ul><li>exchange交换器: durable属性为true;</li><li>queue队列: durable属性为true;</li><li>除了上述两点之外, 还需要在投递消息时候, 设置message的 <code>delivery_mode</code> 模式为<code>2</code>来标识消息为持久化消息;<br>要知道, 一个包含持久化消息的非持久化队列, 在Rabbit Server重启之后, 该队列将会不复存在, 消息就会变成孤儿;</li></ul><h2 id="持久化原理"><a href="#持久化原理" class="headerlink" title="持久化原理"></a>持久化原理</h2><p>RabbitMQ确保持久化的消息能在服务器重启之后恢复的方式是, 将它们写入磁盘上的一个持久化日志文件。当发布一条持久性消息到一个持久交换机上时, Rabbit会在消息提交到日志文件中之后才发送响应; 还需要注意的是, 如果之后这条消息被路由到一个非持久化队列, 则消息又会从上面的日志文件中删除, 并且无法从服务器重启中恢复;<br>一旦你从持久化队列中消费了一条持久性消息(并且进行了确认), RabbitMQ会在持久化日志中把这条消息标记为等待垃圾收集;</p><h2 id="持久化的问题"><a href="#持久化的问题" class="headerlink" title="持久化的问题"></a>持久化的问题</h2><ul><li>持久化由于会写磁盘, 所以会极大降低RabbitMQ每秒处理的消息总数, 降低吞吐量;</li><li>持久化在Rabbit内建集群环境下工作的并不好, 后面在学习集群时, 会给出相应的解决方案;</li></ul><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><p>下面通过使用 Laravel + php-amqplib 扩展, 通过创建一个投递消息的生产者, 展示了如何创建一条持久化消息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;持久化方案&quot;&gt;&lt;a href=&quot;#持久化方案&quot; class=&quot;headerlink&quot; title=&quot;持久化方案&quot;&gt;&lt;/a&gt;持久化方案&lt;/h2&gt;&lt;p&gt;RabbitMQ 默认情况下, &lt;code&gt;Exchange&lt;/code&gt;, &lt;code&gt;队列&lt;/code&gt;, &lt;c
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>05. 一条消息的一生</title>
    <link href="http://blog.renyimin.com/2018/05/28/rabbitmq/2018-05-28-rabbitmq-05/"/>
    <id>http://blog.renyimin.com/2018/05/28/rabbitmq/2018-05-28-rabbitmq-05/</id>
    <published>2018-05-28T09:16:23.000Z</published>
    <updated>2018-05-31T11:46:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>到现在, 已经成功安装运行了Rabbit, 并且简单了解了RabbitMQ的消息通信机制及Rabbit内部的一些组件; 接下来就需要通过编码来学习如何使用RabbitMQ简单发布并消费一条消息;</p><h2 id="生产者应用程序"><a href="#生产者应用程序" class="headerlink" title="生产者应用程序"></a>生产者应用程序</h2><ol><li><p>先尝试创建一个生产者, 其基本步骤可以分为如下几步</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">创建与Rabbit Server的TCP连接</div><div class="line">创建信道</div><div class="line">通过信道--创建exchange</div><div class="line">通过信道--创建queue</div><div class="line">通过信道--对exchange与queue进行绑定</div><div class="line">创建消息</div><div class="line">通过信道--发布消息</div><div class="line">关闭信道</div><div class="line">关闭连接</div></pre></td></tr></table></figure></li><li><p>代码可参考<a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Http/Controllers/Demo/RabbitBaseController.php" target="_blank" rel="external">Github</a>中的 <code>firstProducer()</code> 方法</p></li></ol><h2 id="消费者应用程序"><a href="#消费者应用程序" class="headerlink" title="消费者应用程序"></a>消费者应用程序</h2><ol><li><p>再尝试创建一个生产者, 其基本步骤可以分为如下几步</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">创建与Rabbit Server的TCP连接</div><div class="line">创建信道</div><div class="line">通过信道--创建exchange</div><div class="line">通过信道--创建queue</div><div class="line">通过信道--对exchange与queue进行绑定</div><div class="line">创建消息回调函数</div><div class="line">消费消息</div></pre></td></tr></table></figure></li><li><p>代码可参考<a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Console/Commands/firstConsumer.php" target="_blank" rel="external">Github</a></p></li></ol><h2 id="参数讲解"><a href="#参数讲解" class="headerlink" title="参数讲解"></a><a href="http://www.rabbitmq.com/amqp-0-9-1-reference.html" target="_blank" rel="external">参数讲解</a></h2><p>在上面的生产者的小实例中, 对 声明交换器、声明队列、绑定交换机与队列、声明消息、消息发布 的一些基础参数属性进行了注释讲解;</p><h3 id="声明交换器"><a href="#声明交换器" class="headerlink" title="声明交换器"></a>声明交换器</h3><ol><li><p>passive 参数</p><ul><li><p>默认为false: rabbit-server 会查看有没有已存在的同名exchange, 没有则直接创建, 有则不会进行创建; <strong>结果总是返回 null</strong></p></li><li><p>如果你希望查询交换机是否存在, 而又不想在查询时创建这个交换机, 设置为true即可; <strong>如果存在则返回NULL</strong>, 如果交换机不存在, 则会抛出一个错误的异常;</p></li><li><p>另外需要了解的是, passive设置为true时, 如果exchange已存在, 你当前创建的exchange即使是诸如type之类的参数进行了变更, 也不会报错, 因为压根不会尝试创建, 只是返回null; 但是如果passive设置为false, 则当前会尝试创建exchange, 此时, 如果exchange的参数有变更,比如已存在的exchange的type位direct, 而当前创建的同名exchange的type为fanout, 就会报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PRECONDITION_FAILED - inequivalent arg &apos;type&apos; for exchange &apos;ex1&apos; in vhost &apos;/&apos;: received &apos;fanout&apos; but current is &apos;direct&apos;</div></pre></td></tr></table></figure></li><li><p>参数 和 nowait 参数没关联</p></li><li><p>可参考<a href="https://www.kancloud.cn/xsnet/xinshangjingyan/297803" target="_blank" rel="external">此文</a></p></li></ul></li><li><p>druable(消息持久化的条件之一) : true为持久化</p></li><li><p>auto_delete: 自动删除(默认是启用的, 交换器将会在所有与其绑定的队列被删除后自动删除; (所以如果做持久化的话, 需要设置为false)</p></li><li><p>arguments : 声明exchange时, 可以使用<code>AMQPTable</code>对象来创建一些额外的说明参数, 比如:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$arguments = new AMQPTable([</div><div class="line">       &apos;arguments1&apos; =&gt; &apos;想写什么信息都行&apos;,</div><div class="line">       &apos;arguments2&apos; =&gt; [</div><div class="line">           &apos;想写什么信息都行, 比如声明是那条业务线的&apos;,</div><div class="line">           &apos;想写什么信息都行, 比如连接信息....&apos;,</div><div class="line">       ]</div><div class="line">   ]</div><div class="line">);</div></pre></td></tr></table></figure></li></ol><h3 id="声明队列"><a href="#声明队列" class="headerlink" title="声明队列"></a>声明队列</h3><ol><li>passive 参数 (貌似和exchange的passive稍有不同)<ul><li>默认为false: rabbit-server 会查看有没有已存在的同名queue, 没有则直接创建, 有则不进行创建; 无论创建与否, 结果都返回 <strong>队列基础信息</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">array (size=3)</div><div class="line">  0 =&gt; string &apos;queue1&apos; (length=6)</div><div class="line">  1 =&gt; int 5</div><div class="line">  2 =&gt; int 0</div></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- 如果你希望查询队列是否存在, 而又不想在查询时创建这个队列, 设置此为true即可; 如果存在则返回 **队列基础信息**, 如果队列不存在, 则会抛出一个错误的异常;- 另外需要了解的是, passive设置为true时, 如果queue已存在, 你当前创建的queue即使是诸如type之类的参数进行了变更, 也不会报错, 因为压根不会尝试创建, 只是返回已存在的queue信息; 但是如果passive设置为false, 则当前会尝试创建queue, 此时, 如果queue的参数有变更,比如已存在的queue的为持久型, 而当前创建的同名queue的为非持久的, 就会报错:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PRECONDITION_FAILED - inequivalent arg &apos;durable&apos; for queue &apos;queue1&apos; in vhost &apos;/&apos;: received &apos;false&apos; but current is &apos;true&apos;</div></pre></td></tr></table></figure>- 和 exchange 的 passive 参数不同的是, 此处队列声明的结果会返回 **队列基础信息**, 但是这是依赖于 `nowait` 参数, 如果nowait参数为默认值false, 则会返回, 如果为true, 则就返回null;</code></pre><ol><li><p>druable(消息持久化的条件之一) : true为持久化</p></li><li><p>exclusive : 如果设置为true, 则创建的为<code>排他队列</code><br> 如果一个队列被声明为排他队列, 该队列仅对首次声明它的连接可见, 并在连接断开时自动删除。也就是说, 如果你在生产者中创建排他队列, 则连接结束, 队列就没了, 所以你可能一直看不到创建的队列;<br> 另外需要注意三点:<br> 1.排他队列是<strong>基于连接</strong>可见的, 同一连接的不同信道是可以同时访问同一个连接创建的排他队列的<br> 2.首次，如果一个连接已经声明了一个排他队列, 其他连接是不允许建立同名的排他队列的, 这个与普通队列不同(普通队列可以,无则创建,有则不报错)<br> 3.即使该队列是持久化的,一旦连接关闭或者客户端退出,该排他队列都会被自动删除的<br> 所以, 貌似排他队列只能由消费者创建, 而且这种队列适用于只有一个消费者消费消息的场景</p></li><li><p>auto_delete: 自动删除(默认是启用的, 队列将会在所有的消费者停止使用之后自动删除掉自身, 注意: 没有消费者不算, 只有在有了消费之后, 所有的消费者又断开后, 就会自动删除自己)</p></li><li><p>arguments : 声明queue时, 可以使用<code>AMQPTable</code>对象来创建一些额外的说明参数, 同exchange的arguments参数效果一样;</p></li></ol><h3 id="创建消息"><a href="#创建消息" class="headerlink" title="创建消息"></a>创建消息</h3><p>AMQPMessage 类的第二个参数properties可以设置很多属性, 目前需要熟悉的是</p><ul><li>delivery_mode : 消息持久化的条件之一, 值为2时表示持久化</li><li>content_type : 比如: ‘text/plain’</li></ul><h3 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h3><p>暂时接触到的属性都比较熟悉, 稍后会接触一些特殊作用的属性</p><ol><li><p><a href="http://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.publish.mandatory" target="_blank" rel="external">mandatory</a> </p><ul><li>当mandatory标志位设置为true时, 如果exchange根据自身类型和消息routeKey无法找到一个符合条件的queue, 那么rabbit server会自动去调用 <code>basic.return</code> 方法将消息返回给生产者(Basic.Return + Content-Header + Content-Body);<br>生产者可以使用channel的<code>set_return_listener()</code>绑定一个回调函数来进行监听; 但是注意, 此时生产者貌似需要为阻塞状态在命令行启动;</li><li>当mandatory设置为false时, 出现上述情形broker会直接将消息扔掉;</li><li>代码可以参考<a href="https://github.com/rymuscle/Laravel-RabbitMQ/blob/master/app/Console/Commands/testProducter.php" target="_blank" rel="external">github</a>, <a href="">文档Demo</a></li></ul></li><li><p>php-amqplib并未实现的<strong><a href="http://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.publish.immediate" target="_blank" rel="external">immediate</a></strong></p><ul><li>当immediate标志位设置为true时, 如果exchange在将消息路由到queue(s)时发现对于的queue上没有消费者, 那么这条消息不会放入队列中, 当与消息routeKey关联的所有queue(一个或者多个)都没有消费者时, 该消息会通过 basic.return 方法返还给生产者;</li><li><strong>但是可惜的是</strong>, 这只是AMQP的规定, 客户端不一定会严格实现, 如 <code>php-amqplib</code> 包就没有实现, 如果设置了immediate为true, 运行会报错: <code>PhpAmqpLib \ Exception \ AMQPProtocolConnectionException (540) NOT_IMPLEMENTED - immediate=true</code></li></ul></li><li><p>概括来说, mandatory标志告诉服务器至少将该消息route到一个队列中, 否则将消息返还给生产者; immediate标志告诉服务器如果该消息关联的queue上有消费者, 则马上将消息投递给它, 如果所有queue都没有消费者, 直接把消息返还给生产者, 不用将消息入队列等待消费者了;</p></li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><a href="http://www.rabbitmq.com/amqp-0-9-1-reference.html" target="_blank" rel="external">AMQP协议</a>规定了不同客户端(比如php-amqplib)需要实现的内容, 但是这些客户端不一定会完全并严格地实现;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;到现在, 已经成功安装运行了Rabbit, 并且简单了解了RabbitMQ的消息通信机制及Rabbit内部的一些组件; 接下来就需要通过编码来学习如何使用RabbitMQ简单发布并消费一条消息;&lt;/p&gt;
&lt;h2 id=&quot;生产者应用程序&quot;&gt;&lt;a href=&quot;#生产者应用程序&quot;
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>04. 浅析RabbitMQ通信模式</title>
    <link href="http://blog.renyimin.com/2018/05/27/rabbitmq/2018-05-27-rabbitmq-04/"/>
    <id>http://blog.renyimin.com/2018/05/27/rabbitmq/2018-05-27-rabbitmq-04/</id>
    <published>2018-05-27T10:30:26.000Z</published>
    <updated>2018-05-31T06:18:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为RabbitMQ专注于应用程序之间的消息通信, 所以在开始尝试使用Rabbit进行消息通信前, 清楚地理解通信模式的概念是非常重要的;</p><p>下面是一张比较简单的Rabbit消息通信架构图<br><img src="/img/rabbitmq/rabbitmq-new.png"></p><h2 id="Broker-Server-Rabbit-Server"><a href="#Broker-Server-Rabbit-Server" class="headerlink" title="Broker Server (Rabbit Server)"></a>Broker Server (Rabbit Server)</h2><p>RabbitMQ是作为一个消息投递的<strong>中间代理服务器</strong>存在的(broker有 中间人, 代理人的意思); 应用程序从RabbitMQ获取的数据并不是Rabbit产生的, 可以认为它在应用程序之间扮演着<strong>路由器</strong>的角色;</p><p>所以在使用Rabbit进行消息通信时, 当应用程序连接到RabbitMQ时, 你就必须做个决定, 你的应用程序是准备作为生产者发送消息呢, 还是作为消费者来接收消息;</p><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><p>Connection其实就是一个TCP的连接, 无论你的应用程序是作为 <code>Producer</code> 还是 <code>Consumer</code>, 都是通过TCP连接到RabbitMQ Server的, 任何与Rabbit Server内部交互的应用程序都需要通过TCP连接到RabbitMQ Server, 后面会看到, <strong>程序的起始就是建立这个TCP连接</strong>;<br>Connection是RabbitMQ的socket链接, 它封装了socket协议相关部分逻辑;</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Channel 是我们与RabbitMQ打交道的最重要的一个接口, 我们大部分的业务操作是在channel这个接口中完成的 (包括 <code>定义exchange</code>, <code>定义queue</code>, <code>绑定exchange与queue</code>、<code>发布消息</code> 等);</p><p>Channel 是虚拟连接, 它建立在上述的TCP连接 <code>connection</code> 中, 数据流动都是在channel中进行的, 程序起始第一步就是建立TCP连接 <code>Connection</code>, 第二步就是建立信道 <code>Channel</code>;</p><p>为什么使用Channel, 而不是直接使用TCP连接？<br>对于OS来说, 建立和关闭TCP连接是有代价的, 频繁的建立关闭TCP连接对于系统的性能有很大的影响, 而且TCP的连接数也有限制, 这也限制了系统处理高并发的能力;<br>但是，在TCP连接中建立channel是没有上述代价的, 对于 <code>producer</code> 或者 <code>consumer</code> 来说, 可以并发的使用多个channel进行 ‘publish’或者’receive’;</p><h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h3><p>在你的应用程序连接到Rabbit Server后, Producer发布的消息并不会直接被Rabbit Server投递到queue中, 值得注意的是: 消息永远不可能被直接发送到Rabbit Server的Queue中, 它总是会经过Rabbit Server内部的 <strong>exchange交换机</strong>;</p><p>为什么Rabbit Server不是将生产者投递的消息直接发送到队列, 而必须要经过内部的exchange组件? 毕竟对于生产者来说, 只是希望消息能够到队列而已, Rabbit Server中为啥还多了一步?</p><ul><li>如果没有exchange内部组件, 对于生产者投递来的消息, broker其实貌似也可以根据消息内容中的某个属性来判断消息该投递给哪个队列, 或者也可以指定投递给全部队列, 或者根据正则来投递给某些队列; 但这样的话, 相当于生产者和队列直接面对面做了强绑定;</li><li>而如果有exchange的话, 对于绑定和解析绑定, 直接交由exchange来进行即可, 这样在内部也做到了解耦和单一职责的划分, 这样就可以将一些业务逻辑独立出来(比方你是要群发, 还是指定队列发送, 或者匹配队列发送, 这些绑定和解析工作都由exchange在生产者和队列中间进行处理, 生产者和队列不需要直接面对面);</li></ul><p>在RabbitMQ中, exchange组件有四种类型 ：</p><ul><li><p><code>direct</code> :<br>使用这种类型, 会将生产者发送消息时设置的 <code>routingkey</code> 与 queue和exchange绑定时的 <code>bindingkey</code> 进行<strong>精确匹配</strong>, 如果 <code>routingkey</code> 和 <code>bindingkey</code> 完全一样, 那么Message就会被传递到当前exchange的对应queue中;<br>如果使用了direct类型Exchange, 绑定队列和exchange时, 可以不必指定 <code>routingkey</code> 的名字, 在此类型下创建的queue有一个默认的 <code>routingkey</code>, 这个 <code>routingkey</code> 一般和 <code>queue</code> 同名;<br><strong>注意</strong>: 虽然不可以创建两个相同名字的队列, 但是多个不同名的队列与exchange进行绑定时, <code>bindingkey</code> 可以相同; 所以可能会有多个队列的<code>bindingkey</code>都 与 同一条消息发布时的<code>routingkey</code>可以匹配, 从而导致同一条消息被exchange路由到多个队列中!</p></li><li><p><code>fanout</code>:<br>使用这种类型, 会将生产者发送消息时设置的 <code>routingkey</code> 与 queue和exchange绑定时的 <code>bindingkey</code> 进行<strong>模式匹配</strong>(正则匹配)<br>比如 生产者发送消息时设置的<code>routing key</code>为 <code>ab*</code>, 则可以与 <code>bindingkey</code> 为 <code>ab</code> 开头的所有的queue匹配;</p></li><li><p><code>topic</code> ：<br>使用这种类型, 会忽略<code>routingkey</code>的存在, 直接将消息广播到所有与当前exchange绑定的queue中; </p></li><li><p><code>headers</code> : 不太实用, 而且性能比较差, 几乎再也用不到了</p></li></ul><h3 id="BindingKey"><a href="#BindingKey" class="headerlink" title="BindingKey"></a>BindingKey</h3><p>队列在声明后, 需要与exchange进行绑定, 绑定的时候可以显示地区指定一个 <code>routingkey</code>, 这里我们叫 <code>bindingkey</code>;<br>注意: 队列在与exchange绑定时, 如果没有显示地去设置 <code>bindingkey</code>, 此时 <code>bindingkey</code> 默认为队列名字;</p><h3 id="RoutingKey"><a href="#RoutingKey" class="headerlink" title="RoutingKey"></a>RoutingKey</h3><p>生产者在消息发布时, 需要指明消息的 <code>routingkey</code>, exchange则会依据此<code>routingkey</code>去匹配 与 自身绑定的那些队列在绑定时 所显示或非显示设置的 <code>bindingkey</code>, 从而决定消息将会被路由到与自身绑定的哪些队列中;<br>当然, 如果exchange设置的type是<code>topic</code>类型, 则会忽略 <code>routingkey</code> 和 <code>bindingkey</code> 的存在;</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>生产者投递给broker server的消息, 最终会被内部组件exchange路由到匹配的队列中, 等待consumers处理;</p><p>队列在声明后, 需要与exchange进行绑定 (绑定时会使用一个叫 routingkey 的东西, 这里我一般会叫他 bindingkey); </p><p>注意: 如果你不能承担消息丢入”黑洞”而丢失的话, 你的应用无论是生产者还是消费者, 都应该尝试去创建队列;</p><p>队列有很多参数属性可以设置, 后面在代码中经会一一展示如何使用它的这些属性;</p><h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><p>图中左侧的客户端程序’A,B’, 其实就是生产者: 连接到 Rabbit Server , 并将消息投递到 Rabbit Server, 然后由exchange交换机决定该如何转发消息到队列中;<br>Producer永远不可能直接将消息丢到queue中;<br>Producer可以通过bindingkey与exchange进行绑定;</p><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p>图中右侧的客户端程序’1,2,3’, 其实就是消费者: 连接到 Rabbit Server , 并从 Rabbit Server 中接收消息;</p><p>发送消息时需要指定 routingkey, 如果没有指定routingkey 或者 指定的routingkey匹配不到对应的bindingkey, 消息会被 Rabbit 服务丢弃掉, 掉入”黑洞”;</p><p>另外, consumer在处理完消息之后, </p><h3 id="通道预取设置-QoS"><a href="#通道预取设置-QoS" class="headerlink" title="通道预取设置 QoS"></a>通道预取设置 QoS</h3><p><a href="https://www.jianshu.com/p/c0bfe198739e" target="_blank" rel="external">https://www.jianshu.com/p/c0bfe198739e</a></p><h3 id="Consumer-Prefetch"><a href="#Consumer-Prefetch" class="headerlink" title="Consumer Prefetch"></a>Consumer Prefetch</h3><p><a href="https://www.jianshu.com/p/4d043d3045ca" target="_blank" rel="external">https://www.jianshu.com/p/4d043d3045ca</a></p><p>官方文档<a href="http://www.rabbitmq.com/consumer-prefetch.html" target="_blank" rel="external">消费预取</a>一节可以看到, 在RabbitMQ中, 对prefetch_count的定义与AMQP0-9-1貌似不太一样;</p><p>prefetch允许为每个consumer指定最大的<code>unacked messages</code>数目, 简单来说就是用来指定一个consumer一次可以从Rabbit中获取多少条message并缓存在client中(RabbitMQ提供的各种语言的client library), 一旦缓冲区满了, Rabbit将会停止投递新的message到该consumer中直到它发出ack;</p><p>假设prefetch值设为10, 共有两个consumer, 意味着每个consumer每次会从queue中预抓取10条消息到本地缓存着等待消费, 同时该channel的unacked数变为20, 而Rabbit投递的顺序是，先为consumer1投递满10个message，再往consumer2投递10个message。如果这时有新message需要投递，先判断channel的unacked数是否等于20，如果是则不会将消息投递到consumer中，message继续呆在queue中。<br>之后其中consumer对一条消息进行ack，unacked此时等于19，Rabbit就判断哪个consumer的unacked少于10，就投递到哪个consumer中。</p><p>总的来说，consumer负责不断处理消息，不断ack，然后只要unacked数少于prefetch * consumer数目，broker就不断将消息投递过去</p><p>正常情况下, 如果有多个消费者订阅了同一个Queue, Queue中的消息会被平摊给多个消费者;<br>但是, 如果每个消息的处理时间不同, 就有可能会导致某些消费者一直在忙, 而另外一些消费者很快就处理完手头工作并处于空闲的情况;<br>此时, 可以通过设置 <code>prefetchCount</code> 来限制queue每次发送给每个消费者的消息数, 比如我们设置<code>prefetchCount=1</code>, 则queue每次给每个消费者发送一条消息, 消费者处理完这条消息后Queue会再给该消费者发送一条消息;</p><h3 id="delivery-tag"><a href="#delivery-tag" class="headerlink" title="delivery_tag"></a>delivery_tag</h3><h2 id="vhost"><a href="#vhost" class="headerlink" title="vhost"></a>vhost</h2><p>最后, 还有一个在图中并未体现出来的概念 <code>vhost</code></p><p>每一个RabbitMQ服务器都能创建虚拟消息服务器, 我们称之为虚拟主机(<code>vhost</code>), 每一个 <code>vhost</code> 本质上都是一个 mini 版的 RabbitMQ Server, 拥有自己的 <code>exchagne</code>, <code>queue</code>, 和 <code>bindings rule</code> 等等, 更重要的是, 它还拥有自己的 <code>权限机制</code>, 这使得你能够安全地使用一个RabbitMQ服务器来服务众多应用程序, 而不用担心A应用可能会删除B应用正在使用的队列;</p><p>vhost之于Rabbit就像虚拟机之于物理服务器一样: 通过在各个实例间提供逻辑上隔离, 允许你为不同应用程序安全保密地运行数据, 这很有用, 它既能将同一Rabbit的众多客户端区分开来, 又可以避免队列和交换器的命名冲突; 否则, 你可能不得不去运行多个Rabbit, 并承担随之而来的管理问题, 相反, 你可以只运行一个Rabbit, 然后按需启动或者关闭vhost;<br>当你有多个不同的应用要使用RabbitMQ时, 你可以为每个应用定义一个vhost来将应用从逻辑上隔离开;</p><p>vhost是AMQP概念的基础, 你必须在连接时进行指定, 由于RabbitMQ包含了开箱即用的默认vhost: <code>/</code> , 因此时候用起来非常简单, 如果你不需要多个vhost的话, 就使用默认的即可;<br>通过使用默认的guest用户名和密码guest, 就可以访问默认的 vhost, 为了安全起见, 你应该更改它;</p><p>AMQP 并没有指定权限控制是在vhost级别还是在服务器端级别实现, 这留给了消息服务器的开发者去决定, 而<strong>在RabbitMQ中, 权限控制是以<code>vhost</code>为单位的</strong>, 当你在Rabbit里创建一个用户时, 用户通常会被指派给至少一个vhost, 并且只能访问被指派的vhost内的队列, 交换机和绑定;<br>当你在设计消息通信架构时, 记住vhost之间是绝对隔离的, 你无法将 vhost ‘a’ 中的交换机绑定到 vhost ‘b’ 中的队列去;</p><p>另外需要注意: 当你在RabbitMQ集群上创建vhost时, 整个集群上都会创建该vhost;</p><p>如何创建vhost? vhost和权限控制非常独特, 它们是AMQP中唯一无法通过AMQP协议创建的基元(不同于队列, 交换机和绑定), 对于RabbitMQ来说, 你需要通过 RabbitMQ 安装路径下 <code>./sbin/</code> 目录中的 <code>rabbitmqctl</code> 工具来创建</p><ul><li><p>如果想知道特定rabbitmq服务器上运行着哪些vhost时, 可以执行</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl list_vhosts</div><div class="line">Listing vhosts</div><div class="line">/</div></pre></td></tr></table></figure></li><li><p>创建一个vhost</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl add_vhost test</div><div class="line">Creating vhost &quot;test&quot;</div></pre></td></tr></table></figure></li><li><p>删除一个vhost</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:~ renyimin$ rabbitmqctl delete_vhost test</div><div class="line">Deleting vhost &quot;test&quot;</div></pre></td></tr></table></figure></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一部分只是大概了解一下RabbitMQ服务一些概念性知识, 当然, 关于这些知识点在后面进行编码的时候会进行进一步扩展, 比如 队列, 消息, 交换机的<strong>诸多属性</strong>都会涉及到;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;因为RabbitMQ专注于应用程序之间的消息通信, 所以在开始尝试使用Rabbit进行消息通信前, 清楚地理解通信模式的概念是非常重要的;&lt;
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>03. 服务器管理</title>
    <link href="http://blog.renyimin.com/2018/05/27/rabbitmq/2018-05-27-rabbitmq-03/"/>
    <id>http://blog.renyimin.com/2018/05/27/rabbitmq/2018-05-27-rabbitmq-03/</id>
    <published>2018-05-27T10:20:09.000Z</published>
    <updated>2018-05-28T09:07:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>到目前为止我们已经 下载安装并成功启动了Rabbitmq服务, 接下来, 可以简单了解一些与服务器管理相关的知识点;</p><h2 id="Erlang-和-Erlang-Cookie"><a href="#Erlang-和-Erlang-Cookie" class="headerlink" title="Erlang 和 Erlang Cookie"></a>Erlang 和 Erlang Cookie</h2><h2 id="命令行的基本使用"><a href="#命令行的基本使用" class="headerlink" title="命令行的基本使用"></a>命令行的基本使用</h2><p>RabbitMQ的启动可以在安装目录下的 ‘sbin/‘ 目录下, 运行 <code>rabbitmq-server -detached</code> 来启动后来运行;<br>如果启动中遇到了任何错误, 可以检查RabbitMQ的日志文件; 如果<strong>不知道日志文件的位置</strong>, 可以查看:<br><img src="/img/rabbitmq/rabbitmq-file-path.png" width="400"><br><img src="/img/rabbitmq/rabbitmq-file-path-02.png" width="400"></p><p>2.</p><h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a><a href="http://www.rabbitmq.com/configure.html" target="_blank" rel="external">配置相关</a></h2><p>一般情况下, RabbitMQ的默认配置就足够了, 通过在Web管理平台可以看到, 默认是没有配置文件的; 如果希望特殊设置的话, 有几个位置可以进行配置;<br>注意, 文件默认是没有的, 如果需要必须自己创建, 至于创建配置文件的位置在哪里, 可以通过日志文件来查看:</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">enyimindembp:rabbitmq renyimin$ pwd</div><div class="line">/usr/local/var/log/rabbitmq</div><div class="line">renyimindembp:rabbitmq renyimin$ ls</div><div class="line">lograbbit@localhost-sasl.lograbbit@localhost.lograbbit@localhost_upgrade.log</div><div class="line">enyimindembp:rabbitmq renyimin$ head -20 rabbit\@localhost.log</div><div class="line"></div><div class="line">=INFO REPORT==== 11-Dec-2017::15:37:02 ===</div><div class="line">Starting RabbitMQ 3.6.14 on Erlang 20.1.7</div><div class="line">Copyright (C) 2007-2017 Pivotal Software, Inc.</div><div class="line">Licensed under the MPL.  See http://www.rabbitmq.com/</div><div class="line"></div><div class="line">=INFO REPORT==== 11-Dec-2017::15:37:02 ===</div><div class="line">node           : rabbit@localhost</div><div class="line">home dir       : /Users/renyimin</div><div class="line">config file(s) : /usr/local/etc/rabbitmq/rabbitmq.config (not found)</div><div class="line">cookie hash    : qNSOVbC4c3Bg7punCVVdaQ==</div><div class="line">log            : /usr/local/var/log/rabbitmq/rabbit@localhost.log</div><div class="line">sasl log       : /usr/local/var/log/rabbitmq/rabbit@localhost-sasl.log</div><div class="line">database dir   : /usr/local/var/lib/rabbitmq/mnesia/rabbit@localhost</div></pre></td></tr></table></figure></code></pre><h3 id="rabbitmq-env-conf"><a href="#rabbitmq-env-conf" class="headerlink" title="rabbitmq-env.conf"></a>rabbitmq-env.conf</h3><p>环境变量的配置文件 rabbitmq-env.conf : 可以用来配置rabbitmq的一些基本配置文件的路径;</p><p>这些文件的位置是特定于分发的, 默认情况下, 它们可能不会创建, 但希望位于每个平台的以下位置：</p><ul><li>通用UNIX <code>$ RABBITMQ_HOME/etc/rabbitmq /</code></li><li>Debian <code>/etc/rabbitmq/</code></li><li>RPM <code>/etc/rabbitmq/</code></li><li>Mac OSX(Homebrew) <code>$ {install_prefix}/etc/rabbitmq/</code>，Homebrew前缀通常是<code>/usr/local</code></li><li>Windows <code>％APPDATA％\RabbitMQ\</code></li></ul><p>现在修改 rabbitmq-env.conf 中指定的 rabbitmq.conf 位置为 ‘/usr/local/Cellar/rabbitmq/3.7.5/etc/rabbitmq/rabbitmq.conf’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">renyimindembp:rabbitmq renyimin$ pwd</div><div class="line">/usr/local/etc/rabbitmq</div><div class="line">renyimindembp:rabbitmq renyimin$ cat rabbitmq-env.conf</div><div class="line">CONFIG_FILE=/usr/local/etc/rabbitmq/rabbitmq</div><div class="line">NODE_IP_ADDRESS=127.0.0.1</div><div class="line">NODENAME=rabbit@localhost</div><div class="line">renyimindembp:rabbitmq renyimin$ vim rabbitmq-env.conf</div><div class="line">....</div><div class="line">renyimindembp:rabbitmq renyimin$ cat rabbitmq-env.conf</div><div class="line">#CONFIG_FILE=/usr/local/etc/rabbitmq/rabbitmq</div><div class="line">CONFIG_FILE=/usr/local/Cellar/rabbitmq/3.7.5/etc/rabbitmq/rabbitmq</div><div class="line">NODE_IP_ADDRESS=127.0.0.1</div><div class="line">NODENAME=rabbit@localhost</div><div class="line">renyimindembp:rabbitmq renyimin$</div></pre></td></tr></table></figure></p><p>改完重启之后, 在Web管理界面会发现也有了配置文件的路径:<br><img src="/img/rabbitmq/rabbitmq-env-01.png" width="400"></p><h3 id="rabbitmq-conf"><a href="#rabbitmq-conf" class="headerlink" title="rabbitmq.conf"></a>rabbitmq.conf</h3><p>如果 rabbitmq.conf 不存在, 可以手动创建;<br>如果更改位置, 请设置 <code>RABBITMQ_CONFIG_FILE</code> 环境变量, <strong>RabbitMQ会自动将.conf扩展名附加到此变量的值</strong>;</p><p>配置对于<code>rabbitmq.config</code>文件, rabbit官网提供了默认的<code>rabbitmq.conf.example</code>, 可以从<a href="https://github.com/rabbitmq/rabbitmq-server/blob/master/docs/rabbitmq.conf.example" target="_blank" rel="external">此处</a>获取;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p><p>主要参考官方文档：<a href="http://www.rabbitmq.com/configure.html" target="_blank" rel="external">http://www.rabbitmq.com/configure.html</a></p><h3 id="RabbitMQ权限控制"><a href="#RabbitMQ权限控制" class="headerlink" title="RabbitMQ权限控制"></a>RabbitMQ权限控制</h3><h3 id="解读Rabbit日志文件"><a href="#解读Rabbit日志文件" class="headerlink" title="解读Rabbit日志文件"></a>解读Rabbit日志文件</h3><p>### </p><ol><li>在成功启动了RabbitMQ服务之后, </li><li>命令行查看<code>虚拟机</code>, <code>队列</code>, <code>交换器</code>和<code>绑定状态</code>;</li></ol><p>通常情况下, 你是在服务器上直接运行 <code>rabbitmqctl</code> 来管理自己的rabbitmq节点, 不过你也可以通过 <code>-n rabbit@[server_name]</code>选项来管理远程rabbitmq节点, <code>@</code>符号将节点标识符(rabbit@[server_name])分成两部分: </p><ul><li>左边的是Erlang应用程序名称, 在这里永远都是 <code>rabbit</code>;</li><li>右边的是服务器主机名或者IP地址;</li><li>你要确保运行Rabbit节点的服务器和运行 rabbitmqctl 的工作站点安装了相同的 Erlang Cookie;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;到目前为止我们已经 下载安装并成功启动了Rabbitmq服务, 接下来, 可以简单了解一些与服务器管理相关的知识点;&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>02. Win,MacOS,Linux下载安装RabbitMQ</title>
    <link href="http://blog.renyimin.com/2018/05/27/rabbitmq/2018-05-27-rabbitmq-02/"/>
    <id>http://blog.renyimin.com/2018/05/27/rabbitmq/2018-05-27-rabbitmq-02/</id>
    <published>2018-05-27T04:20:21.000Z</published>
    <updated>2018-05-27T10:19:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><ol><li><p>下载windows版RabbitMQ: 到<a href="http://www.rabbitmq.com/download.html" target="_blank" rel="external">官网</a>下载<a href="https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.5/rabbitmq-server-3.7.5.exe" target="_blank" rel="external">windows installer</a>即可;</p><ul><li>直接傻瓜式双击安装 (可能会提示: <code>Erlang could be detected. You must install Erlang before install RabbitMQ....</code>, 点击是, 会跳转到 Erlang 的<a href="http://www.erlang.org/downloads" target="_blank" rel="external">下载地址</a>)</li><li>然后下载并安装对应版本的 Erlang (你的RabbitMQ对应的Erlang版本该如何选择, 可以参考<a href="http://www.rabbitmq.com/which-erlang.html" target="_blank" rel="external">Windows: With installer (recommended) | Manual</a>)</li><li>然后傻瓜式下载安装 Erlang 即可</li><li>安装完Erlang之后, 双击安装RabbitMQ</li></ul></li><li><p>在安装完RabbitMQ之后, 在Windows的开始菜单中会有 RabbitMQ 服务相关的一些选项可以使用, 如 </p><ul><li><code>RabbitMQ service - start</code> 启动RabbitMQ服务</li><li><code>RabbitMQ service - stop</code> 关闭RabbitMQ服务</li><li><code>RabbitMQ Command Prompt</code> 连接RabbitMQ服务 (命令行连接工具)</li><li><p>……</p></li><li><p>当然, 你可以配置rabbitmq安装目录下的<code>sbin</code>目录到环境变量中, 这样就可以直接<code>cmd</code>使用相关的rabbitmq相关命令了;</p></li></ul></li><li><p>注意windows下的问题: 如果启动命令行连接后, 执行 <code>rabbitmqctl status</code> 报错为 <code>erlang cookie</code> 问题, 目前找到的解决方案是:<br> 将<code>C:\Windows\System32\config\systemprofile\.erlang.cookie</code> 替换到 <code>C:\Users\Administrator\.erlang.cookie</code></p></li><li><p>之后, 可以开启<code>rabbitmq-management</code>插件, 来通过Web UI的形式来进行RabbitMQ的管理</p><ul><li><p>执行如下操作打开<code>rabbitmq-management</code>插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">E:\rabbitmq\rabbitmq_server-3.7.5\sbin&gt;rabbitmqctl list_users</div><div class="line">Listing users ...</div><div class="line">guest   [administrator]</div><div class="line"></div><div class="line">E:\rabbitmq\rabbitmq_server-3.7.5\sbin&gt;rabbitmq-plugins enable rabbitmq_management</div><div class="line">Enabling plugins on node rabbit@DHCCOEPA4DNL18R:</div><div class="line">rabbitmq_management</div><div class="line">The following plugins have been configured:</div><div class="line">  rabbitmq_management</div><div class="line">  rabbitmq_management_agent</div><div class="line">  rabbitmq_web_dispatch</div><div class="line">Applying plugin configuration to rabbit@DHCCOEPA4DNL18R...</div><div class="line">The following plugins have been enabled:</div><div class="line">  rabbitmq_management</div><div class="line">  rabbitmq_management_agent</div><div class="line">  rabbitmq_web_dispatch</div><div class="line"></div><div class="line">started 3 plugins.</div><div class="line"></div><div class="line">E:\rabbitmq\rabbitmq_server-3.7.5\sbin&gt;</div></pre></td></tr></table></figure></li><li><p>访问<a href="http://127.0.0.1:15672即可打开Web管理界面" target="_blank" rel="external">http://127.0.0.1:15672即可打开Web管理界面</a>, 默认账号和密码为guest;</p></li></ul></li></ol><h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><ol><li>Mac下载安装RabbitMQ比较简单, 直接 <code>home install rabbitmq</code> 安装完成即可 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">renyimin$ brew info rabbitmq</div><div class="line">rabbitmq: stable 3.7.5</div><div class="line">Messaging broker</div><div class="line">https://www.rabbitmq.com</div><div class="line">/usr/local/Cellar/rabbitmq/3.7.5 (232 files, 10.1MB) *      // 可以看到, hombrew安装的软件基本上会被放置到 `cd /usr/local/Cellar/` 下</div><div class="line">  Built from source on 2018-05-27 at 11:43:30</div><div class="line">From: https://github.com/Homebrew/homebrew-core/blob/master/Formula/rabbitmq.rb</div><div class="line">==&gt; Dependencies</div><div class="line">Required: erlang ✔              // 可以看到, 已经自动帮你安装了Erlang依赖</div><div class="line">==&gt; Caveats</div><div class="line">Management Plugin enabled by default at http://localhost:15672  // 并且自动开启了插件管理</div><div class="line"></div><div class="line">Bash completion has been installed to:</div><div class="line">  /usr/local/etc/bash_completion.d</div><div class="line"></div><div class="line">To have launchd start rabbitmq now and restart at login:</div><div class="line">  brew services start rabbitmq</div><div class="line">Or, if you don&apos;t want/need a background service you can just run:</div><div class="line">  rabbitmq-server</div><div class="line">renyimindembp:Cellar renyimin$</div></pre></td></tr></table></figure></li></ol><ol><li><p>按照指示, 启动rabbitmq后台运行</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">renyimin$ brew services start rabbitmq</div><div class="line">==&gt; Successfully started `rabbitmq` (label: homebrew.mxcl.rabbitmq)</div></pre></td></tr></table></figure></li><li><p>访问 <code>http://127.0.0.1:15672</code>, 默认账号密码为 <code>guest</code></p></li></ol><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>.. 后续完善</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>.. 后续完善</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Windows&quot;&gt;&lt;a href=&quot;#Windows&quot; class=&quot;headerlink&quot; title=&quot;Windows&quot;&gt;&lt;/a&gt;Windows&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载windows版RabbitMQ: 到&lt;a href=&quot;http://www.
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>01. 认识RabbitMQ消息队列软件</title>
    <link href="http://blog.renyimin.com/2018/05/27/rabbitmq/2018-05-27-rabbitmq-01/"/>
    <id>http://blog.renyimin.com/2018/05/27/rabbitmq/2018-05-27-rabbitmq-01/</id>
    <published>2018-05-27T02:35:21.000Z</published>
    <updated>2018-05-29T06:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p><a href="http://www.rabbitmq.com" target="_blank" rel="external"><code>RabbitMQ</code></a>是一个由 <code>Erlang</code> 开发的 <code>AMQP</code> 的开源消息队列软件, 遵循 Mozilla Public License开源协议;<br> (<code>rabbit</code> : 兔子, 行动迅速, 繁殖疯狂)</p></li><li><p><code>AMQP</code> 即 <code>Advanced Message Queuing Protocol</code>(高级消息队列协议), 一个提供统一消息服务的 <code>应用层</code> 标准 <code>高级消息队列协议</code>, 是应用层协议的一个开放标准, 为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息, 并不受客户端/中间件不同产品, 不同的开发语言等条件的限制)<br> 在《RabbitMQ实战 高效部署分布式消息队列》1.1节 <code>消息队列软件</code> 的相关历史可以了解到, 虽然几十年前就已经存在很多消息队列软件, 但是由于 <code>供应商壁垒</code>, 导致中小型公司对高价格MQ供应商不满, 而大型公司不可避免地使用来自众多供应商的MQ产品来服务企业内部不同的应用, 这些产品使用不同的API, 不同的协议, 因而无法联合起来组成单一总线; 虽然在2001年诞生的JMS通过提供公共Java API的方式, 隐藏了单独MQ产品供应商提供的实际接口, 从而跨越了壁垒和解决了互通问题。但其实我们需要的是新的消息通信标准化方案, 所以就有了 AMQP 协议的诞生;</p></li><li><p>上面简单了解了Rabbit是一款实现AMQP标准协议的消息队列软件, 接下来看一下消息队列软件能够帮我们解决那些问题?</p></li></ol><h2 id="消息队列解决的问题"><a href="#消息队列解决的问题" class="headerlink" title="消息队列解决的问题"></a>消息队列解决的问题</h2><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>首先, 当你将消息通信集成到应用程序时, 你需要理解你正在尝试解决的问题。像探索RabbitMQ的大多数人一样, 你可能并不是在寻找一个消息队列, 而是<strong>解决解耦问题</strong>的方法。<br>比如, 你可能想着:<br>如何将一个<strong>耗时的任务</strong>从触发它的应用程序中移出?<br>如何整合用不同语言编写的应用程序, 使得他们运行起来像单个系统?<br>虽然看起来是两个不同的问题, 但却有着共同的本质: 解耦 <code>请求</code> 和 <code>处理</code>, 这两个问题均需要从同步编程模型转向异步编程模型;</p><blockquote><p>Coffee Bean 模型<br>当你在咖啡馆下了个拿铁订单, 你并不会一直等在收银台, 相反, 咖啡馆会将 接受订单的操作 和 订单处理的操作分开;<br>接单员会接收你的请求(和你的钱), 并告诉咖啡调理师你订的是什么。然后你在等待订单完成的过程中可以继续做其他事情, 同时接单员也可以腾出时间接其他订单;<br>如果等待制作的咖啡挤压太多的话, 他们会增加更多的咖啡调理师以减少订单的挤压, 而无需更改接单员的数量;<br>通过解耦处理过程(分离请求和处理), 他们以同样数量的工作人员完成了更多的工作, 同时工作有很容易按需扩展;<br>而消息通信就可以为你的应用程序做同样的事情!</p></blockquote><h3 id="缓解流量高峰-提高系统吞吐量"><a href="#缓解流量高峰-提高系统吞吐量" class="headerlink" title="缓解流量高峰,提高系统吞吐量"></a>缓解流量高峰,提高系统吞吐量</h3><p>当系统中的同步处理方式在面对高并发涌入的大量操作时, 系统可能会无法立即做出响应, 从而严重影响系统的吞吐量时, 消息队列就可以用来缓解流量高峰, 提高系统吞吐量;<br>从上面的 <code>应用解耦</code> 可以看到, 消息队列提供了一个 <strong>异步通信协议</strong>, 消息的发送者 不用一直等待直到消息被成功处理,而是消息被成功发送后就立即返回, 而消息则被暂存于队列当中,暂时缓解系统压力, 系统后续在进行逐一处理; 这样自然会<strong>缓解流量高峰, 提高系统吞吐量</strong>;</p><h3 id="系统调用中断"><a href="#系统调用中断" class="headerlink" title="系统调用中断"></a>系统调用中断</h3><p>如果系统B,C出现中断, 系统A中的操作已经完成(无法回滚), 那么整个流程就会不完整; 此时就需要系统A的后续流程能够被保留重试;</p><p>……</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>关于RabbitMQ, 这里整理的学习内容包括</p><ul><li>下载安装</li><li>浅析RabbitMQ消息通信模式</li><li>服务器运行及管理</li><li>消息通信及各种细节问题</li><li>消息通信各种实际案例分析</li><li>RabbitMQ集群</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.rabbitmq.com&quot; target=&quot;_blank&quot; rel=&quot;extern
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.renyimin.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Linux文本处理 - awk</title>
    <link href="http://blog.renyimin.com/2018/05/18/linux/2018-05-18-awk/"/>
    <id>http://blog.renyimin.com/2018/05/18/linux/2018-05-18-awk/</id>
    <published>2018-05-18T02:03:51.000Z</published>
    <updated>2018-05-27T14:50:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>Awk是一种便于使用且表达能力强的程序设计语言, 没错, 它是一门编程语言, 它拥有数组, 支持<code>if-else</code>控制语句, <code>for/while</code>循环语句, 内置函数等功能; 同时, <strong>它是一个强大的文本分析工具</strong>; </p></li><li><p>之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的Family Name的首字符;</p></li><li><p>awk 命令的执行过程</p><ul><li>awk是逐行处理的, 就是说, 当awk处理一个文本时, 会一行一行进行处理, 处理完当前行, 再处理下一行, awk默认以 “换行符” 为标记来识别每一行, 跟我们人类一样, 每次遇到”回车换行”, 就认为是当前行的结束, 新的一行的开始;</li><li>awk在逐行处理文本时, 会搜索能够匹配程序中任意模式(也就是在awk命令中的’program’中可以有多个模式)的行, 每个模式依次测试每个输入行, 对于匹配到模式的行, 会执行awk命令中模式后面的动作(也许包含多步), 然后读取下一行并继续匹配, 直到所有的输入读取完毕;</li><li>同时, awk会按照用户指定的分割符去分割当前行为多个字段(每个字段分别被标识为 <code>$1</code> 一直到 <code>$NF</code>, <code>$NF</code>为awk中的变量, 表示当前行被分隔出的最大字段数), 如果没有指定分割符, 默认使用空格作为分隔符, 另外, 默认会将空格符和制表符都视为空格, 而且多个连续的空格都视为一个;</li></ul></li><li><p>作为一个PHP开发人员, 在工作中, 不一定要求会写比较复杂的awk语句, 但可能经常会接触到开发, 沙盒, 预发, 线上等各种环境, 此时可以使用awk对一些日志文本做一些分析很方便的分析工作;</p></li></ol><h2 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h2><ol><li><p>基本语法结构为: <code>awk [options] &#39;program&#39; file1 , file2 ...</code>, 其中, <code>&#39;program&#39;</code> 又可以细分为 <code>pattern</code>模式 和 <code>action</code>动作; 也就是说, awk的完整语法其实为 <code>awk [options] &#39;pattern {action}&#39; file1 , file2 ...</code></p></li><li><p><code>pattern</code> : 指的是模式, 用来匹配awk命令所处理的文本中的每一行内容;</p><ul><li><p><strong>注意模式匹配字符串时, 需要使用双引号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ cat awk.log</div><div class="line">renyimin   200 1200W 男</div><div class="line"></div><div class="line">renfumin 500 200W  男</div><div class="line">renjuanfang          1000 900W 女</div><div class="line"></div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ awk &apos;$1==&quot;renyimin&quot; &#123;print $1,$2,$3&#125;&apos; awk.log</div><div class="line">renyimin 200 1200W</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ awk &apos;$1==&apos;renyimin&apos; &#123;print $1,$2,$3&#125;&apos; awk.log</div><div class="line"></div><div class="line"></div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ awk &apos;$1==renyimin &#123;print $1,$2,$3&#125;&apos; awk.log</div><div class="line"></div><div class="line"></div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$</div></pre></td></tr></table></figure></li><li><p>模式可以组合(可以使用括号和逻辑操作符与 <code>&amp;&amp;</code> ， 或 <code>||</code> ， 以及非 <code>!</code> 对模式进行组合)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ awk &apos;$1==&quot;renyimin&quot; &amp;&amp; $2&gt;20 &#123;print $1,$2,$3&#125;&apos; awk.log</div><div class="line">renyimin 200 1200W</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ awk &apos;$1==&quot;renyimin&quot; &amp;&amp; $2&gt;200 &#123;print $1,$2,$3&#125;&apos; awk.log</div></pre></td></tr></table></figure></li><li><p>模式可以使用<code>运算符</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ cat test1.log</div><div class="line">Beth4.000</div><div class="line">Dan3.750</div><div class="line">kathy4.0010</div><div class="line">Mark5.0020</div><div class="line">Mary5.5022</div><div class="line">Susie4.2518</div><div class="line">renyimindeMacBook-Pro:linux renyimin$ awk &apos;$2*$3&gt;50 &#123;print $0&#125;&apos; test1.log</div><div class="line">Mark5.0020</div><div class="line">Mary5.5022</div><div class="line">Susie4.2518</div><div class="line">renyimindeMacBook-Pro:linux renyimin$</div></pre></td></tr></table></figure></li><li><p>也可以使用<code>正则表达式</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ awk &apos;/Susie/ &#123;print $0&#125;&apos; test1.log</div><div class="line">Susie4.2518</div><div class="line">renyimindeMacBook-Pro:linux renyimin$</div></pre></td></tr></table></figure></li></ul></li></ol><ol><li><p><code>action</code> 指的就是动作, awk 擅长文本格式化并将格式化后的文本<strong>输出</strong>, 所以它比较常用的 action 是 <code>print</code> 和 <code>printf</code>;</p></li><li><p>‘模式+动作’ 语句中的 模式 或 动作都可以省略, 但不是两者同时省略;</p><ul><li>有的awk命令有 一个模式 + 动作</li><li>有的awk命令只有一个模式, 没有动作(如果没有动作, 那么模式匹配到的每一行都会被完整打印出来, 相当于动作是<code>{print}</code> 或者 <code>{print $0}</code>)</li><li>有的awk命令只有多个模式, 没有动作(同上) </li><li>有的awk命令可以有多个模式 + 一个动作</li><li>貌似没有 模式+动作, 模式+动作 这种awk命令</li><li>多个模式可以使用括号和逻辑操作符<code>与&amp;&amp;</code>, <code>或||</code>, 以及 <code>非!</code> 对模式进行组合</li></ul></li><li><p><code>option</code> 选项, 可以不用任何选项, 常用选项为</p><ul><li><p><code>-F fs or --field-separator fs</code> : 指定输入文件分隔符(), fs可以是一个字符串或是一个正则表达式 (当然, 也可以使用内置变量, 结合参数 -v,  <code>-v FS=&#39;分隔符&#39;</code> 来指定分隔符)<br><code>-F</code> 还可以使用正则表达式来定制按照某些字符串来做分隔, 字符需要放在 <code>&#39;[]&#39;中</code>, 比如对nginx的access日志使用<code>[</code>或者<code>]</code>来分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ tail -5 c2b_oms.2018-03-30-access.log</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:16:43:17 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[200] byte=[884] elapsed=[2.189] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[7.55]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:17:11:45 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[500] byte=[22005] elapsed=[0.136] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[-]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:17:13:25 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[200] byte=[695] elapsed=[0.115] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[9.50]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:17:14:41 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[500] byte=[22005] elapsed=[0.133] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[-]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:17:14:58 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[500] byte=[22005] elapsed=[0.139] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[-]</div><div class="line">$ tail -5 c2b_oms.2018-03-30-access.log | awk -F &apos;[][]&apos; &apos;&#123;print $8&#125;&apos;</div><div class="line">GET /api/v1/car_dealer/list HTTP/1.1</div><div class="line">GET /api/v1/car_dealer/list HTTP/1.1</div><div class="line">GET /api/v1/car_dealer/list HTTP/1.1</div><div class="line">GET /api/v1/car_dealer/list HTTP/1.1</div><div class="line">GET /api/v1/car_dealer/list HTTP/1.1</div><div class="line">[work@VM_0_206_centos nginx_log]$</div></pre></td></tr></table></figure><p>或者还可以使用 <code>tail -10 c2b_oms.2018-03-30-access.log | awk -F&#39;[\\[\\]]&#39; &#39;{print $2}&#39;</code></p></li><li>可以按照任意一段字符串进行分隔<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[work@VM_0_206_centos nginx_log]$ tail -3 c2b_oms.2018-03-30-access.log</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:11:26:09 +0800] request=[GET /api/v1/car_dealer/list?car_dealer_name_or_phone=18625036504 HTTP/1.1] status=[200] byte=[276] elapsed=[0.005] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[0.61]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:11:28:23 +0800] request=[GET /api/v1/car_dealer/list?car_dealer_name_or_phone=renyimin HTTP/1.1] status=[200] byte=[786] elapsed=[1.312] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[8.27]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[30/Mar/2018:11:29:39 +0800] request=[GET /api/v1/car_dealer/list?car_dealer_name_or_phone1=renyimin HTTP/1.1] status=[200] byte=[786] elapsed=[0.269] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[8.27]</div><div class="line">[work@VM_0_206_centos nginx_log]$ tail -10 c2b_oms.2018-03-30-access.log | awk -F&apos;+0800&apos; &apos;&#123;print $2&#125;&apos;</div><div class="line">] request=[GET /api/v1/car_dealer/list?car_dealer_name_or_phone=18625036504 HTTP/1.1] status=[200] byte=[276] elapsed=[0.005] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[0.61]</div><div class="line">] request=[GET /api/v1/car_dealer/list?car_dealer_name_or_phone=renyimin HTTP/1.1] status=[200] byte=[786] elapsed=[1.312] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[8.27]</div><div class="line">] request=[GET /api/v1/car_dealer/list?car_dealer_name_or_phone1=renyimin HTTP/1.1] status=[200] byte=[786] elapsed=[0.269] refer=[-] body=[-] ua=[PostmanRuntime/6.1.6] cookie=[-] gzip=[8.27]</div><div class="line">[work@VM_0_206_centos nginx_log]$</div></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- `-v` 变量赋值选项: 该选项将一个值赋予一个变量, 它会在程序开始之前进行赋值, 下面的例子描述了该选项的使用`-v` : 定义一个变量 (变量可以是awk内置的, 也可以是自定义的)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ awk -v name=Rymuscle &apos;BEGIN&#123;printf &quot;Name = %s\n&quot;, name&#125;&apos;</div><div class="line">Name = Jerry</div><div class="line">$</div></pre></td></tr></table></figure>- 上面介绍了如何设定输入分隔符, 其实还有输出分隔符, 可以使用 `-v OFS=&apos;分隔符&apos;`, 来定义输出分隔符 (注意,在输出时, 各字段间的`逗号`就代表了输出分隔符, 没有逗号则各字段会紧连着)-  `-f scriptfile 或者 --file scriptfile` : 从脚本文件中读取awk命令</code></pre><ol><li>多文件处理, 用到了再补充~~</li></ol><h2 id="内置的一些变量"><a href="#内置的一些变量" class="headerlink" title="内置的一些变量"></a>内置的一些变量</h2><p>下面值列出本人常用的一些awk内置变量<br>变量可以在<code>BEGIN</code>语句块中声明, 也可以在<code>program</code>中声明, 也可以使用参数 <code>-v</code> 声明</p><ol><li><p><code>NF</code>: <strong>行的字段数量</strong>, 你可以在awk命令的program中使用action, 在action中比较常用的是print所需的字段, 此时你可能总是需要通过 $1, $2 这样来指定索要打印的不同字段, 但任何表达式都可以使用在<code>$</code>之后来表达一个字段的序号; 表达式会被求值并用于表示字段序号, 同时, Awk会对当前输入的行有多少个字段进行计数, 并且将当前行的字段数量存储在一个内建的称作 <code>NF</code> 的变量中;<br> 因此, 程序 <code>{ print NF, $1, $NF }</code> 会依次打印出每一行的字段数量, 第一个字段的值, 最后一个字段的值;</p></li><li><p><code>NR</code>: 它会存储当前已经读取了多少行的计数. 我们可以使用 <code>$NR</code> 给结果的每一行加上行号</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ awk &apos;&#123;print NR,$0&#125;&apos; awk.log</div><div class="line">1 renyimin   &quot;200&quot; 1200W 男</div><div class="line">2</div><div class="line">3 renfumin 500 &quot;200W&quot;  男</div><div class="line">4 renjuanfang          1000 900W &quot;女&quot;</div><div class="line">5</div><div class="line">renyimindeMacBook-Pro:linux renyimin$</div></pre></td></tr></table></figure></li><li><p><code>FS</code>: 除了使用 <code>-F</code>参数指定字段分隔符, 也可以通过 -v 设定 <code>FS</code> 内置变量来指定字段分隔符 (或者在<code>BEGIN</code>中指定<code>FS</code>变量)</p></li><li><p><code>OFS</code> : 上面介绍了如何设定输入分隔符, 其实还有输出分隔符, 可以使用 <code>-v OFS=&#39;分隔符&#39;</code>(或者在<code>BEGIN</code>中指定<code>OFS</code>变量), 来定义输出分隔符 (注意,在输出时, 各字段间的<code>逗号</code>就代表了输出分隔符, 没有逗号则各字段会紧连着)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[work@VM_0_206_centos nginx_log]$ tail -3 c2b_oms.2018-03-30-access.log | awk -F&quot;[][]&quot; -v OFS=&apos;---&apos; &apos;&#123;print $2,$3&#125;&apos;</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">[work@VM_0_206_centos nginx_log]$ tail -3 c2b_oms.2018-03-30-access.log | awk -F&quot;[][]&quot; &apos;BEGIN&#123;OFS=&quot;---&quot;&#125; &#123;print $2,$3&#125;&apos;</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">[work@VM_0_206_centos nginx_log]$</div></pre></td></tr></table></figure></li><li><p>另外声明变量也可以直接在 <code>program</code> 中进行</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[work@VM_0_206_centos nginx_log]$ tail -3 c2b_oms.2018-03-30-access.log | awk &apos;FS=&quot;[][]&quot;,OFS=&quot;---&quot; &#123;print $2,$3&#125;&apos;</div><div class="line">http_x_forward=[-]---time=[30/Mar/2018:11:26:09</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">172.16.254.2--- http_x_forward=</div><div class="line">[work@VM_0_206_centos nginx_log]$</div></pre></td></tr></table></figure></li><li><p>其余的, 用到了再补充~~</p></li></ol><h2 id="BEGIN-语句块"><a href="#BEGIN-语句块" class="headerlink" title="BEGIN 语句块"></a>BEGIN 语句块</h2><ol><li><code>BEGIN</code> 语句块的语法: 在awk的program中 <code>BEGIN {awk-commands}</code>: BEGIN语句块在程序开始的使用执行, 它只执行一次, 在这里可以初始化变量或者打印一个开头什么的…</li><li><code>BEGIN</code> 是AWK的关键字, 因此它必须为大写, 注意, 这个语句块是可选的;</li><li>测试:<ul><li>可以使用 <code>print &quot;&quot;</code> 在输出之前先打印一个空行<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ awk &apos;BEGIN &#123;print &quot;&quot;&#125; &#123;print NR,$0&#125;&apos; awk.log</div><div class="line"></div><div class="line">1 renyimin   &quot;200&quot; 1200W 男</div><div class="line">2</div><div class="line">3 renfumin 500 &quot;200W&quot;  男</div><div class="line">4 renjuanfang          1000 900W &quot;女&quot;</div><div class="line">5</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="END-语句块"><a href="#END-语句块" class="headerlink" title="END 语句块"></a>END 语句块</h2><p>END 则用于处理匹配过的最后一个文件的最后一行之后的位置;</p><h2 id="多分隔符测试"><a href="#多分隔符测试" class="headerlink" title="多分隔符测试"></a>多分隔符测试</h2><ol><li><code>awk -F&#39;[],&quot; ]&#39; &#39;{print $2,$61,$2-$61}&#39; ttt.log</code> // 可以使用 <code>-F[]</code> 将分隔的字符串包起来, 这样就是使用 ] 或者, 或者双引号或者空格来进行分隔了;</li></ol><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>下面根据nginx的access.log日志来做一些练习 (这个日志还是挺大量的)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wc c2b_bid.2018-04-23-access.log</div><div class="line">   65608  1501442 29580860 c2b_bid.2018-04-23-access.log</div></pre></td></tr></table></figure></p><ol><li><p>统计独立ip的访问量 - 共有多少独立IP访问过本站点</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-bash-4.2$ awk &apos;&#123;print $1&#125;&apos; c2b_bid.2018-04-23-access.log | sort -n | uniq | wc -l</div><div class="line">240</div></pre></td></tr></table></figure><p> 表示共有240个不同ip访问过站点</p></li><li><p>统计独立ip的访问情况 - 每个独立ip的访问次数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bash-4.2$ awk &apos;&#123;print $1&#125;&apos; c2b_bid.2018-04-23-access.log | sort -n | uniq -c</div><div class="line">    190 remote_addr=[100.116.226.0]</div><div class="line">    195 remote_addr=[100.116.226.1]</div><div class="line">    176 remote_addr=[100.116.226.10]</div><div class="line">    176 remote_addr=[100.116.226.100]</div><div class="line">    .....</div><div class="line">    就不全部列出了</div></pre></td></tr></table></figure></li><li><p>统计访问最频繁的前10个ip</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-bash-4.2$ awk &apos;&#123;print $1&#125;&apos; c2b_bid.2018-04-23-access.log | sort -n | uniq -c | sort -rn | head -10</div><div class="line">    407 remote_addr=[100.116.251.123]</div><div class="line">    399 remote_addr=[100.116.251.65]</div><div class="line">    394 remote_addr=[100.116.251.56]</div><div class="line">    390 remote_addr=[100.116.251.97]</div><div class="line">    388 remote_addr=[100.116.251.11]</div><div class="line">    387 remote_addr=[100.116.251.110]</div><div class="line">    384 remote_addr=[100.116.251.98]</div><div class="line">    383 remote_addr=[100.116.251.83]</div><div class="line">    382 remote_addr=[100.116.251.8]</div><div class="line">    381 remote_addr=[100.116.251.40]</div><div class="line">-bash-4.2$</div></pre></td></tr></table></figure></li><li><p>查看访问380次以上的ip</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-bash-4.2$ awk &apos;&#123;print $1&#125;&apos; c2b_bid.2018-04-23-access.log | sort -n | uniq -c | awk &apos;$1 &gt; 380 &#123;print&#125;&apos; | sort -rn</div><div class="line">    407 remote_addr=[100.116.251.123]</div><div class="line">    399 remote_addr=[100.116.251.65]</div><div class="line">    394 remote_addr=[100.116.251.56]</div><div class="line">    390 remote_addr=[100.116.251.97]</div><div class="line">    388 remote_addr=[100.116.251.11]</div><div class="line">    387 remote_addr=[100.116.251.110]</div><div class="line">    384 remote_addr=[100.116.251.98]</div><div class="line">    383 remote_addr=[100.116.251.83]</div><div class="line">    382 remote_addr=[100.116.251.8]</div><div class="line">    381 remote_addr=[100.116.251.40]</div><div class="line">    381 remote_addr=[100.116.251.38]</div><div class="line">    381 remote_addr=[100.116.251.118]</div><div class="line">-bash-4.2$</div></pre></td></tr></table></figure></li><li><p>这是平时日常的日志分析命令</p><ul><li><p>日志为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tail -5 c2b_oms.2018-03-29-access.log</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[29/Mar/2018:18:37:48 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[200] byte=[19305] elapsed=[0.002] refer=[-] body=[-] ua=[Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36] cookie=[-] gzip=[3.19]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[29/Mar/2018:18:41:24 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[200] byte=[24131] elapsed=[0.004] refer=[-] body=[-] ua=[Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36] cookie=[-] gzip=[3.96]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[29/Mar/2018:18:42:06 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[200] byte=[24130] elapsed=[0.004] refer=[-] body=[-] ua=[Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36] cookie=[-] gzip=[3.96]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[29/Mar/2018:18:42:40 +0800] request=[GET /api/v1/car_dealer/list HTTP/1.1] status=[200] byte=[786] elapsed=[1.078] refer=[-] body=[-] ua=[Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36] cookie=[-] gzip=[8.27]</div><div class="line">remote_addr=[172.16.254.2] http_x_forward=[-] time=[29/Mar/2018:18:42:57 +0800] request=[GET /favicon.ico HTTP/1.1] status=[404] byte=[9879] elapsed=[0.010] refer=[http://172.16.0.206:8888/] body=[-] ua=[Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36] cookie=[-] gzip=[2.27]</div></pre></td></tr></table></figure><p>分析为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">awk -F&apos;] &apos; &apos;&#123;status=substr($5,9);elapsed=substr($7,10);if(elapsed &gt;= 2 || status &gt;=500)print $4,status,elapsed;  &#125;&apos; hera.2018-05-07-access.log &gt; /tmp/hera.2018-05-07.log</div><div class="line">cat /tmp/hera.2018-05-07.log | awk &apos;&#123;a[$4]+=1;&#125;END&#123;for(i in a)&#123;print i,a[i]&#125;&#125;&apos;</div><div class="line">cat /tmp/hera.2018-05-07.log | awk &apos;&#123;if($4 == 500)print $2,$4&#125;&apos; | sort</div></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Awk是一种便于使用且表达能力强的程序设计语言, 没错, 它是一门编程语言, 它拥有数组, 支持&lt;code&gt;if-else
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://blog.renyimin.com/2018/05/17/linux/2018-05-17-regular/"/>
    <id>http://blog.renyimin.com/2018/05/17/linux/2018-05-17-regular/</id>
    <published>2018-05-17T06:22:31.000Z</published>
    <updated>2018-05-17T06:22:36.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux编辑器</title>
    <link href="http://blog.renyimin.com/2018/05/17/linux/2018-05-17/"/>
    <id>http://blog.renyimin.com/2018/05/17/linux/2018-05-17/</id>
    <published>2018-05-17T06:17:57.000Z</published>
    <updated>2018-05-17T06:21:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><p>光标跳转到某行<br>光标跳转到行首<br>光标跳转到行尾</p><h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><p>复制当前行<br>复制从当前行开始多少行<br>复制指定某几行</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><h3 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h3><p>垂直<br>水平<br>分屏切换焦点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vim&quot;&gt;&lt;a href=&quot;#vim&quot; class=&quot;headerlink&quot; title=&quot;vim&quot;&gt;&lt;/a&gt;vim&lt;/h2&gt;&lt;h3 id=&quot;跳转&quot;&gt;&lt;a href=&quot;#跳转&quot; class=&quot;headerlink&quot; title=&quot;跳转&quot;&gt;&lt;/a&gt;跳转&lt;/h3&gt;&lt;p
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文本处理 - sort, uniq, wc</title>
    <link href="http://blog.renyimin.com/2018/05/16/linux/2018-05-16-other-command/"/>
    <id>http://blog.renyimin.com/2018/05/16/linux/2018-05-16-other-command/</id>
    <published>2018-05-16T07:28:21.000Z</published>
    <updated>2018-05-23T05:27:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><ol><li>Linux <code>sort</code>命令用于将文本文件内容以<code>行</code>为单位进行排序; </li><li><p>语法: <code>sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][--help][--verison][文件]</code><br> <code>sort</code> 命令既可以从特定的文件，也可以从 stdin 中获取输入;</p></li><li><p>选项</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-b：忽略每行前面开始出的空格字符；</div><div class="line">-c：检查文件是否已经按照顺序排序；</div><div class="line">-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符；</div><div class="line">-f：排序时，将小写字母视为大写字母；</div><div class="line">-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；</div><div class="line">-m：将几个排序号的文件进行合并；</div><div class="line">-M：将前面3个字母依照月份的缩写进行排序；</div><div class="line">-n：依照数值的大小排序；</div><div class="line">-o&lt;输出文件&gt;：将排序后的结果存入制定的文件；</div><div class="line">-r：以相反的顺序来排序；</div><div class="line">-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符；</div><div class="line">+&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</div></pre></td></tr></table></figure></li><li><p>目前常用的选项有 <code>-nr</code></p></li></ol><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><ol><li><p><code>uniq</code> 命令用于报告或忽略文件中的重复行，一般与sort命令结合使用; </p><ul><li>之所以要和sort命令结合使用, 是因为<code>uniq</code>命令值只可以删除相邻的重复行;</li><li>如果一文本中有重复却不相邻的行, 单独使用<code>uniq</code>命令则无法删除, 需要结合sort命令;</li></ul></li><li><p>语法: <code>uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--help][--version][输入文件][输出文件]</code></p></li><li><p>选项:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-c或——count：在每列旁边(貌似是左边)显示该行重复出现的次数；</div><div class="line">-d或--repeated：仅显示重复出现的行列；</div><div class="line">-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;：忽略比较指定的栏位；</div><div class="line">-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;：忽略比较指定的字符；</div><div class="line">-u或——unique：仅显示出一次的行列；</div><div class="line">-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;：指定要比较的字符。</div></pre></td></tr></table></figure></li><li><p>目前常用的选项有 <code>-c</code></p></li><li><p>参数介绍</p><ul><li>输入文件: 指定要去除的重复行文件, 如果不指定此项, 则从标准读取数据; </li><li>输出文件: 指定要去除重复行后的内容要写入的输出文件, 如果不指定此选项, 则将内容显示到标准输出设备(显示到终端);</li></ul></li><li><p>实例</p><ul><li>uniq <strong>无法去除不相邻的重复行</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ cat uniq.log</div><div class="line">renyimin is a it man</div><div class="line">he has many article</div><div class="line">renyimin comes from shanxi province</div><div class="line">he has many article</div><div class="line"></div><div class="line">// 可以看到uniq并没有对不相邻的重复行进行去重操作</div><div class="line">renyimindeMacBook-Pro:linux renyimin$ uniq uniq.log</div><div class="line">renyimin is a it man</div><div class="line">he has many article</div><div class="line">renyimin comes from shanxi province</div><div class="line">he has many article</div><div class="line">renyimindeMacBook-Pro:linux renyimin$</div><div class="line">   </div><div class="line">// 如下进行排序后即可</div><div class="line">renyimindeMacBook-Pro:linux renyimin$ sort uniq.log | uniq</div><div class="line">he has many article</div><div class="line">renyimin comes from shanxi province</div><div class="line">renyimin is a it man</div><div class="line">renyimindeMacBook-Pro:linux renyimin$</div></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- `-c` 参数, 对文件相同行进行去重, 并统计每行重复出现的次数 (类似于mysql的groupby分组统计)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ sort uniq.log | uniq -c</div><div class="line">2 he has many article</div><div class="line">1 renyimin comes from shanxi province</div><div class="line">1 renyimin is a it man</div></pre></td></tr></table></figure>- 当然, 还可以继续结合sort来按照重复条数最多的来排序 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ sort uniq.log | uniq -c | sort</div><div class="line">1 renyimin comes from shanxi province</div><div class="line">1 renyimin is a it man</div><div class="line">2 he has many article</div></pre></td></tr></table></figure></code></pre><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><ol><li><p>利用<code>wc</code>指令我们可以计算文件的 行数、Byte数、字数、或是列数, 若不指定文件名称、或是所给予的文件名为”-“, 则wc指令会从标准输入设备读取数据;</p></li><li><p>语法: <code>wc [-clw][--help][--version][文件...]</code></p></li><li><p>选项</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-c或--bytes或--chars 只显示Bytes数</div><div class="line"></div><div class="line">-l或--lines 只显示行数</div><div class="line"></div><div class="line">-w或--words 只显示字数</div><div class="line"></div><div class="line">--help 在线帮助</div><div class="line"></div><div class="line">--version 显示版本信息</div></pre></td></tr></table></figure></li><li><p>目前常用的选项有 <code>-lwc</code> (貌似也是默认的选项, 而且无论选项的顺序是怎样的, 结果总是: “行数, 字数, 字节数, 文件名”)</p></li><li><p>实例</p><ul><li><p>基本用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ cat uniq.log</div><div class="line">renyimin is a it man</div><div class="line">he has many article</div><div class="line">renyimin comes from shanxi province</div><div class="line">he has many article</div><div class="line">renyimindeMacBook-Pro:linux renyimin$ wc uniq.log</div><div class="line">       4      18      97 uniq.log</div><div class="line">renyimindeMacBook-Pro:linux renyimin$</div></pre></td></tr></table></figure></li><li><p>统计多文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ wc -l uniq.log uniq.log</div><div class="line">       4 uniq.log       // 第一个文件行数为4</div><div class="line">       4 uniq.log       // 第二个文件行数为4</div><div class="line">       8 total          // 两个文件总的行数为8</div><div class="line">renyimindeMacBook-Pro:linux renyimin$</div></pre></td></tr></table></figure></li><li><p>结合之前的 <code>uniq</code>, <code>sort</code> 命令, 统计去重后的行数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:linux renyimin$ cat uniq.log</div><div class="line">renyimin is a it man</div><div class="line">he has many article</div><div class="line">renyimin comes from shanxi province</div><div class="line">he has many article</div><div class="line"></div><div class="line">// 总共有4行</div><div class="line">renyimindeMacBook-Pro:linux renyimin$ sort uniq.log | wc -l</div><div class="line">          4</div><div class="line">// 去重后有3行</div><div class="line">renyimindeMacBook-Pro:linux renyimin$ sort uniq.log | uniq -c | wc -l</div><div class="line">          3</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h2><p>nl命令在linux系统中用来计算文件中行号, nl 可以将输出的文件内容自动的加上行号, 其默认的结果与 <code>cat -n</code> 有点不太一样, nl 可以将行号做比较多的显示设计, 包括位数与是否自动补齐 0 等等的功能<br>1．命令格式 : <code>nl [选项]... [文件]...</code><br>2．命令参数：<br>    -b  ：指定行号指定的方式，主要有两种：<br>    -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>    -b t ：如果有空行，空的那一行不要列出行号(默认值)；<br>    -n  ：列出行号表示的方法，主要有三种：<br>    -n ln ：行号在萤幕的最左方显示；<br>    -n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>    -n rz ：行号在自己栏位的最右方显示，且加 0 ；<br>    -w  ：行号栏位的占用的位数。<br>    -p 在逻辑定界符处不重新开始计算。</p><ol><li>试用 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$ nl -ba Test.class.php</div><div class="line"> 1&lt;?php</div><div class="line"> 2interface Huma</div><div class="line"> 3&#123;</div><div class="line"> 4     public static function say();</div><div class="line"> 5&#125;</div><div class="line"> 6</div><div class="line"> 7class Male implements Huma</div><div class="line"> 8&#123;</div><div class="line"> 9    private static function say()</div><div class="line">10    &#123;</div><div class="line">11        echo &quot;I am a Male&quot;;</div><div class="line">12    &#125;</div><div class="line">13&#125;</div><div class="line">14</div><div class="line">15class Female implements Huma</div><div class="line">16&#123;</div><div class="line">17    public static function say()</div><div class="line">18    &#123;</div><div class="line">19        echo &quot;I am a Female&quot;;</div><div class="line">20    &#125;</div><div class="line">21&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="其他案例"><a href="#其他案例" class="headerlink" title="其他案例"></a>其他案例</h2><ol><li>在多个文件中匹配某个字符串(比如 ‘&lt;?php’), 并列出文件名: <code>grep &#39;&lt;?php&#39; *.php</code></li></ol><p>重点还是多练习….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sort&quot;&gt;&lt;a href=&quot;#sort&quot; class=&quot;headerlink&quot; title=&quot;sort&quot;&gt;&lt;/a&gt;sort&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Linux &lt;code&gt;sort&lt;/code&gt;命令用于将文本文件内容以&lt;code&gt;行&lt;/code&gt;为单位进行排序
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins</title>
    <link href="http://blog.renyimin.com/2018/05/15/Jenkins/2018-05-15-01/"/>
    <id>http://blog.renyimin.com/2018/05/15/Jenkins/2018-05-15-01/</id>
    <published>2018-05-15T10:28:18.000Z</published>
    <updated>2018-05-16T02:28:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jenkins.io/download/" target="_blank" rel="external">下载</a>安装</p><ol><li><p>默认情况下, Jenkins提供了 最新版本 和 长期支持版本(LTS) 可供下载;</p><ul><li><a href="https://hub.docker.com/r/jenkins/jenkins/" target="_blank" rel="external">Docker 拉取</a>Jenkins镜像: <code>docker pull jenkins/jenkins:lts</code></li><li>在本机创建目录 <code>/Users/renyimin/Desktop/jenkins_home</code>, 下面将会以root用户身份将jenkins容器中的jenkins_home目录挂载到宿主机上, 防止容器删除, 数据丢失</li><li><a href="https://github.com/jenkinsci/docker/blob/master/README.md" target="_blank" rel="external">Docker 运行</a>: </li><li>在输出的控制台信息中, 一定要记得记录生成的秘钥串, 稍后会用到, 如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">May 15, 2018 10:55:38 AM jenkins.install.SetupWizard init</div><div class="line">INFO:</div><div class="line"></div><div class="line">*************************************************************</div><div class="line">*************************************************************</div><div class="line">*************************************************************</div><div class="line"></div><div class="line">Jenkins initial setup is required. An admin user has been created and a password generated.</div><div class="line">Please use the following password to proceed to installation:</div><div class="line"></div><div class="line">29b2b48ed7e14cb8bf9f706dde309995</div><div class="line"></div><div class="line">This may also be found at: /var/jenkins_home/secrets/initialAdminPassword</div><div class="line"></div><div class="line">*************************************************************</div><div class="line">*************************************************************</div><div class="line">*************************************************************</div></pre></td></tr></table></figure></li></ul></li><li><p>看到秘钥串生成, 就可以打开浏览器, 输入：<a href="http://127.0.0.1:8080" target="_blank" rel="external">http://127.0.0.1:8080</a> 进入jenkins系统配置界面, 输入刚刚记录的秘钥串 <code>29b2b48ed7e14cb8bf9f706dde309995</code>:<br> <img src="/img/jenkins/install-01.png" width="500/"></p></li><li><p>点继续, 到了选择安装插件的界面, 这里我们选择安装默认常用的插件, 如图:<br> <img src="/img/jenkins/install-02.png" width="500/"><br> <img src="/img/jenkins/install-03.png" width="500/"></p></li><li><p>插件安装完成后, 选择以admin管理员用户继续, 如下:<br> <img src="/img/jenkins/install-04.png" width="500/"></p></li><li><p>然后 开始使用Jenknsi :<br> <img src="/img/jenkins/install-05.png" width="500/"></p></li><li><p>选择 “用户”-&gt;”admin”-&gt;设置”, 把admin管理员账户的密码修改一下, 然后点击保存, 到此Jenkins安装结束;<br> <img src="/img/jenkins/install-06.png" width="500/"></p></li></ol><p>参考:<a href="https://www.cnblogs.com/soar1688/p/6833540.html" target="_blank" rel="external">https://www.cnblogs.com/soar1688/p/6833540.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jenkins.io/download/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载&lt;/a&gt;安装&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;默认情况下, Jenkins提供了 最新版本 和 长期支持版本(LTS) 可供下载;
      
    
    </summary>
    
      <category term="持续集成" scheme="http://blog.renyimin.com/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="持续集成" scheme="http://blog.renyimin.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux文本处理 - grep</title>
    <link href="http://blog.renyimin.com/2018/05/15/linux/2018-05-15-grep/"/>
    <id>http://blog.renyimin.com/2018/05/15/linux/2018-05-15-grep/</id>
    <published>2018-05-15T02:09:02.000Z</published>
    <updated>2018-05-17T06:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;grep&quot;&gt;&lt;a href=&quot;#grep&quot; class=&quot;headerlink&quot; title=&quot;grep&quot;&gt;&lt;/a&gt;grep&lt;/h2&gt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文本处理 - sed</title>
    <link href="http://blog.renyimin.com/2018/05/15/linux/2018-05-15-sed/"/>
    <id>http://blog.renyimin.com/2018/05/15/linux/2018-05-15-sed/</id>
    <published>2018-05-15T02:08:21.000Z</published>
    <updated>2018-05-27T14:57:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h3 id="查找匹配某个字符串的行"><a href="#查找匹配某个字符串的行" class="headerlink" title="查找匹配某个字符串的行"></a>查找匹配某个字符串的行</h3><ol><li><p><code>tail -5 c2b_oms.2018-03-29-access.log | sed -n &#39;/2018:18:41:24/p&#39;</code></p><ul><li><code>/p</code> 是打印的意思</li><li><code>-n</code> 仅显示script处理后的结果, 即: 只打印匹配到 ‘2018:18:41:24’ 的行</li></ul></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sed&quot;&gt;&lt;a href=&quot;#sed&quot; class=&quot;headerlink&quot; title=&quot;sed&quot;&gt;&lt;/a&gt;sed&lt;/h2&gt;&lt;h3 id=&quot;查找匹配某个字符串的行&quot;&gt;&lt;a href=&quot;#查找匹配某个字符串的行&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IO相关的一些概念</title>
    <link href="http://blog.renyimin.com/2018/05/13/socket/2018-05-13-IO/"/>
    <id>http://blog.renyimin.com/2018/05/13/socket/2018-05-13-IO/</id>
    <published>2018-05-13T03:12:19.000Z</published>
    <updated>2018-05-13T12:02:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>在开始socket编程前, 需要先对 <code>IO</code> 的概念有一定的认识: </p><ul><li>我们通常使用php的fopen打开文件关闭文件读读写写, 这叫<code>本地文件IO</code>; </li><li>而在socket编程中, 本质其实是<code>网络IO</code>;</li></ul><h2 id="同步异步阻塞非阻塞"><a href="#同步异步阻塞非阻塞" class="headerlink" title="同步异步阻塞非阻塞"></a>同步异步阻塞非阻塞</h2><p>之前反正一直搞不清楚同步和阻塞, 异步和非阻塞的概念, 总感觉同步就是阻塞, 异步就是非阻塞的, 总是搞得晕乎乎的, 于是就重新查了些资料进行了梳理, 如有不对欢迎大家指正;</p><h3 id="简单来说"><a href="#简单来说" class="headerlink" title="简单来说"></a>简单来说</h3><p>同步: 同步体现在, 在等待一件事情的处理结果时, 对方是否提供通知服务, 如果对方不提供通知服务, 则为 同步;</p><p>异步: 异步体现在, 在等待一件事情的处理结果时, 对方是否提供通知服务, 如果对方提供通知服务, 则为 异步; </p><ul><li>对于常见的Ajax请求, 前端在ajax请求后通常还会执行一些其他加载操作(非阻塞); 在server端处理完后, 会将数据’通知’到前端页面;</li><li>而对于最近正好在看的RabbitMQ消息队列系统, 虽然本质上来说也是异步的(它是通过分隔了数据的发送和接收来解耦应用, 数据在最终被消费者处理完后也不会通知到生产者, 因为消息系统采用了很多手段如持久化, 重试等来确保消息一定会被执行), 但实质上, 消息会在发送成功后会立即得到响应, 所以单就生产者成功生产消息这一步来说, 其实是同步的;</li></ul><p>阻塞: 阻塞体现在, 在等待一件事情的处理结果时, 你是否还去干点其他的事情, 如果不去, 则为 阻塞;</p><p>非阻塞: 非阻塞体现在, 在等待一件事情的处理结果时, 你是否还去干点其他的事情, 如果去了, 则为 非阻塞;</p><h3 id="结合例子来说"><a href="#结合例子来说" class="headerlink" title="结合例子来说"></a>结合例子来说</h3><p>此处找了一位朋友写的例子, 感觉很不错<br>同步阻塞: 你去 甜在心馒头 店买太极馒头, 阿梅说:”暂时没, 正在蒸呢, <strong>你自己看着点儿</strong>!”, 于是你就站在旁边只等馒头, 此时的你, 是阻塞的, 也是同步的;</p><ul><li>阻塞表现在你除了等馒头，别的什么都不做了;</li><li>同步表现在等馒头的过程中, 阿梅不提供通知服务, 你不得不自己主动检查 ＂馒头出炉＂ 的消息;</li></ul><p>同步非阻塞: 你去甜在心馒头店买太极馒头, 阿梅说:＂暂时没, 正在蒸呢, <strong>你自己看着点儿</strong>!＂, 于是你就站在旁边发发微信, 然后问一句:＂好了没？＂, 然后玩玩QQ游戏, 然后再问一句:＂好了没？＂, 此时的你, 是非阻塞的, 不过却还是同步的;</p><ul><li>非阻塞表现在你除了等馒头, 自己还在干别的事情;</li><li>同步表现在等馒头的过程中, 由于阿梅不提供通知服务, 你不得不自己主动检查 ＂馒头出炉＂ 的消息;</li></ul><p>异步阻塞: 你去甜在心馒头店买太极馒头, 阿梅说:＂暂时没, 正在蒸呢, 蒸好了<strong>我打电话告诉你</strong>!＂, 但你依然站在旁边只等馒头, 此时的你, 是阻塞的, 是异步的;</p><ul><li>阻塞表现在你除了等馒头, 也没去干点别的什么(比如玩玩手机啥的);</li><li>异步表现在等馒头的过程中, 阿梅提供电话通知＂馒头出炉＂的消息, 你只需要等阿梅的电话;</li></ul><p>异步非阻塞: 你去甜在心馒头店买太极馒头, 阿梅说:＂暂时没, 正在蒸呢, 蒸好了<strong>我打电话告诉你</strong>!＂, 于是你就走了, 去买了双新球鞋, 看了看武馆, 总之, 从此不再过问馒头的事情, 一心只等阿梅电话, 此时的你, 是非阻塞的, 是异步的</p><ul><li>非阻塞表现在你除了等馒头, 自己还去干点别的事情;</li><li>异步表现在等馒头的过程中, 阿梅提供电话通知＂馒头出炉＂的消息, 你只需要等阿梅的电话;</li></ul><p><a href="https://www.jianshu.com/p/5d00d25ef18a?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IO&quot;&gt;&lt;a href=&quot;#IO&quot; class=&quot;headerlink&quot; title=&quot;IO&quot;&gt;&lt;/a&gt;IO&lt;/h2&gt;&lt;p&gt;在开始socket编程前, 需要先对 &lt;code&gt;IO&lt;/code&gt; 的概念有一定的认识: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们通常使用php的
      
    
    </summary>
    
      <category term="Socket" scheme="http://blog.renyimin.com/categories/Socket/"/>
    
    
      <category term="Socket" scheme="http://blog.renyimin.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Linux软件安装</title>
    <link href="http://blog.renyimin.com/2018/05/13/linux/2018-05-13-install/"/>
    <id>http://blog.renyimin.com/2018/05/13/linux/2018-05-13-install/</id>
    <published>2018-05-13T03:02:35.000Z</published>
    <updated>2018-05-17T06:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;yum&quot;&gt;&lt;a href=&quot;#yum&quot; class=&quot;headerlink&quot; title=&quot;yum&quot;&gt;&lt;/a&gt;yum&lt;/h2&gt;&lt;h2 id=&quot;rpm&quot;&gt;&lt;a href=&quot;#rpm&quot; class=&quot;headerlink&quot; title=&quot;rpm&quot;&gt;&lt;/a&gt;rpm&lt;/h
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统监控</title>
    <link href="http://blog.renyimin.com/2018/05/10/linux/2018-05-10-system-monitor/"/>
    <id>http://blog.renyimin.com/2018/05/10/linux/2018-05-10-system-monitor/</id>
    <published>2018-05-10T05:20:29.000Z</published>
    <updated>2018-05-17T06:27:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000005621984" target="_blank" rel="external">https://segmentfault.com/a/1190000005621984</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000005621984&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://segmentfault.com/a/1190000005621984&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.renyimin.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.renyimin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>PHP-X</title>
    <link href="http://blog.renyimin.com/2018/05/09/PHP/2018-05-09-PHP-X/"/>
    <id>http://blog.renyimin.com/2018/05/09/PHP/2018-05-09-PHP-X/</id>
    <published>2018-05-09T12:29:31.000Z</published>
    <updated>2018-05-09T12:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.swoole.com/wiki/index/prid-15" target="_blank" rel="external">https://wiki.swoole.com/wiki/index/prid-15</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://wiki.swoole.com/wiki/index/prid-15&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://wiki.swoole.com/wiki/index/prid-15&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="PHP" scheme="http://blog.renyimin.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.renyimin.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>01.</title>
    <link href="http://blog.renyimin.com/2018/04/28/oauth/2018-04-28-CAS/"/>
    <id>http://blog.renyimin.com/2018/04/28/oauth/2018-04-28-CAS/</id>
    <published>2018-04-28T13:10:12.000Z</published>
    <updated>2018-05-02T08:07:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Single-Sign-On"><a href="#Single-Sign-On" class="headerlink" title="Single Sign On"></a>Single Sign On</h2><p>单点登录(Single Sign On), 简称为<code>SSO</code>, 是目前比较流行的企业业务整合的解决方案之一;<br>SSO的定义是在多个应用系统中, 用户只需要登录一次就可以访问所有相互信任的应用系统;</p><h2 id="CAS简介"><a href="#CAS简介" class="headerlink" title="CAS简介"></a><a href="https://www.apereo.org/" target="_blank" rel="external">CAS</a>简介</h2><ol><li><a href="https://www.apereo.org/projects/cas" target="_blank" rel="external">CAS</a>由Yale耶鲁大学研发的一款开源的,企业级,SSO单点登录解决方案;</li><li><a href="https://github.com/apereo/cas" target="_blank" rel="external">CAS Github 源码下载</a>, 这里使用的是CAS5.1.9</li><li><a href="https://apereo.github.io/cas/5.1.x/" target="_blank" rel="external">CAS 文档</a><h3 id="CAS系统组件"><a href="#CAS系统组件" class="headerlink" title="CAS系统组件"></a>CAS系统组件</h3>CAS系统架构由 <code>CAS Server</code> 和 <code>CAS Client</code> 两个物理组件构成, 它们通过各种协议进行通信;<h3 id="CAS-Server"><a href="#CAS-Server" class="headerlink" title="CAS Server"></a>CAS Server</h3></li><li>CAS服务器是基于Spring框架构建的Java servlet, 其主要职责是验证用户, 并通过发布和验证票证来对 启用CAS的服务(通常称为CAS客户端)的访问权限 进行授权;<br>服务器在成功登录后, 会向用户授予 <code>票证(TGT)</code>时创建SSO会话;<br>根据用户的请求, 通过使用TGT作为标记的浏览器重定向向服务发出服务票据(ST);<br>ST随后通过反向信道通信在CAS服务器上进行验证。 CAS Protocol文档中详细描述了这些交互;</li></ol><h3 id="CAS-Client"><a href="#CAS-Client" class="headerlink" title="CAS Client"></a>CAS Client</h3><h2 id="CAS-Server搭建"><a href="#CAS-Server搭建" class="headerlink" title="CAS Server搭建"></a>CAS Server搭建</h2><ol><li><code>CAS</code> 可以分为两部分 <code>CAS Server</code> 和 <code>CAS Client</code></li></ol><ul><li><code>CAS Server</code> 用来负责用户的认证工作, 就像是把第一次登录用户的一个标识存在这里, 以便此用户在其他系统登录时验证其需不需要再次登录;</li><li><code>CAS Client</code> 就是我们自己的应用, 需要接入<code>CAS Server</code>端; 当用户访问我们的应用时, 首先需要重定向到CAS Server端进行验证, 要是原来登陆过, 就免去登录, 重定向到下游系统, 否则进行用户名密码登陆操作;</li></ul><ol><li>术语<br>Ticket Granting ticket (TGT): 可以认为是CAS Server根据用户账号和密码生成的一张票, 存在CAS Server端;<br>Ticket-granting cookie (TGC): 其实就是一个cookie, 存放用户身份信息, 由CAS Server发给CAS Client端;<br>Service ticket (ST): 由TGT生成的一次性票据, 用于验证, 只能用一次。相当于server发给client一张票, 然后client拿着这是个票再来找server验证, 看看是不是server签发的;<br>就像是我给了你一张我的照片, 然后你拿照片再来问我, 这个照片是不是你, 没错，就是这么无聊</li></ol><h3 id="TGT-Ticket-Grangting-Ticket"><a href="#TGT-Ticket-Grangting-Ticket" class="headerlink" title="TGT(Ticket Grangting Ticket)"></a>TGT(Ticket Grangting Ticket)</h3><ol><li><code>TGT</code>是<code>CAS</code>为用户签发的登录票据, 拥有了TGT, 用户就可以证明自己在CAS成功登录过;<ul><li>TGT封装了Cookie值以及此Cookie值对应的用户信息;</li><li>用户在CAS认证成功后, CAS生成cookie, 写入浏览器, 同时生成一个TGT对象, 放入自己的缓存;</li><li>TGT对象的ID就是cookie的值</li><li>当HTTP再次请求到来时, 如果传过来的有CAS生成的cookie, 则CAS以此cookie值为key查询缓存中有无TGT, 如果有的话, 则说明用户之前登录过, 如果没有, 则用户需要重新登录;</li></ul></li></ol><p>ST（Service Ticket）<br>ST是CAS为用户签发的访问某一service的票据。用户访问service时，service发现用户没有ST，则要求用户去CAS获取ST。用户向CAS发出获取ST的请求，如果用户的请求中包含cookie，则CAS会以此cookie值为key查询缓存中有无TGT，如果存在TGT，则用此TGT签发一个ST，返回给用户。<br>用户凭借ST去访问service，service拿ST去CAS验证，验证通过后，允许用户访问资源。</p><p>PGT（Proxy Granting Ticket）<br>Proxy Service的代理凭据。用户通过CAS成功登录某一Proxy Service后，CAS生成一个PGT对象，缓存在CAS本地，同时将PGT的值（一个UUID字符串）回传给Proxy Service，并保存在Proxy Service里。Proxy Service拿到PGT后，就可以为Target Service（back-end service）做代理，为其申请PT。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Single-Sign-On&quot;&gt;&lt;a href=&quot;#Single-Sign-On&quot; class=&quot;headerlink&quot; title=&quot;Single Sign On&quot;&gt;&lt;/a&gt;Single Sign On&lt;/h2&gt;&lt;p&gt;单点登录(Single Sign On), 
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>03. 一些注意点</title>
    <link href="http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-03/"/>
    <id>http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-03/</id>
    <published>2018-04-21T07:50:21.000Z</published>
    <updated>2018-04-21T11:21:42.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>类常量</p><ul><li>类常量是公共的</li><li>只能通过<code>类名</code>, 使用 <code>::</code> 静态访问类常量 (也可以使用实例化的对象通过<code>::</code>来访问类常量)</li><li>客户端代码不能对其进行改变</li><li>常量属性使用 <code>const</code> 关键字来声明, 不需要使用 <code>$</code> 符号</li><li>常量属性的值只能包含<strong>基本数据类型</strong>的值, 不能将一个对象指派给常量</li><li>当需要在类的所有实例中都能访问某个属性, 并且属性值无需改变时, 应该使用常量</li></ul></li><li><p>抽象类</p><ul><li>不能实例化抽象类</li><li>抽象类中应该至少包含一个抽象方法 (但也不是强制性的)</li><li>抽象方法使用<code>abstract</code>关键字声明, 不能有具体的内容</li><li>抽象方法不能有消息体<code>{}</code>, 并且需要以<code>;</code>结束</li><li>继承抽象方法的子类必须实现抽象类中的所有抽象方法</li><li>继承抽象方法的子类实现了抽象类中的所有抽象方法之后, 还应该注意: 新实现的这个方法的访问控制权限不能比抽象方法更严格;</li></ul></li><li><p>接口</p><ul><li>接口相对于抽象类, 可能更是彻底的, 一个纯粹的模板;    </li><li>接口只能定义功能, 而不包含实现的内容;</li><li>任何实现了接口的类都需要实现接口中所定义的所有方法, 否则该类必须声明为<code>abstract</code>;</li><li>接口中的所有方法都必须声明为 <code>public</code>(或者不声明权限, 默认就为public)</li><li>接口中的所有方法不能有消息体<code>{}</code>, 并且需要以<code>;</code>结束</li><li>一个类可以同时<strong>继承一个父类</strong>和<strong>实现任意个接口</strong>, <code>extends</code>子句应该在<code>inplements</code> 子句之前;</li><li>一个比较重要的概念是: <strong>实现接口的类接受了它继承的类以及实现的接口的类型</strong>; (对于面向对象来说, 依赖抽象而不依赖具体)</li></ul></li><li><p>final关键字</p></li><li><p>~~未完待续</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;类常量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类常量是公共的&lt;/li&gt;
&lt;li&gt;只能通过&lt;code&gt;类名&lt;/code&gt;, 使用 &lt;code&gt;::&lt;/code&gt; 静态访问类常量 (也可以使用实例化的对象通过&lt;code&gt;::&lt;/code&gt;来访问类常量)&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>02. 延迟静态绑定static关键字</title>
    <link href="http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-02/"/>
    <id>http://blog.renyimin.com/2018/04/21/OOP/PHP/2018-04-21-OOP-PHP-02/</id>
    <published>2018-04-21T07:03:35.000Z</published>
    <updated>2018-05-19T16:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>延迟静态绑定是在PHP5.3引入的;</p></li><li><p><code>static</code> 类似于 <code>self</code>, 但它指的是调用 包含<code>static</code>的方法 的调用类, 而不是包含<code>static</code>的类;</p></li><li><p>一般 <code>static</code> 和 <code>self</code> 的使用语法有下面两种</p><ul><li><p><code>new static()</code> 与 <code>new self()</code> (用作实例化)</p></li><li><p><code>self::</code> 与 <code>static::</code> (静态方法调用)</p></li></ul></li><li><p>如何理解第2点中的意思</p><ul><li><p>如下, <code>Male</code>与<code>Female</code> 两个类分别继承自 <code>Human</code>, 并且继承了<code>createSelf()</code>方法, 结果却发现, <code>Male</code> 和 <code>Female</code> 调用<code>createSelf()</code>后, 创建的却是 <code>Human</code> 对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Human</div><div class="line">&#123;</div><div class="line">    public function createSelf()</div><div class="line">    &#123;</div><div class="line">        return new self();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Human</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Human</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">var_dump($boy-&gt;createSelf());</div><div class="line">$girl = new Female();</div><div class="line">var_dump($girl-&gt;createSelf());</div></pre></td></tr></table></figure></li><li><p>如果<code>Human</code>是个抽象类, 你甚至无法使用 <code>new self()</code><br><img src="/img/oop/php/static-self.png" width="350/"></p></li></ul></li><li><p>而使用了<code>new static()</code>效果就不一样了</p><ul><li>下面, <code>Male</code>与<code>Female</code> 两个类分别继承自 <code>Human</code>, 并且继承了<code>createSelf()</code>方法, 结果 <code>Male</code> 和 <code>Female</code> 调用<code>createSelf()</code>后, 创建的也都是各自的对象实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">abstract class Huma</div><div class="line">&#123;</div><div class="line">    public function createSelf()</div><div class="line">    &#123;</div><div class="line">        return new static();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Huma</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Huma</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">var_dump($boy-&gt;createSelf());</div><div class="line">$girl = new Female();</div><div class="line">var_dump($girl-&gt;createSelf());</div></pre></td></tr></table></figure></li></ul></li><li><p><code>static</code> 和 <code>self</code> 在调用静态方法时也是一样的</p><ul><li><p>如下结果, 两个类都是 <code>Hello!</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">abstract class Huma</div><div class="line">&#123;</div><div class="line">    public static function createSelf()</div><div class="line">    &#123;</div><div class="line">        self::say();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;Hello!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Male&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Female&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">$boy-&gt;createSelf();</div><div class="line">$girl = new Female();</div><div class="line">$girl-&gt;createSelf();</div></pre></td></tr></table></figure></li><li><p>如果想在父类的<code>公共静态方法</code>中, 调用子类自己重载的<code>静态方法</code>, 那就需要使用 <code>static::</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">abstract class Huma</div><div class="line">&#123;</div><div class="line">    public static function createSelf()</div><div class="line">    &#123;</div><div class="line">        static::say();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;Hello!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Male extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Male&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Female extends Huma</div><div class="line">&#123;</div><div class="line">    public static function say()</div><div class="line">    &#123;</div><div class="line">        echo &quot;I am a Female&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">$boy = new Male();</div><div class="line">$boy-&gt;createSelf(); // I am a Male</div><div class="line">$girl = new Female();</div><div class="line">$girl-&gt;createSelf();   // I am a Female</div></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;延迟静态绑定是在PHP5.3引入的;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;static&lt;/code&gt; 类似于 &lt;code&gt;self&lt;/code&gt;, 但它指的是调用 包含&lt;code&gt;static&lt;/code&gt;的方法 的调用类, 而不是包含&lt;code
      
    
    </summary>
    
      <category term="OOP" scheme="http://blog.renyimin.com/categories/OOP/"/>
    
    
      <category term="OOP" scheme="http://blog.renyimin.com/tags/OOP/"/>
    
  </entry>
  
</feed>
