<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2018-03-28T02:10:14.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>103. 分区管理</title>
    <link href="http://blog.renyimin.com/2018/03/28/mysql/2018-03-28-mysql-103/"/>
    <id>http://blog.renyimin.com/2018/03/28/mysql/2018-03-28-mysql-103/</id>
    <published>2018-03-28T02:41:26.000Z</published>
    <updated>2018-03-28T02:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h2><p>MySQL5.1 提供了许多修改分区表的方式, 添加、删除、重新定义、合并或拆分已经存在的分区是可能的, 所有这些操作都可以通过使用<code>ALTER TABLE</code>命令的分区扩展来实现; 当然, 也有获得分区表和分区信息的方式;</p><h3 id="drop删除分区及数据"><a href="#drop删除分区及数据" class="headerlink" title="drop删除分区及数据"></a>drop删除分区及数据</h3><ol><li><p><code>mysql&gt; alter table user drop partition p4;</code></p></li><li><p><strong>注意</strong>: </p><ul><li><p>只能对每个分区进行删除, 不能针对每个子分区进行删除操作, 删除分区后子分区连同数据一并被删除;</p></li><li><p>删除分区后, 数据也被删除了;</p></li><li><p><strong><code>drop partition</code>删除分区的语法, 只能用于 <code>range/list</code> 分区</strong> (如果用来删除hash分区或者key分区,则会报错)</p></li><li><p>如果要删除 <code>hash/key</code> 分区, 则直接使用下面remove来移除分区即可, 一般也不直接删除数据;</p></li></ul></li></ol><h3 id="remove移除分区"><a href="#remove移除分区" class="headerlink" title="remove移除分区"></a>remove移除分区</h3><ol><li><p>使用remove移除分区, 注意仅仅是移除分区, <strong>并不会删除数据</strong> (和drop PARTITION不一样, 后者会连同数据一起删除)</p></li><li><p><code>ALTER TABLE tablename REMOVE PARTITIONING;</code> 这样就可以将一个原本分区的数据表变成不分区的表</p><ul><li><p>移除分区前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">0B    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p><code>ALTER TABLE</code>user<code>REMOVE PARTITIONING;</code> 移除分区后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user.MYD</div><div class="line">4.0K    user.MYI</div><div class="line">12K    user.frm</div></pre></td></tr></table></figure></li></ul></li><li><p>注意: 该语法是可以适用于 <code>range/list/key/hash</code> 类型的分区的;</p></li></ol><h3 id="创建不同类型分区"><a href="#创建不同类型分区" class="headerlink" title="创建不同类型分区"></a>创建不同类型分区</h3><h3 id="分区创建索引-整表创建索引"><a href="#分区创建索引-整表创建索引" class="headerlink" title="分区创建索引(整表创建索引)"></a>分区创建索引(整表创建索引)</h3><h3 id="新增分区"><a href="#新增分区" class="headerlink" title="新增分区"></a>新增分区</h3><h3 id="新增不同类型分区"><a href="#新增不同类型分区" class="headerlink" title="新增不同类型分区"></a>新增不同类型分区</h3><h3 id="合并分区"><a href="#合并分区" class="headerlink" title="合并分区"></a>合并分区</h3><ol><li><p>原本分区结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">4.0K    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p>合并 p2, p3这两个分区 </p><ul><li>分区并无子分区<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE tb_sub_ev REORGANIZE PARTITION p2,p3 INTO (</div><div class="line">    PARTITION m_p2_p3 VALUES LESS THAN (2000)</div><div class="line">    ( SUBPARTITION n0,</div><div class="line">        SUBPARTITION n1</div><div class="line">    ) </div><div class="line">);</div></pre></td></tr></table></figure></li></ul></li></ol><h3 id="拆分分区"><a href="#拆分分区" class="headerlink" title="拆分分区"></a>拆分分区</h3><h3 id="重新分区"><a href="#重新分区" class="headerlink" title="重新分区"></a>重新分区</h3><h2 id="每日自动新增分区"><a href="#每日自动新增分区" class="headerlink" title="每日自动新增分区"></a>每日自动新增分区</h2><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分区管理&quot;&gt;&lt;a href=&quot;#分区管理&quot; class=&quot;headerlink&quot; title=&quot;分区管理&quot;&gt;&lt;/a&gt;分区管理&lt;/h2&gt;&lt;p&gt;MySQL5.1 提供了许多修改分区表的方式, 添加、删除、重新定义、合并或拆分已经存在的分区是可能的, 所有这些操作都可以
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>102. 分区键, 主键, 唯一索引关系</title>
    <link href="http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-102/"/>
    <id>http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-102/</id>
    <published>2018-03-27T07:46:51.000Z</published>
    <updated>2018-03-28T02:09:40.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>若表有 <code>primary key</code> 或 <code>unique key</code>, 在对表进行分区时, 需要注意: <code>分区键</code> 必须包含在primary key或unique key列内, 这是为了确保主键的效率, 否则同一主键区的数据一个在Ａ分区, 一个在Ｂ分区, 显然会比较麻烦;<br> 可以说: 在分区表上, 用于分区表达式里的每一个字段都必须是<code>唯一性索引</code>的<code>一部分</code>;</p></li><li><p>如何理解上面的概念?</p></li><li><p>如果表中既有<code>主键</code>, 也有<code>唯一索引</code>: 无论<code>单列键</code>还是<code>多列键</code>分区都会失败</p><ul><li><p>单列唯一索引键分区报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `user` (  </div><div class="line">    `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;,  </div><div class="line">    `name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">    `sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男，1为女&apos;,</div><div class="line">`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,</div><div class="line">    PRIMARY KEY (`id`),</div><div class="line">UNIQUE KEY `age_unique` (`age`)</div><div class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8</div><div class="line">PARTITION BY RANGE COLUMNS (`age`)</div><div class="line">(</div><div class="line">PARTITION p0 VALUES LESS THAN (3),  </div><div class="line">PARTITION p1 VALUES LESS THAN (6),</div><div class="line">PARTITION p2 VALUES LESS THAN (9),  </div><div class="line">PARTITION p3 VALUES LESS THAN (12),  </div><div class="line">PARTITION p4 VALUES LESS THAN (MAXVALUE)</div><div class="line">);</div><div class="line">// 1503 - A PRIMARY KEY must include all columns in the table&apos;s partitioning function, Time: 0.011000s</div></pre></td></tr></table></figure></li><li><p>单列主键分区报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>),</p><pre><code>UNIQUE KEY `age_unique` (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);<br>// 1503 - A UNIQUE INDEX must include all columns in the table’s partitioning function, Time: 0.008000s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 多列(主键和唯一索引键)分区报错</div></pre></td></tr></table></figure><p>// 两列做分区也是失败的, 如下会报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>),</p><pre><code>UNIQUE KEY `age_unique` (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>,<code>age</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3, 10),<br>  PARTITION p1 VALUES LESS THAN (6, 15),<br>  PARTITION p2 VALUES LESS THAN (9, 20),<br>  PARTITION p3 VALUES LESS THAN (12, 25),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);<br>// 1503 - A PRIMARY KEY must include all columns in the table’s partitioning function, Time: 0.012000s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">4. 表中只有`主键`: 分区键属于主键内的键即可 (多列分区, 需要将列与主键一起作为主键才行)</div><div class="line">    - 分区键属于主键内的键即可</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 如果想多列分区, 则需要将多余的列与主键一起作为主键</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  PRIMARY KEY (<code>id</code>, <code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>,<code>age</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3, 10),<br>  PARTITION p1 VALUES LESS THAN (6, 15),<br>  PARTITION p2 VALUES LESS THAN (9, 20),<br>  PARTITION p3 VALUES LESS THAN (12, 25),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">5. 表中只有`唯一索引`: 分区键属于`唯一索引键`内的键即可 (多列分区, 需要将多个列一起作为唯一索引)</div><div class="line">    - 分区键属于`唯一索引键`内的键即可</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  UNIQUE KEY (<code>id</code>, <code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 多列分区报错(竟然是报主键错): 1503 - A PRIMARY KEY must include all columns in the table&apos;s partitioning function, Time: 0.012000s</div></pre></td></tr></table></figure><p>CREATE TABLE IF NOT EXISTS <code>user</code> (<br><code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br><code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br><code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,<br>  <code>age</code> int(2) NOT NULL DEFAULT ‘0’ COMMENT ‘年龄’,<br>UNIQUE KEY id_u (<code>id</code>),<br>  UNIQUE KEY age_u (<code>age</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>, <code>age</code>)<br>(<br>PARTITION p0 VALUES LESS THAN (3,10),<br>PARTITION p1 VALUES LESS THAN (6,15),<br>PARTITION p2 VALUES LESS THAN (9,20),<br>PARTITION p3 VALUES LESS THAN (12,25),<br>PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)<br>);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- **多个唯一索引: 无论单列分区还是多列分区, 都会报错**</div></pre></td></tr></table></figure><p>// 单列分区报错<br>CREATE TABLE IF NOT EXISTS <code>user</code> (<br>  <code>id</code> int(11) NOT NULL COMMENT ‘用户ID’,<br>  <code>name</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘名称’,<br>  <code>sex</code> int(1) NOT NULL DEFAULT ‘0’ COMMENT ‘0为男，1为女’,</p><pre><code>`age` int(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;年龄&apos;,    </code></pre><p>  UNIQUE KEY id_u (<code>id</code>),</p><pre><code>UNIQUE KEY age_u (`age`)</code></pre><p>) ENGINE=MyISAM DEFAULT CHARSET=utf8<br>PARTITION BY RANGE COLUMNS (<code>id</code>)<br>(<br>  PARTITION p0 VALUES LESS THAN (3),<br>  PARTITION p1 VALUES LESS THAN (6),<br>  PARTITION p2 VALUES LESS THAN (9),<br>  PARTITION p3 VALUES LESS THAN (12),<br>  PARTITION p4 VALUES LESS THAN (MAXVALUE)<br>);<br>```</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li></ul></li></ol><ul><li>要进行分区, 表中不能同时存在<code>主键</code>和<code>唯一索引键</code>, 也不能存在多个唯一索引键;</li><li>分区的键必须包含在<code>主键</code>内 或者 包含在<code>唯一索引键</code>内;</li><li>本篇只是测试了<code>range</code>这种分区类型, 其实上面的限制对于<code>range/list/hash/key</code>类型的分区都适用;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;若表有 &lt;code&gt;primary key&lt;/code&gt; 或 &lt;code&gt;unique key&lt;/code&gt;, 在对表进行分区时, 需要注意: &lt;code&gt;分区键&lt;/code&gt; 必须包含在primary key或unique key列内, 这是为了确保主键
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>101. 分区,分表,分库</title>
    <link href="http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-101/"/>
    <id>http://blog.renyimin.com/2018/03/27/mysql/2018-03-27-mysql-101/</id>
    <published>2018-03-27T03:37:12.000Z</published>
    <updated>2018-03-28T02:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>MySQL是从5.1开始支持分区功能的, 在MySQL中, 数据是以文件的形势存在磁盘上的, 默认放在 ‘/mysql/data/‘ 下(可以通过my.cnf中的datadir来指定)</p></li><li><p>MyISAM引擎中, 一张表主要对应着三个文件: </p><ul><li><code>.frm</code>(与表相关的元数据信息都存放在frm文件, 包括表结构的定义信息等)</li><li><code>.myd</code>(存放表数据)</li><li><code>.myi</code>(存表索引)</li></ul></li><li><p>InnoDB引擎中, 一张表也是对应着三个文件: </p><ul><li><code>.frm</code>(和MyISAM差不多)</li><li><code>.ibd</code>文件和<code>.ibdata</code>文件, 都是存放innodb数据的文件, 之所以用两种文件来存放innodb的数据, 是因为innodb的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据, 还是用独享表空间存放存储数据<br>独享表空间存储方式使用.ibd文件,并且每个表一个ibd文件;<br>共享表空间存储方式使用.ibdata文件，所有表共同使用一个ibdata文件<br>可在mysql的配置文件通过<code>innodb_file_per_table</code>进行配置</li></ul></li><li><p>如果一张表的数据量太大, <code>.ibd</code>, <code>.myd</code>, <code>.myi</code> 之类的文件就会变的很大, 查找数据就会变的很慢, 此时就可以利用mysql的分区功能, 在物理上将这一张表对应的三个文件, 分割成许多个小块, 这样之后, 如果查找一条数据时, 就不用全部查找了, 只要知道这条数据在哪一块, 然后在那一块找即可;<br> 如果表的数据太大, 可能一个磁盘放不下, 此时, 还可以把数据分配到不同的磁盘里面去;</p></li></ol><h2 id="查看当前MySQL版本是否支持分区"><a href="#查看当前MySQL版本是否支持分区" class="headerlink" title="查看当前MySQL版本是否支持分区"></a>查看当前MySQL版本是否支持分区</h2><ol><li><p>对于MySQL5.6以下版本, 如果查询结果显示Empty, 表示不支持分区:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show variables like &apos;%partition%&apos;;</div><div class="line">Empty set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>对于mysql5.6以及以上版本, 需要使用下面的查询命令:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show plugins;</div></pre></td></tr></table></figure><p> 上面的查询方法会显示所有插件, 如果有如下插件的话, 表示支持分区:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| partition                  | ACTIVE   | STORAGE ENGINE     | NULL    | GPL     |</div></pre></td></tr></table></figure></li></ol><h2 id="分区的2种方式"><a href="#分区的2种方式" class="headerlink" title="分区的2种方式"></a>分区的2种方式</h2><h3 id="横向分区"><a href="#横向分区" class="headerlink" title="横向分区"></a>横向分区</h3><p>横向分区: 比如, 有1000W条数据, 分成十份, 前10W条数据放到第一个分区, 第二个10W条数据放到第二个分区, 依此类推; </p><ul><li>也就是把表分成了十份(和使用<code>merge</code>来分表有点像, 取出一条数据的时候, 这条数据包含了表结构中的所有字段);</li><li>横向分区, 并没有改变表的结构;</li></ul><h3 id="纵向分区"><a href="#纵向分区" class="headerlink" title="纵向分区"></a>纵向分区</h3><p>纵向分区: 比如, 在设计用户表的时候, 开始的时候没有考虑好, 把用户的所有信息都放到了一张表里面去, 这样这个表里面就会有比较大的字段, 如个人简介..等, 而这些简介也许不会有好多人去看，所以等到有人要看的时候, 再去查找(分表的时候, 可以把这样的大字段与主表分开来);</p><h2 id="横向分区-1"><a href="#横向分区-1" class="headerlink" title="横向分区"></a>横向分区</h2><p>mysql提供的分区属于第一种 <code>横向分区</code>, 并且细分成很多种方式</p><h3 id="range分区"><a href="#range分区" class="headerlink" title="range分区"></a>range分区</h3><ol><li><p>按照<code>RANGE</code>分区的表是通过如下方式进行分区的, 分区表达式的值位于一个给定的连续区间内的那些行, 会被放到一个分区中</p><ul><li><p>创建表同时进行分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `user` (  </div><div class="line">`id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;,  </div><div class="line">`name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">`sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男，1为女&apos;,  </div><div class="line">PRIMARY KEY (`id`)  </div><div class="line">) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1  </div><div class="line">PARTITION BY RANGE (id) (  </div><div class="line">PARTITION p0 VALUES LESS THAN (3),  </div><div class="line">PARTITION p1 VALUES LESS THAN ( 6 ),</div><div class="line">PARTITION p2 VALUES LESS THAN (9),  </div><div class="line">PARTITION p3 VALUES LESS THAN (12),  </div><div class="line">PARTITION p4 VALUES LESS THAN MAXVALUE  </div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>查看分区效果 (到数据表文件的存放处 <code>$ cd /Library/Application\ Support/appsolute/MAMP\ PRO/db/mysql56/</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">0B    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">0B    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">0B    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">0B    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">0B    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li><li><p>插入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">INSERT INTO `test`.`user` (`name` ,`sex`)VALUES (&apos;tank&apos;, &apos;0&apos;)  </div><div class="line">,(&apos;zhang&apos;,1),(&apos;ying&apos;,1),(&apos;张&apos;,1),(&apos;映&apos;,0),(&apos;test1&apos;,1),(&apos;tank2&apos;,1)  </div><div class="line">,(&apos;tank1&apos;,1),(&apos;test2&apos;,1),(&apos;test3&apos;,1),(&apos;test4&apos;,1),(&apos;test5&apos;,1),(&apos;tank3&apos;,1)  </div><div class="line">,(&apos;tank4&apos;,1),(&apos;tank5&apos;,1),(&apos;tank6&apos;,1),(&apos;tank7&apos;,1),(&apos;tank8&apos;,1),(&apos;tank9&apos;,1)  </div><div class="line">,(&apos;tank10&apos;,1),(&apos;tank11&apos;,1),(&apos;tank12&apos;,1),(&apos;tank13&apos;,1),(&apos;tank21&apos;,1),(&apos;tank42&apos;,1);</div></pre></td></tr></table></figure></li><li><p>再次查看分区效果<br>如下可以看到, 文件大小都是4.0K, 从这儿我们可以看出<strong>MyISAM引擎下, 分区的最小区块是4K (InnoDB貌似是96k)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">4.0K    user#P#p4.MYD</div><div class="line">4.0K    user#P#p4.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li></ul></li><li><p>数据测试</p><ul><li><p>初始数据为25条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select count(id) as count from user;</div><div class="line">+-------+</div><div class="line">| count |</div><div class="line">+-------+</div><div class="line">|    25 |</div><div class="line">+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>删除第四个分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; alter table user drop partition p4; </div><div class="line">Query OK, 0 rows affected (0.15 sec)</div><div class="line">Records: 0  Duplicates: 0  Warnings: 0</div></pre></td></tr></table></figure></li><li><p>可以发现, 存放在第四个分区里面的14条数据丢失了, 剩下的3个分区只有11条数据  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select count(id) as count from user; </div><div class="line">+-------+</div><div class="line">| count |</div><div class="line">+-------+</div><div class="line">|    11 |</div><div class="line">+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>查看分区文件, 发现第四个分区确实被删除了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ ls |grep user |xargs du -sh</div><div class="line">4.0K    user#P#p0.MYD</div><div class="line">4.0K    user#P#p0.MYI</div><div class="line">4.0K    user#P#p1.MYD</div><div class="line">4.0K    user#P#p1.MYI</div><div class="line">4.0K    user#P#p2.MYD</div><div class="line">4.0K    user#P#p2.MYI</div><div class="line">4.0K    user#P#p3.MYD</div><div class="line">4.0K    user#P#p3.MYI</div><div class="line">12K    user.frm</div><div class="line">4.0K    user.par</div></pre></td></tr></table></figure></li></ul></li><li><p>小结: 可以发现, 在进行range分区后</p><ul><li>会生成一个 <code>.par</code>文件,用来存储分区信息;</li><li>MyISAM/InnoDB引擎, 原有的 <code>.frm</code> 表结构文件没有被分隔;</li><li>MyISAM引擎, 原有的 <code>.MYD</code>数据文件, <code>.MYI</code>索引文件都被分隔了;</li><li>InnoDB引擎, 原有的 <code>.idb</code>数据文件被分隔了;</li></ul></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li></ul></li></ol><h3 id="List分区"><a href="#List分区" class="headerlink" title="List分区"></a>List分区</h3><ol><li><p>RANGE分区是从属于一个连续区间值的集合, 而LIST分区是基于某列的值从属于一个值列表集中的一个值</p></li><li><p>如果不用主键, 如下list分区可以创建成功，一般情况下, 一张表肯定会有一个主键(所以如果需要用其他键来做分区, 参考下一篇博文<a href="2017/12/17/mysql/2017-12-17-mysql-102/">分区键, 主键, 唯一索引关系</a>)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `list_part` (  </div><div class="line">`id` int(11) NOT NULL COMMENT &apos;用户ID&apos;,  </div><div class="line">`province_id` int(2) NOT NULL DEFAULT 0 COMMENT &apos;省&apos;,  </div><div class="line">`name` varchar(50) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名称&apos;,  </div><div class="line">`sex` int(1) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0为男, 1为女&apos;</div><div class="line">) ENGINE=INNODB DEFAULT CHARSET=utf8</div><div class="line">PARTITION BY LIST (province_id) (  </div><div class="line">PARTITION p0 VALUES IN (1,2,3,4,5,6,7,8),  </div><div class="line">PARTITION p1 VALUES IN (9,10,11,12,16,21),  </div><div class="line">PARTITION p2 VALUES IN (13,14,15,19),  </div><div class="line">PARTITION p3 VALUES IN (17,18,20,22,23,24)</div><div class="line">);</div><div class="line"></div><div class="line">// 创建成功, 会看到分区效果 (InnoDB默认分区最小是96k)</div><div class="line">$ ls |grep list_part |xargs du -sh</div><div class="line">96K    list_part#P#p0.ibd</div><div class="line">96K    list_part#P#p1.ibd</div><div class="line">96K    list_part#P#p2.ibd</div><div class="line">96K    list_part#P#p3.ibd</div><div class="line">12K    list_part.frm</div><div class="line">4.0K    list_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="hash分区"><a href="#hash分区" class="headerlink" title="hash分区"></a>hash分区</h3><ol><li><p>HASH分区主要用来确保数据在预先确定数目的分区中平均分布, 你所要做的只是</p><ul><li>对将要被哈希的列值, 指定一个列值或表达式;</li><li>指定被分区的表将要被分割成的分区数量;</li><li>对HASH分区，使用的用户函数必须返回一个大于0的整数值;</li></ul></li><li><p>创建表同时进行hash分区</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `hash_part` (  </div><div class="line">`id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;评论ID&apos;,  </div><div class="line">`comment` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;评论&apos;,  </div><div class="line">`ip` varchar(25) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;来源IP&apos;,  </div><div class="line">PRIMARY KEY (`id`)  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1  </div><div class="line">PARTITION BY HASH(id)  </div><div class="line">PARTITIONS 3;</div></pre></td></tr></table></figure></li><li><p>查看分区效果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ls |grep hash_part |xargs du -sh</div><div class="line">96K    hash_part#P#p0.ibd</div><div class="line">96K    hash_part#P#p1.ibd</div><div class="line">96K    hash_part#P#p2.ibd</div><div class="line">12K    hash_part.frm</div><div class="line">4.0K    hash_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="key分区"><a href="#key分区" class="headerlink" title="key分区"></a>key分区</h3><ol><li><p>按照KEY进行分区, 类似于按照HASH分区</p><ul><li>HASH分区是使用用户定义的表达式</li><li>而KEY分区的哈希函数是由MySQL服务器提供</li></ul></li><li><p>创建表同时进行key分区</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `key_part` (  </div><div class="line">`news_id` int(11) NOT NULL  COMMENT &apos;新闻ID&apos;,  </div><div class="line">`content` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;新闻内容&apos;,  </div><div class="line">`u_id` varchar(25) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;来源IP&apos;,  </div><div class="line">`create_time` DATE NOT NULL DEFAULT &apos;0000-00-00 00:00:00&apos; COMMENT &apos;时间&apos;  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8  </div><div class="line">PARTITION BY LINEAR HASH(YEAR(create_time))  </div><div class="line">PARTITIONS 3;</div></pre></td></tr></table></figure></li><li><p>查看分区效果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ls |grep key_part |xargs du -sh</div><div class="line">96Kkey_part#P#p0.ibd</div><div class="line">96Kkey_part#P#p1.ibd</div><div class="line">96Kkey_part#P#p2.ibd</div><div class="line">12Kkey_part.frm</div><div class="line">4.0Kkey_part.par</div></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>当往分区列中插入null值, RANG分区会将其当作最小值来处理即插入最小的分区中</li><li>list分区中, NULL值必须出现在分区枚举值中, 否在在插入数据是会报错</li><li>hash和key会将NULL当做0处理</li><li>RANGE分区必须的连续的且不能重叠(<code>3,6,9,12,MAXVALUE</code>可以, <code>3,6,5,12,MAXVALUE</code>就会报错)</li></ul></li></ol><h3 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h3><ol><li><p>子分区是分区表中每个分区的再次分割, 对于已经通过<code>RANGE</code>或<code>LIST</code>分区了的表再进行子分区是可能的, 子分区既可以使用<code>HASH</code>分区, 也可以使用<code>KEY</code>分区; 这也被称为复合分区(composite partitioning)</p><ul><li>如果一个分区中创建了子分区, 其他分区也要有子分区</li><li>如果创建了子分区, 每个分区中的<strong>子分区数必须相同</strong></li><li>同一分区内的子分区, 名字不相同, 不同分区内的子分区名子可以相同(5.1.50不适用)</li></ul></li><li><p>创建表同时, 进行子分区操作</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS `sub_part` (  </div><div class="line">`news_id` int(11) NOT NULL  COMMENT &apos;新闻ID&apos;,  </div><div class="line">`content` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;新闻内容&apos;,  </div><div class="line">`u_id`  int(11) NOT NULL DEFAULT 0 COMMENT &apos;来源IP&apos;,  </div><div class="line">`create_time` DATE NOT NULL DEFAULT &apos;0000-00-00 00:00:00&apos; COMMENT &apos;时间&apos;  </div><div class="line">) ENGINE=INNODB  DEFAULT CHARSET=utf8  </div><div class="line">PARTITION BY RANGE(YEAR(create_time))  </div><div class="line">SUBPARTITION BY HASH(TO_DAYS(create_time))(  </div><div class="line">    PARTITION p0 VALUES LESS THAN (1990)(</div><div class="line">        SUBPARTITION s0,SUBPARTITION s1,SUBPARTITION s2</div><div class="line">    ),  </div><div class="line">    PARTITION p1 VALUES LESS THAN (2000)(</div><div class="line">        SUBPARTITION s3,SUBPARTITION s4,SUBPARTITION good</div><div class="line">    ),  </div><div class="line">    PARTITION p2 VALUES LESS THAN MAXVALUE(</div><div class="line">        SUBPARTITION tank0,SUBPARTITION tank1,SUBPARTITION tank3</div><div class="line">    )  </div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>查看分区后, 数据表文件结构</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ ls |grep sub_part |xargs du -sh</div><div class="line">96K    sub_part#P#p0#SP#s0.ibd</div><div class="line">96K    sub_part#P#p0#SP#s1.ibd</div><div class="line">96K    sub_part#P#p0#SP#s2.ibd</div><div class="line">96K    sub_part#P#p1#SP#good.ibd</div><div class="line">96K    sub_part#P#p1#SP#s3.ibd</div><div class="line">96K    sub_part#P#p1#SP#s4.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank0.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank1.ibd</div><div class="line">96K    sub_part#P#p2#SP#tank3.ibd</div><div class="line">12K    sub_part.frm</div><div class="line">4.0K    sub_part.par</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;MySQL是从5.1开始支持分区功能的, 在MySQL中, 数据是以文件的形势存在磁盘上的, 默认放在 ‘/mysql/d
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>15.实战compose编排集成环境</title>
    <link href="http://blog.renyimin.com/2017/10/21/docker/2017-10-21-15-docker/"/>
    <id>http://blog.renyimin.com/2017/10/21/docker/2017-10-21-15-docker/</id>
    <published>2017-10-21T03:50:08.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker-Composer编排<code>nginx+phpfpm+mysql+redis+mongo</code>集成环境<br>Github仓库地址:<a href="https://github.com/rymuscle/docker-composer-lnmp" target="_blank" rel="external">https://github.com/rymuscle/docker-composer-lnmp</a></p><h2 id="定义项目目录结构"><a href="#定义项目目录结构" class="headerlink" title="定义项目目录结构"></a>定义项目目录结构</h2><ol><li><p>为了在项目启动后, 能方便地对各项服务服务进行配置, 观察日志, 持久化数据, 并且保证容器不过于臃肿; 我们在项目中的各服务在启动时, 我们就需要将诸如: 服务的<code>配置文件</code>, <code>日志文件</code>, 数据库服务的<code>数据文件目录</code>, Nginx服务的<code>项目目录</code>等从容器的存储层用挂载数据卷的方式持久化出来;</p></li><li><p>要对各服务进行数据挂载, 因此在使用Docker-Composer编排环境项目前, 要先定义好项目的目录结构, 本人目前的目录结构如下 (基本已做到见名知意):</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">├── docker-compose.yml</div><div class="line">├── mongo</div><div class="line">│   ├── Dockerfile</div><div class="line">│   └── data</div><div class="line">├── mysql</div><div class="line">│   ├── Dockerfile</div><div class="line">│   ├── conf</div><div class="line">│   ├── data</div><div class="line">│   ├── env_config.env</div><div class="line">│   └── log</div><div class="line">├── nginx</div><div class="line">│   ├── Dockerfile</div><div class="line">│   ├── conf</div><div class="line">│   └── log</div><div class="line">├── php</div><div class="line">│   ├── php56</div><div class="line">│   │   ├── Dockerfile</div><div class="line">│   │   ├── conf</div><div class="line">│   │   └── log</div><div class="line">│   └── php72</div><div class="line">│       ├── Dockerfile</div><div class="line">│       ├── conf</div><div class="line">│       └── log</div><div class="line">├── redis</div><div class="line">│   ├── Dockerfile</div><div class="line">│   ├── conf</div><div class="line">│   ├── data</div><div class="line">│   └── log</div><div class="line">└── site</div></pre></td></tr></table></figure></li><li><p>目录结构说明</p></li></ol><ul><li>每个服务下面都放置了一份属于容器自己的<code>Dockerfile</code>文件, 方便对容器进行单独定制 (比如php可能需要安装一些扩展, 就可以放在自己的Dockerfile中进行)</li><li>因为挂载会使用 本机文件/目录 覆盖 容器中的目录/文件, 所以<strong>各服务的配置文件需要提前准备好</strong>, 然后挂载到容器服务的对应目录下(可以直接对应文件,也可以对应目录),<ul><li>各容器的配置文件, 日志等的路径, 可以到<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>上参考具体容器的详情</li><li>拿到各容器的中的的配置文件路径后, 需要使用先启动容器, 然后使用 <code>docker cp</code> 将配置文件/目录拷贝到本地</li></ul></li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在挂载项目根目录<code>site</code>时需要注意, 由于nginx和php-fpm为各自独立的服务(分布式部署方式), 所以</p><ul><li>本机<code>site</code>目录挂载到nginx容器中的项目目录 和 本机<code>site</code>目录挂载到php-fpm容器中的项目目录应该一样, 比如都是 <code>./site:/www</code></li><li>在nginx配置时稍加注意, php-fpm才可以正确找到项目路径</li></ul><h2 id="准备各容器镜像"><a href="#准备各容器镜像" class="headerlink" title="准备各容器镜像"></a>准备各容器镜像</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">renyimindembp:php56 renyimin$ docker pull nginx:1.12.2</div><div class="line">renyimindembp:php56 renyimin$ docker pull mongo:3.2</div><div class="line">renyimindembp:php56 renyimin$ docker pull redis:3.2</div><div class="line">renyimindembp:php56 renyimin$ docker pull mysql:5.6</div><div class="line">renyimindembp:php56 renyimin$ docker pull php:5.6-fpm</div><div class="line">renyimindembp:php56 renyimin$ docker pull php:7.2-fpm</div><div class="line">renyimindembp:php56 renyimin$ docker images</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">mysql                                                 5.6                 0248eeb807c7        4 days ago          256MB</div><div class="line">nginx                                                 1.12.2              a810e4ccb26c        2 weeks ago         108MB</div><div class="line">php                                                   5.6-fpm             aaf299648ff3        2 weeks ago         367MB</div><div class="line">php                                                   7.2-fpm             60245f64ed12        2 weeks ago         367MB</div><div class="line">redis                                                 3.2                 3859b0a6622a        2 weeks ago         99.7MB</div><div class="line">mongo                                                 3.2                 56d7fa068c3d        2 weeks ago         300MB</div></pre></td></tr></table></figure></code></pre><h2 id="从容器中获取配置文件"><a href="#从容器中获取配置文件" class="headerlink" title="从容器中获取配置文件"></a>从容器中获取配置文件</h2><h3 id="启动上面所有容器"><a href="#启动上面所有容器" class="headerlink" title="启动上面所有容器"></a>启动上面所有容器</h3><p>容器的启动方式最好也参考一下<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>上相关资料 (比如mysql在启动时就需要<code>-e</code>设置环境变量来提供root用户密码)</p><ol><li><p>nginx 容器启动: <code>$ docker run -d --name nginx nginx:1.12.2</code></p></li><li><p>mysql 容器启动: <code>$ docker run --name mysql -e MYSQL_ROOT_PASSWORD=renyimin -d mysql:5.6</code></p></li><li><p>php:fpm5.6容器的启动: <code>docker run -d --name php-5.6-fpm php:5.6-fpm</code> 即可启动</p></li><li><p>php:fpm7.2容器的启动: <code>docker run -d --name php-7.2-fpm php:7.2-fpm</code> 即可启动</p></li><li><p>mongo容器的启动: <code>docker run -d --name mg mongo:3.2</code></p></li><li><p>redis容器的启动: <code>docker run -d --name redis redis:3.2</code></p></li><li><p>结果如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">renyimindembp:php56 renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                                NAMES</div><div class="line">145a629c84be        nginx:1.12.2        &quot;nginx -g &apos;daemon ...&quot;   3 seconds ago        Up 2 seconds        80/tcp                               nginx</div><div class="line">72390d1e2aa1        mysql:5.6           &quot;docker-entrypoint...&quot;   56 seconds ago       Up 56 seconds       3306/tcp                             mysql</div><div class="line">6b5019214fc1        mongo:3.2           &quot;docker-entrypoint...&quot;   About a minute ago   Up About a minute   27017/tcp                            mg</div><div class="line">7524ffe44739        redis:3.2           &quot;docker-entrypoint...&quot;   About a minute ago   Up About a minute   6379/tcp                             redis</div><div class="line">8716df7a08fb        php:7.2-fpm         &quot;docker-php-entryp...&quot;   About an hour ago    Up 27 minutes       9000/tcp                             php-7.2-fpm</div><div class="line">2d2d5bb12a68        php:5.6-fpm         &quot;docker-php-entryp...&quot;   About an hour ago    Up About an hour    9000/tcp                             php-5.6-fpm</div></pre></td></tr></table></figure></li></ol><h3 id="docker-cp-获取配置文件"><a href="#docker-cp-获取配置文件" class="headerlink" title="docker cp 获取配置文件"></a><code>docker cp</code> 获取配置文件</h3><p>各容器的配置文件, 日志等的路径, 可以到<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>上参考具体容器的详情<br>最后需要手动调整一下目录结构即可</p><ol><li><p>nginx</p><ul><li>拷贝nginx默认配置文件到设定的 nginx/conf 目录 :<br><code>docker cp 8d572e88f735:/etc/nginx/ /Users/renyimin/Desktop/docker-compose/nginx/conf/</code></li></ul></li><li><p>mysql</p><ul><li>拷贝mysql默认数据库文件到设定的 mysql/data 目录<br><code>docker cp 72390d1e2aa1:/var/lib/mysql /Users/renyimin/Desktop/docker-compose/mysql/data</code></li><li>拷贝mysql默认配置文件到设定的 mysql/conf 目录<br><code>docker cp 72390d1e2aa1:/etc/mysql/ /Users/renyimin/Desktop/docker-compose/mysql/conf/</code></li></ul></li><li><p>php56</p><ul><li>拷贝php56默认配置文件到设定的 php56/conf 目录<br><code>docker cp 2d2d5bb12a68:/usr/local/etc/php/ /Users/renyimin/Desktop/docker-compose/php/php56/conf/</code><br><code>docker cp 2d2d5bb12a68:/usr/local/etc/php-fpm.d/ /Users/renyimin/Desktop/docker-compose/php/php56/conf/</code></li></ul></li><li><p>php72</p><ul><li>拷贝php72默认配置文件到设定的 php72/conf 目录<br><code>docker cp 8716df7a08fb:/usr/local/etc/php/ /Users/renyimin/Desktop/docker-compose/php/php72/conf/</code><br><code>docker cp 8716df7a08fb:/usr/local/etc/php-fpm.d/ /Users/renyimin/Desktop/docker-compose/php/php72/conf/</code></li></ul></li><li><p>mongo</p><ul><li>拷贝mongo默认数据库文件到设定的 mongo/data 目录 (mongo容器的/data有configdb和db两个目录)<br><code>docker cp 6b5019214fc1:/data/ /Users/renyimin/Desktop/docker-compose/mongo/</code></li></ul></li><li><p>redis</p><ul><li>拷贝redis默认数据库文件到设定的 redis/data 目录<br><code>docker cp 7524ffe44739:/data /Users/renyimin/Desktop/docker-compose/redis/data</code></li><li>拷贝redis默认配置文件到设定的 redis/conf 目录<br><code>docker cp 7524ffe44739:/usr/local/etc/redis/ /Users/renyimin/Desktop/docker-compose/redis/conf/</code></li></ul></li></ol><h2 id="整理各个服务的Dockerfile"><a href="#整理各个服务的Dockerfile" class="headerlink" title="整理各个服务的Dockerfile"></a>整理各个服务的Dockerfile</h2><ol><li>首先, 每个服务的 <code>FROM</code> 和 <code>MAINTAINER</code> 需要写在Dockerfile的开头;</li><li>这里主要定制了php-fpm的 <code>Dockerfile</code>, 安装哪些扩展主要是参考<ul><li><a href="https://hub.docker.com/_/php/" target="_blank" rel="external">Docker Hub</a>上php容器的介绍</li><li><a href="https://github.com/twang2218/docker-lnmp" target="_blank" rel="external">https://github.com/twang2218/docker-lnmp</a></li><li><a href="https://www.awaimai.com/2120.html#53_docker-composeyml" target="_blank" rel="external">歪麦博客</a></li></ul></li><li>最后在Dockerfile中完成对扩展的安装 <ul><li>如何安装扩展可以参考<a href="https://hub.docker.com/_/php/" target="_blank" rel="external">Docker Hub</a> 和 <a href="https://my.oschina.net/antsky/blog/1591418" target="_blank" rel="external">这里</a></li><li><strong>注意如何清理?</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 貌似源码安装的软件需要如下进行清理:</div><div class="line">RUN docker-php-source extract \</div><div class="line">    # 此处开始执行你需要的操作 \</div><div class="line">    &amp;&amp; docker-php-source delete</div></pre></td></tr></table></figure></li></ul></li></ol><ol><li>如果稍后需要安装其他扩展, 在Dockerfile文件中定制即可, 然后 <code>docker-compose up -d --build php(docker-composer.yml中设定的服务名)</code> 重新构建即可 </li></ol><h2 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写docker-compose.yml</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line"></div><div class="line">services:</div><div class="line">  nginx:</div><div class="line">    build:</div><div class="line">      context: ./nginx/</div><div class="line">      dockerfile: Dockerfile</div><div class="line">      #args:</div><div class="line">    ports:</div><div class="line">      - &quot;8090:80&quot;</div><div class="line">    volumes:</div><div class="line">      - ./site/:/www:rw</div><div class="line">      - ./nginx/conf/conf.d:/etc/nginx/conf.d/:ro</div><div class="line">      - ./nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro</div><div class="line">      - ./nginx/log/:/var/log/nginx/:rw</div><div class="line">    depends_on:</div><div class="line">      - php</div><div class="line">    networks:</div><div class="line">      - frontend</div><div class="line">  php:</div><div class="line">    build: ./php/php72/</div><div class="line">    expose:</div><div class="line">      - &quot;9000&quot;</div><div class="line">    volumes:</div><div class="line">      - ./site/:/www:rw</div><div class="line">      - ./php/php72/conf/php/:/usr/local/etc/php/</div><div class="line">      - ./php/php72/conf/php-fpm.d/:/usr/local/etc/php-fpm.d/:rw</div><div class="line">      - ./php/php72/log/php-fpm/:/var/log/:rw</div><div class="line">    depends_on:</div><div class="line">      - mysql</div><div class="line">      - redis</div><div class="line">      - mongo</div><div class="line">    networks:</div><div class="line">      - frontend</div><div class="line">      - backend</div><div class="line"></div><div class="line">  mysql:</div><div class="line">    build: ./mysql/</div><div class="line">    ports:</div><div class="line">      - &quot;3307:3306&quot;</div><div class="line">    volumes:</div><div class="line">      - ./mysql/conf/:/etc/mysql/:rw</div><div class="line">      - ./mysql/data/:/var/lib/mysql/:rw</div><div class="line">      - ./mysql/log/:/var/log/mysql/:rw</div><div class="line">    env_file: ./mysql/env_config.env</div><div class="line">    environment:</div><div class="line">      TZ: &apos;Asia/Shanghai&apos;</div><div class="line">      MYSQL_ROOT_PASSWORD: &quot;renyimin&quot;</div><div class="line">    networks:</div><div class="line">      - backend</div><div class="line"></div><div class="line">  mongo:</div><div class="line">      build: ./mongo/</div><div class="line">      ports:</div><div class="line">        - 27018:27017</div><div class="line">      volumes:</div><div class="line">        - ./mongo/data:/data:rw</div><div class="line">        - ./mongo/data:/var/log/mongodb/:rw</div><div class="line"></div><div class="line">  redis:</div><div class="line">    build: ./redis/</div><div class="line">    volumes:</div><div class="line">      - ./redis/conf/:/usr/local/etc/redis</div><div class="line">      - ./redis/data/:/data:rw</div><div class="line">      - ./redis/log/:/var/log/</div><div class="line">    ports:</div><div class="line">      - &quot;6380:6379&quot;</div><div class="line"></div><div class="line">networks:</div><div class="line">    frontend:</div><div class="line">    backend:</div></pre></td></tr></table></figure></code></pre><h2 id="编排"><a href="#编排" class="headerlink" title="编排"></a>编排</h2><p>编排构建过程可能会有点慢(视网络快慢, 因为需要安装一些php扩展)</p><h2 id="小细节问题"><a href="#小细节问题" class="headerlink" title="小细节问题"></a>小细节问题</h2><ol><li><p>如果修改docker-compose.yml文件中某个容器的配置, 需要如何单独重新构建这个容器?</p><ul><li><code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> , 如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 当docker-compose.yml中nginx服务的相关配置没有改动时</div><div class="line">renyimindembp:docker-compose renyimin$ docker-compose up --no-deps -d nginx</div><div class="line">dockercompose_nginx_1 is up-to-date</div><div class="line"># 当docker-compose.yml中nginx服务的相关配置被改动后</div><div class="line">renyimindembp:docker-compose renyimin$ docker-compose up --no-deps -d nginx</div><div class="line">Recreating dockercompose_nginx_1 ... done</div><div class="line">renyimindembp:docker-compose renyimin$</div></pre></td></tr></table></figure></li></ul></li><li><p>如果修改了某个容器的配置文件, 如何单独重启这个容器? </p><ul><li>注意, 此时<code>docker-compose up --no-deps -d nginx</code>重新构建会发现docker-compose.yml中nginx服务的相关配置并没有改动, 所以不会生效</li><li>此时应该重启这个容器: <code>docker-compose restart nginx</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindembp:docker-compose renyimin$ docker-compose restart nginx</div><div class="line">Restarting dockercompose_nginx_1 ... done</div><div class="line">renyimindembp:docker-compose renyimin$</div></pre></td></tr></table></figure></li></ul></li></ol><ol><li>每次 <code>docker-compose up</code> 会重新构建所有容器<ul><li>但是只构建<code>docker-compose.yml</code>中配置发生变化的容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">renyimindembp:docker-compose renyimin$ docker-compose up -d</div><div class="line">dockercompose_mongo_1 is up-to-date</div><div class="line">dockercompose_redis_1 is up-to-date</div><div class="line">dockercompose_mysql_1 is up-to-date</div><div class="line">dockercompose_php_1 is up-to-date</div><div class="line">dockercompose_nginx_1 is up-to-date</div><div class="line">renyimindembp:docker-compose renyimin$</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="pecl扩展安装问题"><a href="#pecl扩展安装问题" class="headerlink" title="pecl扩展安装问题"></a>pecl扩展安装问题</h2><p>代理问题:  参考<a href="https://www.awaimai.com/2120.html讨论" target="_blank" rel="external">https://www.awaimai.com/2120.html讨论</a><br>未完待续~~ (安装mongo, redis, memcached 扩展)</p><p>参考:<a href="https://yeasy.gitbooks.io/docker_practice/content/compose/commands.html#up" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/compose/commands.html#up</a><br>参考:<a href="https://github.com/twang2218/docker-lnmp" target="_blank" rel="external">https://github.com/twang2218/docker-lnmp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker-Composer编排&lt;code&gt;nginx+phpfpm+mysql+redis+mongo&lt;/code&gt;集成环境&lt;br&gt;Github仓库地址:&lt;a href=&quot;https://github.com/rymuscle/docker-composer-lnmp&quot;
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>14.Compose模板文件</title>
    <link href="http://blog.renyimin.com/2017/10/19/docker/2017-10-19-14-docker/"/>
    <id>http://blog.renyimin.com/2017/10/19/docker/2017-10-19-14-docker/</id>
    <published>2017-10-19T10:50:08.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://yeasy.gitbooks.io/docker_practice/content/compose/compose_file.html" target="_blank" rel="external">docker-compose.yml</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/content/compose/compose_file.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;docker-compose.yml&lt;/
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>13.Compose命令</title>
    <link href="http://blog.renyimin.com/2017/10/19/docker/2017-10-19-13-docker/"/>
    <id>http://blog.renyimin.com/2017/10/19/docker/2017-10-19-13-docker/</id>
    <published>2017-10-19T06:27:53.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Compose命令说明"><a href="#Compose命令说明" class="headerlink" title="Compose命令说明"></a>Compose命令说明</h2><ol><li><p>命令作用的对象: 对于<code>Compose</code>来说, 大部分命令所作用的对象既可以是<code>项目本身</code>, 也可以指定为<code>项目中的服务或者容器</code>。如果没有特别的说明, 命令针对的对象将是项目, 这意味着项目中所有的服务都会受到命令影响。</p></li><li><p>命令格式: </p><ul><li>docker-compose 命令的基本的使用格式是: <code>docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</code></li><li>执行<code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</li></ul></li><li><p>命令选项:</p><ul><li><p><code>-f, --file FILE</code> 指定使用的Compose模板文件,默认为docker-compose.yml, 可以多次指定。</p></li><li><p><code>-p, --project-name NAME</code> 指定项目名称,<strong>默认将使用所在目录名称作为项目名</strong>。</p></li><li><p><code>--x-networking</code> 使用Docker的可拔插网络后端特性</p></li><li><p><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 bridge</p></li><li><p><code>--verbose</code> 输出更多调试信息。</p></li><li><p><code>-v, --version</code> 打印版本并退出。</p></li></ul></li></ol><h2 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h2><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>打印compose的版本信息 <code>docker-compose version</code></p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><p>列出Compose模板文件中包含的镜像 <code>docker-compose images</code></p><h3 id="build"><a href="#build" class="headerlink" title="build ??"></a>build ??</h3><ol><li>构建(重新构建)项目中的服务容器, 格式为 <code>docker-compose build [options] [SERVICE...]</code><ul><li>服务容器一旦构建后, 将会带上一个标记名, 例如对于<code>web项目</code>中的一个<code>db容器</code>, 可能叫web_db</li><li>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务</li></ul></li><li>选项包括：<ul><li><code>--force-rm</code> 删除构建过程中的临时容器</li><li><code>--no-cache</code> 构建镜像过程中不使用 cache(这将加长构建过程)</li><li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li></ul></li></ol><h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><ol><li><p>该命令十分强大, 它将尝试自动完成包括构建镜像, (重新)创建服务, 启动服务, 并关联服务相关容器的一系列操作。</p><ul><li>链接的服务都将会被自动启动, 除非已经处于运行状态; (可以说，大部分时候都可以直接通过该命令来启动一个项目。)</li><li>格式为 docker-compose up [options] [SERVICE…]。</li></ul></li><li><p>默认情况, <code>docker-compose up</code> 启动的容器都在前台, 控制台将会同时打印所有容器的输出信息, 可以很方便进行调试。当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p></li><li><p>如果使用 <code>docker-compose up -d</code>, 将会在后台启动并运行所有的容器, 一般推荐生产环境下使用该选项。</p></li><li><p>默认情况, 如果服务容器已经存在, <code>docker-compose up</code>将会尝试停止容器, 然后重新创建(保持使用 <code>volumes-from</code> 挂载的卷), 以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。<br> 如果用户不希望容器被停止并重新创建, 可以使用 <code>docker-compose up --no-recreate</code>。<br> 这样将只会启动处于停止状态的容器, 而忽略已经运行的服务;</p></li><li><p>如果用户只想重新部署某个服务, 可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务, 启动新服务, 并不会影响到其所依赖的服务。</p></li></ol><h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>打印某个容器端口所映射的公共端口, 格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code></p><ul><li><code>--protocol=proto</code> 指定端口协议, tcp(默认值)或者 udp</li><li><code>--index=index</code> 如果同一服务存在多个容器, 指定命令对象容器的序号(默认为 1)</li></ul><h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>在指定服务上执行一个命令, 格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code></p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>进入指定的容器</p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>通过发送SIGKILL信号来强制停止服务容器, 格式为 <code>docker-compose kill [options] [SERVICE...]</code><br>支持通过 -s 参数来指定发送的信号, 例如, 通过<code>$ docker-compose kill -s SIGINT</code>指令发送SIGINT信号</p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>查看各个服务容器内运行的进程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Compose命令说明&quot;&gt;&lt;a href=&quot;#Compose命令说明&quot; class=&quot;headerlink&quot; title=&quot;Compose命令说明&quot;&gt;&lt;/a&gt;Compose命令说明&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;命令作用的对象: 对于&lt;code&gt;Compose&lt;
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>12.Docker三剑客 之 Compose</title>
    <link href="http://blog.renyimin.com/2017/10/19/docker/2017-10-19-12-docker/"/>
    <id>http://blog.renyimin.com/2017/10/19/docker/2017-10-19-12-docker/</id>
    <published>2017-10-19T03:07:53.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Compose简介"><a href="#Compose简介" class="headerlink" title="Compose简介"></a>Compose简介</h2><ol><li><p><a href="https://github.com/docker/compose" target="_blank" rel="external">Compose 项目</a>是Docker官方的开源项目, 负责快速在集群中部署分布式应用。</p></li><li><p>Compose定位是「定义和运行多个Docker容器的应用(Defining and running multi-container Docker applications)」。</p></li><li><p>通过之前的学习，已经知道使用一个Dockerfile模板文件, 可以让用户很方便的定义一个单独的应用容器。然而, 在日常工作中, 经常会碰到需要多个容器相互配合来完成某项任务的情况。<br> 例如要实现一个Web项目, 除了 <code>Web服务容器</code> 本身, 往往还需要再加上后端的 <code>数据库服务容器</code>，甚至还包括 <code>负载均衡容器</code> 等。</p></li><li><p>Compose 恰好满足了这样的需求, 它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件(YAML格式)来定义 <strong>一组相关联的应用容器</strong> 为一个<strong>项目(project)</strong>。</p></li><li><p>Compose 中有两个重要的概念:</p><ul><li>服务(service): 一个应用容器，实际上可以包括若干运行相同镜像的容器实例。 </li><li>项目(project): 由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li></ul></li><li><p>Compose的默认管理对象是<strong>项目</strong>, 通过子命令对项目中的一组容器进行便捷地生命周期管理。<br>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。   </p></li></ol><h2 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h2><ol><li>Compose 目前支持 Linux、macOS、Windows 10 三大平台。</li><li>Compose 可以通过 Python 的包管理工具 <code>pip</code> 进行安装，也可以直接下载编译好的二进制文件使用，甚至直接运行在 Docker 容器中。</li><li><p>PIP 安装</p><ul><li>这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。</li><li>执行安装命令: <code>pip install -U docker-compose</code></li></ul></li><li><p>安装成功后，可以查看 docker-compose 命令的用法: <code>$ docker-compose -h</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Compose简介&quot;&gt;&lt;a href=&quot;#Compose简介&quot; class=&quot;headerlink&quot; title=&quot;Compose简介&quot;&gt;&lt;/a&gt;Compose简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/docke
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>11.高级网络配置</title>
    <link href="http://blog.renyimin.com/2017/10/19/docker/2017-10-19-11-docker/"/>
    <id>http://blog.renyimin.com/2017/10/19/docker/2017-10-19-11-docker/</id>
    <published>2017-10-19T02:20:31.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker虚拟网络原理"><a href="#Docker虚拟网络原理" class="headerlink" title="Docker虚拟网络原理"></a>Docker虚拟网络原理</h2><ol><li><p>当Docker启动时, 会自动在主机上创建一个<code>docker0虚拟网桥</code>, 实际上是 Linux 的一个 bridge, 可以理解为一个软件交换机。它会在 挂载到它上面的哪些网口 之间转发信息。</p></li><li><p>同时, Docker随机分配一个本地未占用的私有网段中的一个地址给<code>docker0</code>接口, 比如典型的172.17.42.1,掩码为255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段(172.17.0.0/16)的地址。</p></li><li><p>当创建一个Docker容器的时候,同时会创建了一对<code>veth pair</code>接口(当数据包发送到一个接口时, 另外一个接口也可以收到相同的数据包)</p><ul><li>这对接口一端在容器内,即 <code>eth0</code>; </li><li>另一端在本地并被挂载到<code>docker0</code>网桥, 名称以 veth 开头(例如 vethAQI2QT);</li></ul></li><li><p>通过这种方式, 主机可以跟容器通信, 容器之间也可以相互通信, Docker就创建了在主机和所有容器之间一个虚拟共享网络。<br><img src="/img/docker/network.png" width="350/"></p></li></ol><p>接下来的部分将介绍在一些场景中, Docker 所有的网络定制配置, 以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认的网络配置。</p><p>未完待续….</p><p>参考: <a href="https://yeasy.gitbooks.io/docker_practice/content/advanced_network/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/advanced_network/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker虚拟网络原理&quot;&gt;&lt;a href=&quot;#Docker虚拟网络原理&quot; class=&quot;headerlink&quot; title=&quot;Docker虚拟网络原理&quot;&gt;&lt;/a&gt;Docker虚拟网络原理&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当Docker启动时, 会自动在主机上创建
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>10.Docker中的网络功能</title>
    <link href="http://blog.renyimin.com/2017/10/17/docker/2017-10-17-10-docker/"/>
    <id>http://blog.renyimin.com/2017/10/17/docker/2017-10-17-10-docker/</id>
    <published>2017-10-17T10:15:23.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><ol><li><p>容器中可以运行一些网络应用, 要让外部也可以访问这些应用, 可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 8090:80 --name testVip --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div></pre></td></tr></table></figure></li><li><p>使用 <code>docker ps</code> 可以看到本地主机的 8090 被映射到了容器的 80 端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                       NAMES</div><div class="line">27863a3a8f70        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   39 minutes ago      Up 39 minutes       3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   testVip</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure><p>此时访问本机的 8090 端口即可访问容器内 web 应用提供的界面。</p></li></ol><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><ol><li><p>使用 <code>docker port 容器名</code>  来查看当前映射的端口配置, 也可以查看到绑定的地址</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                       NAMES</div><div class="line">27863a3a8f70        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   45 minutes ago      Up 45 minutes       3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   testVip</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker port testVip</div><div class="line">80/tcp -&gt; 0.0.0.0:8090</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></li><li><p>注意:</p><ul><li><code>-p</code> 可以多次使用来绑定多个端口</li><li>容器有自己的内部网络和 ip 地址(使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置)</li></ul></li></ol><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>容器的连接(linking)系统是除了端口映射外, 另一种跟容器中应用交互的方式。该系统会在源和接收容器之间创建一个隧道, 接收容器可以看到源容器指定的信息。<br>相对于端口映射, 这种方式主要用来做内部链接, 不暴露链接接口给外部</p><h3 id="自定义容器命名"><a href="#自定义容器命名" class="headerlink" title="自定义容器命名"></a><strong>自定义容器命名</strong></h3><ol><li>连接系统依据<strong>容器的名称</strong>来执行。因此，首先需要自定义一个好记的容器命名。虽然当创建容器的时候, 系统默认会分配一个名字。</li><li>自定义命名容器有2个好处:<ul><li>自定义的命名，比较好记，比如一个web应用容器我们可以给它起名叫web</li><li>当要连接其他容器时候，可以作为一个有用的参考点，比如连接web容器到db容器</li></ul></li><li>使用 <code>--name</code> 标记可以为容器自定义命名(使用 docker ps 来验证设定的命名)<ul><li>注意:<strong>容器的名称是唯一的</strong>。如果已经命名了一个叫 web 的容器，当你要再次使用 web 这个 名称的时候，需要先用 docker rm 来删除之前创建的同名容器。<h3 id="–rm"><a href="#–rm" class="headerlink" title="–rm"></a>–rm</h3>在执行 <code>docker run</code> 的时候如果添加 <code>--rm</code> 标记，则容器在终止后会立刻删除。注意, <code>--rm</code> 和 <code>-d</code> 参数不能同时使用。</li></ul></li></ol><h2 id="容器互联-1"><a href="#容器互联-1" class="headerlink" title="容器互联"></a>容器互联</h2><p>使用 <code>--link name:alias</code> 参数可以让容器之间安全的进行交互, 其中 <code>name</code> 是要链接的容器的名称, <code>alias</code> 是这个连接的别名;</p><ol><li><p>下面先创建一个新的数据库容器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 3307:3306 --name db --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div><div class="line">fd29cafa699da868a57f559630c6fb7f5dcf30705f884c9fa7feb4a373bba37c</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></li><li><p>然后创建一个新的 web 容器，并将它连接到 db 容器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 8090:80 --name web --link db:db --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div><div class="line">0e20f11d0f57fedb9d5fee96c8d9d56b67a7c62ded101fd92abf12bba04d09e4</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></li><li><p>使用 <code>docker ps</code> 来查看容器的连接</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                                       NAMES</div><div class="line">0e20f11d0f57        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   About a minute ago   Up About a minute   3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   web</div><div class="line">fd29cafa699d        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   About a minute ago   Up About a minute   80/tcp, 15672/tcp, 0.0.0.0:3307-&gt;3306/tcp   db</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure><p> (理论上可以看到自定义命名的容器 db 和 web, db 容器的 names 列有 db 也有 web/db。这表示 web 容器链接到 db 容器，web 容器将被允许访问 db 容器的信息。)<br> 但实际上貌似没有在names列看到有web/db</p></li><li><p>Docker 在两个互联的容器之间创建了一个安全隧道，而且不用映射它们的端口到宿主主机 上。在启动 db 容器的时候可以不用使用 -p 和 -P 标记，从而避免了暴露数据库端口到外部网络上。</p></li><li><p>Docker 通过 2 种方式为容器公开连接信息:</p><ul><li>环境变量</li><li>更新 /etc/hosts 文件</li></ul></li><li><p>使用 <code>env</code> 命令来查看 web 容器的环境变量</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run --rm --name web2 --link db:db vipservice env</div></pre></td></tr></table></figure><p> 更多参考书上…</p></li><li><p>除了环境变量, Docker 还添加 host 信息到父容器的 <code>/etc/hosts</code> 的文件。下面是父容器 web 的 <code>hosts</code> 文件</p><ul><li><p>这里有 2 个 hosts，第一个是 web 容器，web 容器用 id 作为他的主机名，第二个是 db 容器 的 ip 和主机名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                       NAMES</div><div class="line">297c83c40bc4        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   9 minutes ago       Up 8 minutes        3306/tcp, 15672/tcp, 0.0.0.0:8090-&gt;80/tcp   web</div><div class="line">46985aa1ab7b        vipservice          &quot;/bin/sh -c &apos;/run....&quot;   9 minutes ago       Up 9 minutes        80/tcp, 15672/tcp, 0.0.0.0:3307-&gt;3306/tcp   db</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker exec -it web /bin/sh</div><div class="line">sh-4.2# cat /etc/hosts</div><div class="line">127.0.0.1localhost</div><div class="line">::1localhost ip6-localhost ip6-loopback</div><div class="line">fe00::0ip6-localnet</div><div class="line">ff00::0ip6-mcastprefix</div><div class="line">ff02::1ip6-allnodes</div><div class="line">ff02::2ip6-allrouters</div><div class="line">172.17.0.2db 46985aa1ab7b</div><div class="line">172.17.0.3297c83c40bc4</div><div class="line">sh-4.2#</div></pre></td></tr></table></figure></li><li><p>可以在 web 容器中安装 ping 命令来测试跟db容器的连通, 用 ping 来测试db容器，它会解析成 172.17.0.2 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sh-4.2# ping db</div><div class="line">PING db (172.17.0.2) 56(84) bytes of data.</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=1 ttl=64 time=0.243 ms</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=2 ttl=64 time=0.330 ms</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=3 ttl=64 time=0.136 ms</div><div class="line">64 bytes from db (172.17.0.2): icmp_seq=4 ttl=64 time=0.129 ms</div></pre></td></tr></table></figure></li><li><p>用户可以链接多个父容器到子容器，比如可以链接多个 web 到 db 容器上。</p></li></ul></li></ol><p>参考: <a href="https://yeasy.gitbooks.io/docker_practice/content/network/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/network/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;外部访问容器&quot;&gt;&lt;a href=&quot;#外部访问容器&quot; class=&quot;headerlink&quot; title=&quot;外部访问容器&quot;&gt;&lt;/a&gt;外部访问容器&lt;/h2&gt;&lt;h3 id=&quot;端口映射&quot;&gt;&lt;a href=&quot;#端口映射&quot; class=&quot;headerlink&quot; title=&quot;端
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>09.Docker数据管理</title>
    <link href="http://blog.renyimin.com/2017/10/17/docker/2017-10-17-09-docker/"/>
    <id>http://blog.renyimin.com/2017/10/17/docker/2017-10-17-09-docker/</id>
    <published>2017-10-17T06:40:23.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>容器中管理数据主要有两种方式：<code>数据卷(Volumes)</code> 和 <code>挂载主机目录(Bind mounts)</code></p><h2 id="数据卷-Volumes"><a href="#数据卷-Volumes" class="headerlink" title="数据卷(Volumes)"></a>数据卷(Volumes)</h2><ol><li>数据卷 是一个可供<strong>一个或多个</strong>容器使用的特殊目录, 它绕过UFS, 可以提供很多有用的特性:<ul><li>数据卷 可以在容器之间共享和重用</li><li>对 数据卷 的修改会立马生效</li><li>对 数据卷 的更新，不会影响镜像</li><li>数据卷 默认会一直存在，即使容器被删除</li></ul></li><li>注意: 数据卷 的使用, 类似于 Linux 下对目录或文件进行 <code>mount</code>，镜像中的被指定为挂载点的目录中的文件会隐藏掉, 能显示看的是挂载的数据卷。</li></ol><h2 id="数据卷操作"><a href="#数据卷操作" class="headerlink" title="数据卷操作"></a>数据卷操作</h2><p>(在主机里使用)</p><ol><li>创建一个数据卷: <code>docker volume create my-vol</code> (其实还有一种方式就是在docker run的时候直接指定一个数据卷名, 就会自动帮你创建数据卷)</li><li>查看所有数据卷: <code>docker volume ls</code></li><li>查看指定数据卷的信息: <code>docker volume inspect my-vol</code><br> 查看容器的数据卷挂载信息: <code>docker inspect 容器名</code></li><li><p>删除数据卷 <code>$ docker volume rm my-vol</code></p><ul><li>数据卷 是被设计用来<strong>持久化</strong>数据的, 它的生命周期独立于容器, Docker不会在容器被删除后自动删除数据卷, 并且<strong>也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷</strong>。</li><li>如果需要在删除容器的同时移除数据卷, 可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令, <strong>这个命令貌似只是移除该容器和数据卷之间的关系</strong>, 除非这个数据卷没有任何容器引用了, 才可以使用下面介绍的命令来删除掉。</li></ul></li><li><p><strong>无主的数据卷</strong>可能会占据很多空间，要清理请使用命令 <code>$ docker volume prune</code></p><ul><li>可以看到清除时会提醒你 <code>WARNING! This will remove all volumes not used by at least one container</code></li><li>清除的是没有被<strong>至少一个</strong>容器使用的数据卷!</li></ul></li></ol><h2 id="创建并启动容器时-挂载数据卷"><a href="#创建并启动容器时-挂载数据卷" class="headerlink" title="创建并启动容器时,挂载数据卷"></a>创建并启动容器时,挂载数据卷</h2><ol><li>在使用 <code>docker run</code> 命令的时候, 还可以使用 <code>--mount</code> 参数来将<code>数据卷</code>挂载到容器里, 另外, 在一次 <code>docker run</code> 中可以挂载多个数据卷。</li><li><p>下面创建一个名为 <code>my-first-vol</code> 的数据卷</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">localhost:~ renyimin$ docker volume create my-first-vol</div><div class="line">my-first-vol</div><div class="line">localhost:~ renyimin$ </div><div class="line">localhost:~ renyimin$ docker volume inspect my-first-vol</div><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;CreatedAt&quot;: &quot;2017-04-26T13:43:16Z&quot;,</div><div class="line">        &quot;Driver&quot;: &quot;local&quot;,</div><div class="line">        &quot;Labels&quot;: &#123;&#125;,</div><div class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-first-vol/_data&quot;,</div><div class="line">        &quot;Name&quot;: &quot;my-first-vol&quot;,</div><div class="line">        &quot;Options&quot;: &#123;&#125;,</div><div class="line">        &quot;Scope&quot;: &quot;local&quot;</div><div class="line">    &#125;</div><div class="line">]</div><div class="line">localhost:~ renyimin$</div></pre></td></tr></table></figure></li><li><p>创建并运行一个名为 <code>web</code> 的容器, 同时加载上面的<code>数据卷</code>到容器内的 <code>/test-vol</code> 目录</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">localhost:~ renyimin$ docker run -d -p 5000:5000 --name myFirstRegistry --mount source=my-first1-vol,target=/test-vol registry</div><div class="line">45e2da7a8ee3c51ae682ff78d02c9779531a79fe2f7a58739023cd19ab48b09d</div><div class="line">localhost:~ renyimin$ docker exec -it myFirstRegistry /bin/sh</div><div class="line">/ # ls</div><div class="line">bin            entrypoint.sh  home           linuxrc        mnt            root           sbin           sys            tmp            var</div><div class="line">dev            etc            lib            media          proc           run            srv            test-vol       usr</div><div class="line">/ #</div></pre></td></tr></table></figure><ul><li>容器中会自动创建虚拟机中的挂载目录;</li><li>另外, 之前我们创建的数据卷是 <code>my-first-vol</code>, 此次运行容器时, 加载的数据卷<strong>却是</strong> <code>my-first1-vol</code>,<br>后面通过查看容器在<code>&quot;Mounts&quot;</code>key下面的数据卷信息, 会发现在启动容器时如果指定的数据卷不存在, 则会自动创建;<br>通过<code>docker volume ls</code>也可以看到现在有<code>my-first-vol</code> 和 <code>my-first1-vol</code> 这两个我们创建的数据卷;</li></ul></li><li><p>可以在主机里使用以下命令查看 <code>myFirstRegistry</code> 容器的信息, 数据卷信息在 <code>&quot;Mounts&quot;</code> Key 下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ docker inspect myFirstRegistry</div><div class="line">&quot;Mounts&quot;: [</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;volume&quot;,</div><div class="line">        &quot;Name&quot;: &quot;my-first1-vol&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-first1-vol/_data&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/test-vol&quot;,</div><div class="line">        &quot;Driver&quot;: &quot;local&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;z&quot;,</div><div class="line">        &quot;RW&quot;: true,</div><div class="line">        &quot;Propagation&quot;: &quot;&quot;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;volume&quot;,</div><div class="line">        &quot;Name&quot;: &quot;4fde6460059e4f0f07bc1c91ed852da7884b872dffc66bc4e237a260c7248250&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/4fde6460059e4f0f07bc1c91ed852da7884b872dffc66bc4e237a260c7248250/_data&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/var/lib/registry&quot;,</div><div class="line">        &quot;Driver&quot;: &quot;local&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;&quot;,</div><div class="line">        &quot;RW&quot;: true,</div><div class="line">        &quot;Propagation&quot;: &quot;&quot;</div><div class="line">    &#125;</div><div class="line">],</div></pre></td></tr></table></figure></li></ol><h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><ol><li><p>挂载一个主机目录作为数据卷: 使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 8090:80 --name testVip --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha vipservice</div><div class="line">2dea428aa379aaf415e5eff38b76f43d64e77b6b34d25bb5e353354ba897cee6</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker exec -it 2dea428aa379aaf415e5eff38b76f43d64e77b6b34d25bb5e353354ba897cee6 /bin/sh</div><div class="line">sh-4.2# cd /</div><div class="line">sh-4.2# ls</div><div class="line">anaconda-post.log  bindata  dev  etchaha  home  lib  lib64lost+found  media  mntopt  proc  root  run  run.sh  sbin  srv  sys  tmp  usrvar</div><div class="line">sh-4.2# cd haha</div><div class="line">sh-4.2# ls</div><div class="line">myfirstregistry  registry.tar</div><div class="line">sh-4.2#</div></pre></td></tr></table></figure></li><li><p>上面的命令会加载主机的 <code>/Users/renyimin/Desktop/testVip</code> 目录到容器的 <code>/haha</code> 目录, 这个功能在进行测试的时候十分方便, 比如, 你可以放置一些程序到本地目录中,来查看容器是否正常工作。<strong>本地目录的路径必须是绝对路径</strong>, 以前使用 <code>-v</code> 参数时, 如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在, Docker 会报错。</p></li><li><p>查看容器的挂载信息, 发现和数据卷相比, <code>Type</code>信息是<code>bind</code>而不是<code>volume</code>, 并且没有数据卷的<code>name</code>信息, <code>docker volume ls</code> 也不会看到有新的数据卷被创建, 所以…可以认为只是一次简单的目录绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker inspect testVip</div><div class="line">&quot;Mounts&quot;: [</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;bind&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/Users/renyimin/Desktop/testVip&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/haha&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;&quot;,</div><div class="line">        &quot;RW&quot;: true,</div><div class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure></li><li><p>选择 <code>-v</code> 还是 <code>--mount</code> 参数?</p><ul><li>Docker 新用户应该选择 <code>--mount</code> 参数，经验丰富的 Docker 使用者对 <code>-v</code> 或者 <code>--volume</code> 已经很熟悉了，但是推荐使用 <code>--mount</code> 参数;</li><li>可以理解为, <strong><code>--mount</code> 参数应该可以挂载数据卷, 也可以代替-v来进行目录关联</strong>。</li></ul></li><li><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <strong>只读</strong></p><ul><li><p>加了 readonly 之后，就挂载为 只读 了。如果你在容器内 /haha 目录新建文件，会显示如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 8090:80 --name testVip --mount type=bind,source=/Users/renyimin/Desktop/testVip,target=/haha,readonly vipservice</div><div class="line">27863a3a8f70fa4bddb9c97fabfee2db7f35d5615d4b90ad0be13717dc23d092</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker exec -it 27863a3a8f70fa4bddb9c97fabfee2db7f35d5615d4b90ad0be13717dc23d092 /bin/sh</div><div class="line">sh-4.2# </div><div class="line">sh-4.2# cd /</div><div class="line">sh-4.2# ls</div><div class="line">anaconda-post.log  bindata  dev  etchaha  home  lib  lib64lost+found  media  mntopt  proc  root  run  run.sh  sbin  srv  sys  tmp  usrvar</div><div class="line">sh-4.2# cd haha</div><div class="line">sh-4.2# ls</div><div class="line">myfirstregistry  registry.tar</div><div class="line">// 可以看到报错了</div><div class="line">sh-4.2# touch a.txt</div><div class="line">touch: cannot touch &apos;a.txt&apos;: Read-only file system</div><div class="line">sh-4.2#</div></pre></td></tr></table></figure></li><li><p>查看数据卷的具体信息 <code>$ docker inspect testVip</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&quot;Mounts&quot;: [</div><div class="line">    &#123;</div><div class="line">        &quot;Type&quot;: &quot;bind&quot;,</div><div class="line">        &quot;Source&quot;: &quot;/Users/renyimin/Desktop/testVip&quot;,</div><div class="line">        &quot;Destination&quot;: &quot;/haha&quot;,</div><div class="line">        &quot;Mode&quot;: &quot;&quot;,</div><div class="line">        &quot;RW&quot;: false,</div><div class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</div><div class="line">    &#125;</div><div class="line">],</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="数据卷挂载的问题"><a href="#数据卷挂载的问题" class="headerlink" title="数据卷挂载的问题"></a>数据卷挂载的问题</h2><p>上面提到的数据卷, 对很多容器都非常有用, 比如 </p><ul><li>mysql容器中存储数据文件的 <code>/var/lib/mysql</code> 目录你就需要挂载数据卷;</li><li>mysql, php-fpm, nginx等容器中, 关于服务配置的目录你也需要挂载到数据卷, 这些配置你可能需要进行改动;</li></ul><p>但是挂载数据卷有个问题, 一旦挂载之后, 容器中的目录就是空的, 原本服务的配置文件就被清空了, 也就导致有些容器在挂载数据卷之后, 无法正常启动;</p><h2 id="docker-cp-命令"><a href="#docker-cp-命令" class="headerlink" title="docker cp 命令"></a>docker cp 命令</h2><ol><li><p>可以将本地目录/文件拷贝到容器, 也可以将容器中的目录/文件拷贝到本地; 格式: </p><ul><li><code>docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</code></li><li><code>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</code></li></ul></li><li><p>所以为了避免挂载导致容器无法正常启动, 挂载的可以这样来:</p><ul><li>先确定你需要挂载的容器中目录的位置(比如: nginx容器中的配置文件在<code>/etc/nginx/conf.d/default.conf</code> )</li><li>使用 <code>docker cp</code> 命令, 将需要映射的目录从容器复制到本地; (比如:  <code>docker cp nginx_test:/etc/nginx/ ./conf/</code>)</li><li>然后再将本地default.conf文件挂载到nginx容器的/etc/nginx/conf.d/default.conf</li></ul></li></ol><p>参考: <a href="https://yeasy.gitbooks.io/docker_practice/content/data_management/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/data_management/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;容器中管理数据主要有两种方式：&lt;code&gt;数据卷(Volumes)&lt;/code&gt; 和 &lt;code&gt;挂载主机目录(Bind mounts)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据卷-Volumes&quot;&gt;&lt;a href=&quot;#数据卷-Volumes&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>08.容器--基本操作</title>
    <link href="http://blog.renyimin.com/2017/10/17/docker/2017-10-17-08-docker/"/>
    <id>http://blog.renyimin.com/2017/10/17/docker/2017-10-17-08-docker/</id>
    <published>2017-10-17T04:01:08.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>1.镜像(Image)和容器(Container)的关系, 就像是面向对象程序设计中的 类 和 实例 的关系一样, 镜像是静态的定义, 容器是镜像运行时的实体。容器可以被 <code>创建</code>、<code>启动</code>、<code>停止</code>、<code>删除</code>、<code>暂停</code>等。</p><p>2.容器的实质是<strong>进程</strong>，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。</p><ul><li>因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。</li><li>容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会把容器和虚拟机搞混。</li></ul><p>3.前面讲过镜像使用的是<strong>分层存储</strong>，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。<br><code>容器存储层</code>的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，<strong>任何保存于容器存储层的信息都会随容器的删除而丢失</strong>。</p><p>4.按照 Docker 最佳实践的要求, 容器不应该向其存储层内写入任何数据，<strong>容器存储层要保持无状态化</strong></p><ul><li>所有的文件写入操作，都应该使用<code>数据卷(Volume)</code>、或者<code>绑定宿主目录</code>，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</li><li>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</li></ul><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a><strong>容器操作</strong></h2><p>启动容器有两种方式：<strong>一种是基于镜像新建一个容器并启动</strong>, <strong>另外一个是将在终止状态(stopped)的容器启动</strong></p><h3 id="创建并启动"><a href="#创建并启动" class="headerlink" title="创建并启动"></a>创建并启动</h3><p>1.因为 Docker 的容器<strong>实在太轻量级了</strong>, 很多时候用户都是<strong>随时删除和新创建容器</strong>。 </p><p>2.新建并启动一个容器, 所需要的命令主要为 <code>docker run</code>, 例如: <code>$ docker run -d -p 5000:5000 --name myFirstRegistry registry</code>, 是根据名为registry的镜像创建并运行一个名为myFirstRegistry容器;</p><p>3.当利用 <code>docker run</code> 来创建容器时, Docker 在后台运行的标准操作包括:</p><ul><li>检查本地是否存在指定的镜像, 不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统, 并在只读的镜像层外面挂载一层可读写层 </li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 </li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p>4.<strong>容器被启动后, 设置的挂载目录, 端口映射都会随着此容器, 容器stop后, 再次start, 这些设置都还在;</strong></p><h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker start [containerID or NAME]</code> 命令, 直接将一个已经终止的容器启动运行。 </p><h3 id="守护态运行容器"><a href="#守护态运行容器" class="headerlink" title="守护态运行容器"></a>守护态运行容器</h3><p>其实更多时候, 我们需要让容器在后台运行, 而不是直接运行容器并展示出结果, 此时只用在运行时加上 <code>-d 参数</code>即可; (在容器的第一种启动方式中已经介绍过了)</p><h3 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h3><p>可以通过 <code>docker ps</code> 命令来查看正在运行的容器信息</p><p>可以通过 <code>docker ps -a</code> 命令来查看 正在运行的和终止的 容器信息</p><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>可以使用 <code>docker stop [containerID or NAME]</code> 来终止一个运行中的容器</p><h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><p>可以使用 <code>docker restart [containerID or NAME]</code> 来重启一个运行中的容器</p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>1.可以使用 <code>docker rm 容器ID/容器NAME</code> 来删除一个<strong>处于终止状态</strong>的容器。 </p><p>2.如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>可参考<a href="https://yeasy.gitbooks.io/docker_practice/content/container/attach_exec.html" target="_blank" rel="external">书中介绍</a></p><p>本人通常使用 <code>docker exec -it [containerID or NAME] /bin/sh</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;容器&quot;&gt;&lt;a href=&quot;#容器&quot; class=&quot;headerlink&quot; title=&quot;容器&quot;&gt;&lt;/a&gt;容器&lt;/h2&gt;&lt;p&gt;1.镜像(Image)和容器(Container)的关系, 就像是面向对象程序设计中的 类 和 实例 的关系一样, 镜像是静态的定义, 容器
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>07.Docker Registry 仓库</title>
    <link href="http://blog.renyimin.com/2017/10/17/docker/2017-10-17-07-docker/"/>
    <id>http://blog.renyimin.com/2017/10/17/docker/2017-10-17-07-docker/</id>
    <published>2017-10-17T03:30:08.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公开-Docker-Registry"><a href="#公开-Docker-Registry" class="headerlink" title="公开 Docker Registry"></a>公开 Docker Registry</h2><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务</p><ul><li>一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</li><li>最常使用的Registry公开服务是官方的 <code>Docker Hub</code>, 这也是默认的 Registry，并拥有大量的高质量的官方镜像。</li></ul><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务(Registry Mirror)，这些镜像服务被称为<strong>加速器</strong>。</p><p>但是, 有时候使用 Docker Hub 或其他公共仓库可能不方便(比如, 有时候我们的服务器无法访问互联网 或者 你不希望将自己的镜像放到公网当中)，则可以创建一个 <code>本地仓库供</code> 私人使用。</p><h2 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h2><p>1.除了使用公开服务外, 用户还可以在本地搭建私有Docker Registry, <a href="https://docs.docker.com/registry/" target="_blank" rel="external"><code>docker-registry</code></a>是官方提供的工具, 可以用于构建私有的镜像仓库。</p><p>2.安装运行 <code>docker-registry</code></p><ul><li><p>你可以通过获取官方<code>registry</code>镜像来在本地运行一个自己的私有镜像仓库 (如 <code>$ docker run -d -p 5000:5000 --restart=always --name registry registry</code>, 将使用官方的registry镜像来启动一个私有仓库)</p></li><li><p>默认情况下, 仓库中的镜像会被创建在容器的 <code>/var/lib/registry</code> 目录下, 你可以通过 <code>-v</code> 参数来将镜像文件存放到本地的指定路径中。</p></li><li><p>另外, 可以将私有仓库的配置文件指定到本地的路径下 (如 ~/Desktop/registry-config/ 下 )</p></li></ul><p>3.我们大可不必这么麻烦, 只是简单运行一个私有仓库服务 <code>$ docker run -d -p 5000:5000 --restart=always --name registry registry</code></p><h3 id="查看私有仓库中镜像"><a href="#查看私有仓库中镜像" class="headerlink" title="查看私有仓库中镜像"></a>查看私有仓库中镜像</h3><p>1.用 <code>curl</code> 查看仓库中的镜像, 可以看到你的私有仓库暂时还是空的</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl 127.0.0.1:5000/v2/_catalog</div><div class="line">&#123;&quot;repositories&quot;:[]&#125;</div><div class="line">$</div></pre></td></tr></table></figure></code></pre><p>2.还可以在浏览器中直接查看私有仓库中的镜像(并且内网其他机器也可以通过内网地址来访问你所搭建的私有仓库的镜像):<br><img src="/img/docker/private_registry_01.png" width="200/"><br><img src="/img/docker/private_registry_02.png" width="200/"></p><h3 id="上传镜像到私有仓库中"><a href="#上传镜像到私有仓库中" class="headerlink" title="上传镜像到私有仓库中"></a>上传镜像到私有仓库中</h3><p>1.之前我们已经通过获取官方 <code>registry镜像</code> 来创建好了自己的私有仓库, 接下来就可以使用 <code>docker tag</code> 来标记一个镜像, 然后推送它到仓库。</p><p>2.先查看一下本地已有的镜像 <code>docker image ls</code> :</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div></pre></td></tr></table></figure></code></pre><p>3.使用 <code>docker tag</code> 将 <code>registry:lates</code> 这个镜像标记为一个新的本地镜像 <code>127.0.0.1:5000/registry:latest</code> ; </p><ul><li><p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker tag registry:latest 127.0.0.1:5000/registry:latest</div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div></pre></td></tr></table></figure></li><li><p>这样, 假设你的小组成员需要尝试在本地搭建自己的私有仓库的话，就不用去公共镜像仓库去下载了, 只用在内网就可以方便地下载registry镜像</p></li></ul><p>4.使用 docker push 上传标记的镜像</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker push 127.0.0.1:5000/registry:latest</div><div class="line">The push refers to a repository [127.0.0.1:5000/registry]</div><div class="line">9113493eaae1: Pushed </div><div class="line">621c2399d41a: Pushed </div><div class="line">59e80739ed3f: Pushed </div><div class="line">febf19f93653: Pushed </div><div class="line">e53f74215d12: Pushed </div><div class="line">latest: digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c size: 1364</div></pre></td></tr></table></figure></code></pre><p>5.然后查看仓库中的镜像，可以看到镜像已经被成功上传了</p><ul><li><p>curl 查看</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl 127.0.0.1:5000/v2/_catalog</div><div class="line">&#123;&quot;repositories&quot;:[&quot;registry&quot;]&#125;</div></pre></td></tr></table></figure></li><li><p>浏览器查看<br><img src="/img/docker/private_registry_03.png" width="200/"><br><img src="/img/docker/private_registry_04.png" width="200/"></p></li></ul><h3 id="上传私有仓库问题"><a href="#上传私有仓库问题" class="headerlink" title="上传私有仓库问题"></a>上传私有仓库问题</h3><p>1.如果上传的时候, 打包的镜像使用的是本机的内网地址, 最后在上传的时候, 你会发现<strong>如下报错信息</strong>:</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker push 192.168.1.3:5000/registry:latest</div><div class="line">The push refers to a repository [192.168.1.3:5000/registry]</div><div class="line">Get https://192.168.1.3:5000/v2/: http: server gave HTTP response to HTTPS client</div><div class="line">renyimindembp:vipvip renyimin$</div></pre></td></tr></table></figure></code></pre><p>2.此时, 你需要将内网地址配置到本机docker的 <code>insecure registries</code> 中, 如下:<br><img src="/img/docker/insecure_registries_01.png" width="300"></p><p>3.之后, 无论本机还是在同一内网中的其他机器也都可以推送镜像到仓库中了(之前打包好的两个镜像, 都可以成功推送到私有仓库中):</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ docker push 192.168.1.3:5000/registry</div><div class="line">The push refers to a repository [192.168.1.3:5000/registry]</div><div class="line">9113493eaae1: Pushed </div><div class="line">621c2399d41a: Pushed </div><div class="line">59e80739ed3f: Pushed </div><div class="line">febf19f93653: Pushed </div><div class="line">e53f74215d12: Pushed </div><div class="line">latest: digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c size: 1364</div><div class="line">   </div><div class="line">$ docker push 127.0.0.1:5000/registry</div><div class="line">The push refers to a repository [127.0.0.1:5000/registry]</div><div class="line">9113493eaae1: Layer already exists </div><div class="line">621c2399d41a: Layer already exists </div><div class="line">59e80739ed3f: Layer already exists </div><div class="line">febf19f93653: Layer already exists </div><div class="line">e53f74215d12: Layer already exists </div><div class="line">latest: digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c size: 1364</div></pre></td></tr></table></figure></code></pre><h3 id="从私有仓库中下载镜像"><a href="#从私有仓库中下载镜像" class="headerlink" title="从私有仓库中下载镜像"></a>从私有仓库中下载镜像</h3><p>1.先删除已有镜像</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">192.168.1.3:5000/registry                             latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line"></div><div class="line">$ docker image rm 127.0.0.1:5000/registry:latest 192.168.1.3:5000/registry:latest</div><div class="line">Untagged: 127.0.0.1:5000/registry:latest</div><div class="line">Untagged: 127.0.0.1:5000/registry@sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line">Untagged: 192.168.1.3:5000/registry:latest</div><div class="line">Untagged: 192.168.1.3:5000/registry@sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line"></div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">renyimindembp:vipvip renyimin$</div></pre></td></tr></table></figure></code></pre><p>2.再尝试从私有仓库中下载这个镜像 (两个地址都可以下载, 也是因为之前配置了 <code>Insecure registries</code>, 这里最后才可以使用内网地址来下载)</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">$ docker pull 127.0.0.1:5000/registry:latest</div><div class="line">latest: Pulling from registry</div><div class="line">Digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line">Status: Downloaded newer image for 127.0.0.1:5000/registry:latest</div><div class="line"></div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line"></div><div class="line">$ docker pull 192.168.1.3:5000/registry:latest</div><div class="line">latest: Pulling from registry</div><div class="line">Digest: sha256:feb40d14cd33e646b9985e2d6754ed66616fedb840226c4d917ef53d616dcd6c</div><div class="line">Status: Downloaded newer image for 192.168.1.3:5000/registry:latest</div><div class="line"></div><div class="line">$ docker image ls</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">192.168.1.3:5000/registry                             latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">registry                                              latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        4 weeks ago         33.3MB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.3               47c844c76c53        2 months ago        2.92GB</div><div class="line">vipservice                                            latest              47c844c76c53        2 months ago        2.92GB</div><div class="line">docker-registry.haodai.com:80/devhdjfapi.haodai.com   1.1.1               52bd20b1d39b        3 months ago        2.46GB</div><div class="line">devhdjfapi.haodai.com_full                            latest              52bd20b1d39b        3 months ago        2.46GB</div><div class="line">oldvip.haodai.com                                     latest              52bd20b1d39b        3 months ago        2.46GB</div></pre></td></tr></table></figure></code></pre><h2 id="几个简单问题"><a href="#几个简单问题" class="headerlink" title="几个简单问题"></a>几个简单问题</h2><p>1.<a href="https://docs.docker.com/registry/spec/api/#deleting-an-image" target="_blank" rel="external">删除<code>仓库</code>镜像</a><br>    自己的docker仓库中存放的镜像, 时间长了难免存在一些废弃的镜像在里面, 如果不删除就造成空间的浪费。<br>2.容器启动之后, 如果忘记挂载某个目录, 能否再进行挂载?<br>其实没有必要, 直接停止删除, 重开一个即可！</p><p><del>~~未完待续</del>~~    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;公开-Docker-Registry&quot;&gt;&lt;a href=&quot;#公开-Docker-Registry&quot; class=&quot;headerlink&quot; title=&quot;公开 Docker Registry&quot;&gt;&lt;/a&gt;公开 Docker Registry&lt;/h2&gt;&lt;p&gt;Docker
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>06.其他方法定制 -- (镜像/容器 的 导入导出)</title>
    <link href="http://blog.renyimin.com/2017/10/14/docker/2017-10-14-06-docker/"/>
    <id>http://blog.renyimin.com/2017/10/14/docker/2017-10-14-06-docker/</id>
    <published>2017-10-14T12:15:28.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="镜像-save-load"><a href="#镜像-save-load" class="headerlink" title="镜像 (save/load)"></a>镜像 (save/load)</h2><p>1.<code>docker save nginx:v1 &gt; alpine-latest.tar.gz</code>：将指定<strong>镜像</strong>导出为 <code>镜像存储文件</code>;</p><p>2.再使用 <code>docker load -i alpine-latest.tar.gz</code> 命令将 <code>镜像存储文件</code> 导入到本地镜像库;</p><h2 id="容器-export-import"><a href="#容器-export-import" class="headerlink" title="容器(export/import)"></a>容器(export/import)</h2><p>1.<code>docker export container_id &gt; my_container.tar</code>：将一个<strong>容器</strong>导出为 <code>容器快照文件</code>;<br>2.再使用 <code>docker import my_container.tar imageName:tag</code> 命令将 <code>容器快照文件</code> 导入为一个新的镜像到本地镜像库;<br>3.测试, 将nginx_v1容器导出, 并在本地重新生成nginx:v3镜像, 然后运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 运行中的nginx_v1容器</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</div><div class="line">d5d17a25cc35        nginx:v1            &quot;nginx -g &apos;daemon ...&quot;   2 hours ago         Up 11 minutes       0.0.0.0:8089-&gt;80/tcp     nginx_v1</div><div class="line">0e7070854958        registry            &quot;/entrypoint.sh /e...&quot;   26 hours ago        Up About an hour    0.0.0.0:5000-&gt;5000/tcp   registry</div><div class="line">//导出容器为 容器快照文件</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker export nginx_v1 &gt; nginx_v1.tar</div><div class="line">//将 nginx_v1的容器快照文件, 重新导入为一个新的本地镜像 nginx:v3</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker import nginx_v1.tar nginx:v3</div><div class="line">sha256:985fba7fd176d79685322d184bc79b81ca4365619bc0a773672e5c87cfc701cd</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker images</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">nginx                                                 v3                  985fba7fd176        10 seconds ago      107MB</div><div class="line">nginx                                                 v1                  8b748aee8b23        2 hours ago         109MB</div><div class="line">nginx                                                 latest              e548f1a579cf        8 days ago          109MB</div><div class="line">// 运行新镜像, 发现报错</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker run -d --name nginx_v3 nginx:v3</div><div class="line">docker: Error response from daemon: No command specified.</div><div class="line">See &apos;docker run --help&apos;.</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$</div></pre></td></tr></table></figure></p><p>4.解决方案, 通过<code>docker import 导入容器快照文件</code>生成的镜像, 在初次创建并启动(run)时, 需要提供快照文件所对应的容器的<code>COMMAND</code>字段, 可以通过<code>docker ps</code>查看, 如果命令太长, 则需要使用 <code>docker inspect 容器名</code> 查看 <code>cmd</code> 字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker run -d --name nginx_v3 nginx:v3 nginx &apos;-g&apos; &apos;daemon off;&apos;</div><div class="line">0fb30bafe266248bbb58e31d9dcab7479f4a59494fcc636f7f7dfd2df498066d</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</div><div class="line">0fb30bafe266        nginx:v3            &quot;nginx -g &apos;daemon ...&quot;   2 seconds ago       Up 1 second                                  nginx_v3</div><div class="line">d5d17a25cc35        nginx:v1            &quot;nginx -g &apos;daemon ...&quot;   2 hours ago         Up 19 minutes       0.0.0.0:8089-&gt;80/tcp     nginx_v1</div><div class="line">0e7070854958        registry            &quot;/entrypoint.sh /e...&quot;   26 hours ago        Up About an hour    0.0.0.0:5000-&gt;5000/tcp   registry</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$</div></pre></td></tr></table></figure></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1.可以使用 <code>docker load</code> 来导入<code>镜像存储文件</code>到本地镜像库。<br>2.也可以使用 <code>docker import</code> 来导入一个<code>容器快照文件</code>到本地镜像库。<br>3.这两者的区别在于:</p><ul><li><code>镜像存储文件</code>将保存完整记录, 体积也要大</li><li>而<code>容器快照文件</code>将丢弃所有的历史记录和元数据信息(即仅保存容器当时的快照状态)</li><li>此外，从容器快照文件导入时可以<strong>重新指定标签</strong>等元数据信息</li></ul><ol><li>另外, 使用<code>docker save</code>保存的<code>镜像存储文件</code>, 不能使用 <code>docker import</code> 来导入成镜像, 这样导入的镜像无法运行起来</li></ol><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>在初次为公司内部准备镜像时, 可以启动一个基础镜像, 然后在容器中做好软件安装, 完成各种配置工作之后:</p><ul><li>可以手动commit成功新的 <code>镜像:tag</code>, 然后将镜像push到私有仓库供给大家下载使用;</li><li>可以简单将容器直接export成容器快照文件, 然后import为新的 <code>镜像:tag</code>, 然后push到私有仓库供给大家下载使用; </li><li>或者通过Dockerfile定制脚本及<code>docker build</code>来构建新的 <code>镜像:tag</code>, 然后push到私有仓库供给大家下载使用; </li></ul><p><strong>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡, 这里的消亡是指容器被删除, 而不是stop容器, stop容器后, 容器中发生的改变不会被忽略, 除非容器被删除掉</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>如果只是做集成环境的镜像, 比如lnmp全部在一个镜像中运行, 自己觉着可以:</p><ul><li>使用一个基础镜像运行起容器, 然后自己安装各种环境, 最后可以直接 <code>export</code> 导出容器为快照文件, 然后分发给组员;(如果需要再次修改环境信息, 直接修改好, 然后导出新的容器快找文件给组员即可)</li><li>可以在容器中构建好各环境之后, <code>commit</code> 手动构建好镜像, 然后将镜像 <code>push</code> 到仓库中, 供组员使用 (变动频次较高的时候不方便, 因为这样会导致容器变得越来越臃肿); </li><li>可以使用<code>Dockerfile</code>对镜像进行定制(如果镜像比较基础, 可能编写的比较多), 然后将镜像 <code>push</code> 到仓库中, 供组员使用</li></ul></li><li><p>如果做多容器部署, 需要使用到docker-compose….<br>未完待续~~</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://yeasy.gitbooks.io/docker_practice/content/image/other.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/image/other.html</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/content/container/import_export.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/container/import_export.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;镜像-save-load&quot;&gt;&lt;a href=&quot;#镜像-save-load&quot; class=&quot;headerlink&quot; title=&quot;镜像 (save/load)&quot;&gt;&lt;/a&gt;镜像 (save/load)&lt;/h2&gt;&lt;p&gt;1.&lt;code&gt;docker save nginx:
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>05.镜像 - Dockerfile常见指令详解</title>
    <link href="http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/"/>
    <id>http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/</id>
    <published>2017-10-13T02:25:07.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h2><ol><li>所谓定制镜像, <strong>是以一个镜像为基础, 在其上进行定制</strong>。<code>FROM</code> 就用来指定基础镜像, 因此一个 Dockerfile 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</li><li>格式: <code>FROM 镜像名[:标签]</code></li></ol><h2 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h2><ol><li>指定镜像的作者和联系方式信息(执行<code>docker inspect image</code> 输出中有相应的字段记录该信息)</li><li>格式:<code>MAINTAINER author &quot;e-mail&quot;</code> 指定作者名和E-mail</li></ol><h2 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h2><ol><li><p><code>RUN</code>指令是用来执行<code>命令行命令</code>的。(由于命令行的强大能力, RUN指令在定制镜像时是最常用的指令之一)</p></li><li><p>其格式有两种：</p><ul><li>shell 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样, 如: <code>RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code></li><li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code> , 这更像是函数调用中的格式, 如: <code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code>。</li></ul></li><li><p>虽然RUN就像Shell脚本一样可以执行命但是我们也不能像Shell脚本一样把每个命令对应一个RUN, 因为每一个RUN的行为, 就像手工建立commit镜像的过程一样:新建立一层，在其上执行这些命令, 执行结束后, commit 这一层的修改, 构成新的镜像。</p><ul><li><p>像下面的这种写法，创建了 7 层镜像, 这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。<strong>结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。这是很多初学 Docker 的人常犯的一个错误</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN apt-get update</div><div class="line">RUN apt-get install -y gcc libc6-dev make</div><div class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</div><div class="line">RUN mkdir -p /usr/src/redis</div><div class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</div><div class="line">RUN make -C /usr/src/redis</div><div class="line">RUN make -C /usr/src/redis install</div></pre></td></tr></table></figure></li><li><p>上面的 Dockerfile 正确的写法应该是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN buildDeps=&apos;gcc libc6-dev make&apos; \</div><div class="line">    &amp;&amp; apt-get update \</div><div class="line">    &amp;&amp; apt-get install -y $buildDeps \</div><div class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \</div><div class="line">    &amp;&amp; mkdir -p /usr/src/redis \</div><div class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</div><div class="line">    &amp;&amp; make -C /usr/src/redis \</div><div class="line">    &amp;&amp; make -C /usr/src/redis install \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</div><div class="line">    &amp;&amp; rm redis.tar.gz \</div><div class="line">    &amp;&amp; rm -r /usr/src/redis \</div><div class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</div></pre></td></tr></table></figure><blockquote><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层, 这只是一层的事情。<br><strong>在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建</strong>。<br>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，因为<strong>镜像是多层存储，每一层的东西并不会在下一层被删除</strong>，会一直跟随着镜像。<br>因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p></blockquote></li></ul></li></ol><h2 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h2><ol><li>这个指令很简单,就是设置环境变量而已,无论是后面的其它指令,如RUN,还是运行时的应用,都可以直接使用这里定义的环境变量。</li><li><code>ENV</code>设置环境变量格式有两种:<ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul></li><li>下面例子中演示了”设置环境变量”, “如何换行”, 以及对”含有空格的值用双引号括起来”的办法, 这和Shell下的行为是一致的 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ENV VERSION=1.0 DEBUG=on \</div><div class="line">NAME=&quot;Happy Feet&quot;</div></pre></td></tr></table></figure></li></ol><h2 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h2><ol><li><p>构建参数和ENV的效果一样, 都是设置环境变量。所不同的是,<code>ARG</code>所设置的环境变量,在将来容器运行时是<strong>不会存在</strong>这些环境变量的;但是不要因此就使用ARG保存密码之类的信息, 因为 <code>docker history</code> 还是可以看到所有值的;</p></li><li><p>Dockerfile 中的ARG指令是定义参数名称及其默认值, 该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖</p></li><li><p>格式: <code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p></li></ol><h2 id="WORKDIR-切换工作目录"><a href="#WORKDIR-切换工作目录" class="headerlink" title="WORKDIR 切换工作目录"></a>WORKDIR 切换工作目录</h2><ol><li>使用 <code>WORKDIR</code> 指令可以来指定接下来之后各层的工作目录, <strong>如该目录不存在, WORKDIR 会帮你建立目录</strong>。</li><li>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code></li><li><p>之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写, 这种错误的理解还可能会导致出现下面这样的错误:</p><ul><li><p>如果将下面这个 Dockerfile 进行构建镜像运行后, 会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 hello </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RUN cd /app #第一层 `RUN cd /app` 的执行仅仅是当前进程的工作目录变更, 一个内存上的变化而已, 其结果不会造成任何文件变更。</div><div class="line">RUN echo &quot;hello&quot; &gt; world.txt #而到第二层的时候, 启动的是一个全新的容器, 跟第一层的容器更完全没关系, 自然不可能继承前一层构建过程中的内存变化</div></pre></td></tr></table></figure></li><li><p>原因其实很简单, 在Shell中, 上面连续的两行是同一个进程执行环境, 而在 Dockerfile 中, 这两行 RUN 命令的执行环境根本不同, 是两个完全不同的容器。(这就是对 Dokerfile 构建分层存储的概念不了解所导致的错误)</p></li><li>之前说过每一个RUN都是启动一个容器、执行命令、然后提交存储层文件变更</li></ul></li></ol><h2 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h2><ol><li><p><code>USER</code> 指令和 WORKDIR 相似, <strong>都是改变环境状态并影响以后的层</strong> (<code>WORKDIR</code>是改变工作目录, 而<code>USER</code>则是改变之后层执行RUN,CMD以及ENTRYPOINT这类命令时的身份)。</p></li><li><p>格式: <code>USER &lt;用户名&gt;</code></p></li><li><p>注意: USER只是帮助你切换到指定用户而已, <strong>这个用户必须是事先建立好的, 否则无法切换</strong>。</p></li><li><p>如果以root执行的脚本, 在执行期间希望改变身份, 比如希望以某个已经建立好的用户来运行某个服务进程, 不要使用 <code>su</code> 或者 <code>sudo</code>, 这些都需要比较麻烦的配置, 而且在TTY缺失的环境下经常出错。</p><ul><li>建议使用 <code>gosu</code> ，可以从其<a href="https://github.com/tianon/gosu" target="_blank" rel="external">项目网站</a>看到进一步的信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</div><div class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</div><div class="line"># 下载 gosu</div><div class="line">RUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot; \</div><div class="line">    &amp;&amp; chmod +x /usr/local/bin/gosu \</div><div class="line">    &amp;&amp; gosu nobody true</div><div class="line"># 设置 CMD，并以另外的用户执行</div><div class="line">CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ]</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h2><ol><li><p>容器运行时应该尽量保持<code>容器存储层</code>不发生写操作, 对于像数据库这类需要保存动态数据的应用, 其数据库文件应该保存于<code>卷(volume)</code>中。</p></li><li><p>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在Dockerfile中, 可以事先指定某些目录挂载为匿名卷, 这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p></li><li><p>格式为: <code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></p></li><li><p><code>VOLUME /data</code> : 容器中的 “/data” 目录就会在运行时自动挂载为匿名卷, 任何向 /data 中写入的信息都不会记录进容器存储层。<br>当然，运行时可以覆盖这个挂载设置。比如:<code>docker run -d -v mydata:/data xxxx</code> 在这行命令中, 就使用了 mydata 这个命名卷挂载到了 /data 这个位置, 替代了 Dockerfile 中定义的匿名卷的挂载配置。</p></li></ol><h2 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h2><ol><li><p><code>EXPOSE</code>指令是声明运行时为容器提供的映射端口, 这<strong>只是一个声明, 并不会自动在宿主进行端口映射</strong>。</p></li><li><p>格式为:<code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p></li><li><p>在 Dockerfile 中写入这样的声明有两个好处</p><ul><li>一个是帮助镜像使用者理解这个镜像服务的守护端口, 以方便配置映射;</li><li>另一个用处则是在运行时使用随机端口映射时, 也就是 <code>docker run -P</code> 时, 会自动随机映射 <code>EXPOSE</code> 的端口。</li></ul></li><li><p>要将 <code>EXPOSE</code> 和 在运行时使用<code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来</p><ul><li><code>-p</code> 是映射宿主端口和容器端口, 换句话说, 就是将容器的对应端口服务公开给外界访问;</li><li>而 <code>EXPOSE</code> 仅仅是声明, 容器打算使用什么端口而已, <strong>并不会自动在宿主进行端口映射</strong>;</li></ul></li></ol><h2 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h2><ol><li><p><code>CMD</code> 指令的格式和 RUN 相似，也是两种格式:</p><ul><li>shell 格式: <code>CMD &lt;命令&gt;</code></li><li>exec 格式: <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li></ul></li><li><p>但是如果指定了 <code>ENTRYPOINT</code> 指令，用 CMD 指定的就是具体的参数 <code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。</p></li><li><p>Docker不是虚拟机, 容器就是进程, 那么在启动容器的时候, CMD 指令就是用于指定默认的容器主进程的启动命令的。</p><ul><li><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令<br>比如ubuntu镜像默认的CMD是<code>/bin/bash</code>, 如果我们直接 <code>docker run -it ubuntu</code> 的话, 会直接进入 bash ;<br>我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>, 这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了, 输出了系统版本信息。 </p></li><li><p>在指令格式上, 一般推荐使用 <code>exec</code> 格式, 这类格式在解析时会被解析为JSON数组，因此一定要使用双引号, 而不要使用单引号。</p></li><li><p>如果使用 shell 格式的话，实际的命令会被包装为<code>sh -c</code>的参数的形式进行执行。比如 <code>CMD echo $HOME</code> 在实际执行中，会将其变更为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code><br>这就是为什么我们可以使用环境变量的原因, 因为这些环境变量会被shell进行解析处理。</p></li></ul></li><li><p>Docker不是虚拟机, 容器中的应用都应该以前台执行, 而不是像虚拟机、物理机里面那样, 用 <code>upstart/systemd</code> 去启动后台服务, <strong>容器内没有后台服务的概念</strong>。</p><ul><li><p>一些初学者将 CMD 写为 <code>CMD service nginx start</code>, 然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。<br>这就是因为没有搞明白前台、后台的概念, 没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p></li><li><p>对于容器而言, 其启动程序就是容器应用进程, 容器就是为了主进程而存在的，主进程退出, 容器就失去了存在的意义, 从而退出, 其它辅助进程不是它需要关心的东西。<br>而使用 <code>service nginx start</code> 命令，则是希望upstart来以后台守护进程形式启动nginx服务, <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>, 因此主进程实际上是sh, 那么当 <code>service nginx start</code> 命令结束后, sh也就结束了, sh 作为主进程退出了, 自然就会令容器退出。</p></li><li><p>正确的做法是直接执行nginx可执行文件，并且要求以前台形式运行。比如: <code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code></p></li></ul></li></ol><h2 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h2><ol><li><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样, 都是在指定容器启动程序及参数。 </p><ul><li>ENTRYPOINT 在运行时也可以被替代, 不过比CMD要略显繁琐, 需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定;</li><li>当指定了 ENTRYPOINT 后, <strong>CMD 的含义就发生了改变</strong>, 不再是直接的运行其命令, 而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令, 换句话说实际执行时, 将变为:<code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code></li></ul></li><li><p><code>ENTRYPOINT</code> 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。</p></li><li><p>有了<code>CMD</code>后, 为什么还要有<code>ENTRYPOINT</code>? 这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处? <a href="https://yeasy.gitbooks.io/docker_practice/content/image/dockerfile/entrypoint.html" target="_blank" rel="external">参考书中</a></p><ul><li>场景一：让镜像变成像命令一样使用</li><li>场景二：应用运行前的准备工作</li></ul></li></ol><h2 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h2><ol><li><p>和RUN指令一样, 也有两种格式:</p><ul><li><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li></ul></li><li><p>COPY 指令将从 <code>构建上下文目录</code> 中 <code>&lt;源路径&gt;</code>目录/ 复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如:<code>COPY package.json /usr/src/app/</code></p><ul><li>&lt;源路径&gt; 可以是多个, 甚至可以是通配符</li><li>&lt;目标路径&gt; 可以是容器内的绝对路径, 也可以是相对于工作目录的相对路径(工作目录可以用 <code>WORKDIR</code> 指令来指定)。</li><li>目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</li></ul></li><li><p>此外, 还需要注意一点, 使用 COPY 指令, 源文件的各种元数据都会保留。比如读、写、执 行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p></li></ol><h2 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h2><ol><li><p><code>ADD</code> 指令 和 <code>COPY</code> 的格式和性质基本一致, 但是在 COPY 基础上增加了一些功能:</p><ul><li><p>比如 &lt;源路径&gt; 可以是一个 URL , 这种情况下, Docker 引擎会试图去下载这个链接的文件放 到 &lt;目标路径&gt; 去, 下载后的文件权限自动设置为 600 , 如果这并不是想要的权限, 则需要增加额外的一层 RUN 进行权限调整<br>另外, 如果下载的是个压缩包, 需要解压缩, 也一样, 还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令, 然后使用 wget 或 者 curl 工具下载, 处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并 不实用，而且不推荐使用。</p></li><li><p>如果 &lt;源路径&gt; 为一个tar压缩文件的话,压缩格式为 gzip , bzip2 以及 xz 的情况下, ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去<br>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。</p></li></ul></li><li><p>在 Docker 官方的最佳实践文档中要求，尽可能的使用 COPY ，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。<strong>最适合使用ADD 的场合，就是所提及的需要自动解压缩的场合</strong>。</p></li><li><p>另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD 。</p></li></ol><h2 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h2><h2 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h2><ol><li><p>格式：<code>ONBUILD &lt;其它指令&gt;</code></p></li><li><p><code>ONBUILD</code> 是一个特殊的指令, 它后面跟的是其它指令, 比如 RUN, COPY 等, 而这些指令, 在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像, 去构建下一级镜像的时候才会被执行。</p></li><li><p>Dockerfile 中的其它指令都是为了定制当前镜像而准备的, 唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p></li><li><p>假设我们要制作Node.js所写的应用的镜像, 我们都知道Node.js使用npm进行包管理, 所有依赖、配置、启动信息等会放到package.json文件里。</p><ul><li>在拿到程序代码后, 需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。</li><li><p>然后就可以通过 <code>npm start</code> 来启动应用, 因此, 一般来说会这样写 Dockerfile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FROM node:slim</div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">COPY ./package.json /app</div><div class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ]</div><div class="line">COPY . /app/</div><div class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</div></pre></td></tr></table></figure></li><li><p>把这个 Dockerfile 放到 Node.js 项目的根目录, 构建好镜像后, 就可以直接拿来启动容器运行。</p></li></ul></li><li><p>但是如果我们还有第二个 Node.js 项目也差不多呢？好吧, 那就再把这个Dockerfile复制到第二个项目里。那如果有第三个项目呢?再复制么?文件的副本越多,版本控制就越困难,让我们继续看这样的场景维护的问题。</p><ul><li>如果第一个Node.js项目在开发过程中, 发现这个Dockerfile里存在问题,比如敲错字了、或者需要安装额外的包, 然后开发人员修复了这个 Dockerfile, 再次构建, 问题解决。</li><li>第一个项目没问题了,但是第二个项目呢?虽然最初 Dockerfile 是复制、粘贴自第一个项目的,但是并不会因为第一个项目修复了 Dockerfile, 而第二个项目的 Dockerfile 就会被自动修复。</li></ul></li><li><p>那么我们可不可以做一个基础镜像, 然后各个项目使用这个基础镜像呢? 这样基础镜像更新, 各个项目不用同步Dockerfile的变化, 重新构建后就继承了基础镜像的更新?</p><ul><li><p>其实是可以的, 那么上面的这个 Dockerfile 就会变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FROM node:slim</div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</div></pre></td></tr></table></figure></li><li><p>这里我们把项目相关的构建指令拿出来, 放到子项目里去。假设这个基础镜像的名字为my-node的话, 各个项目内的自己的 Dockerfile 就变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FROM my-node</div><div class="line">COPY ./package.json /app</div><div class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ]</div><div class="line">COPY . /app/</div></pre></td></tr></table></figure><p>基础镜像变化后, 各个项目都用这个 Dockerfile 重新构建镜像, 会继承基础镜像的更新。</p></li></ul></li><li><p>此时问题只解决了一半, 如果这个Dockerfile里面有些东西需要调整, 比如 npm install 都需要加一些参数, 那怎么办?</p><ul><li>这一行 RUN 是不可能放入基础镜像的, 因为涉及到了当前项目的 ./package.json, 难道又要一个个修改么?</li><li>所以说, 这样制作基础镜像, 只解决了原来的 Dockerfile 的前4条指令的变化问题, 而后面三条指令的变化则完全没办法处理。</li></ul></li><li><p><code>ONBUILD</code> 可以解决这个问题, 用ONBUILD重新写一下基础镜像的 Dockerfile:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FROM node:slim</div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">ONBUILD COPY ./package.json /app</div><div class="line">ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]</div><div class="line">ONBUILD COPY . /app/</div><div class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</div></pre></td></tr></table></figure></li></ol><p>这次我们回到原始的 Dockerfile，但是这次将项目相关的指令加上 ONBUILD，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 Dockerfile 就变成了简单地：<code>FROM my-node</code>, 只有这么一行。<br>当在各个项目目录中, 用这个只有一行的 Dockerfile 构建镜像时, 之前基础镜像的那三行 ONBUILD 就会开始执行, 成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>, 生成应用镜像。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FROM-指定基础镜像&quot;&gt;&lt;a href=&quot;#FROM-指定基础镜像&quot; class=&quot;headerlink&quot; title=&quot;FROM 指定基础镜像&quot;&gt;&lt;/a&gt;FROM 指定基础镜像&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;所谓定制镜像, &lt;strong&gt;是以一个镜像为基础, 在
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>04.定制镜像 - Dockerfile脚本</title>
    <link href="http://blog.renyimin.com/2017/10/12/docker/2017-10-12-04-docker/"/>
    <id>http://blog.renyimin.com/2017/10/12/docker/2017-10-12-04-docker/</id>
    <published>2017-10-12T15:05:07.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Dockerfile定制镜像"><a href="#使用Dockerfile定制镜像" class="headerlink" title="使用Dockerfile定制镜像"></a>使用Dockerfile定制镜像</h2><ol><li><p>通过之前<code>docker commit</code>的学习了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 <code>Dockerfile</code>。</p></li><li><p>Dockerfile是一个文本文件，其内包含了一条条的指令, <strong>每一条指令构建一层</strong>，因此每一条指令的内容，就是描述该层应当如何构建。</p></li><li><p>在使用Dockerfile脚本定制镜像时, 有很多指令可以使用;</p></li></ol><h2 id="Dockerfile指令详解"><a href="#Dockerfile指令详解" class="headerlink" title="Dockerfile指令详解"></a>Dockerfile指令详解</h2><p>参考下一篇博文<a href="/2017/10/13/2017-10-13-05-docker/">05.Dockerfile指令详解</a></p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>1.还以之前定制 nginx 镜像为例，下面使用Dockerfile来定制</p><ul><li><p>在一个空白目录中，建立一个文本文件，并命名为 Dockerfile, 其内容为如下:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FROM nginx</div><div class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</div></pre></td></tr></table></figure></li><li><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code></p></li></ul><p>2.在 Dockerfile 文件所在目录执行</p><ul><li><p>从命令的输出结果如下</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:image_build renyimin$ docker build -t nginx:v5 .</div><div class="line">Sending build context to Docker daemon  2.048kB</div><div class="line">Step 1/2 : FROM nginx</div><div class="line"> ---&gt; e548f1a579cf</div><div class="line">Step 2/2 : RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</div><div class="line"> ---&gt; Running in 5dc1025063e7</div><div class="line"> ---&gt; 65c15ffa7c7c</div><div class="line">Removing intermediate container 5dc1025063e7</div><div class="line">Successfully built 65c15ffa7c7c</div><div class="line">Successfully tagged nginx:v5</div><div class="line">renyimindeMacBook-Pro:image_build renyimin$</div></pre></td></tr></table></figure></li><li><p>可以看到镜像的构建过程: 在Step2中, RUN指令重新启动了一个容器 <code>5dc1025063e7</code>，执行了所要求的命令，并最后提交了新的层 <code>65c15ffa7c7c</code>, 随后删除了所用到的容器<code>5dc1025063e7</code></p></li></ul><p>3.这里我们使用了 <code>docker build</code> 命令进行镜像构建, 其格式为: <code>docker build [选项] &lt;上下文路径/URL/-&gt;</code></p><ul><li>在这里我们指定了最终镜像的名称 <code>-t nginx:v5</code>，构建成功后, <code>docker images</code> 就会看到这个新镜像  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:image_build renyimin$ docker images</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">nginx                                                 v5                  65c15ffa7c7c        5 minutes ago       109MB</div></pre></td></tr></table></figure></li></ul><p>4.启动这个新镜像: <code>docker run -d -p 8098:80 --name nginx_v5 nginx:v5</code></p><ul><li><p>执行过程</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:image_build renyimin$ docker run -d -p 8098:80 --name nginx_v5 nginx:v5</div><div class="line">247dfedcf52c3cbfd652302a8f2226274661cea77200092b54044d37e0a2ae25</div><div class="line">renyimindeMacBook-Pro:image_build renyimin$ </div><div class="line">renyimindeMacBook-Pro:image_build renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</div><div class="line">247dfedcf52c        nginx:v5            &quot;nginx -g &apos;daemon ...&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8098-&gt;80/tcp     nginx_v5</div><div class="line">d762abfc1ab6        nginx:latest        &quot;nginx -g &apos;daemon ...&quot;   8 minutes ago       Up 8 minutes        0.0.0.0:8090-&gt;80/tcp     nginx_l</div><div class="line">0e7070854958        registry            &quot;/entrypoint.sh /e...&quot;   2 days ago          Up 39 hours         0.0.0.0:5000-&gt;5000/tcp   registry</div><div class="line">renyimindeMacBook-Pro:image_build renyimin$</div></pre></td></tr></table></figure></li><li><p>对比定制前后<br><img src="/img/docker/dockerfile_test_01.png" width="400/"></p></li></ul><h3 id="镜像构建上下文-Context"><a href="#镜像构建上下文-Context" class="headerlink" title="镜像构建上下文(Context)"></a>镜像构建上下文(Context)</h3><p>上面在构建镜像时, 如果注意, 会看到 <code>docker build</code> 命令最后有一个 <code>.</code>, 表示当前目录, 而 <code>Dockerfile</code> 就在当前目录, 因此不少初学者以为这个路径是在指定Dockerfile所在的路径, 但这么理解其实是不准确的。<br>这是在指定<code>上下文路径</code>, 那么什么是上下文呢?</p><ol><li><p>首先我们要理解 <code>docker build</code> 的工作原理</p><ul><li><p>Docker 在运行时分为<code>Docker引擎</code>(也就是服务端守护进程)和<code>客户端工具</code>;</p></li><li><p>Docker 的引擎提供了一组REST API, 被称为Docker Remote API, 而如docker命令这样的客户端工具, 则是通过这组 API 与 Docker 引擎交互, 从而完成各种功能, 因此, 虽然表面上我们好像是在本机执行各种docker功能, 但实际上, 一切都是使用的远程调用形式在服务端(Docker 引擎)完成。<br>也因为这种C/S设计, 让我们操作远程服务器的 Docker 引擎变得轻而易举。</p></li></ul></li><li><p>当我们进行镜像构建的时候, 并非所有定制都会通过RUN指令完成, <strong>经常会需要将一些主机本地文件复制进镜像</strong>, 比如通过<code>COPY</code>、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像, 其实并非在本地构建, 而是在服务端, 也就是Docker引擎中构建的。那么在这种客户端/服务端的架构中, 如何才能让服务端获得本地文件呢?</p></li><li><p>这就引入了上下文的概念, 当构建的时候, 用户会指定构建镜像上下文的路径, <code>docker build</code> 命令得知这个路径后, 会将路径下的所有内容打包, 然后上传给Docker引擎。这样 Docker 引擎收到这个上下文包后, 展开就会获得构建镜像所需的一切文件。</p></li><li><p>如果在 Dockerfile 中 <code>COPY ./package.json</code> 这么写:</p><ul><li>这并不是要复制你执行 <code>docker build</code> 命令时, 所在的目录下的 package.json, 也不是复制 Dockerfile 所在目录下的 package.json, 而是复制上下文(context)目录下的 package.json</li><li><strong>COPY 这类指令中的源文件的路径都是相对上下文路径的</strong></li></ul></li><li><p>理解构建上下文对于镜像构建是很重要的, 避免犯一些不应该的错误, 比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后, 于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建, 结果发现 <code>docker build</code> 执行后, 在发送一个几十GB的东西, 极为缓慢而且很容易构建失败(因为这种做法是在让 docker build 打包整个硬盘, 这显然是使用错误)。</p></li><li><p>一般来说, 应该将 <code>Dockerfile</code> 置于一个空目录下, 或者项目根目录下。</p><ul><li>如果该目录下没有所需文件, 那么应该把所需文件复制一份过来。</li><li>如果目录下有些东西确实不希望构建时传给 Docker 引擎, 那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>, 该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</li></ul></li><li><p>那么为什么会有人误以为 <code>.</code> 是指定 Dockerfile 所在目录呢?</p><ul><li>这是因为在默认情况下, 如果不额外指定 Dockerfile 的话, 会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。</li><li>这只是默认行为, 实际上Dockerfile的文件名并不要求必须为Dockerfile, 而且并不要求 必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为Dockerfile。</li></ul></li></ol><p>参考 : <a href="https://yeasy.gitbooks.io/docker_practice/content/image/commit.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/image/commit.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用Dockerfile定制镜像&quot;&gt;&lt;a href=&quot;#使用Dockerfile定制镜像&quot; class=&quot;headerlink&quot; title=&quot;使用Dockerfile定制镜像&quot;&gt;&lt;/a&gt;使用Dockerfile定制镜像&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通过之前&lt;
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>03.定制镜像 - docker commit手动定制</title>
    <link href="http://blog.renyimin.com/2017/10/12/docker/2017-10-12-03-docker/"/>
    <id>http://blog.renyimin.com/2017/10/12/docker/2017-10-12-03-docker/</id>
    <published>2017-10-12T13:50:07.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>镜像是容器的基础, 每次执行 <code>docker run</code> 的时候都会指定哪个镜像作为容器运行的基础。<br>在之前的例子中, 我们所使用的都是来自于 Docker Hub 的镜像, 直接使用这些镜像是可以满足一定的需求, 而当这些镜像无法直接满足需求时, 我们就需要<strong>定制这些镜像</strong>。</p><h2 id="docker-commit-手动定制镜像"><a href="#docker-commit-手动定制镜像" class="headerlink" title="docker commit 手动定制镜像"></a><code>docker commit</code> 手动定制镜像</h2><p>1.当运行一个容器的后(如果不使用<code>数据卷</code>的话), 你所做的任何文件修改都会被记录于<code>容器存储层</code>里</p><ul><li>如果改动了容器的存储层, 我们可以通过 <code>docker diff</code> 命令看到具体的改动</li><li>但是如果改动的是数据卷挂载到容器对应目录下的内容, <code>docker diff</code> 看不到具体的改动</li></ul><p>2.注意: 容器存储层的生存周期和容器一样, 容器被删除后, 存储层中的内容也就会被删除掉, 而不会保留到镜像中。</p><p>3.Docker提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像</p><ul><li>换句话说，就是在原有镜像的基础上，<strong>再叠加上容器的存储层，并构成新的镜像</strong></li><li>以后我们运行这个新镜像的时候, 就会拥有原有容器最后的文件变化</li></ul><p>4.docker commit 的语法格式为: <code>docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</code>, 如下:</p><ul><li>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker commit --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; --message &quot;修改了默认网页&quot; webserver nginx:v2</div></pre></td></tr></table></figure></li></ul><h3 id="手动定制镜像-挂载数据卷问题"><a href="#手动定制镜像-挂载数据卷问题" class="headerlink" title="手动定制镜像~~挂载数据卷问题"></a>手动定制镜像~~挂载数据卷问题</h3><p>1.之前已经配置了docker中国加速镜像, 现在通过<code>git pull nginx</code>获取一个<a href="https://hub.docker.com/_/nginx/" target="_blank" rel="external">nginx基础镜像</a>;</p><p>2.直接运行这个nginx基础镜像为一个容器(由于该镜像非常基础,甚至没有像vi的工具,因此在启动时可以将nginx的项目根目录<code>/usr/share/nginx/html</code>映射出来, 以便于测试)</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 8088:80 --mount type=bind,source=/Users/renyimin/Desktop/nginx_test,target=/usr/share/nginx/html --name nginx_test nginx</div><div class="line">1c39a78311e579482a2334347f80ba479555097d869a1254a27c9ac581c13eed</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</div><div class="line">1c39a78311e5        nginx               &quot;nginx -g &apos;daemon ...&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8088-&gt;80/tcp   nginx_test</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></code></pre><p>3.通过 <code>localhost:8088</code> 会看到nginx的欢迎界面<br><img src="/img/docker/nginx_test_01.png" width="300/"></p><p>4.现在，假设需要更改欢迎界面文字(本应该使用 <code>docker exec -it nginx_test /bin/sh</code> 命令进入容器修改其内容, 但后来发现该进行非常基础,很多基础工具如vi都没有, 所以最终采用挂载主机目录方式启动, 然后在主机新增一个index.html文件)<br><img src="/img/docker/nginx_test_02.png" width="300/"></p><p>5.之后直接刷新浏览器的话，会发现内容被改变了<br><img src="/img/docker/nginx_test_03.png" width="300/"></p><p>6.现在修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动, 你会发现自己的改动并没有体现出来, 其实这主要是因为<strong>你将目录挂载出来了</strong>, 如果不是挂载出来,而是直接在容器中修改的话, 则会体现出来</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker diff nginx_test</div><div class="line">C /run</div><div class="line">A /run/nginx.pid</div><div class="line">C /var/cache/nginx</div><div class="line">A /var/cache/nginx/client_temp</div><div class="line">A /var/cache/nginx/fastcgi_temp</div><div class="line">A /var/cache/nginx/proxy_temp</div><div class="line">A /var/cache/nginx/scgi_temp</div><div class="line">A /var/cache/nginx/uwsgi_temp</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></code></pre><p>7.当运行一个容器的时候(如果不使用卷的话)，我们做的任何文件修改都会被记录于<strong>容器存储层里</strong>, 可以使用 <code>docker diff</code> 命令看到容器存储层中的变动, 但是如果使用了数据卷, 则挂载目录中的改动无法体现出来;</p><h3 id="手动定制镜像-实验"><a href="#手动定制镜像-实验" class="headerlink" title="手动定制镜像~~实验"></a>手动定制镜像~~实验</h3><p>1.既然数据卷中的内容无法使用<code>docker diff</code>来查看差异, 我们可以将index.html文件复制到容器的<code>/home</code>下, 然后使用 <code>docker diff</code> 命令就可以看到容器存储层中的改动</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker diff nginx_test</div><div class="line">C /home</div><div class="line">A /home/index.html</div><div class="line">C /run</div><div class="line">A /run/nginx.pid</div><div class="line">C /var/cache/nginx</div><div class="line">A /var/cache/nginx/client_temp</div><div class="line">A /var/cache/nginx/fastcgi_temp</div><div class="line">A /var/cache/nginx/proxy_temp</div><div class="line">A /var/cache/nginx/scgi_temp</div><div class="line">A /var/cache/nginx/uwsgi_temp</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></code></pre><p>2.<code>docker commit --author &#39;renyimin&#39; --message &quot;在/home下添加了一个index.html文件&quot; nginx_test nginx:v1</code></p><p>3.<code>docker images</code> 可以看到这个新定制的镜像</p><p>4.我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 nginx:v1 的历史记录，我们会发现新增了我们刚刚提交的这一层</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:Desktop renyimin$ docker history nginx:v1</div><div class="line">IMAGE               CREATED              CREATED BY                                      SIZE                COMMENT</div><div class="line">fe3e3a4c47b8        About a minute ago   nginx -g daemon off;                            1.4MB               在/home下添加了一个index.html文件</div><div class="line">e548f1a579cf        8 days ago           /bin/sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daem...   0B                  </div><div class="line">&lt;missing&gt;           8 days ago           /bin/sh -c #(nop)  STOPSIGNAL [SIGTERM]         0B                  </div><div class="line">&lt;missing&gt;           8 days ago           /bin/sh -c #(nop)  EXPOSE 80/tcp                0B                  </div><div class="line">.....</div><div class="line">.....</div><div class="line">renyimindeMacBook-Pro:Desktop renyimin$</div></pre></td></tr></table></figure></code></pre><p>5.新的镜像定制好后，就可以来运行这个镜像</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker run -d -p 8089:80 --name nginx_v1 nginx:v1</div><div class="line">d5d17a25cc35837c64f446a6623afa0a23b6c543593276979ebb7c5ced1e7e1d</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</div><div class="line">d5d17a25cc35        nginx:v1            &quot;nginx -g &apos;daemon ...&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8089-&gt;80/tcp   nginx_v1</div><div class="line">785d252f5c94        nginx               &quot;nginx -g &apos;daemon ...&quot;   4 minutes ago       Up 3 minutes        0.0.0.0:8088-&gt;80/tcp   nginx_test</div><div class="line">// 会发现使用新的镜像启动容器后, 容器中的/home目录下包含我们提交的index.html个文件, 当然, localhost:8089和localhost:8088不同, 8089访问的还是默认欢迎页</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker exec -it nginx_v1 /bin/sh</div><div class="line"># cd /home</div><div class="line"># ls</div><div class="line">index.html</div><div class="line">#</div></pre></td></tr></table></figure></code></pre><blockquote><p>至此，我们第一次完成了定制镜像，使用的是 <code>docker commit</code> 命令，<strong>手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉</strong>。</p></blockquote><h2 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用 docker commit"></a>慎用 docker commit</h2><p>使用 docker commit 命令虽然可以比较直观的帮助理解镜像分层存储的概念, <strong>但是实际环境中并不会这样使用</strong>。<br>1.首先，如果仔细观察之前的 <code>docker diff nginx_test</code> 的结果，你会发现除了真正想要的 /home/index.html 文件外，由于命令的执行，还有很多文件被改动或添加了。<br>这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。</p><p>2.此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是<strong>黑箱操作</strong>，生成的镜像也被称为<strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 docker diff 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p><p>3.而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 docker commit 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p><p>4.可以结合<a href="/2017/10/17/2017-10-17-07-docker/#构建镜像">07.镜像/容器 – 导入导出</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;镜像是容器的基础, 每次执行 &lt;code&gt;docker run&lt;/code&gt; 的时候都会指定哪个镜像作为容器运行的基础。&lt;br&gt;在之前的例子
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>02.镜像 - 基础</title>
    <link href="http://blog.renyimin.com/2017/10/12/docker/2017-10-12-02-docker/"/>
    <id>http://blog.renyimin.com/2017/10/12/docker/2017-10-12-02-docker/</id>
    <published>2017-10-12T11:40:07.000Z</published>
    <updated>2018-03-13T12:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>镜像(Image)和容器(Container)的关系，就像是面向对象程序设计中的类和实例一样, 镜像是静态的定义, 容器是镜像运行时的实体。<br>所以 Docker 运行容器前首先需要本地存在对应的镜像, 如果本地不存在该镜像, Docker 会从镜像仓库下载该镜像。</p><h2 id="镜像的获取"><a href="#镜像的获取" class="headerlink" title="镜像的获取"></a>镜像的获取</h2><p><a href="https://hub.docker.com/explore/" target="_blank" rel="external">Docker Hub</a>上有大量的高质量的镜像可以用, 如何获取这些镜像呢?</p><p>1.从Docker镜像仓库获取镜像的命令是 <code>docker pull</code>, 其命令格式为：<code>docker pull [选项] [Docker Registry地址[:端口号]/]仓库名[:标签]</code></p><ul><li>docker pull命令的具体选项可以通过 <code>docker pull --help</code> 命令看到</li><li>镜像名称的格式:<br><strong>Docker镜像仓库地址</strong>: 地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code> (默认地址是 Docker Hub 仓库地址)<br><strong>仓库名</strong>: 仓库名是<strong>两段式名称</strong>, 即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code> (对于 Docker Hub, 如果不给出用户名, 则默认为 library, 也就是官方镜像。)</li><li>比如 <code>$ docker pull ubuntu:16.04</code>: 由于没有给出Docker镜像仓库地址, 因此将会从Docker Hub获取镜像, 而镜像名称是 <code>ubuntu:16.04</code>(没有用户名), 因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>16.04</code> 的镜像;</li></ul><p>2.另外, 如果从 Docker Hub 下载镜像非常缓慢，可以 配置镜像加速器。</p><h2 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h2><p>1.国内从 Docker Hub 拉取镜像有时会遇到困难, 此时可以配置镜像加速器, Docker 官方和国内很多云服务商都提供了<strong>国内加速器服务</strong>, 例如:</p><ul><li><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror" target="_blank" rel="external">Docker 官方提供的中国 registry mirror</a></li><li><a href="https://cr.console.aliyun.com/?accounttraceid=d520cfad-1577-4905-91cd-09aa8b4964cd#/imageSearch" target="_blank" rel="external">阿里云加速器</a></li><li><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="external">DaoCloud 加速器</a></li></ul><p>2.此处以 Docker 官方加速器为例进行介绍(由于本人使用macOS系统,下面只列出macOS上如何配置镜像加速器, 其他系统请<a href="https://yeasy.gitbooks.io/docker_practice/content/install/mirror.html" target="_blank" rel="external">参考</a>)</p><ul><li>在任务栏点击<code>Docker for mac</code> 应用图标 -&gt; <code>Perferences</code>… -&gt; <code>Daemon</code> -&gt; <code>Registry mirrors</code></li><li>在列表中填写加速器地址即可, 修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像地址了</li></ul><p>3.如果在添加加速器地址后出现 <code>registry-mirrors no certs for egistry.docker-....</code><br><img src="/img/docker/jiasuqi-error-macOS.png" width="300">  </p><p>4.网上查找资料后, <a href="https://yq.aliyun.com/articles/29941" target="_blank" rel="external">有人说是证书问题</a>, 尝试修改https为http后正常<br><img src="/img/docker/jiasuqi-macOS.png" width="300"> </p><p>5.检查加速器是否生效</p><ul><li>配置加速器之后,如果拉取镜像仍然十分缓慢,请手动检查加速器配置是否生效,在命令行执行 <code>docker info</code></li><li>由于我配置的是docker hub提供的中国镜像站点, 所以如果从结果中看到了如下内容，说明配置成功(你看到的可能和我的不一样)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Registry Mirrors:</div><div class="line">http://registry.docker-cn.com/</div><div class="line">//如果添加了多个加速站点, 此处也会有多个</div></pre></td></tr></table></figure></li></ul><h2 id="镜像相关基础操作"><a href="#镜像相关基础操作" class="headerlink" title="镜像相关基础操作"></a>镜像相关基础操作</h2><h3 id="列出已存在镜像"><a href="#列出已存在镜像" class="headerlink" title="列出已存在镜像"></a>列出已存在镜像</h3><p>1.<code>docker images</code>：列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>;</p><p>2.虽然 <code>镜像ID</code> 是镜像的唯一标识, 但是一个镜像可以打包出多个不同标签的镜像 (所以有些镜像的ID一样, 但是tag会不一样);</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">renyimindeMacBook-Pro:testVip renyimin$ docker images</div><div class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">127.0.0.1:5000/registry                               latest              d1fd7d86a825        7 weeks ago         33.3MB</div><div class="line">registry                                              latest              d1fd7d86a825        7 weeks ago         33.3MB</div><div class="line">renyimindeMacBook-Pro:testVip renyimin$</div></pre></td></tr></table></figure></code></pre><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>如果要删除本地的镜像, 可以使用 <code>$ docker image rm [选项] &lt;镜像名1&gt; [&lt;镜像名2&gt; ...]</code> 命令; (因为镜像ID可能会一样, 所以删除镜像用的是镜像名)</p><h3 id="镜像更名"><a href="#镜像更名" class="headerlink" title="镜像更名"></a>镜像更名</h3><p>镜像更改名称也很简单, 直接 <code>$ docker tag 镜像名 新镜像名:标签</code></p><p>在 Docker 1.13+ 版本中推荐使用 <code>docker image</code> 来管理镜像。 (比如 <code>docker image ls</code> 会列出所有镜像);</p><h2 id="理解分层存储"><a href="#理解分层存储" class="headerlink" title="理解分层存储"></a>理解分层存储</h2><p>1.严格来说，镜像并非是像一个ISO那样的打包文件, 镜像只是一个虚拟的概念, 其实际体现并非由一个文件组成, 而是由一组文件系统组成, 或者说, 由<code>多层文件系统</code>联合组成。</p><p>2.镜像是多层存储，每一层是在前一层的基础上进行的修改; 而容器同样也是多层存储，是在以镜像为基础层，<strong>在其基础上加一层作为容器运行时的存储层</strong>。</p><p>3.镜像构建时, 会一层层构建, 前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p><p>4.<strong>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡, 这里的消亡是指容器被删除, 而不是stop容器, stop容器后, 容器中发生的改变不会被忽略, 除非容器被删除掉</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;镜像(Image)和容器(Container)的关系，就像是面向对象程序设计中的类和实例一样, 镜像是静态的定义, 容器是镜像运行时的实体。
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>01.认识Docker</title>
    <link href="http://blog.renyimin.com/2017/10/12/docker/2017-10-12-01-docker/"/>
    <id>http://blog.renyimin.com/2017/10/12/docker/2017-10-12-01-docker/</id>
    <published>2017-10-12T11:30:41.000Z</published>
    <updated>2018-03-13T12:45:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p><code>Docker</code>使用Google公司推出的Go语言实现; 属于<strong>操作系统层面的虚拟化技术</strong>; 也称其为容器; </p></li><li><p>docker 和 传统虚拟机技术 对比</p></li></ol><ul><li><p>传统虚拟机技术是: 虚拟出一套硬件后; 在其上运行一个完整操作系统; 最后在该系统上再运行所需应用进程;</p></li><li><p>而容器内的应用进程直接运行于宿主的内核, 容器内没有自己的内核, 而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便;</p></li><li><p>如下图, 可以看到有<code>应用A</code>和<code>应用B</code>两个应用, 相比于传统虚拟技术, docker少了<code>Hypervisor</code>(所有虚拟化技术的核心)和<code>Guest OS</code>这两层<br>  <img src="/img/docker/docker-vs-virtualmachines.png" width="600"></p></li></ul><h2 id="为什么使用docker"><a href="#为什么使用docker" class="headerlink" title="为什么使用docker?"></a><a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/why.html" target="_blank" rel="external">为什么使用docker?</a></h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势</p><h3 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h3><p>由于容器不需要进行 <code>硬件虚拟</code> 以及 <code>运行完整操作系统</code> 等额外开销, 所以其实<strong>Docker对系统资源的利用率更高</strong>。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。<br>因此，相比虚拟机技术，<strong>一个相同配置的主机，往往可以运行更多数量的应用</strong>。</p><h3 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h3><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，<strong>由于直接运行于宿主内核，无需启动完整的操作系统</strong>，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h3 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h3><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。<br>而 Docker 的镜像提供了<strong>除内核外完整的运行时环境</strong>，确保了应用运行环境一致性，从而不会再出现 <code>「这段代码在我机器上没问题啊」</code> 这类问题。</p><p>更多好处请参考(<a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/why.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/introduction/why.html</a>)</p><h2 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h2><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">容器</th><th style="text-align:center">虚拟机</th></tr></thead><tbody><tr><td style="text-align:center">启动</td><td style="text-align:center">秒级</td><td style="text-align:center">分钟级</td></tr><tr><td style="text-align:center">硬盘使用</td><td style="text-align:center">一般为MB</td><td style="text-align:center">一般为GB</td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">接近原生</td><td style="text-align:center">弱于原生</td></tr><tr><td style="text-align:center">系统支持量</td><td style="text-align:center">单机支持上千个容器</td><td style="text-align:center">一般几十个</td></tr></tbody></table><h2 id="Docker三个基本概念"><a href="#Docker三个基本概念" class="headerlink" title="Docker三个基本概念"></a>Docker三个基本概念</h2><p>理解了这三个概念，就理解了 Docker 的整个生命周期</p><h3 id="镜像-Image"><a href="#镜像-Image" class="headerlink" title="镜像 (Image)"></a><a href="/2017/10/12/2017-10-12-02-docker/">镜像 (Image)</a></h3><h3 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器 (Container)"></a>容器 (Container)</h3><h3 id="仓库-Repository"><a href="#仓库-Repository" class="headerlink" title="仓库 (Repository)"></a>仓库 (Repository)</h3><blockquote><p><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">《Docker从入门到实践》</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt;使用Google公司推出的Go语言实现; 属于&lt;strong&gt;操作系统层面的虚拟化技
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.renyimin.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.renyimin.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>70. 查询性能优化</title>
    <link href="http://blog.renyimin.com/2017/09/27/mysql/2017-09-27-mysql-70/"/>
    <id>http://blog.renyimin.com/2017/09/27/mysql/2017-09-27-mysql-70/</id>
    <published>2017-09-27T12:50:37.000Z</published>
    <updated>2018-03-08T06:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前已经了解了<code>索引优化</code>的相关内容, 它对于高性能是必不可少的, 但还不够, 还需要<code>合理设计查询</code>;</p><ul><li>如果查询写的很糟糕, 即使库表结构再合理, 索引再合适, 也无法实现高性能;</li><li>查询优化, 库表结构优化, 索引优化需要齐头并进, 一个不落;</li></ul><h2 id="慢查询基础"><a href="#慢查询基础" class="headerlink" title="慢查询基础"></a>慢查询基础</h2><h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><ul><li>确认应用程序是否在检索大量超过需要的数据, 你可能访问了太多的行, 也可能是太多的列;<br>比如: 总是返回全部的列; 只展示5条数据,你却查出100条;</li><li>确认<code>MySQL服务器层</code>是否在分析大量超过需要的数据行; (注意: 索引是在存储引擎层, 一旦服务器层分析的数据过多, 可能你的索引不太合适, 没有在存储引擎层过滤掉数据)<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>未完待续~~</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前已经了解了&lt;code&gt;索引优化&lt;/code&gt;的相关内容, 它对于高性能是必不可少的, 但还不够, 还需要&lt;code&gt;合理设计查询&lt;/co
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="查询性能优化" scheme="http://blog.renyimin.com/tags/%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>50. EXPLAIN 分析</title>
    <link href="http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-50/"/>
    <id>http://blog.renyimin.com/2017/09/25/mysql/2017-09-25-mysql-50/</id>
    <published>2017-09-25T13:23:08.000Z</published>
    <updated>2018-03-16T06:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `user_info` (</div><div class="line">  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,</div><div class="line">  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">  `age`  INT(11) DEFAULT NULL,</div><div class="line">  PRIMARY KEY (`id`),</div><div class="line">  KEY `name_index` (`name`)</div><div class="line">) ENGINE = InnoDB, DEFAULT CHARSET = utf8;</div><div class="line"></div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);</div><div class="line">INSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);</div><div class="line"></div><div class="line">CREATE TABLE `order_info` (</div><div class="line">  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,</div><div class="line">  `user_id`      BIGINT(20)           DEFAULT NULL,</div><div class="line">  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">  `productor`    VARCHAR(30)          DEFAULT NULL,</div><div class="line">  PRIMARY KEY (`id`),</div><div class="line">  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</div><div class="line">)ENGINE = InnoDB,</div><div class="line">DEFAULT CHARSET = utf8;</div><div class="line"></div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);</div><div class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);</div></pre></td></tr></table></figure></code></pre><h2 id="EXPLAIN-输出"><a href="#EXPLAIN-输出" class="headerlink" title="EXPLAIN 输出"></a>EXPLAIN 输出</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from user_info where id = 2;</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref   | rows | Extra |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">|  1 | SIMPLE      | user_info | const | PRIMARY       | PRIMARY | 8       | const |    1 | NULL  |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></code></pre><h2 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h2><ol><li><p>select_type 表示了查询的类型, 它的常用取值有:</p><ul><li><code>SIMPLE</code>, 表示此查询不包含 UNION 查询或子查询 (最常见的查询类别就是 <code>SIMPLE</code> 了)</li><li><code>PRIMARY</code>, 表示此查询是最外层的查询</li><li><code>UNION</code>, 表示此查询是 UNION 的第二或随后的查询</li><li><code>DEPENDENT UNION</code>, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li><code>UNION RESULT</code>, UNION 的结果</li><li><code>SUBQUERY</code>, 子查询中的第一个 SELECT</li><li><code>DEPENDENT SUBQUERY</code>: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li></ul></li><li><p>如果使用了<code>UNION</code>查询, 那么EXPLAIN 输出结果类似如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN ( SELECT * FROM user_info WHERE id IN ( 1, 2, 3 ) ) UNION</div><div class="line">( SELECT * FROM user_info WHERE id IN ( 3, 4, 5 ) );</div><div class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</div><div class="line">| id   | select_type  | table      | type  | possible_keys | key     | key_len | ref  | rows | Extra           |</div><div class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</div><div class="line">|    1 | PRIMARY      | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where     |</div><div class="line">|    2 | UNION        | user_info  | range | PRIMARY       | PRIMARY | 8       | NULL |    3 | Using where     |</div><div class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | ALL   | NULL          | NULL    | NULL    | NULL | NULL | Using temporary |</div><div class="line">+------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></li></ol><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><ol><li>type 字段比较重要, 它<strong>提供了判断查询是否高效的重要依据依据</strong>; 通过 type 字段, 我们判断此次查询是 <strong>全表扫描</strong> 还是 <strong>索引扫描</strong> 等;</li><li><p>type 常用的取值有:</p><ul><li><p><code>system</code>: 表中只有一条数据, 这个类型是特殊的 <code>const</code> 类型; ??</p></li><li><p><code>const</code>: 针对<strong>主键</strong>或<strong>唯一索引</strong>的<strong>等值查询扫描</strong>, 最多只返回一行数据(const 查询速度非常快, 因为它仅仅读取一次即可)</p></li><li><p><code>eq_ref</code>: 此类型通常出现在多表的join查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果, 并且查询的比较操作通常是 =, <strong>查询效率较高</strong>, 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id;</div><div class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</div><div class="line">| id | select_type | table      | type   | possible_keys             | key                       | key_len | ref                     | rows | Extra                    |</div><div class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | order_info | index  | user_product_detail_index | user_product_detail_index | 254     | NULL                    |    9 | Using where; Using index |</div><div class="line">|  1 | SIMPLE      | user_info  | eq_ref | PRIMARY                   | PRIMARY                   | 8       | test.order_info.user_id |    1 | NULL                     |</div><div class="line">+----+-------------+------------+--------+---------------------------+---------------------------+---------+-------------------------+------+--------------------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询, 例如下面这个例子中, 就使用到了 ref 类型的查询:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5;</div><div class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</div><div class="line">| id | select_type | table      | type  | possible_keys             | key                       | key_len | ref   | rows | Extra       |</div><div class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info  | const | PRIMARY                   | PRIMARY                   | 8       | const |    1 | NULL        |</div><div class="line">|  1 | SIMPLE      | order_info | ref   | user_product_detail_index | user_product_detail_index | 9       | const |    1 | Using index |</div><div class="line">+----+-------------+------------+-------+---------------------------+---------------------------+---------+-------+------+-------------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>range: 表示使用<code>索引范围查询</code>, 通过索引字段范围获取表中部分数据记录; 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL (没用到索引), 并且 key_len 字段是此次查询中使用到的索引的最长的那个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT * FROM user_info WHERE id BETWEEN 2 AND 8;</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | range | PRIMARY       | PRIMARY | 8       | NULL |    7 | Using where |</div><div class="line">+----+-------------+-----------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>下面对比, 都使用了范围查询, 但是一个可以使用<strong>索引范围查询</strong>, 另一个不能使用索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name&gt;&apos;nihao&apos;;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra                    |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | user_info | range | name_index    | name_index | 152     | NULL |    1 | Using where; Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age&gt;10;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>另外, 可参考 P185: in语句虽然有时候 type结果也是range (不过, 对于真正的范围查询, 确实是无法使用范围列后面的其他索引了, 但是对于”多个等值条件查询”则没有这个限制)</p></li><li><p>index: 表示<strong>全索引扫描(full index scan)</strong>, 和 ALL 类型类似, 只不过ALL类型是全表扫描, <strong>而 index 类型则仅仅扫描所有的索引, 而不扫描数据</strong><br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据, 即 做的是<strong>覆盖索引</strong>, 当是这种情况时, Extra 字段会显示 <code>Using index</code></p><p>下面的例子中, 查询的 <code>name</code> 字段恰好是一个索引(<strong>做到了覆盖索引</strong>), 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据;<br>因此这样的情况下, type 的值是 <code>index</code>, 并且 Extra 的值是 Using index;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM user_info;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | index | NULL          | name_index | 152     | NULL |   10 | Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>下面不但使用了<code>全索引扫描</code>, 而且使用了<code>where条件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name=&apos;nihao&apos;;</div><div class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                    |</div><div class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using where; Using index |</div><div class="line">+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>但是, 如果不使用索引的话, 下面type就是<code>ALL</code>, 表示使用了<code>全表扫描</code>, 并且使用了where条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age=10;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where age&gt;10;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure><p>下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info where name&gt;&apos;nihao&apos;;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra                    |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | user_info | range | name_index    | name_index | 152     | NULL |    1 | Using where; Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+--------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一, 通常来说, 我们的查询<strong>不应该出现 ALL 类型的查询</strong>, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难<br>如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</p></li><li></li></ul></li></ol><h2 id="type小结"><a href="#type小结" class="headerlink" title="type小结"></a>type小结</h2><p><strong>type 类型的性能比较</strong> : 通常来说, 不同的 type 类型的性能关系如: <code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code></p><ol><li>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的;</li><li>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快;</li><li>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了;</li></ol><h2 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h2><p>possible_keys 表示 MySQL 在查询时, 能够使用到的索引;<br>注意: 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到;(MySQL 在查询时具体使用了哪些索引, 由 key 字段决定)</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>此字段是 MySQL 在当前查询时所真正使用到的索引</p><h2 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h2><p>rows 也是一个重要的字段, MySQL 查询优化器根据统计信息, <strong>估算SQL要查找到结果集需要到表中扫描读取的数据行数</strong>(上面的例子可以看到, 基本上使用到了索引的话, 真正扫描的行数都很少); 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好</p><h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><p>Explain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ol><li><p><strong>Using filesort</strong>: 当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. </p><ul><li><p>一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</p></li><li><p>比如下面, <code>使用索引扫描做排序</code> 和 <code>不使用索引扫描做排序</code> 的效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; EXPLAIN SELECT name FROM user_info ORDER BY name;</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">| id | select_type | table     | type  | possible_keys | key        | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | user_info | index | NULL          | name_index | 152     | NULL |   10 | Using index |</div><div class="line">+----+-------------+-----------+-------+---------------+------------+---------+------+------+-------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; EXPLAIN SELECT name FROM user_info ORDER BY age;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra          |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</div><div class="line">|  1 | SIMPLE      | user_info | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using filesort |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li></ul></li><li><p><code>Using index</code> 与 <code>Using index condition</code></p><ul><li>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li><li><p>比如下面, 第一个做到了<code>覆盖索引</code>扫描, 后面两个都没做到</p><pre><code>mysql&gt; EXPLAIN SELECT name FROM user_info where name=&apos;haha&apos;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                    |+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using where; Using index |+----+-------------+-----------+------+---------------+------------+---------+-------+------+--------------------------+1 row in set (0.00 sec)mysql&gt; EXPLAIN SELECT name,age FROM user_info where name=&apos;haha&apos;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                 |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using index condition |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+1 row in set (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM user_info where name=&apos;haha&apos;;+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra                 |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+|  1 | SIMPLE      | user_info | ref  | name_index    | name_index | 152     | const |    1 | Using index condition |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-----------------------+1 row in set (0.00 sec)</code></pre></li></ul></li><li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备环境&quot;&gt;&lt;a href=&quot;#准备环境&quot; class=&quot;headerlink&quot; title=&quot;准备环境&quot;&gt;&lt;/a&gt;准备环境&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.renyimin.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.renyimin.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.renyimin.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="高性能索引策略" scheme="http://blog.renyimin.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
</feed>
