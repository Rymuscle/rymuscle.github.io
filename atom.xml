<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2018-10-15T08:44:06.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>18. Closure</title>
    <link href="http://blog.renyimin.com/2018/10/15/python/2018-10-15-Python-18/"/>
    <id>http://blog.renyimin.com/2018/10/15/python/2018-10-15-Python-18/</id>
    <published>2018-10-15T08:29:56.000Z</published>
    <updated>2018-10-15T08:44:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><ol><li><p>在面向对象(OOP)的设计模式中, decorator被称为装饰模式, OOP的装饰模式需要通过 继承 和 组合 来实现, 而Python除了能支持OOP的decorator外, 直接从语法层次支持decorator, Python的decorator可以用函数实现, 也可以用类实现;</p></li><li><p>decorator可以增强函数的功能, 定义起来虽然有点复杂, 但使用起来非常灵活和方便</p></li><li><p>示例:  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@log</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2015-3-25&apos;)</span><br><span class="line"></span><br><span class="line"># now = log(now)</span><br><span class="line">now()</span><br><span class="line">print(now.__name__)</span><br><span class="line">print(&apos;\n----------------------\n&apos;)</span><br><span class="line"></span><br><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">@log(&apos;execute&apos;)</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2015-3-25&apos;)</span><br><span class="line"></span><br><span class="line"># now = log(&apos;execute&apos;)(now)</span><br><span class="line">now()</span><br><span class="line">print(now.__name__)</span><br></pre></td></tr></table></figure></li><li></li></ol><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><ol><li>简单总结 <code>functools.partial</code> 的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;装饰器&quot;&gt;&lt;a href=&quot;#装饰器&quot; class=&quot;headerlink&quot; title=&quot;装饰器&quot;&gt;&lt;/a&gt;装饰器&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在面向对象(OOP)的设计模式中, decorator被称为装饰模式, OOP的装饰模式需要通过 继承 和 组合 
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>17. Closure</title>
    <link href="http://blog.renyimin.com/2018/10/15/python/2018-10-15-Python-17/"/>
    <id>http://blog.renyimin.com/2018/10/15/python/2018-10-15-Python-17/</id>
    <published>2018-10-15T06:34:28.000Z</published>
    <updated>2018-10-15T07:26:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ol><li><p>当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，但其内部实现起来可不容易</p></li><li><p>坑: 如下, 返回的三个函数在最终被调用后, 返回的是 9，9，9 而不是 1，4，9</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        def f():</span><br><span class="line">             return i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    return fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line">print(f1, f2, f3)</span><br><span class="line">print(f1(), f2(), f3())</span><br></pre></td></tr></table></figure><p> 原因就在于返回的函数<strong>引用了变量i</strong>, 但它<strong>并非立刻执行</strong>; <strong>等到3个函数都返回时, 它们所引用的变量i已经变成了3</strong>, 因此最终结果为9;</p></li><li><p>因此, 返回闭包时牢记一点: 返回函数不要引用任何循环变量, 或者后续会发生变化的变量;</p></li><li><p>如果一定要引用循环变量怎么办? 方法是再创建一个函数, 用该函数的参数绑定循环变量当前的值, 无论该循环变量后续如何更改, 已绑定到函数参数的值不变:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    def count():</span><br><span class="line">           def f(j):</span><br><span class="line">               def g():</span><br><span class="line">                   return j*j</span><br><span class="line">               return g</span><br><span class="line">           fs = []</span><br><span class="line">           for i in range(1, 4):</span><br><span class="line">               fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()</span><br><span class="line">           return fs</span><br><span class="line">    ```   </span><br><span class="line">    缺点是代码较长，可利用lambda函数缩短代码</span><br><span class="line">    </span><br><span class="line">## 匿名函数</span><br><span class="line">1. lambda</span><br><span class="line">    - 匿名函数 `lambda x: x * x` 实际上就是:</span><br></pre></td></tr></table></figure><p> def f(x):</p><pre><code> return x * x</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    - 关键字lambda表示匿名函数, 冒号前面的x表示函数参数</span><br><span class="line">    - 匿名函数有个限制, 就是只能有一个表达式, 不用写return, 返回值就是该表达式的结果</span><br><span class="line"></span><br><span class="line">2. 用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>f = lambda x: x * x<br>f<br> <function <lambda=""> at 0x101c6ef28&gt;<br>f(5)<br> 25</function></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 也可以把匿名函数作为返回值返回</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><p> def build(x, y):</p><pre><code> return lambda: x * x + y * y</code></pre><p> ```</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，但其内部实现起来可不容易&lt;/p&gt;
&lt;/l
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>15. 函数式编程</title>
    <link href="http://blog.renyimin.com/2018/10/12/python/2018-10-14-Python-16/"/>
    <id>http://blog.renyimin.com/2018/10/12/python/2018-10-14-Python-16/</id>
    <published>2018-10-12T03:52:31.000Z</published>
    <updated>2018-10-15T04:06:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ol><li><p>在Python中, 函数本身也可以赋值给变量, 即 变量可以指向函数; 如果一个变量指向了一个函数, 那么你可以通过该变量来调用这个函数, 如下直接调用<code>abs()</code>函数和调用变量<code>f()</code>完全相同</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = abs</span><br><span class="line">&gt;&gt;&gt; f(-10)</span><br><span class="line">10</span><br></pre></td></tr></table></figure></li><li><p>函数名其实就是指向函数的变量, 对于abs()这个函数, 完全可以把函数名abs看成变量, 它指向一个可以计算绝对值的函数!</p><ul><li>如果把abs指向其他对象，会有什么情况发生<br>把abs指向10后( <code>abs = 10</code>), 就无法通过abs(-10)调用绝对值函数了, 因为abs这个变量已经不指向求绝对值函数而是指向一个整数10</li><li><p>当然实际代码绝对不能这么写，这里是为了说明函数名也是变量, <strong>要恢复abs函数, 请重启Python交互环境</strong></p></li><li><p>注: 由于abs函数实际上是定义在 <code>import builtins</code> 模块中的, 所以要让修改abs变量的指向在其它模块也生效, 要用<code>import builtins; builtins.abs = 10</code></p></li></ul></li><li><p>传入函数: 既然变量可以指向函数, 函数的参数能接收变量, 那么<strong>一个函数就可以接收另一个函数作为参数, 这种函数就称之为高阶函数</strong></p><ul><li>一个最简单的高阶函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def add(x, y, f):</span><br><span class="line">   return f(x) + f(y)</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>把函数作为参数传入, 这样的函数称为高阶函数, 函数式编程就是指这种高度抽象的编程范式</p><h2 id="内建函数map"><a href="#内建函数map" class="headerlink" title="内建函数map()"></a>内建函数map()</h2><ol><li><p>map()函数接收两个参数</p><ul><li>一个是函数</li><li>一个是 <code>Iterable</code></li></ul></li><li><p>map将传入的函数依次作用到序列的每个元素, 并把结果作为新的<strong>Iterator</strong>返回<br> 举例说明, 比如我们有一个函数<code>f(x)=x2</code>, 要把这个函数作用在一个list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>上, 就可以用map()实现如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">    return x * x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">print(type(r))</span><br><span class="line">print(list(r))</span><br></pre></td></tr></table></figure></li></ol><h2 id="内建函数reduce"><a href="#内建函数reduce" class="headerlink" title="内建函数reduce()"></a>内建函数reduce()</h2><ol><li><p>reduce把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上, 这个函数必须接收两个参数, reduce把结果继续和序列的下一个元素做累积计算, 其效果就是:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure></li><li></li></ol><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;高阶函数&quot;&gt;&lt;a href=&quot;#高阶函数&quot; class=&quot;headerlink&quot; title=&quot;高阶函数&quot;&gt;&lt;/a&gt;高阶函数&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在Python中, 函数本身也可以赋值给变量, 即 变量可以指向函数; 如果一个变量指向了一个函数, 那么
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>14. 迭代, 生成器</title>
    <link href="http://blog.renyimin.com/2018/10/12/python/2018-10-12-Python-14/"/>
    <id>http://blog.renyimin.com/2018/10/12/python/2018-10-12-Python-14/</id>
    <published>2018-10-12T03:19:31.000Z</published>
    <updated>2018-10-12T08:44:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><ol><li><p>如果给定一个list或tuple, 我们可以通过for循环来遍历这个list或tuple, 这种遍历我们称为迭代(Iteration); 在Python中, 迭代是通过 <code>for ... in</code> 来完成的</p><ul><li>Python的for循环抽象程度要高于C的for循环, 因为Python的for循环不仅可以用在list或tuple上, 还可以作用在其他可迭代对象上, 如 dict 和 str 都是可迭代对象, 因此都可以用于for循环</li><li>所以, 当我们使用for循环时, 只要作用于一个<strong>可迭代对象</strong>, for循环就可以正常运行, 而我们不太关心该对象究竟是list还是其他数据类型;</li></ul></li><li><p>那么, 如何判断一个对象是可迭代对象呢?</p><ul><li>方法是通过<strong>collections模块</strong>的<code>Iterable</code>类型判断<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line"></span><br><span class="line"># str是否可迭代</span><br><span class="line">isinstance(&apos;abc&apos;, Iterable)</span><br><span class="line"></span><br><span class="line"># dict是否可迭代</span><br><span class="line">dict = &#123;0: &apos;renyimin&apos;, 1:&apos;rymuscle&apos;, 2:&apos;lant&apos;, &apos;info&apos;:&#123;&apos;address&apos;:&apos;运城&apos;&#125;, 3:[3,6,9]&#125;</span><br><span class="line">print(dict)</span><br><span class="line">print(isinstance(dict, Iterable))</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><ol><li><p>通过 <code>list(range(1, 20))</code> 或者 <code>列表生成式</code>, 我们可以直接创建一个列表, 但是, 受到内存限制, 列表容量肯定是有限的; 而且, 创建一个包含100万个元素的列表, 不仅占用很大的存储空间, 如果我们仅仅需要访问前面几个元素, 那后面绝大多数元素占用的空间都白白浪费了; 所以, 如果列表元素可以按照某种算法推算出来, 那我们是否可以在循环的过程中不断推算出后续的元素呢? 这样就不必创建完整的list, 从而节省大量的空间;</p></li><li><p>在Python中, 这种一边循环一边计算的机制, 称为<strong>生成器(generator)</strong>; 要创建一个generator, 有很多种方法, 第一种方法很简单, 只要把一个 列表生成式的<code>[]</code>改成<code>()</code>, 就创建了一个generator<br> 创建 L 和 g 的区别仅在于最外层的<code>[]</code>和<code>()</code>, L是一个list, 而g是一个generator</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = [x * x for x in range(10)]</span><br><span class="line">print(type(L))</span><br><span class="line">g = (x * x for x in range(10))</span><br><span class="line">print(type(g))</span><br></pre></td></tr></table></figure><p> 结果:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;list&apos;&gt;</span><br><span class="line">&lt;class &apos;generator&apos;&gt;</span><br></pre></td></tr></table></figure></li><li><p>我们可以直接打印出list的每一个元素, 但我们怎么打印出generator的每一个元素呢?</p><ul><li><p>如果要一个一个打印出来，可以通过<code>next()</code>函数获得generator的下一个返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">g = (x * x for x in range(5))</span><br><span class="line">print(type(g))</span><br><span class="line">print(g)</span><br><span class="line">print(next(g))</span><br><span class="line">print(next(g))</span><br><span class="line">print(next(g))</span><br><span class="line">print(next(g))</span><br><span class="line">print(next(g))</span><br><span class="line">print(next(g))</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;generator&apos;&gt;</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x105faa9a8&gt;</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;generator.py&quot;, line 27, in &lt;module&gt;</span><br><span class="line">    print(next(g))</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>: generator保存的是算法, 每次调用<code>next(g)</code>, 就计算出g的下一个元素的值, 直到计算到最后一个元素, 没有更多的元素时, 抛出StopIteration的错误</p></li><li><p>当然, 上面这种不断调用next(g)实在是太变态了, 正确的方法是使用for循环, 因为 <strong>generator也是可迭代对象</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line"></span><br><span class="line">g = (x * x for x in range(5))</span><br><span class="line">print(type(g))</span><br><span class="line"># generator 是否可迭代, 返回True</span><br><span class="line">print(isinstance(g, Iterable))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = (x * x for x in range(10))</span><br><span class="line">for n in g:</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure></li><li><p>所以, 我们创建了一个generator后, 基本上永远不会调用next(), 而是通过for循环来迭代它, 这样也不需要你关心StopIteration的错误</p></li></ul></li><li><p><strong>定义generator的另一种方法</strong></p><ul><li>generator非常强大, <strong>如果推算的算法比较复杂, 用类似 列表生成式 的for循环无法实现的时候, 还可以用函数来实现</strong></li><li>比如, 著名的斐波拉契数列(Fibonacci), 除第一个和第二个数外, 任意一个数都可由前两个数相加得到: <code>1, 1, 2, 3, 5, 8, 13, 21, 34, ...</code></li><li><p>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    i, a, b = 0, 0, 1</span><br><span class="line">    while i &lt; max:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        i = i + 1</span><br><span class="line">    return &apos;done&apos;</span><br><span class="line"></span><br><span class="line">fib(5)</span><br></pre></td></tr></table></figure></li><li><p>fib函数实际上是定义了斐波拉契数列的推算规则, 可以从第一个元素开始, 推算出后续任意的元素, 这种逻辑其实非常类似generator</p></li><li><p>也就是说, 上面的函数和generator仅一步之遥, 要把fib函数变成generator, 只需要把 <code>print(b)</code> 改为 <strong>yield b</strong> 就可以了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    i, a, b = 0, 0, 1</span><br><span class="line">    while i &lt; max:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        i = i + 1</span><br><span class="line">    return &apos;done&apos;</span><br><span class="line"></span><br><span class="line">f = fib(5)</span><br><span class="line">print(type(f))</span><br><span class="line">print(f)</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;generator&apos;&gt;</span><br><span class="line">&lt;generator object fib at 0x10cc309a8&gt;</span><br></pre></td></tr></table></figure><p>这就是定义 generator 的另一种方法, 如果一个函数定义中包含<code>yield</code>关键字, 那么这个函数就不再是一个普通函数, 而是一个generator:</p></li></ul></li><li><p>这里, 最难理解的就是generator和函数的执行流程不一样</p><ul><li>函数是顺序执行，遇到return语句或者最后一行函数语句就返回; 而变成generator的函数, 在每次调用next()的时候执行, 遇到yield语句返回, 再次执行时从上次返回的yield语句处继续执行;</li><li><p>举个简单的例子，定义一个generator，依次返回数字1，3，5:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def odd():</span><br><span class="line">    print(&apos;step 1&apos;)</span><br><span class="line">    yield 1</span><br><span class="line">    print(&apos;step 2&apos;)</span><br><span class="line">    yield(3)</span><br><span class="line">    print(&apos;step 3&apos;)</span><br><span class="line">    yield(5)</span><br></pre></td></tr></table></figure></li><li><p>调用该generator时, 首先要生成一个generator对象, 然后用next()函数不断获得下一个返回值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o = odd()</span><br><span class="line">next(o)</span><br><span class="line">next(o)</span><br><span class="line">next(o)</span><br><span class="line">next(o)</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">step 1</span><br><span class="line">step 2</span><br><span class="line">step 3</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;generator.py&quot;, line 78, in &lt;module&gt;</span><br><span class="line">    next(o)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></li><li><p>可以看到, odd不是普通函数, 而是generator, 在执行过程中, 遇到yield就中断, 下次又继续执行; 执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。</p></li></ul></li><li><p>回到fib的例子，我们在循环过程中不断调用yield，就会不断中断, 当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来; 同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    i, a, b = 0, 0, 1</span><br><span class="line">    while i &lt; max:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        i = i + 1</span><br><span class="line">    return &apos;done&apos;</span><br><span class="line"></span><br><span class="line">for n in fib(6):</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure></li><li><p>但是用for循环调用generator时, 发现拿不到generator的return语句的返回值, 如果想要拿到返回值, 必须捕获StopIteration错误, 返回值包含在StopIteration的value中</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    i, a, b = 0, 0, 1</span><br><span class="line">    while i &lt; max:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        i = i + 1</span><br><span class="line">    return &apos;done&apos;</span><br><span class="line"></span><br><span class="line">for n in fib(6):</span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line">g = fib(6)</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        x = next(g)</span><br><span class="line">        print(&apos;g:&apos;, x)</span><br><span class="line">    except StopIteration as e:</span><br><span class="line">        print(&apos;Generator return value:&apos;, e.value)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure></li></ol><h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><ol><li>方法1, 使用了 列表生成式, 生成器 来实现 杨辉三角的生成和输出<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def yanghui():</span><br><span class="line">    row = [1]</span><br><span class="line">    while True:</span><br><span class="line">        yield(row)</span><br><span class="line">        row = [1] + [row[k] + row[k + 1] for k in range(len(row) - 1)] + [1]</span><br><span class="line"></span><br><span class="line">g = yanghui()</span><br><span class="line">i = 0</span><br><span class="line">while i &lt; 10:</span><br><span class="line">    try:</span><br><span class="line">        x = next(g)</span><br><span class="line">        print(&apos;g:&apos;, x)</span><br><span class="line">        i = i + 1</span><br><span class="line">    except StopIteration as e:</span><br><span class="line">        print(&apos;Generator return value:&apos;, e.value)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;迭代&quot;&gt;&lt;a href=&quot;#迭代&quot; class=&quot;headerlink&quot; title=&quot;迭代&quot;&gt;&lt;/a&gt;迭代&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果给定一个list或tuple, 我们可以通过for循环来遍历这个list或tuple, 这种遍历我们称为迭代(Iter
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>15</title>
    <link href="http://blog.renyimin.com/2018/10/12/python/2018-10-14-Python-15/"/>
    <id>http://blog.renyimin.com/2018/10/12/python/2018-10-14-Python-15/</id>
    <published>2018-10-12T03:19:31.000Z</published>
    <updated>2018-10-14T03:43:23.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>可以直接作用于for循环的数据类型有以下几种:</p><ul><li>一类是集合数据类型: 如 list、tuple、dict、set、str 等;</li><li>一类是 generator, 包括生成器 和 带yield的 generator function;</li><li>这些可以直接作用于for循环的对象统称为<strong>可迭代对象 Iterable</strong><br>可以使用<code>isinstance()</code>判断一个对象是否是Iterable对象</li></ul></li><li><p>而生成器不但可以作用于for循环, 还可以被next()函数不断调用并返回下一个值, 直到最后抛出StopIteration错误表示无法继续返回下一个值了</p><ul><li>可以被next()函数调用并不断返回下一个值的对象称为 <strong>迭代器 Iterator</strong></li><li><p>生成器都是Iterator对象, <strong>但list、dict、str虽然是Iterable, 却不是Iterator</strong><br>也可以使用isinstance()判断一个对象是否是Iterator对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance([], Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterator)</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li><p>把 list、dict、str 等 Iterable 变成 Iterator 可以使用 <code>iter()</code> 函数</p></li></ul></li><li><p><strong>iter()</strong> </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(iter([]), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator)</span><br><span class="line">True</span><br></pre></td></tr></table></figure></li><li><p>为什么list、dict、str等数据类型不是 Iterator ?</p><ul><li>这是因为Python的Iterator对象表示的是一个数据流, Iterator对象可以被next()函数调用并不断返回下一个数据, 直到没有数据时抛出StopIteration错误;<br>可以把这个数据流看做是一个有序序列, 但我们却不能提前知道序列的长度, 只能不断通过next()函数实现按需计算下一个数据, 所以Iterator的计算是<strong>惰性的</strong>, 只有在需要返回下一个数据时它才会计算;</li><li>Iterator甚至可以表示一个无限大的数据流, 例如全体自然数, 而使用list是永远不可能存储全体自然数的</li></ul></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>凡是可作用于for循环的对象都是Iterable类型;</li><li>凡是可作用于next()函数的对象都是Iterator类型, 它们表示一个惰性计算的序列;<ul><li>集合数据类型如list、dict、str等是Iterable但不是Iterator</li><li>不过可以通过iter()函数获得一个Iterator对象。</li></ul></li><li><p>Python的for循环本质上就是通过不断调用next()函数实现的，例如</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for x in [1, 2, 3, 4, 5]:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p> 实际上完全等价于：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 首先获得Iterator对象:</span><br><span class="line">it = iter([1, 2, 3, 4, 5])</span><br><span class="line"># 循环:</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        # 获得下一个值:</span><br><span class="line">        x = next(it)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        # 遇到StopIteration就退出循环</span><br><span class="line">        break</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以直接作用于for循环的数据类型有以下几种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一类是集合数据类型: 如 list、tuple、dict、set、str 等;&lt;/li&gt;
&lt;li&gt;一类是 generator, 包括生成器 和 带yield的 generator f
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>13. 切片</title>
    <link href="http://blog.renyimin.com/2018/10/11/python/2018-10-11-Python-13/"/>
    <id>http://blog.renyimin.com/2018/10/11/python/2018-10-11-Python-13/</id>
    <published>2018-10-11T13:41:39.000Z</published>
    <updated>2018-10-12T03:19:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="切片Slice"><a href="#切片Slice" class="headerlink" title="切片Slice"></a>切片Slice</h2><ol><li><p>取一个 <code>list</code> 或 <code>tuple</code> 的部分元素是非常常见的操作; 但是这种经常取指定索引范围的操作, 用循环十分繁琐; 因此，Python提供了切片（Slice）操作符，能大大简化这种操作</p></li><li><p>可以取单个索引处的元素, 如 <code>L[2]</code>, <code>L[-2]</code></p></li><li><p>也可以取范围索引的多个元素</p><ul><li><code>L[0:3]</code> 表示从索引0开始取，直到索引3为止，但<strong>不包括索引3</strong>, 即索引0，1，2，正好是3个元素; </li><li><code>L[1:2]</code> 表示从索引1开始取，直到索引2为止，但<strong>不包括索引2</strong>, 即索引1处的元素, 正好是1个;</li><li><code>L[-2:-1]</code> 表示从索引-2开始取，直到索引-1为止，但<strong>不包括索引-1</strong> (共1个元素)</li></ul></li><li><p>如果所取的索引范围是从0开始, 还可以省略 <code>L[:3]</code></p></li><li><p>如上面第2点提到, 还支持 负数 来倒着取索引或者索引范围</p><ul><li><code>L[-3:]</code> 表示从倒数第3个元素开始, 到结尾所有元素</li><li><code>L[-3:-1]</code> 表示从倒数第2个元素开始, 到结尾所有元素, 但是注意: <strong>不包含最后一个元素</strong>, 即 -1索引处的元素 </li></ul></li><li><p>每n个数, 只取一个</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">print(L[:3:2])</span><br><span class="line">print(L[:4:2])</span><br><span class="line">print(L[:5:2])</span><br><span class="line"># 所有数, 每隔2个取一个</span><br><span class="line">print(L[::2])</span><br></pre></td></tr></table></figure><p> 结果:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0, 2]</span><br><span class="line">[0, 2]</span><br><span class="line">[0, 2, 4]</span><br><span class="line">[0, 2, 4, 6, 8]</span><br></pre></td></tr></table></figure></li><li><p>什么都不写，只写<code>[:]</code>就可以原样复制一个list (<strong>tuple也是一种list</strong>, 唯一区别是tuple不可变, 因此tuple也可以用切片操作, 只是操作的结果仍是tuple)</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;切片Slice&quot;&gt;&lt;a href=&quot;#切片Slice&quot; class=&quot;headerlink&quot; title=&quot;切片Slice&quot;&gt;&lt;/a&gt;切片Slice&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;取一个 &lt;code&gt;list&lt;/code&gt; 或 &lt;code&gt;tuple&lt;/code
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>12. 函数的参数</title>
    <link href="http://blog.renyimin.com/2018/10/10/python/2018-10-10-Python-12/"/>
    <id>http://blog.renyimin.com/2018/10/10/python/2018-10-10-Python-12/</id>
    <published>2018-10-10T10:00:31.000Z</published>
    <updated>2018-10-16T07:30:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python的函数定义非常简单, 但灵活度却非常大, 除了正常定义的 必选参数 外, 还可以使用 默认参数, 可变参数 和 关键字参数, 使得函数定义出来的接口, 不但能处理复杂的参数, 还可以简化调用者的代码; </p><h2 id="必选参数"><a href="#必选参数" class="headerlink" title="必选参数"></a>必选参数</h2><p>即, 函数调用时必须要传的参数</p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><ol><li><p>设置默认参数时, 有几点要注意：</p><ul><li><strong>必选参数在前, 默认参数在后</strong>, 否则Python的解释器会报错;</li><li>当函数有多个参数时, 把变化大的参数放前面, 变化小的参数放后面作为默认参数;</li></ul></li><li><p>使用默认参数最大的好处是能降低调用函数的难度; 而当需要更复杂的调用时, 也可以传递更多的参数来实现:</p></li><li><p>有多个默认参数的函数在调用时</p><ul><li>既可以按顺序提供参数 </li><li>也可以不按顺序提供默认参数(甚至不按顺序且只提供部分默认参数), 此时, <strong>需要把参数名写上</strong>, 如下: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def info(name, gender, age=6, city=&apos;Beijing&apos;):</span><br><span class="line">    print(&apos;name:&apos;, name)</span><br><span class="line">    print(&apos;gender:&apos;, gender)</span><br><span class="line">    print(&apos;age:&apos;, age)</span><br><span class="line">    print(&apos;city:&apos;, city)</span><br><span class="line"></span><br><span class="line">info(&apos;rrc&apos;, &apos;male&apos;, city=&apos;北京&apos;)</span><br><span class="line"># 注意: 如果在传递city参数时, 既没有传前面的默认参数age, 又不指定city的参数名, 则city的值将会传递给age</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol><li><p><strong>大坑</strong>: 默认参数有个大坑, 那就是 <strong>默认参数必须指向不变对象</strong></p><ul><li><p>如下正常传参, 结果没什么问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def add_end(L=[]):</span><br><span class="line">    L.append(&apos;END&apos;)</span><br><span class="line">    return L</span><br><span class="line"></span><br><span class="line">print(add_end([1, 2, 3]))</span><br><span class="line">print(add_end([1, 2, 3]))</span><br></pre></td></tr></table></figure></li><li><p>但是如果 <strong>使用默认参数调用时</strong>, 问题就出来了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def add_end(L=[]):</span><br><span class="line">    L.append(&apos;END&apos;)</span><br><span class="line">    return L</span><br><span class="line"></span><br><span class="line">print(add_end())</span><br><span class="line">print(add_end())</span><br></pre></td></tr></table></figure><p>结果如下: 默认参数是[], <strong>但是函数似乎每次都“记住了”上次添加了’END’后的list</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(myEnv_001) renyimindeMacBook-Pro:PythonStudy renyimin$ python keng.py </span><br><span class="line">[&apos;END&apos;]</span><br><span class="line">[&apos;END&apos;, &apos;END&apos;]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>上述原因是因为, Python函数在定义的时候, 默认参数 L 的值就被计算出来了, 即 <code>[]</code>, 因为默认参数 L 也是一个变量, 它指向对象 <code>[]</code></p><ul><li>每次调用该函数, 如果改变了L的内容, 则下次调用时, 默认参数的内容就变了, 不再是函数定义时的 <code>[]</code> 了, 除非下次调用时显示地通过传参来重新设置L的内容;</li><li>因此: 定义默认参数要牢记一点, <strong>默认参数必须指向不变对象</strong>;</li><li><p>要修改上面的例子, 我们可以用None这个不变对象来实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def add_end(L=None):</span><br><span class="line">   if L is None:</span><br><span class="line">       L = []</span><br><span class="line">   L.append(&apos;END&apos;)</span><br><span class="line">   return L</span><br></pre></td></tr></table></figure><p>现在, 无论调用多少次都不会有问题</p></li></ul></li><li><p>为什么要设计 str、None 这样的不变对象呢??</p><ul><li>因为不变对象一旦创建, 对象内部的数据就不能修改, 这样就减少了由于修改数据导致的错误;</li><li>此外, 由于对象不变, <strong>多任务环境下同时读取对象不需要加锁</strong>, 同时读一点问题都没有, 我们在编写程序时, 如果可以设计一个不变对象，那就尽量设计成不变对象;</li></ul></li></ol><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数 *"></a>可变参数 <code>*</code></h2><ol><li><p>可变参数是指: 传入参数的个数是可变的, 可以是1个、2个到任意个, 还可以是0个</p></li><li><p>例: 要定义一个 计算一组数中每个数平方的和的函数, 就必须确定输入的参数, 如果参数个数不确定</p><ul><li>首先想到的是, 可以把 这组数字 作为一个 <code>list</code> 或 <code>tuple</code> 型的参数传进来, 为此你需要先组装出一个 <code>list</code> 或 <code>tuple</code>;</li><li>如果利用可变参数, 则上面那一步将会被省略, 代码就被简化了</li></ul></li><li><p>要定义可变参数, 仅仅需要在参数前面加一个 <code>*</code> 号: 可变参数在函数内部 是作为 <strong>tuple</strong> 存在的; 因此, 相比于使用tuple参数, 使用可变参数的函数代码完全不变; 方便的是, 在调用该函数时, 你可以传入任意个参数, 包括0个参数, 而不用在调用函数前再组装一个 <code>list</code> 或 <code>tuple</code>    </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># tuple参数</span><br><span class="line">def func1(param):</span><br><span class="line">    sum = 0;</span><br><span class="line">    for v in param:</span><br><span class="line">        sum = sum + v * v</span><br><span class="line">    return sum</span><br><span class="line"></span><br><span class="line">t = (1, 2, 3, 6, 8)</span><br><span class="line">print(func1(t))</span><br><span class="line"></span><br><span class="line"># 可变参数</span><br><span class="line">def calc(*numbers):</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br><span class="line"></span><br><span class="line">print(calc(1, 2, 3, 6, 8))</span><br></pre></td></tr></table></figure></li><li><p><strong>list或tuple转变为可变参数</strong>, 如果已经有一个list或者tuple, 要调用一个参数是 <code>可变参数</code> 的函数</p><ul><li><p>可以这样做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])</span><br><span class="line">14</span><br></pre></td></tr></table></figure></li><li><p>上述写法的问题是太繁琐, 所以Python允许你 <strong>在list或tuple前面加一个 <code>*</code> 号, 把list或tuple的元素变成可变参数传进去</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t1 = (1, 2, 3, 6, 8)</span><br><span class="line">def func2(*param):</span><br><span class="line">   sum = 0</span><br><span class="line">   for v in param:</span><br><span class="line">     sum = sum + v * v</span><br><span class="line">   return sum</span><br><span class="line"></span><br><span class="line"># 看这里</span><br><span class="line">print(func2(*t1))</span><br></pre></td></tr></table></figure></li><li><p><code>*nums</code> 就表示把nums这个list的所有元素作为可变参数传进去, 这种写法相当有用, 而且很常见;</p></li></ul></li><li><p>注意下例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def func2(name, age, *address):</span><br><span class="line">    print(&apos;name: %s, age: %s, address:%s&apos; % (name, age, address))</span><br><span class="line"></span><br><span class="line">func2(&apos;renyimin&apos;, 102, *(1,2,3,4,&apos;运城&apos;), &apos;ddd&apos;)</span><br><span class="line">func2(&apos;renyimin&apos;, 102, (1,2,3,4,&apos;运城&apos;), &apos;ddd&apos;)</span><br></pre></td></tr></table></figure><p> 结果:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: renyimin, age: 102, address:(1, 2, 3, 4, &apos;运城&apos;, &apos;ddd&apos;)</span><br><span class="line">name: renyimin, age: 102, address:((1, 2, 3, 4, &apos;运城&apos;), &apos;ddd&apos;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数 **"></a>关键字参数 <code>**</code></h2><ol><li><p><code>可变参数</code>允许你传入0个或任意个参数, 这些可变参数在函数调用时自动组装为一个 <code>tuple</code>; 而<strong>关键字参数</strong>允许你传入0个或任意个含参数名的参数, 这些关键字参数在函数内部自动组装为一个 <code>dict</code>;</p></li><li><p>示例: </p><ul><li>函数person除了必选参数name和age外, 还接受关键字参数kw<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">   print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数的调用</p><ul><li><p>可以只传入必选参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;Michael&apos;, 30)</span><br><span class="line">name: Michael age: 30 other: &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>也 <strong>可以传入任意个数的关键字参数</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)</span><br><span class="line">name: Bob age: 35 other: &#123;&apos;city&apos;: &apos;Beijing&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)</span><br><span class="line">name: Adam age: 45 other: &#123;&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure></li><li><p>和 可变参数 类似, 也可以先组装出一个 dict, 然后把该 dict 转换为 关键字参数 传进去(只不过这里用的是 <code>**</code>):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=extra[&apos;city&apos;], job=extra[&apos;job&apos;])</span><br><span class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面复杂的调用可以简化为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra)</span><br><span class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>**extra</code> 表示把 extra这个dict的所有key-value用关键字参数传入到函数的 <code>**kw</code> 参数, kw将获得一个dict, 注意kw获得的dict是extra的一份拷贝, 对kw的改动不会影响到函数外的extra;</p></li></ul></li></ol><h2 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数 *,"></a>命名关键字参数 <code>*,</code></h2><ol><li><p>对于关键字参数, 函数的调用者可以传入任意不受限制的关键字参数, 至于到底传入了哪些, 就需要在函数内部进行检查 (可以用 <code>in</code> 检查参数是否在 关键字参数 中)</p></li><li><p>仍以person()函数为例, 我们希望检查是否有city和job参数:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">   if &apos;city&apos; in kw:</span><br><span class="line">       # 有city参数</span><br><span class="line">       pass</span><br><span class="line">   if &apos;job&apos; in kw:</span><br><span class="line">       # 有job参数</span><br><span class="line">       pass</span><br><span class="line">   print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>但上面的函数, 调用者仍可以传入不受限制的关键字参数, 如果要限制关键字参数的名字, 就可以用 <strong>命名关键字参数</strong>, 例如, 只接收 city 和 job 作为关键字参数, 这种方式定义的函数如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    def person(name, age, *, city, job):</span><br><span class="line">           print(name, age, city, job)</span><br><span class="line">    ```   </span><br><span class="line">    和关键字参数 `**kw` 不同, 命名关键字参数需要一个特殊分隔符 `*`, *后面的参数被视为 命名关键字参数</span><br><span class="line">   </span><br><span class="line">4. 调用方式如下:</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>person(‘Jack’, 24, city=’Beijing’, job=’Engineer’)<br> Jack 24 Beijing Engineer</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 如果函数定义中已经有了一个可变参数, 后面跟着的命名关键字参数就不再需要特殊分隔符 `*,` 了:</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><p> def person(name, age, *args, city, job):</p><pre><code> print(name, age, args, city, job)</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 命名关键字参数必须传入参数名, 如果没有传入参数名, 否则调用将报错:</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>person(‘Jack’, 24, ‘Beijing’, ‘Engineer’)<br> Traceback (most recent call last):<br>   File “<stdin>“, line 1, in <module><br> TypeError: person() takes 2 positional arguments but 4 were given</module></stdin></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    - 由于调用时缺少参数名city和job, Python解释器把这4个参数均视为位置参数, 但person()函数仅接受2个位置参数</span><br><span class="line"></span><br><span class="line">6. 命名关键字参数 也可以有默认值, 从而简化调用:</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><p> def person(name, age, *, city=’Beijing’, job):</p><pre><code> print(name, age, city, job)</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 由于命名关键字参数city具有默认值, 调用时可不传入city参数:</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>person(‘Jack’, 24, job=’Engineer’)<br> Jack 24 Beijing Engineer</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 使用命名关键字参数时, 要特别注意, 如果没有可变参数, 就必须加一个 `*` 作为特殊分隔符</span><br><span class="line">如果缺少`*`, **Python解释器将无法识别位置参数和命名关键字参数**</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><p> def person(name, age, city, job):</p><pre><code> # 缺少 *，city和job被视为位置参数 pass</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 参数组合</span><br><span class="line">1. 在Python中定义函数, 必选参数、默认参数、可变参数、关键字参数 和 命名关键字参数, 这5种参数都可以组合使用; 但是需要注意: </span><br><span class="line">    **参数定义的顺序必须是 必选参数、默认参数、可变参数、命名关键字参数 和 关键字参数**</span><br><span class="line"></span><br><span class="line">2. 比如定义一个函数，包含上述若干种参数：</span><br></pre></td></tr></table></figure><p> def f1(a, b, c=0, <em>args, *</em>kw):</p><pre><code>print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;args =&#39;, args, &#39;kw =&#39;, kw)</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><p> def f2(a, b, c=0, <em>, d, *</em>kw):</p><pre><code> print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;d =&#39;, d, &#39;kw =&#39;, kw)</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在函数调用的时候, Python解释器自动按照参数位置和参数名把对应的参数传进去</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>f1(1, 2)<br> a = 1 b = 2 c = 0 args = () kw = {}<br>f1(1, 2, c=3)<br> a = 1 b = 2 c = 3 args = () kw = {}<br>f1(1, 2, 3, ‘a’, ‘b’)<br> a = 1 b = 2 c = 3 args = (‘a’, ‘b’) kw = {}<br>f1(1, 2, 3, ‘a’, ‘b’, x=99)<br> a = 1 b = 2 c = 3 args = (‘a’, ‘b’) kw = {‘x’: 99}<br>f2(1, 2, d=99, ext=None)<br> a = 1 b = 2 c = 0 d = 99 kw = {‘ext’: None}</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最神奇的是通过一个 tuple 和 dict, 你也可以调用上述函数：</span><br></pre></td></tr></table></figure><p>args = (1, 2, 3, 4)<br>kw = {‘d’: 99, ‘x’: ‘#’}<br>f1(<em>args, **kw)<br> a = 1 b = 2 c = 3 args = (4,) kw = {‘d’: 99, ‘x’: ‘#’}<br>args = (1, 2, 3)<br>kw = {‘d’: 88, ‘x’: ‘#’}<br>f2(</em>args, **kw)<br> a = 1 b = 2 c = 3 d = 88 kw = {‘x’: ‘#’}</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    所以, 对于任意函数, 都可以通过类似 func(*args, **kw) 的形式调用它, 无论它的参数是如何定义的</span><br><span class="line"></span><br><span class="line">3. 虽然可以组合多达5种参数, 但不要同时使用太多的组合, 否则函数接口的可理解性很差</span><br><span class="line"></span><br><span class="line">## 小结</span><br><span class="line">1. 默认参数一定要用不可变对象, 如果是可变对象, 程序运行时会有逻辑错误!</span><br><span class="line">   </span><br><span class="line">2. 要注意定义可变参数和关键字参数的语法:</span><br><span class="line">   - `*args` 是可变参数, args接收的是一个 `tuple`</span><br><span class="line">   - `**kw` 是关键字参数, kw接收的是一个 `dict`</span><br><span class="line"></span><br><span class="line">## 递归</span><br><span class="line">1. 使用递归函数的优点是逻辑简单清晰, 缺点是 **过深的调用会导致栈溢出**; 使用递归函数需要注意防止栈溢出: 在计算机中, 函数调用是通过栈(stack)这种数据结构实现的, 每当进入一个函数调用, 栈就会加一层栈帧, 每当函数返回, 栈就会减一层栈帧; 由于栈的大小不是无限的, 所以, 递归调用的次数过多, 会导致栈溢出</span><br><span class="line"></span><br><span class="line">2. 比如求阶乘的过程, 递归过程可以展示如下</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><p> ===&gt; fact(5)<br> ===&gt; 5 <em> fact(4)<br> ===&gt; 5 </em> (4 <em> fact(3))<br> ===&gt; 5 </em> (4 <em> (3 </em> fact(2)))<br> ===&gt; 5 <em> (4 </em> (3 <em> (2 </em> fact(1))))<br> ===&gt; 栈层的递减<br> ===&gt; 5 <em> (4 </em> (3 <em> (2 </em> 1)))<br> ===&gt; 5 <em> (4 </em> (3 <em> 2))<br> ===&gt; 5 </em> (4 <em> 6)<br> ===&gt; 5 </em> 24<br> ===&gt; 120</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">3. **递归 vs 循环** 求阶乘: 貌似循环看起来更省资源, 但是递归确实逻辑清晰</span><br></pre></td></tr></table></figure><p> def jiecheng(n):</p><pre><code> if n == 1 :     return 1 return n * jiecheng(n-1)</code></pre><p> print(jiecheng(5))</p><p> t = range(1, 6)<br> def forJieCheng(t):</p><pre><code> res = 1 for v in t:     res = res * v return res</code></pre></li></ol><pre><code>print(forJieCheng(t))```</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python的函数定义非常简单, 但灵活度却非常大, 除了正常定义的 必选参数 外, 还可以使用 默认参数, 可变参数 和 关键字参数, 使得函数定义出来的接口, 不但能处理复杂的参数, 还可以简化调用者的代码; &lt;/p&gt;
&lt;h2 id=&quot;必选参数&quot;&gt;&lt;a href=&quot;#必
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>11. 函数</title>
    <link href="http://blog.renyimin.com/2018/10/10/python/2018-10-10-Python-11/"/>
    <id>http://blog.renyimin.com/2018/10/10/python/2018-10-10-Python-11/</id>
    <published>2018-10-10T09:52:45.000Z</published>
    <updated>2018-10-10T10:00:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li><p>抽象是数学中非常常见的概念, 如计算数列的和, 比如：1 + 2 + 3 + … + 100, 写起来十分不方便, 于是数学家发明了求和符号 <code>∑</code>, 这种抽象记法非常强大，因为我们看到 <code>∑</code> 就可以理解成求和，而不是还原成低级的加法运算; 而函数就是最基本的一种代码抽象的方式; </p></li><li><p>在Python中，定义一个函数要使用<code>def</code>语句，依次写出<code>函数名</code>、<code>括号</code>、<code>括号中的参数</code>和<code>冒号:</code>，然后，在缩进块中编写函数体，函数的返回值用return语句返回;</p><ul><li><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(param):</span><br><span class="line">    if param &gt; 0:</span><br><span class="line">        return param</span><br><span class="line">    else:</span><br><span class="line">        return -param</span><br><span class="line">print(my_abs(-5.6))    </span><br><span class="line"># 结果为5.6</span><br></pre></td></tr></table></figure></li><li><p>如果没有return语句，函数执行完毕后<strong>也会返回结果</strong>，只是结果为<code>None</code>, return None可以简写为return</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(param):</span><br><span class="line">    if param &gt; 0:</span><br><span class="line">        return param</span><br><span class="line">    else:</span><br><span class="line">        return</span><br><span class="line">print(my_abs(-5.6))</span><br><span class="line"># 结果为 None</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果你已经把 my_abs() 的函数定义保存为abstest.py文件了, 那么, 可以在该文件的当前目录下启动Python解释器, 用 <code>from abstest import my_abs</code> 来导入my_abs()函数, 注意abstest是文件名（不含.py扩展名）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 可以理解为从abstest.py文件中导入abs函数</span><br><span class="line">from abstest import my_abs</span><br><span class="line">my_abs(-9)</span><br><span class="line"># 运行后结果也是正确的9</span><br></pre></td></tr></table></figure></li></ol><h2 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h2><ol><li><p>如果想定义一个什么事也不做的空函数，可以用<code>pass</code>语句：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def nop():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></li><li><p>pass语句什么都不做, 那有什么用?</p><ul><li>实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass, <strong>让代码能运行起来</strong>; (因为如果不写pass, 空函数运行就会有语法错误)</li><li>pass还可以用在其他语句里，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">   pass</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h2><ol><li><p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError;</p></li><li><p>但是如果参数类型不对，Python解释器就无法帮我们检查; 数据类型检查可以用内置函数 <code>isinstance()</code> 实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(&apos;bad operand type&apos;)</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure><p> 添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误</p></li></ol><h2 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431679203477b5b364aeba8c4e05a9bd4ec1b32911e2000" target="_blank" rel="noopener">函数返回多个值</a></h2><ol><li>函数返回多个值其实只是一种假象, Python函数返回的仍然是单一值, 由于这个值是个 tuple, 而在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line"></span><br><span class="line">def move(x, y, step, angle=0):</span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    return nx, ny</span><br><span class="line">x, y = move(100, 100, 60, math.pi / 6)</span><br><span class="line">print(x, y)</span><br><span class="line"># 返回 &lt;class &apos;tuple&apos;&gt;</span><br><span class="line">print(type(move(100, 100, 60, math.pi / 6)))</span><br></pre></td></tr></table></figure></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>定义函数时，需要确定函数名和参数个数；</li><li>如果有必要，可以先对参数的数据类型做检查；</li><li>函数体内部可以用return随时返回函数结果；</li><li>函数执行完毕也没有return语句时，自动return None；</li><li>函数可以同时返回多个值，但其实就是一个tuple；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;抽象是数学中非常常见的概念, 如计算数列的和, 比如：1 + 2 + 3 + … + 100, 写起来十分不方便, 于是数
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>10. 条件判断, 循环, 列表生成式</title>
    <link href="http://blog.renyimin.com/2018/10/10/python/2018-10-10-Python-10/"/>
    <id>http://blog.renyimin.com/2018/10/10/python/2018-10-10-Python-10/</id>
    <published>2018-10-10T02:54:35.000Z</published>
    <updated>2018-10-12T06:28:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431675624710bb20e9734ef343bbb4bd64bcd37d4b52000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431675624710bb20e9734ef343bbb4bd64bcd37d4b52000</a><br><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431676242561226b32a9ec624505bb8f723d0027b3e7000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431676242561226b32a9ec624505bb8f723d0027b3e7000</a></p><h2 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h2><ol><li>可用于 list, tuple, dict <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, [&apos;你好&apos;, &apos;大家好&apos;])</span><br><span class="line">for v in classmates:</span><br><span class="line">    print(v)</span><br><span class="line"></span><br><span class="line">list = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, [1,2,3,4]]</span><br><span class="line">for v in list:</span><br><span class="line">    print(v)</span><br></pre></td></tr></table></figure></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(myEnv_001) renyimindeMacBook-Pro:PythonStudy renyimin$ python for-tuple.py </span><br><span class="line">Michael</span><br><span class="line">Bob</span><br><span class="line">Tracy</span><br><span class="line">[&apos;你好&apos;, &apos;大家好&apos;]</span><br><span class="line">Michael</span><br><span class="line">Bob</span><br><span class="line">Tracy</span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure></code></pre><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431779637539089fd627094a43a8a7c77e6102e3a811000" target="_blank" rel="noopener">列表生成式</a></h2><ol><li><p>列表生成式(List Comprehensions), 是Python内置的非常简单却强大的可以用来创建list的生成式</p></li><li><p><strong>运用列表生成式, 可以写出非常简洁的代码</strong>, 如 要生成<code>list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>可以用<code>list(range(1, 11))</code>; 但是如果要生成<code>[1x1, 2x2, 3x3, ..., 10x10]</code>怎么做?</p><ul><li><p>方法一是循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L = list(range(1,11))</span><br><span class="line">res = []</span><br><span class="line">for v in L:</span><br><span class="line">    res.append(v*v)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure></li><li><p>可以看到循环仍然比较繁琐, 而列表生成式则可以用一行语句代替循环生成上面的list<br>写列表生成式时, 把要<code>生成的元素x * x</code>放到前面, 后面跟for循环, 就可以把list创建出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print([x * x for x in range(1, 11)])</span><br></pre></td></tr></table></figure></li></ul></li><li><p>列表生成式的for循环后面还可以加上if判断, 如下仅筛选出偶数的平方</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x * x for x in range(1, 11) if x % 2 == 0]</span><br></pre></td></tr></table></figure></li><li><p>列表生成式的for循环还可以是多层的(不过一般三层和三层以上的就很少用到了)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print([m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;])</span><br></pre></td></tr></table></figure></li><li><p>运用列表生成式，可以写出非常简洁的代码, 再如, <strong>列出当前目录下的所有文件和目录名</strong>, 可以通过一行代码实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 导入os模块，模块的概念后面讲到</span><br><span class="line">import os</span><br><span class="line">print([d for d in os.listdir(&apos;.&apos;)])</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431675624710bb20e9734ef343bbb4bd64bcd37d4
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>09. dict 和 set</title>
    <link href="http://blog.renyimin.com/2018/10/10/python/2018-10-10-Python-09/"/>
    <id>http://blog.renyimin.com/2018/10/10/python/2018-10-10-Python-09/</id>
    <published>2018-10-10T02:53:33.000Z</published>
    <updated>2018-10-12T06:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dict"><a href="#dict" class="headerlink" title="dict {}"></a>dict <code>{}</code></h2><ol><li><p>Python内置了字典 <code>dict</code> 的支持, dict全称dictionary, 在其他语言中也称为map, 使用键-值(key-value)存储, 具有极快的查找速度;</p></li><li><p>举个例子, 假设要根据同学的名字查找对应的成绩, 如果用list实现, 需要两个list:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">scores = [95, 75, 85]</span><br></pre></td></tr></table></figure><p> 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩, <strong>list越长耗时越长</strong></p></li><li><p>而如果用dict实现, 只需要一个 “名字”-“成绩” 的对照表, 直接根据名字查找成绩, 无论这个表有多大, 查找速度都不会变慢, 用Python写一个dict如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&apos;Michael&apos;: 95, &apos;Bob&apos;: 75, &apos;Tracy&apos;: 85&#125;</span><br><span class="line">&gt;&gt;&gt; d[&apos;Michael&apos;]</span><br><span class="line">95</span><br></pre></td></tr></table></figure></li><li><p>为什么dict查找速度这么快?</p><ul><li>因为dict的实现原理和查字典是一样的, 假设字典包含了1万个汉字, 我们要查某一个字, 一个办法是把字典从第一页往后翻, 直到找到我们想要的字为止, 这种方法就是在list中查找元素的方法, list越大, 查找越慢;</li><li>第二种方法是先在字典的索引表里(比如部首表)查这个字对应的页码, 然后直接翻到该页, 找到这个字;无论找哪个字, 这种查找速度都非常快, 不会随着字典大小的增加而变慢<br>dict就是第二种实现方式，给定一个名字，比如’Michael’，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。<br>这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。</li></ul></li><li><p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&apos;Adam&apos;] = 67</span><br><span class="line">&gt;&gt;&gt; d[&apos;Adam&apos;]</span><br><span class="line">67</span><br></pre></td></tr></table></figure></li><li><p>如果获取的key不存在，dict就会报错：</p><ul><li><p>要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Thomas&apos; in d</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li><p>二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.get(&apos;Thomas&apos;)</span><br><span class="line">&gt;&gt;&gt; d.get(&apos;Thomas&apos;, -1)</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：返回None的时候Python的交互环境不显示结果。</strong></p></li><li><p>要删除一个key，用pop(key)方法，对应的value也会从dict中删除；</p></li><li><p>和list比较，dict有以下几个特点：</p><ul><li>查找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多。</li><li>而list相反：<br>查找和插入的时间随着元素的增加而增加；<br>占用空间小，浪费内存很少。<br>所以，dict是用空间来换取时间的一种方法。</li></ul></li><li><p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。<br> 要保证hash的正确性，作为key的对象就不能变。<strong>在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; key = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; d[key] = &apos;a list&apos;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: &apos;list&apos;</span><br></pre></td></tr></table></figure></li><li><p>dict 也可以使用 for … in 来进行迭代</p><ul><li>因为dict的存储不是按照list的方式顺序排列, 所以, 迭代出的结果顺序很可能不一样</li><li>默认情况下, dict迭代的是key; 如果要迭代value, 可以用 <code>for value in d.values()</code>; 如果要同时迭代key和value, 可以用 <code>for k, v in d.items()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;0:&quot;renyimin&quot;, &quot;age&quot;:500&#125;</span><br><span class="line"># 注意: 下面不能写成  for k, v in dict:</span><br><span class="line">for k, v in dict.items():</span><br><span class="line">    print(&apos;k=&gt;v : %s =&gt; %s&apos; % (k, v))</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>顺序存储, 链式存储, hash : <a href="https://yq.aliyun.com/ziliao/430573" target="_blank" rel="noopener">https://yq.aliyun.com/ziliao/430573</a></li></ol><h2 id="set-set"><a href="#set-set" class="headerlink" title="set set([])"></a>set <code>set([])</code></h2><ol><li>set和dict类似, 不过它只是一组key的集合, 不存储value; 另外, 它的 key不重复;</li><li><p>要创建一个set, 需要提供一个list作为输入集合:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>注意, 传入的参数 <code>[1, 2, 3]</code> 是一个list, 而显示的 <code>{1, 2, 3}</code> 只是告诉你这个set内部有1，2，3这3个元素，<strong>显示的顺序也不表示set是有序的</strong>; <strong>重复元素在set中自动被过滤</strong></p></li><li>通过 <code>add(key)</code> 方法可以添加元素到set中，可以重复添加，但不会有效果;</li><li><code>remove(key)</code> 方法可以删除元素</li><li><p><strong>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s2 = set([2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure></li><li><p>set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”; </p><ul><li>set和dict的唯一区别仅在于没有存储对应的value;</li><li>如果把list放入set, 会报错<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1,2,3,4,2,3,4,[57,8]])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: &apos;list&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># str是不变对象</span><br><span class="line">&gt;&gt;&gt; a = &apos;abc&apos;</span><br><span class="line">&gt;&gt;&gt; a.replace(&apos;a&apos;, &apos;A&apos;)</span><br><span class="line">&apos;Abc&apos;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;abc&apos;</span><br><span class="line"># 而list是可变对象</span><br><span class="line">&gt;&gt;&gt; b = [&apos;c&apos;, &apos;b&apos;, &apos;a&apos;]</span><br><span class="line">&gt;&gt;&gt; b.sort()</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;dict&quot;&gt;&lt;a href=&quot;#dict&quot; class=&quot;headerlink&quot; title=&quot;dict {}&quot;&gt;&lt;/a&gt;dict &lt;code&gt;{}&lt;/code&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Python内置了字典 &lt;code&gt;dict&lt;/code&gt; 的支持,
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>08. list 和 tuple</title>
    <link href="http://blog.renyimin.com/2018/10/09/python/2018-10-09-Python-08/"/>
    <id>http://blog.renyimin.com/2018/10/09/python/2018-10-09-Python-08/</id>
    <published>2018-10-09T14:06:23.000Z</published>
    <updated>2018-10-10T08:32:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="list"><a href="#list" class="headerlink" title="list []"></a>list <code>[]</code></h2><ol><li><p>Python内置的<strong>有序列表</strong>list, 可以随时添加和删除其中的元素</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = [&apos;小明&apos;, &apos;小强&apos;, &apos;小张&apos;, &apos;小明&apos;]</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;小明&apos;, &apos;小强&apos;, &apos;小张&apos;, &apos;小明&apos;]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p>用 <code>len()</code> 函数可以获得list元素的个数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(classmates)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p>可以用索引来访问list中每一个位置的元素(索引是从0开始的), 当索引超出了范围时, Python会报一个IndexError错误, 所以, 要确保索引不要越界, 最后一个元素的索引是len(classmates) - 1;<br> 还可以用负数做索引, 比如-1做索引, 会直接获取最后一个元素; 当然, -5 就越界了</p></li><li><p>list是一个可变的有序表</p><ul><li>可以往list中追加元素到末尾 <code>classmates.append(&#39;小王&#39;)</code></li><li>也可以把元素插入到指定的位置, 比如在索引号为1的位置插入: <code>classmates.insert(1, &#39;Jack&#39;)</code></li><li>要删除list末尾的元素, 用 <code>pop()</code> 方法</li><li>要删除指定位置的元素, 用 <code>pop(i)</code> 方法, 其中i是索引位置</li></ul></li><li><p>list里面的元素的<strong>数据类型可以不同</strong>, 还可以是另一个list</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [&apos;python&apos;, &apos;java&apos;, [&apos;asp&apos;, &apos;php&apos;], &apos;scheme&apos;]</span><br><span class="line">&gt;&gt;&gt; len(s)</span><br><span class="line">4</span><br></pre></td></tr></table></figure><ul><li>要注意s只有4个元素, 其中 <code>s[2]</code> 又是一个list，如果拆开写就更容易理解了：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p = [&apos;asp&apos;, &apos;php&apos;]</span><br><span class="line">&gt;&gt;&gt; s = [&apos;python&apos;, &apos;java&apos;, p, &apos;scheme&apos;]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>要拿到’php’可以写 <code>p[1]</code> 或者 <code>s[2][1]</code>，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到</p></li></ol><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple ()"></a>tuple <code>()</code></h2><ol><li><p>另一种<strong>有序列表</strong>叫元组: tuple, tuple和list非常类似, 但是tuple一旦初始化就不能修改, 比如同样是列出同学的名字</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;)</span><br></pre></td></tr></table></figure></li><li><p>现在, classmates这个tuple不能变了, 它也没有append(), insert()这样的方法, 其他获取元素的方法和list是一样的, 你可以正常地使用<code>classmates[0]</code>, <code>classmates[-1]</code>; 但不能赋值成另外的元素</p></li><li><p>因为<strong>tuple不可变</strong>, 所以代码更安全, 如果可能, 能用 tuple 代替 list 就尽量用tuple;</p></li><li><p>tuple 的坑: </p><ul><li><p>当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1, 2)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1, 2)</span><br></pre></td></tr></table></figure></li><li><p>如果要定义一个空的tuple，可以写成():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t=tuple()</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">()</span><br></pre></td></tr></table></figure></li><li><p>但是，<strong>如果要定义一个只有1个元素的tuple</strong>，如果你这么定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>定义的不是tuple, 而是1这个数!! 因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</p></li><li><p>所以, 如果只有1个元素的tuple, 定义时必须加一个逗号<code>,</code>，来消除歧义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1,)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1,)</span><br></pre></td></tr></table></figure><p>Python在显示只有1个元素的tuple时，也会加一个逗号<code>,</code>，以免你误解成数学计算意义上的括号</p></li></ul></li><li><p>最后来看一个 <strong>可变的</strong> tuple: tuple所谓的“不变”是说，tuple的每个元素，指向永远不变, 即指向’a’, 就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的; 另外, 即便是tuple中有变量, tuple也是拿到变量的具体的值(这个值需要是不变的)</p><ul><li><p>例1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># tuple的每个元素，指向永远不变</span><br><span class="line">&gt;&gt;&gt; a=1</span><br><span class="line">&gt;&gt;&gt; b=2</span><br><span class="line">&gt;&gt;&gt; t=(a, b, 3)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1, 2, 3)</span><br><span class="line"># 改变a,b后, 发现tuple并没有发生变化, 可以理解为 tuple在创建时, 在拿到了 a, b 变量的值之后就 和 a, b 变量没关系了; 再次改变a,b的指向, 只是a,b变量本身的问题, 和tuple中的前两个元素就没关系了</span><br><span class="line">&gt;&gt;&gt; a=10</span><br><span class="line">&gt;&gt;&gt; b=20</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1, 2, 3)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p>再如下例子 tuple中 <code>t[0]</code>的地址和 值100在内存中的地址一样; 当a 重新指向 值1000在内存中的地址后, a 的地址变了, 但是 <code>t[0]</code> 的地址并没有变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 100</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4437875824</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t = (a, 200, 300)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(100, 200, 300)</span><br><span class="line"># t[0]的地址和 值100在内存中的地址一样</span><br><span class="line">&gt;&gt;&gt; id(t[0])</span><br><span class="line">4437875824</span><br><span class="line"># 当a 重新指向 值1000在内存中的地址后, a 的地址变了, 但是 t[0] 的地址并没有变化</span><br><span class="line">&gt;&gt;&gt; a = 1000</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4439732016</span><br><span class="line">&gt;&gt;&gt; id(t[0])</span><br><span class="line">4437875824</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>扩展</strong>: 两个变量 a, b都是2.0时, 你会发现它们的地址不一样, 说明系统为a,b分配了不同的内存空间; 但是, 当a,b都是2时, 0它们的地址是一样的，怎么回事呢?<br> 这是因为，<strong>为了提高内存空间的利用效率</strong>，对于一些比较小的整型变量(int)使用了相同的内存空间。如果数值比较大，地址就不一样了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=2.0</span><br><span class="line">&gt;&gt;&gt; b=2.0</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4438892784</span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">4438893024</span><br><span class="line">&gt;&gt;&gt; a=2</span><br><span class="line">&gt;&gt;&gt; b=2</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4437872688</span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">4437872688</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;list&quot;&gt;&lt;a href=&quot;#list&quot; class=&quot;headerlink&quot; title=&quot;list []&quot;&gt;&lt;/a&gt;list &lt;code&gt;[]&lt;/code&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Python内置的&lt;strong&gt;有序列表&lt;/strong&gt;list
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>07. 字符串相关</title>
    <link href="http://blog.renyimin.com/2018/10/09/python/2018-10-09-Python-07/"/>
    <id>http://blog.renyimin.com/2018/10/09/python/2018-10-09-Python-07/</id>
    <published>2018-10-09T09:36:27.000Z</published>
    <updated>2018-10-17T11:37:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>Python 不支持单字符类型, 单字符在 Python 中也是作为一个字符串使用, 也就是字符和字符串都一样, 都是 单引号或双引号包起来即可;</li><li>Python 访问子字符串<ul><li>可以使用 <code>[索引]</code> 来获取字符串</li><li>也可以使用 切片Slice (<code>str[0:3]</code>, <code>str[-3:-2]</code>) 来截取字符串 (切片遵循左闭右开原则, 即左边包含,右边不包含)</li></ul></li><li><p>字符串运算符</p><ul><li>拼接用 <code>+</code> (注意: 字符串不能 <code>+</code> 其他类型如 <code>&#39;python&#39;+10</code> 会报错)</li><li><p>重复输出字符串用 <code>*</code> : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;Python&quot;*3</span><br><span class="line">&apos;PythonPythonPython&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>in</code> 成员运算符 - 如果字符串中包含给定的字符返回 True</p></li><li><code>not in</code> 成员运算符 - 如果字符串中不包含给定的字符返回 True</li><li><code>%</code> 格式化字符串</li></ul></li><li><p><strong>三引号</strong>(<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>)让程序员从引号和特殊字符串的泥潭里面解脱出来, 在三引号中的内容会所见即所得地输出, 允许字符串跨多行, 里面的单引号, 双引号, 换行符都不用转义;</p></li><li><p>字符串内建函数</p><ul><li><p><code>title()</code> : 返回”标题化”的字符串, 即 所有单词都是以大写开始, 其余字母均为小写</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;hELlo world&apos;.title()</span><br><span class="line">&apos;Hello World&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>istitle()</code> : 如果字符串是标题化的则返回 True, 否则返回 False</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Hello World&apos;.istitle()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &apos;Hello world&apos;.istitle()</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li><p><code>swapcase()</code> : 将字符串中大写转小写, 小写转大写 (汉字自然就不变)</p></li><li><code>upper()</code> : 将字符串中所有小写字母转换成大写</li><li><code>lower()</code> : 将字符串中所有大写字母转换成小写</li><li><p><code>capitalize()</code> :将字符串的第一个字符转换为大写 </p></li><li><p><code>count(str, beg= 0,end=len(string))</code> : 返回 str 在 string 里面出现的次数, 如果 beg 或者 end 指定, 则返回指定范围内 str 出现的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;renyimin&quot;.count(&apos;n&apos;, 2)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; &quot;renyimin&quot;.count(&apos;n&apos;, 2, -1)</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li><li><p><code>startswith(str, beg=0,end=len(string))</code> : 检查字符串是否是以 obj 开头, 是则返回 True, 否则返回 False, 如果beg 和 end 指定值, 则在指定范围内检查</p></li><li><p><code>split(str=&quot;&quot;, num)</code> : 以 str 为分隔符截取字符串, 如果 num 有指定值, 则仅截取 num 个子字符串</p></li><li>……</li></ul></li></ol><h2 id="格式化str"><a href="#格式化str" class="headerlink" title="% 格式化str"></a><code>%</code> 格式化str</h2><ol><li><p>在Python中, 采用的格式化方式和C语言是一致的, 用 <code>%</code> 实现, 举例如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;</span><br><span class="line">&apos;Hello, %s&apos; % &apos;world&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>%</code> 运算符就是用来格式化字符串的</p><ul><li>在字符串内部, <code>%s</code> 表示用字符串替换, <code>%d</code> 表示用整数替换, 有几个占位符, 后面就跟几个变量或者值, 顺序要对应好, 多个变量或者值用括号括起来; 如果只有一个占位符, 则后面变量或值的括号可以省略;</li><li>占位符有多种(%d, %f, %s, %x), 如果你不太确定应该用什么占位符, <code>%s</code> 永远起作用, 它会把任何数据类型转换为字符串;</li></ul></li></ol><h2 id="format-格式化字符串"><a href="#format-格式化字符串" class="headerlink" title="format()格式化字符串"></a><code>format()</code>格式化字符串</h2><ol><li><p>它会用传入的参数依次替换字符串内的占位符<code>{0}</code>、<code>{1}</code> ……, 不过这种方式写起来比%要麻烦得多</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&apos;.format(&apos;小明&apos;, 17.125)</span><br><span class="line">&apos;Hello, 小明, 成绩提升了 17.1%&apos;</span><br></pre></td></tr></table></figure></li><li></li></ol><h2 id="str-与-bytes转换"><a href="#str-与-bytes转换" class="headerlink" title="str 与 bytes转换"></a>str 与 bytes转换</h2><ol><li>对于单个字符的编码, Python提供了 <code>ord()</code> 函数获取字符的整数表示, <code>chr()</code> 函数把编码转换为对应的字符; </li><li><p>如果知道字符的十六进制编码, 还可以如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;\u4e2d\u6587&apos;</span><br><span class="line">&apos;中文&apos;</span><br></pre></td></tr></table></figure></li><li><p>由于Python的字符串类型是str, 在内存中以Unicode表示, 一个字符对应若干个字节; 如果要在网络上传输或者保存到磁盘上, 就需要把str变为以字节为单位的bytes:</p><ul><li>Python对 <code>bytes类型</code> 的数据用带 <code>b前缀</code> 的单引号或双引号表示</li><li>以Unicode表示的str通过<code>encode()</code>方法可以编码为指定的<code>bytes</code><br>纯英文的str可以用<code>ASCII</code>编码为bytes, 内容是一样的;<br>含有中文的str可以用<code>UTF-8</code>编码为bytes;<br>含有中文的str无法用<code>ASCII</code>编码, 因为中文编码的范围超过了ASCII编码的范围, Python会报错;</li></ul></li><li><p>反过来, 如果我们从网络或磁盘上读取了字节流, 那么读到的数据就是bytes, 要把bytes变为str, 就需要用decode()方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)</span><br><span class="line">&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;)</span><br><span class="line">&apos;中文&apos;</span><br></pre></td></tr></table></figure></li><li><p>要计算str包含多少个<strong>字符</strong>, 可以用 <code>len()</code> 函数; len()函数计算的是str的字符数, 如果换成bytes, len()函数就计算<strong>字节数</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&apos;ABC&apos;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(&apos;中文&apos;)</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">// 可见, 1个中文字符经过UTF-8编码后通常会占用3个字节, 而1个英文字符只占用1个字节</span><br><span class="line">&gt;&gt;&gt; len(b&apos;ABC&apos;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; len(&apos;中文&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">6</span><br></pre></td></tr></table></figure></li><li><p>在操作字符串时, 经常遇到str和bytes的互相转换, 为了避免乱码问题, 应当始终坚持使用UTF-8编码对str和bytes进行转换;</p><ul><li>当str和bytes使用 <code>encode()</code>, <code>decode()</code> 互相转换时, 需要指定编码; 最常用的编码是UTF-8; </li><li>Python当然也支持其他编码方式, 比如把Unicode编码成GB2312; <strong>但这纯属自找麻烦</strong>, 如果没有特殊业务要求, 请牢记仅使用UTF-8编码;</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Python 不支持单字符类型, 单字符在 Python 中也是作为一个字符串使用, 也就是字符和字符串都一样, 都是 单引号或
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>05. 基本数据类型简介</title>
    <link href="http://blog.renyimin.com/2018/10/08/python/2018-10-08-Python-05/"/>
    <id>http://blog.renyimin.com/2018/10/08/python/2018-10-08-Python-05/</id>
    <published>2018-10-08T12:36:23.000Z</published>
    <updated>2018-10-16T09:47:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>Python3 六个标准数据类型</p><ul><li>Number(数字)</li><li>String(字符串)</li><li>List(列表)</li><li>Tuple(元组)</li><li>Set(集合)</li><li>Dictionary(字典)</li></ul></li><li><p>注意: </p><ul><li>不可变数据(3 个): Number、String、Tuple</li><li>可变数据(3 个): List、Dictionary、Set</li></ul></li><li><p>内置的 <code>type()</code> 函数可以用来查询变量所指的对象类型</p></li></ol><h2 id="Number-数字"><a href="#Number-数字" class="headerlink" title="Number(数字)"></a>Number(数字)</h2><p>Python3 支持 int、float、bool、complex(复数) 这几种数字类型;</p><h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><ol><li><p>注意: 在Python3里, 整型只有 <code>int</code>, 并且是长整型(没有 python2 中的 Long)</p><ul><li>适合大数据运算, 不会溢出, 也不会有其他语言那样还分 短整型, 整型, 长整型;</li><li>python中的整数理论上支持的大数是无限位的, 对于超大整数运算是直接支持的, 没有大小限制(只要内存足够大); 而某些语言的整数根据其存储长度是有大小限制的, 例如Java对int型的范围限制在 $-2^{31}$(-2147483648) 到 $2^{31}-1$(2147483647)</li><li>获取 python 支持的最大整数 (但实际上可以支持更大整数的运算, 可参考 <a href="https://bbs.csdn.net/wap/topics/310241283" target="_blank" rel="noopener">https://bbs.csdn.net/wap/topics/310241283</a>, <a href="https://my.oschina.net/748/blog/2221779" target="_blank" rel="noopener">https://my.oschina.net/748/blog/2221779</a>)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">max = sys.maxsize</span><br><span class="line">print (max)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意: python 对较小的整型变量(int)使用了相同的内存空间, 但是如果数值比较大, 地址就不一样了</p><ul><li>参考: <a href="https://blog.csdn.net/WSBruce/article/details/79234389" target="_blank" rel="noopener">https://blog.csdn.net/WSBruce/article/details/79234389</a></li><li>当 a,b 的值都是2.0时, 它们的地址不一样, 说明系统为a,b分配了不同的内存空间; 但是当 a,b 的值都是2时, 它们的地址是一样的, 这是因为, 为了提高内存空间的利用效率, 对于一些比较小的整型变量(int)使用了相同的内存空间, 如果数值比较大, 地址就不一样了</li></ul></li></ol><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><ol><li><p>Python的浮点数也没有大小限制, 但是超出一定范围就直接表示为inf（无限大）</p></li><li><p><a href="http://www.runoob.com/w3cnote/python-round-func-note.html" target="_blank" rel="noopener">round</a>问题</p><ul><li><p>如果只有一个参数: round(num), 返回最靠近num的整数, 如果num出现.5, 此时两边的距离都一样, round()取偶数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; round(3.5)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; round(4.5)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; round(4.51)</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li><li><p>第二个参数是保留的小数位数</p></li><li>在操作 浮点数 时, 除非对精确度没什么要求, <strong>否则尽量避开用round()函数</strong></li></ul></li><li><p>ceil: math模块的 <code>math.ceil(x)</code>, 取大于等于x的最小整数</p></li><li><p>floor: math模块的 <code>math.floor(x)</code>, 取小于等于x的最大整数</p></li><li><p><strong>浮点数精度要求如果很高的话，请用 decimal 模块</strong> </p></li></ol><h2 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h2><ol><li><p>python 中布尔值使用常量 <code>True</code> 和 <code>False</code>来表示, <strong>注意大小写</strong></p></li><li><p>注意: </p><ul><li><p>python中, bool是int的子类(继承int), 故 <code>True==1</code>  <code>False==0</code> 是会返回Ture的; 如要切实判断用 <code>xxx is True</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(1 == True)</span><br><span class="line">print(0 == False)</span><br><span class="line">print(True is True)</span><br><span class="line">print(False is False)</span><br></pre></td></tr></table></figure></li><li><p>由于bool是int, 可进行数字计算 <code>print(True+True)</code> </p></li></ul></li><li><p><strong>True False 判定</strong></p><ul><li><p>以下会被判定为 False:<br><code>None</code><br><code>False</code><br><code>zero of any numeric type, for example, 0, 0.0, 0j</code><br><code>any empty sequence, for example, &#39;&#39;, (), []</code><br><code>any empty mapping, for example, {}</code><br><code>instances of user-defined classes, if the class defines a __bool__() or __len__() method, when that method returns the integer zero or bool value False</code></p></li><li><p>除了以上的, 其他的表达式均会被判定为 True (这个需要注意, 与其他的语言有比较大的不同)<br>(注意, 字符串的’0’,”0.0” 可不包含在False的范畴中)</p></li></ul></li></ol><h2 id="inf"><a href="#inf" class="headerlink" title="inf"></a>inf</h2><ol><li><p>Python中可以用如下方式表示正负无穷</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float(&quot;inf&quot;)</span><br><span class="line">float(&quot;-inf&quot;)</span><br></pre></td></tr></table></figure></li><li><p>inf 运算</p><ul><li>inf 做简单加、乘算术运算仍会得到 inf</li><li>inf 乘以0会得到 <code>NaN</code> (not-a-number)</li><li>inf 外的其他数 除以inf, 会得到0</li></ul></li><li><p>inf不等式</p><ul><li>所有数都比-inf大</li><li>所有数都比+inf小</li></ul></li><li><p>inf等式: +inf 和 +inf相等, -inf 和 -inf相等</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(infinity&lt;-infinity)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; print(infinity&gt;-infinity)</span><br><span class="line">True</span><br></pre></td></tr></table></figure></li></ol><h2 id="待补充知识"><a href="#待补充知识" class="headerlink" title="待补充知识"></a>待补充知识</h2><ol><li>不同语言的 int, long 整数类型范围为何不同?? 有的还和操作系统有关 ??</li><li>为什么Python中整型不会溢出 ??</li><li>大整数加减乘除算法专题 ??</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Python3 六个标准数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Number(数字)&lt;/li&gt;
&lt;li&gt;String(字符串)
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>04. 基础语法</title>
    <link href="http://blog.renyimin.com/2018/09/30/python/2018-09-30-Python-04/"/>
    <id>http://blog.renyimin.com/2018/09/30/python/2018-09-30-Python-04/</id>
    <published>2018-09-30T07:38:57.000Z</published>
    <updated>2018-10-17T11:44:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两种执行模式"><a href="#两种执行模式" class="headerlink" title="两种执行模式"></a>两种执行模式</h2><ol><li><p>命令行模式</p><ul><li>可以执行 <code>python XXX.py</code> 运行一个.py文件</li><li>可以执行 <code>python</code> 进入Python交互模式</li></ul></li><li><p>Python交互模式</p><ul><li>进入到Python交互模式, 它的提示符是 <code>&gt;&gt;&gt;</code></li><li>在Python交互模式下输入 <code>exit()</code> 并回车, 就退出了Python交互模式, 并回到命令行模式 (也可以 <code>Ctrl+d</code>)</li></ul></li><li><p>两种模式小区别:</p><ul><li>进入python交互模式, 相当于启动了Python解释器, 等待你一行一行地输入源代码, 每输入一行就执行一行;</li><li>直接运行 .py文件 相当于启动了Python解释器, 然后一次性把 .py文件的源代码 给执行了;</li></ul></li><li><p><strong>python源码文件头</strong>: </p><ul><li><p>当Python解释器读取源代码时, 为了让它按UTF-8编码读取, 我们通常在文件开头写上如下两行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure><p>第一行注释是为了告诉Linux/OS X系统, 这是一个Python可执行程序, Windows系统会忽略这个注释;<br>第二行注释是为了告诉Python解释器, 按照UTF-8编码读取源代码, 否则, 你在源代码中写的中文输出可能会有乱码;</p></li><li><p>可以为你的pycharm编辑器设置文件头部模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : $&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class="line"># @Author  : Ryu</span><br><span class="line"># @Site    : $&#123;SITE&#125;</span><br><span class="line"># @File    : $&#123;NAME&#125;.py</span><br><span class="line"># @Software: $&#123;PRODUCT_NAME&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/python/pycharm-pythonscript-head.png"></p></li></ul></li></ol><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ol><li><p>输出 <code>print()</code></p><ul><li>用 <code>print()</code> 在括号中加上字符串, 就可以向屏幕上输出指定的文字, 比如输出’hello, world’: <code>&gt;&gt;&gt; print(&#39;hello, world&#39;)</code></li><li><code>print()</code> 函数也可以接受多个字符串, 用逗号 <code>,</code> 隔开, 就可以连成一串输出 (用逗号隔开时, 遇到逗号 <code>,</code> 会输出一个 <code>空格</code>)</li></ul></li><li><p>输入 <code>input()</code></p></li></ol><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ol><li><p>对编码格式要求比较严格, 采用<strong>缩进方式</strong>(推荐使用4个空格缩进); 如果随意缩进, 是会报错的;</p></li><li><p><strong>大小写敏感</strong></p></li><li><p>单行注释: 以 <code>#</code> 开头, 并且需要确保 注释与其下方的代码处于同一缩进级别;</p></li><li><p>多行注释: 3个单引号 <code>&#39;&#39;&#39; ... &#39;&#39;&#39;</code>, 或者 3个双引号 <code>&quot;&quot;&quot; ... &quot;&quot;&quot;</code> </p></li><li><p>当语句以冒号 <code>:</code> 结尾时, 缩进的语句视为代码块</p></li></ol><h2 id="PyCharm忽略警告信息"><a href="#PyCharm忽略警告信息" class="headerlink" title="PyCharm忽略警告信息"></a>PyCharm忽略警告信息</h2><ol><li><p>使用 PyCharm 编写Python代码非常高效, 但有一点体验不太好, 就是代码编写时要按照 <strong>PEP8</strong> 代码风格编写, 不然会有波浪线的警告信息, 如 <code>PEP 8: expected 2 blank lines, found 0</code> : </p></li><li><p>解决方法:</p><ul><li>方法一: 将鼠标移到提示的地方, 按 <code>alt+Enter</code>, 选择忽略(Ignore)这个错误即可 (会自动像方法二中那样对pycharm进行配置)</li><li>方法二: 配置pycharm忽略该提示, 参考: <code>&quot;File –&gt;Settings–&gt;Editor–&gt;Inspections–&gt;Python–&gt;PEP8 coding style violation&quot;</code><br><a href="https://blog.csdn.net/zgljl2012/article/details/51907663" target="_blank" rel="noopener">https://blog.csdn.net/zgljl2012/article/details/51907663</a><br><a href="http://www.zgljl2012.com/pycharmxuan-ze-xing-hu-lue-pep8dai-ma-feng-ge-jing-gao-xin-xi/" target="_blank" rel="noopener">http://www.zgljl2012.com/pycharmxuan-ze-xing-hu-lue-pep8dai-ma-feng-ge-jing-gao-xin-xi/</a><br><a href="https://pep8.readthedocs.io/en/latest/intro.html#configuration" target="_blank" rel="noopener">https://pep8.readthedocs.io/en/latest/intro.html#configuration</a></li></ul></li><li><p><code>Function name should be lowercase</code>, 决方法同上 : <code>&quot;File –&gt;Settings–&gt;Editor–&gt;Inspections–&gt;Python–&gt;PEP 8 naming convention violation&quot;</code></p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/ajianbeyourself/p/4377933.html" target="_blank" rel="noopener">PEP8 中文翻译</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;两种执行模式&quot;&gt;&lt;a href=&quot;#两种执行模式&quot; class=&quot;headerlink&quot; title=&quot;两种执行模式&quot;&gt;&lt;/a&gt;两种执行模式&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;命令行模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以执行 &lt;code&gt;python XXX.py&lt;/
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>01. 基础 - Anaconda 环境管理</title>
    <link href="http://blog.renyimin.com/2018/09/29/python/2018-09-29-Python-02/"/>
    <id>http://blog.renyimin.com/2018/09/29/python/2018-09-29-Python-02/</id>
    <published>2018-09-29T07:41:12.000Z</published>
    <updated>2018-09-29T08:44:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h2><ol><li>在使用Python时，我们经常需要用到很多第三方库，例如，Pillow，MySQL驱动程序，Web框架Flask，科学计算Numpy等。用pip一个一个安装费时费力，还需要考虑兼容性。我们推荐直接使用Anaconda，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用;</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>在安装Anaconda之前, 其实不需要安装Python, 因为Anaconda中包括了Python; 可在<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">Anaconda官网</a>下载并双击进行安装</p><ul><li>下载时会发现有两个不同版本的Anaconda，分别对应Python 2.7和Python 3.6, 两个版本其实除了这点区别外其他都一样 (但其实选择安装哪个版本并不重要, 因为通过Anaconda的环境管理, 可以很方便地切换运行时的Python版本)</li><li>如下就安装好了:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ which conda</span><br><span class="line">/Users/renyimin/Desktop/Anaconda3/anaconda3/bin/conda</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意: Anaconda会把系统Path中的python指向自己自带的Python, 并且, Anaconda安装的第三方模块会安装在Anaconda自己的路径下, 不影响系统已安装的Python目录</p><ul><li><p>可以看到, 之前的系统path中的python是Mac默认的python2.7, 而现在是Anaconda中自带的python3.6.5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ python</span><br><span class="line">Python 3.6.5 |Anaconda, Inc.| (default, Apr 26 2018, 08:42:37)</span><br><span class="line">[GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p>另外, 之前path中的版本都还在 (只不过直接使用python3的话, 不会使用之前安装的3.7, 而是用的Anaconda中的python3.6)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ python2 -V</span><br><span class="line">Python 2.7.14</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ python2.7 -V</span><br><span class="line">Python 2.7.14</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ python3 -V</span><br><span class="line">Python 3.6.5 :: Anaconda, Inc.</span><br><span class="line">// 要用自己安装的python3.7, 需要使用 python3.7</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ python3.7 -V</span><br><span class="line">Python 3.7.0</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></li></ul></li><li><p>另外, Anaconda会把系统Path中的pip指向自己的pip </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ pip -V</span><br><span class="line">pip 10.0.1 from /Users/renyimin/Desktop/Anaconda3/anaconda3/lib/python3.6/site-packages/pip (python 3.6)</span><br><span class="line"></span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ pip2 -V</span><br><span class="line">pip 9.0.3 from /usr/local/lib/python2.7/site-packages (python 2.7)</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ pip2.7 -V</span><br><span class="line">pip 9.0.3 from /usr/local/lib/python2.7/site-packages (python 2.7)</span><br><span class="line"></span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ pip3 -V</span><br><span class="line">pip 18.0 from /usr/local/lib/python3.7/site-packages/pip (python 3.7)</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ pip3.7 -V</span><br><span class="line">pip 18.0 from /usr/local/lib/python3.7/site-packages/pip (python 3.7)</span><br></pre></td></tr></table></figure></li><li><p>同时, Anaconda还内置了许多非常有用的第三方库, 由于我们现在本机既有Python2(<code>python</code>), 又有Python3.7(<code>python3.7</code>), 还有Anaconda自带的Python3.6(<code>python3</code>), 所以查看包列表也是有三个pip命令可以运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip (Anaconda自带的) list : 会发现有很多内置包</span><br><span class="line"></span><br><span class="line">pip2 (Mac默认带的) list : 干净的, 需要自己安装</span><br><span class="line">pip3 (自己装的Python3) list : 干净的, 需要自己安装</span><br></pre></td></tr></table></figure></li><li><p>另外, 安装完后, 电脑中多了一些应用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Anaconda Navigtor ：用于管理工具包和环境的图形用户界面，后续涉及的众多管理命令也可以在 Navigator 中手工实现</span><br><span class="line">Jupyter notebook ：基于web的交互式计算环境，可以编辑易于人们阅读的文档，用于展示数据分析的过程</span><br><span class="line">qtconsole ：一个可执行 IPython 的仿终端图形界面程序，相比 Python Shell 界面，qtconsole 可以直接显示代码生成的图形，实现多行代码输入执行，以及内置许多有用的功能和函数。</span><br><span class="line">spyder ：一个使用Python语言、跨平台的、科学运算集成开发环境。</span><br></pre></td></tr></table></figure></li><li><p>安装完成后，我们还需要对所有工具包进行升级，以避免可能发生的错误, 打开你电脑的终端，在命令行中输入</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:bin renyimin$ conda upgrade --all</span><br><span class="line">Solving environment: |</span><br></pre></td></tr></table></figure></li></ol><h2 id="虚拟环境管理"><a href="#虚拟环境管理" class="headerlink" title="虚拟环境管理"></a>虚拟环境管理</h2><ol><li><p>可以在命令中运行 <code>conda info -e</code> 或者 <code>conda env list</code> 查看 Anaconda 中已安装的环境, 当前被<strong>激活</strong>的环境会显示有一个星号或者括号:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ conda info -e</span><br><span class="line"># conda environments:</span><br><span class="line">#</span><br><span class="line">base                  *  /Users/renyimin/Desktop/Anaconda3/anaconda3</span><br><span class="line"></span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></li><li><p>尝试 创建<strong>指定版本</strong>的<strong>独立python虚拟环境</strong></p><ul><li><p><code>conda create -n your_env_name python=X.X</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个2.7版本的python环境</span><br><span class="line">conda create -n my-conda-python-2 python=2.7</span><br><span class="line">// 创建一个3.6版本的python环境</span><br><span class="line">conda create -n my-conda-python-3 python=3.6</span><br></pre></td></tr></table></figure></li><li><p>安装过程会提示你需不需要自带一些安装包 (选择 是, 这样会创建一个内置很多第三方库的虚拟环境):</p></li><li>创建完成之后:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ conda info -e</span><br><span class="line"># conda environments:</span><br><span class="line">#</span><br><span class="line">base                  *  /Users/renyimin/Desktop/Anaconda3/anaconda3</span><br><span class="line">my-conda-python-2        /Users/renyimin/Desktop/Anaconda3/anaconda3/envs/my-conda-python-2</span><br><span class="line">my-conda-python-3        /Users/renyimin/Desktop/Anaconda3/anaconda3/envs/my-conda-python-3</span><br><span class="line"></span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></li></ul></li><li><p>激活自己创建的python虚拟环境, <strong>并进入环境</strong>, 安装好后, 可以使用 <code>activate</code> 激活某个环境</p><ul><li><code>activate my-conda-python-3</code> # for Windows</li><li><p><code>source activate my-conda-python-3</code> # for Linux &amp; Mac</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ source activate my-conda-python-3</span><br><span class="line">(my-conda-python-3) renyimindeMacBook-Pro:~ renyimin$ conda info -e</span><br><span class="line"># conda environments:</span><br><span class="line">#</span><br><span class="line">base                     /Users/renyimin/Desktop/Anaconda3/anaconda3</span><br><span class="line">my-conda-python-2        /Users/renyimin/Desktop/Anaconda3/anaconda3/envs/my-conda-python-2</span><br><span class="line">my-conda-python-3     *  /Users/renyimin/Desktop/Anaconda3/anaconda3/envs/my-conda-python-3</span><br><span class="line"></span><br><span class="line">(my-conda-python-3) renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></li><li><p><strong>激活后，会发现 终端的前缀 多了 (my-conda-python-3) 的字样</strong></p></li></ul></li><li><p>如果想从虚拟环境返回宿主环境:</p><ul><li><code>deactivate my-conda-python-3</code> # for Windows</li><li><p><code>source deactivate my-conda-python-3</code> # for Linux &amp; Mac</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(my-conda-python-3) renyimindeMacBook-Pro:~ renyimin$ source deactivate my-conda-python-3</span><br><span class="line">    renyimindeMacBook-Pro:~ renyimin$ conda info -e</span><br><span class="line">    # conda environments:</span><br><span class="line">    #</span><br><span class="line">    base                  *  /Users/renyimin/Desktop/Anaconda3/anaconda3</span><br><span class="line">    my-conda-python-2        /Users/renyimin/Desktop/Anaconda3/anaconda3/envs/my-conda-python-2</span><br><span class="line">    my-conda-python-3        /Users/renyimin/Desktop/Anaconda3/anaconda3/envs/my-conda-python-3</span><br><span class="line">    </span><br><span class="line">    renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></li><li><p>可以看到, 该命令除了<strong>返回宿主环境</strong>, 之前的虚拟环境<strong>退出激活状态</strong>转而由Anaconda默认的base版本做虚拟环境;</p></li></ul></li><li><p>如果要删除 Anaconda 中创建的一个虚拟环境, 可以 <code>conda remove --name my-conda-python-2 --all</code></p></li></ol><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><ol><li><p>conda的一些常用操作如下：</p><ul><li>conda list  # 查看当前环境下已安装的包</li><li><p>conda list -n my-conda-python-3  # 查看某个指定环境的已安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ source activate my-conda-python-3</span><br><span class="line">(my-conda-python-3) renyimindeMacBook-Pro:~ renyimin$ conda list</span><br><span class="line"># packages in environment at /Users/renyimin/Desktop/Anaconda3/anaconda3/envs/my-conda-python-3:</span><br><span class="line">#</span><br><span class="line"># Name                    Version                   Build  Channel</span><br><span class="line">certifi                   2016.2.28                py36_0    https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">openssl                   1.0.2l                        0    https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">pip                       9.0.1                    py36_1    https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">python                    3.6.2                         0    https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">readline                  6.2                           2    https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">setuptools                36.4.0                   py36_1    https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">sqlite                    3.13.0                        0    https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">tk                        8.5.18                        0    https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">wheel                     0.29.0                   py36_0    https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">xz                        5.2.3                         0    https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">zlib                      1.2.11                        0    https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">(my-conda-python-3) renyimindeMacBook-Pro:~ renyimin$</span><br></pre></td></tr></table></figure></li><li><p>conda search numpy  # 查找package信息</p></li><li><p>conda install -n my-conda-python-3 numpy : 安装package, 如果不用 -n 指定环境名称，则被安装在当前活跃环境 (也可以通过-c指定通过某个channel安装)</p></li><li><p>conda update -n my-conda-python-3 numpy : 更新package</p></li><li><p>conda remove -n my-conda-python-3 numpy : 删除package </p></li></ul></li><li><p>前面已经提到, conda将conda自身、python等都视为package, 因此，完全可以使用 conda 来管理 conda和python的版本, 例如 </p><ul><li>conda update conda : 更新conda，保持conda最新</li><li>conda update anaconda : 更新 anaconda</li><li>conda update python : 更新python(假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本)</li></ul></li><li><p>项目需要选择哪个虚拟环境, 直接在 Pycharm 中指定即可(和virtualenv一样)</p></li></ol><h2 id="设置国内镜像"><a href="#设置国内镜像" class="headerlink" title="设置国内镜像"></a>设置国内镜像</h2><ol><li><p>如果需要安装很多packages, 你会发现conda下载的速度经常很慢，因为Anaconda.org的服务器在国外, 所幸的是，清华TUNA镜像源有Anaconda仓库的镜像, 我们将其加入conda的配置即可：</p><ul><li><p>设置源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></li><li><p>查看当前使用的源 <code>conda config --show-sources</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ conda config --show-sources</span><br><span class="line">==&gt; /Users/renyimin/.condarc &lt;==</span><br><span class="line">ssl_verify: True</span><br><span class="line">channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: True</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="导入导出环境"><a href="#导入导出环境" class="headerlink" title="导入导出环境"></a>导入导出环境</h2><ol><li></li><li></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>到目前为止, 我机器上的python环境有<ul><li>Mac 自带的Python2.7</li><li>自己安装的Python3.7</li><li>后来又装了Anaconda (其中包含默认的3.6, 自己创建的两个虚拟环境3.6版本和2.7版本)</li></ul></li></ol><p>参考: <a href="https://www.jianshu.com/p/eaee1fadc1e9" target="_blank" rel="noopener">https://www.jianshu.com/p/eaee1fadc1e9</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Anaconda&quot;&gt;&lt;a href=&quot;#Anaconda&quot; class=&quot;headerlink&quot; title=&quot;Anaconda&quot;&gt;&lt;/a&gt;Anaconda&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在使用Python时，我们经常需要用到很多第三方库，例如，Pillow，MySQ
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>03. 基础 - virtualenv , virtualenvwrapper</title>
    <link href="http://blog.renyimin.com/2018/09/29/python/2018-09-29-Python-03/"/>
    <id>http://blog.renyimin.com/2018/09/29/python/2018-09-29-Python-03/</id>
    <published>2018-09-29T07:41:12.000Z</published>
    <updated>2018-09-30T07:28:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h2><ol><li><p>在开发Python应用程序的时候, 如果系统只安装了一个Python版本, 那么所有第三方的包都会被pip安装到这个Python的 site-packages 目录下; 如果要同时开发多个应用程序, 这些应用程序就会共用这一个Python环境, 如果应用A需要 jinja 2.7, 而应用B需要jinja 2.6怎么办?</p></li><li><p>这种情况下, 每个应用可能需要各自拥有一套 <strong>各自独立</strong> 的Python运行环境, <code>virtualenv</code> 就是用来为一个应用创建一套 <strong>隔离</strong> 的Python运行环境;</p></li><li><p>virtualenv : 可以在系统中建立多个不同并且相互不干扰的虚拟环境(另外, 值得一提的是, 在 virtualenv 的虚拟环境中使用 pip 安装依赖还可以绕过某些系统的权限设置, 因为毕竟不需要向系统目录写入数据)<br> 总之, virtualenv是用来创建一个独立的Python虚拟环境的工具, 通过virtualenv可以创建一个拥有独立的python版本和安装库的虚拟开发环境;<br> 这样一来我们就可以在虚拟环境中安装各种各种所需要的库, 从而不会造成本地的库过多所引起的使用混乱, 同时也可以创建不同的python版本来完成不同的需求开发</p></li><li><p>由于 virtualenv 用起来有点麻烦, virtualenvwrapper 对它进行了封装, 让它更好用, 最终我们使用 virtualenvwrapper 提供的命令, 但是实际工作都是 virtualenv 做的;</p></li><li><p>virtualenv 安装 (推荐使用pip安装)</p><ul><li>直接安装 virtualenvwrapper 即可, 你会发现 <code>virtualenv</code> 和 <code>virtualenvwrapper</code> 都被安装了 (由于这里的 pip3 是python3.7, 所以就是在 python3.7 的基础上进行 virtualenvwrapper 的安装)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:~ renyimin$ pip3 -V</span><br><span class="line">pip 18.0 from /usr/local/lib/python3.7/site-packages/pip (python 3.7)</span><br><span class="line">renyimindeMacBook-Pro:~ renyimin$ pip3 install virtualenvwrapper</span><br><span class="line">Successfully installed pbr-4.2.0 six-1.11.0 stevedore-1.29.0 virtualenv-16.0.0 virtualenv-clone-0.3.0 virtualenvwrapper-4.8.2</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="virtualenv虚拟环境管理"><a href="#virtualenv虚拟环境管理" class="headerlink" title="virtualenv虚拟环境管理"></a>virtualenv虚拟环境管理</h2><ol><li><p>创建一个独立的python新环境: <code>virtualenv myEnv_01</code> 会在当前目录下生成 ‘myEnv_01’ 目录</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:Desktop renyimin$ mkdir virtualEnvPython</span><br><span class="line">renyimindeMacBook-Pro:Desktop renyimin$ cd virtualEnvPython</span><br><span class="line">renyimindeMacBook-Pro:virtualEnvPython renyimin$ virtualenv myEnv_01</span><br><span class="line">renyimindeMacBook-Pro:virtualEnvPython renyimin$ ls</span><br><span class="line">myEnv_01</span><br><span class="line">renyimindeMacBook-Pro:virtualEnvPython renyimin$ cd myEnv_01/</span><br><span class="line">renyimindeMacBook-Pro:myEnv_01 renyimin$ ls</span><br><span class="line">binlib</span><br><span class="line">includepip-selfcheck.json</span><br><span class="line">renyimindeMacBook-Pro:myEnv_01 renyimin$</span><br></pre></td></tr></table></figure></li><li><p>一个新的python虚拟环境就创建好了, 并且在这个目录下会有3个目录被创建:</p><ul><li>bin : 包含一些在这个虚拟环境中可用的命令, 以及开启虚拟环境的脚本 activate</li><li>include : 包含虚拟环境中的头文件, 包括 Python 的头文件;</li><li>lib : 依赖库</li></ul></li><li><p>激活并进入虚拟环境: </p><ul><li><p>进入虚拟环境目录 myEnv_01 中, 然后执行: <code>source ./bin/activate</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:myEnv_01 renyimin$ ls</span><br><span class="line">binlib</span><br><span class="line">includepip-selfcheck.json</span><br><span class="line">renyimindeMacBook-Pro:myEnv_01 renyimin$ source ./bin/activate</span><br><span class="line">(myEnv_01) renyimindeMacBook-Pro:myEnv_01 renyimin$</span><br></pre></td></tr></table></figure></li><li><p>此时, 我们就已经在虚拟环境中了, 可以看到, 命令提示符是 <code>(myEnv_01) renyimindembp:myEnv_01 renyimin$</code></p></li></ul></li><li><p>从虚拟环境返回宿主环境: 要退出虚拟环境到达宿主环境, 无论在哪个目录下, 只要在虚拟环境中(命令提示符和宿主环境的命令提示符有区别), 直接执行 <code>deactivate</code> 就会退出到宿主python环境中;</p></li><li><p>如果想要删除虚拟环境, 只要把虚拟环境目录删除即可; (貌似比Anaconda简单多了)</p></li></ol><h2 id="virtualenv包管理"><a href="#virtualenv包管理" class="headerlink" title="virtualenv包管理"></a>virtualenv包管理</h2><ol><li>在 ‘myEnv_01’ python虚拟环境中安装一个test依赖库: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># myEnv_01虚拟环境中默认是没有该扩展的</span><br><span class="line">(myEnv_01) renyimindeMacBook-Pro:myEnv_01 renyimin$ pip3 list</span><br><span class="line">Package    Version</span><br><span class="line">---------- -------</span><br><span class="line">pip        18.0</span><br><span class="line">setuptools 40.4.3</span><br><span class="line">wheel      0.32.0</span><br><span class="line">(myEnv_01) renyimindeMacBook-Pro:myEnv_01 renyimin$ pip3 install test</span><br><span class="line"></span><br><span class="line"># 之后就有了</span><br><span class="line">(myEnv_01) renyimindeMacBook-Pro:myEnv_01 renyimin$ pip3 list</span><br><span class="line">Package    Version</span><br><span class="line">---------- -------</span><br><span class="line">pip        18.0</span><br><span class="line">setuptools 40.4.3</span><br><span class="line">test       2.3.4.5</span><br><span class="line">wheel      0.32.0</span><br><span class="line">(myEnv_01) renyimindeMacBook-Pro:myEnv_01 renyimin$</span><br></pre></td></tr></table></figure></li></ol><h2 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h2><ol><li><p>有了virtualenv, 为何还要 virtualenvwrapper ?</p><ul><li>virtualenv 的一个最大的缺点就是, 每次开启虚拟环境之前, 你都需要去虚拟环境所在目录下的 bin 目录下 source 一下 activate, 这就需要我们记住每个虚拟环境所在的目录;</li><li>当然, 你可以将所有的虚拟环境目录全都集中起来, 比如放到 /Users/renyimin/Desktop/virtualEnvPython/, 这个目录下专门存放所有的python虚拟环境, 对不同的虚拟环境使用不同的目录来管理;<br>而 <code>virtualenvwrapper</code> 正是这样做的, 并且, 它还省去了每次开启虚拟环境时候的 source 操作, 使得虚拟环境更加好用</li></ul></li><li><p>安装 <code>virtualenvwrapper</code>:</p><ul><li><p>卸载之前安装的 <code>virtualenv</code> (因为我们要安装 <code>virtualenvwrapper</code> 的话, 会自动安装 <code>virtualenv</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 uninstall virtualenv</span><br></pre></td></tr></table></figure></li><li><p>顺便也手动删除之前的 myEnv_01 目录</p></li><li><p>然后直接安装 <code>virtualenvwrapper</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">renyimindembp:~ renyimin$ pip3 install virtualenvwrapper</span><br><span class="line">renyimindembp:~ renyimin$</span><br></pre></td></tr></table></figure><p>现在, 我们就拥有了一个可以管理虚拟环境的神器</p></li></ul></li><li><p>接下来要做的比较重要, 那就是对 <code>virtualenvwrapper</code> 进行配置 : 它需要指定一个环境变量, 叫做 WORKON_HOME, 并且需要运行一下它的初始化工具 virtualenvwrapper.sh, 这个脚本在 <code>/usr/local/bin/</code> 目录下;</p><ul><li><code>WORKON_HOME</code> 就是它将要用来存放各种虚拟环境目录的目录, 这里我们可以设置为 ‘~/Desktop/virtualEnvPython/‘</li><li><p><code>VIRTUALENVWRAPPER_PYTHON</code> # 这句是为了防止环境变量$PATH中已有其它环境的python, 需要换成自己需要的python路径, 此处使用 <code>python3.7</code> 而不使用 <code>python3</code>, 是因为之前安装virtualenvwrapper时使用的<code>pip3</code>其实还是独立安装的python3.7, 而 <code>python3</code> 已经变成了Anaconda中的python3.6了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3.7 </span><br><span class="line">export WORKON_HOME=&apos;~/Desktop/virtualEnvPython/&apos;</span><br><span class="line">source /usr/local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure></li><li><p>由于每次都需要执行这两步操作, 我们可以将其写入终端的配置文件中, 例如:<br>如果使用 bash, 则添加到 ~/.bashrc 中;<br>如果使用 zsh, 则添加到 ~/.zshrc 中; 这样每次启动终端的时候都会自动运行，终端其中之 virtualenvwrapper 就可以用啦;<br>如果 ~/ 下没有 .bashrc的话, 写到.bash_profile文件中也可以</p></li></ul></li><li><p>利用 virtualenvwrapper, 我们可以使用命令 <code>mkvirtualenv myEnv_001</code> 轻松创建一个虚拟环境, 之后我们就有了一个叫做 myEnv_001 的虚拟环境, 它被存放在 $WORKON_HOME/myEnv_001 目录下, 也就是 <code>~/Desktop/virtualEnvPython/myEnv_001/</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:virtualEnvPython renyimin$ mkvirtualenv myEnv_001</span><br><span class="line">Using base prefix &apos;/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7&apos;</span><br><span class="line">New python executable in /Users/renyimin/Desktop/virtualEnvPython/myEnv_001/bin/python3.7</span><br><span class="line">Also creating executable in /Users/renyimin/Desktop/virtualEnvPython/myEnv_001/bin/python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br><span class="line">virtualenvwrapper.user_scripts creating /Users/renyimin/Desktop/virtualEnvPython/myEnv_001/bin/predeactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /Users/renyimin/Desktop/virtualEnvPython/myEnv_001/bin/postdeactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /Users/renyimin/Desktop/virtualEnvPython/myEnv_001/bin/preactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /Users/renyimin/Desktop/virtualEnvPython/myEnv_001/bin/postactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /Users/renyimin/Desktop/virtualEnvPython/myEnv_001/bin/get_env_details</span><br><span class="line">(myEnv_001) renyimindeMacBook-Pro:virtualEnvPython renyimin$</span><br><span class="line">(myEnv_001) renyimindeMacBook-Pro:virtualEnvPython renyimin$ ls</span><br><span class="line">myEnv_001</span><br><span class="line">(myEnv_001) renyimindeMacBook-Pro:virtualEnvPython renyimin$</span><br></pre></td></tr></table></figure></li><li><p>新建虚拟环境之后会自动激活虚拟环境, 如果我们平时想要进入某个虚拟环境, 可以用命令 <code>workon myEnv_001</code>, 这样才能真正进入激活的虚拟环境中</p></li><li><p>同样, 离开虚拟环境, 可以使用 <code>deactivate</code></p></li><li><p>删除虚拟环境也一样简单 <code>rmvirtualenv myEnv_001</code> (不像之前只使用virtualenv那样, 需要手动删除目录来删除一个虚拟环境, 没那么low了)</p></li><li><p>virtualenvwrapper 中的其他命令:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsvirtualenv，虚拟环境的列表</span><br><span class="line">cdvirtualenv，进入当前激活的虚拟环境</span><br><span class="line">cdsitepackages，进入虚拟环境中的site-packages目录</span><br><span class="line">lssitepackages，site-packages目录的列表</span><br></pre></td></tr></table></figure><p> 同时, 你还可以使用 <code>virtualenv</code> 来操作!!</p></li><li><p>另外, <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000" target="_blank" rel="noopener">参考</a>了解到**:</p><ul><li><p>命令 virtualenv 就可以创建一个独立的Python运行环境，我们还加上了参数 <code>--no-site-packages</code>, 这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境, 好像这个参数是默认就有的, 因为测试后发现加和不加都是干净的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:virtualEnvPython renyimin$ ls myEnv_001/lib/python3.7/site-packages/</span><br><span class="line">__pycache__pippkg_resourcessetuptools-40.4.3.dist-infowheel-0.32.0.dist-info</span><br><span class="line">easy_install.pypip-18.0.dist-infosetuptoolswheel</span><br><span class="line">renyimindeMacBook-Pro:virtualEnvPython renyimin$</span><br></pre></td></tr></table></figure></li><li><p><a href="https://segmentfault.com/a/1190000004079979" target="_blank" rel="noopener">参考</a></p></li></ul></li></ol><h2 id="创建虚拟环境的时候-python版本如何指定"><a href="#创建虚拟环境的时候-python版本如何指定" class="headerlink" title="创建虚拟环境的时候, python版本如何指定"></a>创建虚拟环境的时候, python版本如何指定</h2><ol><li>当我的机器上有Python2.7和Python3.6两个Python版本的时候, 那么virtualenv创建的虚拟环境使用哪个Python版本呢? 可以通过 <code>virtualenv -h</code> 查看帮助命令<ul><li>-p : 指定一个python版本, 通常当你的系统中安装了多个python版本时会用到, 默认情况下virtualenv会优先选取它的宿主python环境，也就是它的 VIRTUALENVWRAPPER_PYTHON 是哪个版本的, 默认就会选择哪个版本作为默认python隔离环境<br>我们使用的是 Python3.7 所以virtualenv默认安装的就是Python3.6虚拟环境;</li><li>尝试创建一个 2.7 版本的python环境<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:virtualEnvPython renyimin$ mkvirtualenv myEnv_002 -p python2.7</span><br><span class="line">Running virtualenv with interpreter /usr/local/bin/python2.7</span><br><span class="line">New python executable in /Users/renyimin/Desktop/virtualEnvPython/myEnv_002/bin/python2.7</span><br><span class="line">Also creating executable in /Users/renyimin/Desktop/virtualEnvPython/myEnv_002/bin/python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br><span class="line">virtualenvwrapper.user_scripts creating /Users/renyimin/Desktop/virtualEnvPython/myEnv_002/bin/predeactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /Users/renyimin/Desktop/virtualEnvPython/myEnv_002/bin/postdeactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /Users/renyimin/Desktop/virtualEnvPython/myEnv_002/bin/preactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /Users/renyimin/Desktop/virtualEnvPython/myEnv_002/bin/postactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /Users/renyimin/Desktop/virtualEnvPython/myEnv_002/bin/get_env_details</span><br><span class="line">(myEnv_002) renyimindeMacBook-Pro:virtualEnvPython renyimin$ python -V</span><br><span class="line">Python 2.7.14</span><br><span class="line">(myEnv_002) renyimindeMacBook-Pro:virtualEnvPython renyimin$</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>目前本机环境有</p><ul><li>Mac 自带的Python2.7</li><li>自己安装的Python3.7</li><li>后来又装了Anaconda (其中包含默认的3.6, 自己创建的两个虚拟环境3.6版本和2.7版本)</li><li>virtualenv 中创建的两个虚拟环境3.7和2.7版本</li></ul></li><li><p>在pycharm中引入本地的虚拟环境(可以看到也可以在pycharm中直接使用 conda 或者 virtualenv 来新建虚拟环境, 不过由于之前已经了一些虚拟环境了, 所以直接add即可)<br> <img src="/img/python/python-env-01.png" width="500"></p></li><li><p>在 pycharm 的 左下角有 <code>Python Console</code> 和 <code>Terminal</code> 两个终端, 但是发现在切换 <code>conda</code> 或者 <code>virtual</code> 虚拟环境时:</p><ul><li>virtual 虚拟环境切换时候, 两个终端都会切换<br><img src="/img/python/virtualenv01.png" width="500"></li><li>而 conda 虚拟环境切换时, 貌似不会切换 <code>Terminal</code> 终端到虚拟环境中</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;virtualenv&quot;&gt;&lt;a href=&quot;#virtualenv&quot; class=&quot;headerlink&quot; title=&quot;virtualenv&quot;&gt;&lt;/a&gt;virtualenv&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在开发Python应用程序的时候, 如果系统只安装了一个P
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>01. 基础 - Python 环境安装</title>
    <link href="http://blog.renyimin.com/2018/09/29/python/2018-09-29-Python-01/"/>
    <id>http://blog.renyimin.com/2018/09/29/python/2018-09-29-Python-01/</id>
    <published>2018-09-29T04:11:12.000Z</published>
    <updated>2018-09-29T08:46:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python安装"><a href="#Python安装" class="headerlink" title="Python安装"></a>Python安装</h2><ol><li><p>目前, Python有两个版本, 一个是2.x版, 一个是3.x版, 这两个版本是不兼容的; </p><ul><li>MacOS 是10.8或者最新的10.9 Mavericks，恭喜你，系统自带了Python 2.7目前自带的是Python2.7版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">renyimindembp:~ renyimin$ python</span><br><span class="line">Python 2.7.10 (default, Feb  7 2017, 00:08:15)</span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.34)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>由于3.x版越来越普及, 所以接下来将会使用的是Python3.x:</p><ul><li>从Python官网下载<a href="https://www.python.org/ftp/python/3.6.3/python-3.6.3-macosx10.6.pkg" target="_blank" rel="noopener">Python 3.6</a>的安装程序(傻瓜式安);</li><li>Mac可以 直接 <code>brew install python3</code> 安装(安装后发现是python3.7, 卸载方便 <code>brew uninstall python3.7</code> );</li><li>以上两种方法都可以, 这里使用第二种, 安装完成后将会存在两个python版本:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">renyimindembp:~ renyimin$ python -V</span><br><span class="line">Python 2.7.10</span><br><span class="line">renyimindembp:~ renyimin$ python3 -V</span><br><span class="line">Python 3.6.4</span><br><span class="line">renyimindembp:~ renyimin$</span><br></pre></td></tr></table></figure></li></ul></li><li><p>安装后, 就会得到Python解释器(就是负责运行Python程序的), 一个命令行交互环境, 还有一个简单的集成开发环境</p></li></ol><h2 id="pip-安装"><a href="#pip-安装" class="headerlink" title="pip 安装"></a>pip 安装</h2><ol><li><p>在Python中, 安装第三方模块, 是通过包管理工具pip完成的</p><ul><li>如果你正在使用Mac或Linux, 安装pip这个步骤就可以跳过了</li><li>如果你正在使用Windows，请参考安装Python一节的内容，确保安装时勾选了pip和Add python.exe to Path</li></ul></li><li><p>Mac为我们准备了Python2.7的同时, 还默认准备了pip, 另外, 自己安装Python3.6之后, 也同时安装了pip:</p><ul><li><p>自己安装的Python3.7所带的pip需要运行 <code>pip3</code> (注意: Mac或Linux上有可能并存Python 3.x和Python 2.x, 因此对应的pip命令是pip3)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:bin renyimin$ which pip</span><br><span class="line">/usr/local/bin/pip</span><br><span class="line">renyimindeMacBook-Pro:bin renyimin$ which pip2</span><br><span class="line">/usr/local/bin/pip2</span><br><span class="line">renyimindeMacBook-Pro:bin renyimin$ which pip2.7</span><br><span class="line">/usr/local/bin/pip2.7</span><br><span class="line">renyimindeMacBook-Pro:bin renyimin$ which pip3</span><br><span class="line">/usr/local/bin/pip3</span><br><span class="line">renyimindeMacBook-Pro:bin renyimin$ which pip3.7</span><br><span class="line">/usr/local/bin/pip3.7</span><br></pre></td></tr></table></figure></li><li><p>可以看到软链已经创建好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">renyimindeMacBook-Pro:bin renyimin$ ls -al pip*</span><br><span class="line">lrwxr-xr-x  1 renyimin  admin  35  4 22 18:26 pip -&gt; ../Cellar/python@2/2.7.14_3/bin/pip</span><br><span class="line">lrwxr-xr-x  1 renyimin  admin  36  4 22 18:26 pip2 -&gt; ../Cellar/python@2/2.7.14_3/bin/pip2</span><br><span class="line">lrwxr-xr-x  1 renyimin  admin  38  4 22 18:26 pip2.7 -&gt; ../Cellar/python@2/2.7.14_3/bin/pip2.7</span><br><span class="line">lrwxr-xr-x  1 renyimin  admin  31  9 29 11:50 pip3 -&gt; ../Cellar/python/3.7.0/bin/pip3</span><br><span class="line">lrwxr-xr-x  1 renyimin  admin  33  9 29 11:50 pip3.7 -&gt; ../Cellar/python/3.7.0/bin/pip3.7</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python安装&quot;&gt;&lt;a href=&quot;#Python安装&quot; class=&quot;headerlink&quot; title=&quot;Python安装&quot;&gt;&lt;/a&gt;Python安装&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;目前, Python有两个版本, 一个是2.x版, 一个是3.x版, 这两
      
    
    </summary>
    
      <category term="Python" scheme="http://blog.renyimin.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.renyimin.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>03.</title>
    <link href="http://blog.renyimin.com/2018/09/08/elastic-stack/2018-09-08-03/"/>
    <id>http://blog.renyimin.com/2018/09/08/elastic-stack/2018-09-08-03/</id>
    <published>2018-09-08T02:50:15.000Z</published>
    <updated>2018-09-08T02:50:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Elastic-Stack" scheme="http://blog.renyimin.com/categories/Elastic-Stack/"/>
    
    
      <category term="Elastic-Stack" scheme="http://blog.renyimin.com/tags/Elastic-Stack/"/>
    
  </entry>
  
  <entry>
    <title>02. 安装配置</title>
    <link href="http://blog.renyimin.com/2018/09/08/elastic-stack/2018-09-08-02/"/>
    <id>http://blog.renyimin.com/2018/09/08/elastic-stack/2018-09-08-02/</id>
    <published>2018-09-08T02:46:43.000Z</published>
    <updated>2018-09-08T02:50:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a><a href="">安装Elasticsearch</a></h2><h2 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a><a href="">安装Kibana</a></h2><h2 id="安装Logstash"><a href="#安装Logstash" class="headerlink" title="安装Logstash"></a><a href="">安装Logstash</a></h2><h2 id="安装Filebeat"><a href="#安装Filebeat" class="headerlink" title="安装Filebeat"></a><a href="">安装Filebeat</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装Elasticsearch&quot;&gt;&lt;a href=&quot;#安装Elasticsearch&quot; class=&quot;headerlink&quot; title=&quot;安装Elasticsearch&quot;&gt;&lt;/a&gt;&lt;a href=&quot;&quot;&gt;安装Elasticsearch&lt;/a&gt;&lt;/h2&gt;&lt;h2 id
      
    
    </summary>
    
      <category term="Elastic-Stack" scheme="http://blog.renyimin.com/categories/Elastic-Stack/"/>
    
    
      <category term="Elastic-Stack" scheme="http://blog.renyimin.com/tags/Elastic-Stack/"/>
    
  </entry>
  
  <entry>
    <title>01. 从ELK Stack 到 Elastic Stack</title>
    <link href="http://blog.renyimin.com/2018/09/04/elastic-stack/2018-09-04-01/"/>
    <id>http://blog.renyimin.com/2018/09/04/elastic-stack/2018-09-04-01/</id>
    <published>2018-09-04T09:36:39.000Z</published>
    <updated>2018-09-08T02:47:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ELK-Stack-简介"><a href="#ELK-Stack-简介" class="headerlink" title="ELK Stack 简介"></a>ELK Stack 简介</h2><p>ELK Stack 是三个开源工具的统称: Elasticsearch, Logstash 和 Kibana</p><ol><li><p><strong><a href="">Logstash</a></strong>: 开源的日志收集工具, 能按你所定义的配置信息来规范化数据, 并根据需要将其他送到指定的目的地; (监听9600端口)</p><ul><li>拥有非常多的Input输入数据类型的插件, 这些Input插件可以用于从大量不同来源的信息中读取数据;</li><li>同时, 它也拥有非常多的Output输出数据类型插件, 可用于把数据提交到各种不同的目的地(其中的一种插件就是把数据传输到Elasticsearch中去);<br>比如, 它可以从本地磁盘, 网络服务(自己监听端口, 接受用户日志), 消息队列……中, 收集各种各样的日志; 然后对日志进行分析整理, 输出到指定的输出(如 elasticsearch、redis、终端等);</li><li>它能帮助我们搜集原始数据, 修改/过滤数据并将其转换成某种有含义的数据, 完成数据格式化和重新组织数据等;</li></ul></li><li><p><strong><a href="">Elasticsearch</a></strong>: 基于Lucene的开源分布式全文搜索引擎; Elasticsearch 服务会开启两个端口 9200和9300, 9200是对外服务的 9300是对集群内交互使用的;<br> Logstash读取的数据可输出到Elasticsearch中, 完成数据的索引; </p></li><li><p><strong><a href="">Kibana</a></strong>: 是一个开源的可视化日志web展示工具, 提供友好的日志分析 Web 界面, 帮助你汇总、分析和搜索重要数据日志 (监听 5601 端口);<br> Kibana使用Elasticsearch提供的API来读取/检索存放在Elasticsearch中的索引数据, 并以图表等形式对这些数据进行可视化分析;</p></li></ol><h2 id="Elastic-Stack诞生"><a href="#Elastic-Stack诞生" class="headerlink" title="Elastic Stack诞生"></a><a href="https://www.elastic.co/elk-stack" target="_blank" rel="noopener">Elastic Stack</a>诞生</h2><ol><li><p>上面在介绍 ELK Stack 时提到, 所有读取数据的工作都是由 Logstash 来完成的, 但是这是一种资源消耗, 因为 Logstash 需要运行在Java虚拟机上, 会消耗大量内存; 因此, 软件研发社区认为需要提高其性能, 并使用管道(pipeline)处理机制 — 一种友好且轻量级的方式来处理资源;</p></li><li><p>因此, 一种新的概念 <strong><a href="">Beats</a></strong> 诞生, 并加入到了 ELK Stack 家族成为重要组件(Beats 是由 GO 语言编写的)<br> Beats 用于读取、解析并将数据输出到 Elasticsearch 或 Logstash 中; 不同的是, 它是一种轻量级的, 服务于某种特殊用途的代理(它可以是Metricbeat/Filebeat/Packetbeat等), 它们都是由Elastic开发团队提供;</p></li><li><p>Elastic Stack 的起始版本号是5.0.0, 其虽然是原 ELK Stack 在 5.0 版本加入 Beats 套件后的新称呼, 但其实涵盖的内容还不止这些; 在产生数据管道的作用中, 所有组件都发挥了重要作用:</p><ul><li>Beats 和 Logstash 用于搜索, 解析, 传输数据;</li><li>Elasticsearch 负责对数据的索引; </li><li>Elasticsearch 索引的数据, 最后会被 Kibana 用于数据的可视化;</li><li>在基于 Elastic Stack 的数据处理管道中, 还有诸如 安全, 监控, 报警 等方面需要特别关注, 这些工具组件现在统称为 <strong><a href="">X-Pack</a></strong></li></ul></li></ol><p>参考:《精通Elastic Stack》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ELK-Stack-简介&quot;&gt;&lt;a href=&quot;#ELK-Stack-简介&quot; class=&quot;headerlink&quot; title=&quot;ELK Stack 简介&quot;&gt;&lt;/a&gt;ELK Stack 简介&lt;/h2&gt;&lt;p&gt;ELK Stack 是三个开源工具的统称: Elastics
      
    
    </summary>
    
      <category term="Elastic-Stack" scheme="http://blog.renyimin.com/categories/Elastic-Stack/"/>
    
    
      <category term="Elastic-Stack" scheme="http://blog.renyimin.com/tags/Elastic-Stack/"/>
    
  </entry>
  
</feed>
