<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2018-12-22T14:30:20.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>33. 为什么需要泛型类</title>
    <link href="http://blog.renyimin.com/2018/12/22/JAVA/2018-12-22-34/"/>
    <id>http://blog.renyimin.com/2018/12/22/JAVA/2018-12-22-34/</id>
    <published>2018-12-22T05:43:51.000Z</published>
    <updated>2018-12-22T14:30:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安全隐患"><a href="#安全隐患" class="headerlink" title="安全隐患"></a>安全隐患</h2><ol><li>在没有使用泛型的情况下, 如果要实现参数 任意化, 通常会定义成Object类型来接受, 然后在使用时再进行强制类型转换使用; 而强制类型转换有明显的缺点, 就是必须要知道实际参数的具体类型的情况才可以进行转换, 同时在强制转换的过程中, 编译器不会报错提示的, 只有在运行阶段才会出现异常, 一定程度上<strong>存在安全隐患</strong>;</li><li><p>示例, 使用数组模拟一个简单的 ArrayList</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用数组模拟一个ArrayList</span><br><span class="line"> * 功能非常简单, 只是为学习泛型相关知识</span><br><span class="line"> */</span><br><span class="line">class ArrayListObject &#123;</span><br><span class="line"></span><br><span class="line">    private int size;</span><br><span class="line">    private int index;</span><br><span class="line">    private Object[] array;</span><br><span class="line"></span><br><span class="line">    public ArrayListObject(int size)</span><br><span class="line">    &#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">        array = new Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean add(Object element)</span><br><span class="line">    &#123;</span><br><span class="line">        if (index &lt; size) &#123;</span><br><span class="line">            array[index++] = element;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object get(int index) &#123;</span><br><span class="line">        return array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ObjectTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayListObject arrayListObject = new ArrayListObject(2);</span><br><span class="line">        arrayListObject.add(&quot;renyimin&quot;);</span><br><span class="line">        arrayListObject.add(100);</span><br><span class="line">        for(int i = 0; i&lt; arrayListObject.size();i++)&#123;</span><br><span class="line">            String item = (String)arrayListObject.get(i);</span><br><span class="line">            System.out.println(&quot;泛型测试, item = &quot; + item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上述代码运行后会报错:<br> <img src="/img/javase/generic-error-10.png" width="500/"></p></li><li><p>由于ArrayList的底层使用的是数组, 所以要能够存放不同类型的对象, 只能将元素类型设定为Object; 这样在使用元素时, 需要进行强制类型转换, 并且安全隐患也是在运行时才会暴露出来, 在编译时并不会报错;</p></li></ol><h2 id="类膨胀问题"><a href="#类膨胀问题" class="headerlink" title="类膨胀问题"></a>类膨胀问题</h2><ol><li><p>除了将元素类型定义为Object来实现参数 任意化, 来实现ArrayList可以存储不同类型的对象; 还可以为每种不同类型的对象各自实现一个ArrayList</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 简单模拟一个存放整数的 ArrayList</span><br><span class="line"> */</span><br><span class="line">class ArrayListInteger &#123;</span><br><span class="line"></span><br><span class="line">    private int size = 0;</span><br><span class="line">    private int index = 0;</span><br><span class="line">    private Integer[] array;</span><br><span class="line"></span><br><span class="line">    public ArrayListInteger(int size)</span><br><span class="line">    &#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">        array = new Integer[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean add(Integer element)</span><br><span class="line">    &#123;</span><br><span class="line">        if (index &lt; size) &#123;</span><br><span class="line">            array[index++] = element;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer get(int index) &#123;</span><br><span class="line">        return array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 简单模拟一个存放字符串的 ArrayList</span><br><span class="line"> */</span><br><span class="line">class ArrayListString &#123;</span><br><span class="line"></span><br><span class="line">    private int size = 0;</span><br><span class="line">    private int index = 0;</span><br><span class="line">    private String[] array;</span><br><span class="line"></span><br><span class="line">    public ArrayListString(int size)</span><br><span class="line">    &#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">        array = new String[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean add(String element)</span><br><span class="line">    &#123;</span><br><span class="line">        if (index &lt; size) &#123;</span><br><span class="line">            array[index++] = element;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String get(int index) &#123;</span><br><span class="line">        return array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassBloat</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayListInteger arrayListInteger = new ArrayListInteger(10);</span><br><span class="line">        arrayListInteger.add(10);</span><br><span class="line">        arrayListInteger.add(11);</span><br><span class="line">        arrayListInteger.add(12);</span><br><span class="line">        System.out.println(arrayListInteger.get(0));</span><br><span class="line"></span><br><span class="line">        ArrayListString arrayListString = new ArrayListString(10);</span><br><span class="line">        arrayListString.add(&quot;renyimin&quot;);</span><br><span class="line">        arrayListString.add(&quot;lant&quot;);</span><br><span class="line">        arrayListString.add(&quot;rymuscle&quot;);</span><br><span class="line">        System.out.println(arrayListString.get(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>很明显, 这样带来的严重问题是, 如果你的业务场景中出现类似问题, 那么你项目中的类文件会急剧增多, 出现类膨胀问题; </p></li></ol><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><ol><li><p>对于上述问题, 可以引入泛型来进行解决, 代码如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package generic;</span><br><span class="line"></span><br><span class="line">class ArrayListGeneric&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private int size = 0;</span><br><span class="line">    private int index = 0;</span><br><span class="line">    private Object[] array;</span><br><span class="line"></span><br><span class="line">    public ArrayListGeneric(int size)</span><br><span class="line">    &#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">        array = new Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean add(T element)</span><br><span class="line">    &#123;</span><br><span class="line">        if (index &lt; size) &#123;</span><br><span class="line">            array[index++] = element;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T get(int index) &#123;</span><br><span class="line">        return (T) array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class GenericTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayListGeneric&lt;String&gt; arrayListGeneric = new ArrayListGeneric&lt;String&gt;(2);</span><br><span class="line">        arrayListGeneric.add(&quot;renyimin&quot;);</span><br><span class="line">        arrayListGeneric.add(100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以看到, IDE直接进行了错误提示, 并且运行代码会发现, 在编译阶段就报错了<br> <img src="/img/javase/generic-error-11.png" width="500/"></p></li></ol><h2 id="泛型带来的好处"><a href="#泛型带来的好处" class="headerlink" title="泛型带来的好处"></a>泛型带来的好处</h2><ol><li><p>类型安全: 泛型主要是提供了一种类型检测的机制, 只有相匹配的数据才能正常的赋值, 否则编译器就不通过; 所以说, 它是一种类型安全检测机制, 一定程度上提高了软件的安全性, 防止出现低级的失误;</p></li><li><p>消除强制类型转换: 泛型的一个附带好处是, 它消除了代码中的许多强制类型转换, 提高了代码可读性, 减少了出错机会;</p></li><li><p>同时, 泛型也帮助普通类成为一个模板类, 然后当实例化该类时, 可以根据传入的类型实参, 创建出多个不同类型的对象;</p></li></ol><h2 id="ArrayList回顾"><a href="#ArrayList回顾" class="headerlink" title="ArrayList回顾"></a>ArrayList回顾</h2><ol><li><p>之前已经学习过了ArrayList, 了解到其底层使用 数组 实现, 不过由于ArrayList中对数组元素类型使用的是Object, 所以虽然它底层采用的是数组, 你却可以往ArrayList中add多个不同类型的对象;</p></li><li><p>虽然ArrayList可以存放不同类型的对象元素, 但这样可能会导致当你对元素使用时, 需要进行强制类型转换, 所以代码可读性和安全性都会降低; </p></li><li><p>幸运的是, ArrayList 中使用了泛型, 如果你要往ArrayList中add数据元素, 最好在实例化时, 使用泛型类型;</p><ul><li>一方面如果元素类型不一致的话, IDE会进行提示, 并且在编译阶段会将安全隐患暴露出来;</li><li>同时, 你在编译阶段就将ArrayList中的数据进行了类型统一, 所以不用在使用元素时做大量的类型检测和转换;</li></ul></li><li><p>所以貌似在使用ArrayList, 我们仍然都会使用泛型来保证其存储的是同一类型的对象元素;</p></li></ol><h2 id="不能创建泛型数组"><a href="#不能创建泛型数组" class="headerlink" title="不能创建泛型数组"></a>不能创建泛型数组</h2><ol><li><p>对于上面的适应泛型类来自己实现 ArrayList 的例子, 可能比较有争议的地方就是, 为什么没把数组的类型定义成泛型, 而是使用了Object ? (Java中对ArrayList的实现貌似也是如此)</p></li><li><p>其实这涉及到泛型的一个注意点: 在Java中, 你是不能直接创建泛型数组的</p></li><li><p>泛型解决方案出错, <strong>这是因为在Java中, 不能直接创建泛型数组</strong> (稍后再进行介绍)<br> <img src="/img/javase/Generic-Error-01.png" width="500/"></p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安全隐患&quot;&gt;&lt;a href=&quot;#安全隐患&quot; class=&quot;headerlink&quot; title=&quot;安全隐患&quot;&gt;&lt;/a&gt;安全隐患&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在没有使用泛型的情况下, 如果要实现参数 任意化, 通常会定义成Object类型来接受, 然后在使用时再进行强制
      
    
    </summary>
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>30. Generics(泛型)</title>
    <link href="http://blog.renyimin.com/2018/12/22/JAVA/2018-12-22-30/"/>
    <id>http://blog.renyimin.com/2018/12/22/JAVA/2018-12-22-30/</id>
    <published>2018-12-22T05:43:51.000Z</published>
    <updated>2018-12-22T14:11:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>Java <strong>泛型(generics)</strong> 是 JDK 5 中引入的一个新特性, 在java中有很重要的地位, 在面向对象编程及各种设计模式中有非常广泛的应用</p></li><li><p>泛型(Generics): 参数化类型, 将 类型 定义成 参数形式, 然后在调用时传入具体的类型(类型实参)</p></li><li><p>泛型提供了<strong>编译时类型安全检测机制</strong>, 该机制允许程序员在编译时检测到非法的类型</p></li><li><p>泛型的本质是为了参数化类型, 在泛型使用过程中, 数据类型被指定为一个参数, 这种参数类型可以用在 类、接口 和 方法中, 分别被称为 <code>泛型类</code>、<code>泛型接口</code>、<code>泛型方法</code></p></li></ol><h2 id="为什么需要使用泛型"><a href="#为什么需要使用泛型" class="headerlink" title="为什么需要使用泛型?"></a>为什么需要使用泛型?</h2><p>下面通过泛型类, 泛型接口, 泛型方法的学习来了解是使用泛型程序设计的好处</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a><a href="">泛型类</a></h3><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a><a href="">泛型接口</a></h3><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a><a href="">泛型方法</a></h3><h2 id="泛型写法注意"><a href="#泛型写法注意" class="headerlink" title="泛型写法注意"></a>泛型写法注意</h2><ol><li><p>前后泛型的类型要一致, 即便前后的类型有继承关系也不可以: </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 即便Student类继承自Person类</span><br><span class="line">List&lt;Person&gt; list = new ArrayList&lt;Student&gt;();</span><br></pre></td></tr></table></figure></li><li><p>虽然前后泛型的类型要一致, 但是在向集合中添加元素时, 可以添加泛型类型的子类型,:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; list = new ArrayList&lt;Person&gt;();</span><br><span class="line">list.add(new Student());</span><br></pre></td></tr></table></figure></li><li><p>在jdk7推出了一个新特性, 泛型的菱形语法, 即 后面的泛型类型可以省略 (因为编译器可以从前面(List)推断出推断出类型参数, 所以后面的ArrayList之后可以不用写泛型参数, 只用一对空着的尖括号就可以):</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 在Java SE 7之前, 声明泛型对象的代码如下:</span><br><span class="line">List&lt;Person&gt; list = new ArrayList&lt;Person&gt;();</span><br><span class="line">// 而在Java 7中, 可以使用如下代码：</span><br><span class="line">List&lt;Person&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(new Student());</span><br></pre></td></tr></table></figure></li><li><p>泛型只支持对象类型, 如下是错误示例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; list = new ArrayList&lt;int&gt;();</span><br></pre></td></tr></table></figure></li><li><p>无意义的泛型</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure></li><li></li></ol><h2 id="泛型类-1"><a href="#泛型类-1" class="headerlink" title="泛型类"></a>泛型类</h2><ol><li>泛型类型用于类的定义中, 被称为泛型类</li><li><p>一个简单示例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest3&lt;T&gt; &#123;</span><br><span class="line">    private T key;</span><br><span class="line"></span><br><span class="line">    public T getKey() &#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GenericTest3(T key)</span><br><span class="line">    &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //泛型的类型参数只能是类类型（包括自定义类）, 不能是简单类型</span><br><span class="line">        //传入的实参类型需与泛型的类型参数类型相同, 即为Integer.</span><br><span class="line">        GenericTest3&lt;Integer&gt; genericInteger = new GenericTest3&lt;Integer&gt;(123456);</span><br><span class="line"></span><br><span class="line">        //传入的实参类型需与泛型的类型参数类型相同, 即为String.</span><br><span class="line">        GenericTest3&lt;String&gt; genericString = new GenericTest3&lt;String&gt;(&quot;key_vlaue&quot;);</span><br><span class="line">        System.out.println(&quot;key is &quot; + genericInteger.getKey());</span><br><span class="line">        System.out.println(&quot;key is &quot; + genericString.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义的泛型类, 就一定要传入泛型类型实参么?<br> 并不是这样, 在使用泛型的时候如果传入泛型实参, 则会根据传入的泛型实参做相应的限制, 此时泛型才会起到本应起到的限制作用;<br> 如果不传入泛型类型实参的话, 在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package jcf;</span><br><span class="line"></span><br><span class="line">public class GenericTest3&lt;T&gt; &#123;</span><br><span class="line">    private T key;</span><br><span class="line"></span><br><span class="line">    public T getKey() &#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GenericTest3(T key)</span><br><span class="line">    &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GenericTest3 generic = new GenericTest3(&quot;111111&quot;);</span><br><span class="line">        GenericTest3 generic1 = new GenericTest3(4444);</span><br><span class="line">        GenericTest3 generic2 = new GenericTest3(55.55);</span><br><span class="line">        GenericTest3 generic3 = new GenericTest3(false);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;key is &quot; + generic.getKey());  // key is 111111</span><br><span class="line">        System.out.println(&quot;key is &quot; + generic1.getKey()); // key is 4444</span><br><span class="line">        System.out.println(&quot;key is &quot; + generic2.getKey()); // key is 55.55</span><br><span class="line">        System.out.println(&quot;key is &quot; + generic3.getKey()); // key is false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意：</p><ul><li>泛型的类型参数只能是类类型, 不能是简单类型;</li><li>不能对确切的泛型类型使用 <code>instanceof</code> 操作, 如下面的操作是非法的, 编译时会出错<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(ex_num instanceof Generic&lt;Number&gt;)&#123; &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><ol><li><p>泛型是 Java 1.5 版本才引进的概念, 在这之前是没有泛型的概念的, 但显然, 泛型代码能够很好地和之前版本的代码很好地兼容。 这是因为, 泛型信息只存在于代码编译阶段, 在进入 JVM 之前, 与泛型相关的信息会被擦除掉, 专业术语叫做<strong>类型擦除</strong>;</p></li><li><p>通俗地讲, 泛型类和普通类在 java 虚拟机内是没有什么特别的地方, 对于下面的代码, 打印的结果为 true, 是因为 List<string> 和 List<integer> 在 jvm 中的 Class 都是 List.class, <strong>泛型信息被擦除了</strong></integer></string></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = new ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">System.out.println(l1.getClass() == l2.getClass());</span><br></pre></td></tr></table></figure></li><li></li><li><p>如果使用泛型, <strong>编译器会在编译阶段就能够帮我们发现类似这样的问题</strong></p></li><li><p>类型的参数化 (涉及到了自定义泛型类)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package jcf;</span><br><span class="line"></span><br><span class="line">class A&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private T name;</span><br><span class="line"></span><br><span class="line">    public T getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(T name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A&lt;String&gt; a = new A&lt;&gt;();</span><br><span class="line">        a.setName(&quot;renyimin&quot;);</span><br><span class="line">        System.out.println(a.getName());</span><br><span class="line"></span><br><span class="line">        A&lt;Integer&gt; aa = new A&lt;&gt;();</span><br><span class="line">        aa.setName(100);</span><br><span class="line">        System.out.println(aa.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ol><li></li><li><p>使用泛型的好处</p><ul><li>提高安全性: 将运行期的错误转换到编译期</li><li>省去强制转换的麻烦</li><li>减少类的数量, 将类做的更加通用一些</li></ul></li><li><p>可以在定义类的同时, 预设一个占位符作为某种特定类型, 在类的内部方法和属性上就可以使用这个占位符来表示某种类型, 最后在构建new这个类对象的时候, 需要指明具体是哪个类型(本质上就是参数化类型, 把类型作为参数传递)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package jcf;</span><br><span class="line">    </span><br><span class="line">    class A&lt;T&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        private T name;</span><br><span class="line">    </span><br><span class="line">        public T getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public void setName(T name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public class GenericTest &#123;</span><br><span class="line">    </span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            A&lt;String&gt; a = new A&lt;&gt;();</span><br><span class="line">            a.setName(&quot;renyimin&quot;);</span><br><span class="line">            System.out.println(a.getName());</span><br><span class="line">    </span><br><span class="line">            A&lt;Integer&gt; aa = new A&lt;&gt;();</span><br><span class="line">            aa.setName(100);</span><br><span class="line">            System.out.println(aa.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="泛型类-预设类型的命名"><a href="#泛型类-预设类型的命名" class="headerlink" title="泛型类 - 预设类型的命名"></a>泛型类 - 预设类型的命名</h2><ol><li>为了简化命名, 通常只用一个字母来命名类型参数, 常用字母如下:<ul><li><code>E</code>: 代表Element (在集合中使用, 因为集合中存放的是元素)<br><code>ArrayList</code>用的就是<code>E</code></li><li><code>T</code>: Type (Java 类)</li><li><code>K</code> <code>V</code>: 分别代表键值中的Key和Value</li><li><code>N</code>: Number(数值类型)</li><li><code>?</code>: 表示不确定的类型</li></ul></li></ol><h3 id="静态泛型方法"><a href="#静态泛型方法" class="headerlink" title="静态泛型方法"></a>静态泛型方法</h3><p>不可以用类的泛型类型, 类的泛型类型是 new 的时候传入的<br>但是静态方法可以用泛型</p><h2 id="类型边界"><a href="#类型边界" class="headerlink" title="类型边界"></a>类型边界</h2><ol><li>extends 可以实现接口</li><li>既继承父类又实现接口 注意 <code>&amp;</code> 符号, 类在前, 接口在后</li><li></li></ol><h2 id="泛型接口-1"><a href="#泛型接口-1" class="headerlink" title="泛型接口"></a>泛型接口</h2><h2 id="泛型通配符-lt-gt"><a href="#泛型通配符-lt-gt" class="headerlink" title="泛型通配符 &lt;?&gt;"></a>泛型通配符 &lt;?&gt;</h2><ol><li>无边界? 和 Object 不一样么?<br> Object 不接受子类</li><li></li></ol><h2 id="固定上边界通配符"><a href="#固定上边界通配符" class="headerlink" title="固定上边界通配符"></a>固定上边界通配符</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Java &lt;strong&gt;泛型(generics)&lt;/strong&gt; 是 JDK 5 中引入的一个新特性, 在java中有
      
    
    </summary>
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>26. Set的contains()方法</title>
    <link href="http://blog.renyimin.com/2018/12/20/JAVA/2018-12-20-26/"/>
    <id>http://blog.renyimin.com/2018/12/20/JAVA/2018-12-20-26/</id>
    <published>2018-12-20T11:25:03.000Z</published>
    <updated>2018-12-23T09:24:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/violet_echo_0908/article/details/50152915" target="_blank" rel="noopener">https://blog.csdn.net/violet_echo_0908/article/details/50152915</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/violet_echo_0908/article/details/50152915&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/violet_ech
      
    
    </summary>
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>23. HashMap 和 Hashtable 的区别</title>
    <link href="http://blog.renyimin.com/2018/12/19/JAVA/2018-12-19-23/"/>
    <id>http://blog.renyimin.com/2018/12/19/JAVA/2018-12-19-23/</id>
    <published>2018-12-19T06:05:10.000Z</published>
    <updated>2018-12-22T06:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hashtable 是个过时的集合类, 存在于Java API中很久了, 在Java 4中被重写了, 实现了Map接口, 所以自此以后也成了Java集合框架中的一部分</p><ol><li><p>HashMap 和 Hashtable 都实现了Map接口, 但决定用哪一个之前先要弄清楚它们之间的分别, 主要的区别有: 线程安全性, 同步(synchronization), 以及速度</p><ul><li>HashMap 几乎可以等价于 Hashtable, 除了HashMap是非synchronized的, 并可以接受null(HashMap可以接受为null的键值(key)和值(value), 而Hashtable则不行)</li><li>HashMap是非synchronized, 而Hashtable是synchronized<br>这意味着Hashtable是线程安全的, 多个线程可以共享一个Hashtable, 而如果没有正确的同步的话, 多个线程是不能共享HashMap的<br>Java 5提供了ConcurrentHashMap, 它是HashTable的替代, 比HashTable的扩展性更好</li><li>另一个区别是 HashMap 的迭代器(Iterator)是 fail-fast 迭代器, 而 Hashtable 的 enumerator迭代器不是 fail-fast 的, 所以当有其它线程改变了HashMap的结构(增加或者移除元素), 将会抛出 ConcurrentModificationException, 但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常, 但这并不是一个一定发生的行为, 要看JVM, 这条同样也是Enumeration和Iterator的区别<br>由于Hashtable是线程安全的也是synchronized, 所以在单线程环境下它比HashMap要慢, 如果你不需要同步, 只需要单一线程, 那么使用HashMap性能要好过Hashtable<br>HashMap不能保证随着时间的推移Map中的元素次序是不变的</li></ul></li><li><p>要注意的一些重要术语：<br>1) sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。</p><p>2) Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。</p><p>3) 结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。</p><p>我们能否让HashMap同步？<br>HashMap可以通过下面的语句进行同步：<br>Map m = Collections.synchronizeMap(hashMap);</p><p>结论<br>Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java 5或以上的话，请使用ConcurrentHashMap吧。 </p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hashtable 是个过时的集合类, 存在于Java API中很久了, 在Java 4中被重写了, 实现了Map接口, 所以自此以后也成了Java集合框架中的一部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;HashMap 和 Hashtable 都实现了Map接口, 但决定用哪一
      
    
    </summary>
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>22. JCF - Java集合框架</title>
    <link href="http://blog.renyimin.com/2018/12/19/JAVA/2018-12-19-22/"/>
    <id>http://blog.renyimin.com/2018/12/19/JAVA/2018-12-19-22/</id>
    <published>2018-12-19T02:17:23.000Z</published>
    <updated>2018-12-29T06:30:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JCF简介"><a href="#JCF简介" class="headerlink" title="JCF简介"></a>JCF简介</h2><ol><li><p><strong>JCF(Java Collection Framework)</strong> 主要是由一组精心设计的接口、类和隐含在其中的数据结构及算法所组成, 通过它们可以对Java对象进行存储、获取、操作和转换等功能; </p></li><li><p>虽然称为框架, 但这些接口和类是以库的方式工作: 所有的集合类都位于 <code>java.util</code> 包下, 是用来存放对象的容器, 后来为了处理多线程环境下的并发安全问题, java5还在 <code>java.util.concurrent</code> 包下提供了一些多线程支持的集合类;</p></li><li><p><strong>Java集合</strong>就像一种容器, 可以动态第把多个对象的引用放入容器中, 所以也叫<strong>Java容器</strong>, 这些容器可以用于存储数量不等的多个对象, 还可以用于保存具有映射关系的关联数组; </p></li><li><p>总之, JCF提供了各种集合的接口和实现它们的类; 用来存放数据对象并实现对其数据对象的各种操作;</p></li></ol><h2 id="JCF框架结构"><a href="#JCF框架结构" class="headerlink" title="JCF框架结构"></a>JCF框架结构</h2><ol><li><p>下面是一比较常见的Java集合框架图<br> <img src="/img/javase/jcf-01.gif" width="500/"></p></li><li><p>从上图来看, 其实Java集合框架主要包括两种类型的容器: Collection和Map, 它们是Java集合框架的根接口, 这两个接口又包含了一些子接口或实现类</p><ul><li>Collection: 一个独立元素的序列, 这些元素会遵循一定的规则</li><li>Map: 一组成对的 “键值对” 对象, 允许你使用键来查找值</li></ul></li><li><p>Java的集合类也主要由 Collection和Map 这两个根接口派生而出, 不过Java不提供直接继承自Collection的集合类, Java提供的集合类都是实现自Collection的 <code>子接口</code> 如 <code>List</code>, <code>Set</code>, <code>Queue</code> </p></li></ol><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><ol><li><p>Collection是最基本的集合接口, 一个Collection代表一组Object(即Collection的元素Elements); 一些Collection允许相同的元素而另一些不行, 一些能排序而另一些不行;</p></li><li><p>Collection 接口下又有 3 种子接口 List、Set 和 Queue, 再下面是一些抽象类, 最后是具体实现类, 常用的有 <code>ArrayList</code>、<code>LinkedList</code>、<code>HashSet</code>、<code>LinkedHashSet</code>、<code>HashMap</code>、<code>LinkedHashMap</code> 等等</p></li><li></li><li><p>Collection中的几个主要实现类 (中间省略一些实现和继承关系)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|Collection </span><br><span class="line">|   ├List </span><br><span class="line">|   │--├LinkedList </span><br><span class="line">|   │--├ArrayList </span><br><span class="line">|   │--└Vector </span><br><span class="line">|   │　    └Stack </span><br><span class="line">|   ├Set</span><br><span class="line">|   │--├HashSet </span><br><span class="line">|   │--├TreeSet </span><br><span class="line">|   │--└LinkedSet </span><br><span class="line">|   │</span><br><span class="line">|   ├Queue</span><br><span class="line">|   │--├PriorityQueue</span><br><span class="line">|   │--├Deque</span><br><span class="line">|   │   ├ArrayDeque</span><br><span class="line">|   │   └LinkedList</span><br></pre></td></tr></table></figure></li><li><p><strong>List, Set,Map三者的区别及总结:</strong></p><ul><li><p>List:对付顺序的好帮手<br>List接口存储一组不唯一(可以有多个元素引用相同的对象), 有序的对象</p></li><li><p>Set:注重独一无二的性质<br>不允许重复的集合, 不会有多个元素引用相同的对象</p></li><li><p>Map: 用Key来搜索的专家<br>使用键值对存储;<br>Map会维护与Key有关联的值, 两个Key可以引用相同的对象, 但Key不能重复, 典型的Key是String类型, 但也可以是任何对象;</p></li></ul></li></ol><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><ol><li>List 接口存储一组不唯一, 有序(插入顺序)的对象 <ul><li>该接口是一个 <strong>有序的</strong> Collection</li><li>使用此接口能够精确的控制每个元素插入的位置</li><li>能够通过索引(元素在List中位置, 类似于数组的下标)来访问List中的元素, 第一个元素的索引为0</li><li>允许有相同的元素 </li></ul></li><li><p>List接口下我们通常使用的实现类有: <code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code>及其子类<code>Stack</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├List </span><br><span class="line">│--├LinkedList </span><br><span class="line">│--├ArrayList </span><br><span class="line">│--└Vector (已过时)</span><br><span class="line">│　    └Stack</span><br></pre></td></tr></table></figure></li><li><p>List子接口的操作有<br> <img src="/img/javase/collection-list01.png" width="450/"></p></li><li>List子接口是<strong>有序</strong>集合, 所以与Set相比, 增加了与索引位置相关的操作: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(int index, Object o): 在指定位置插入元素</span><br><span class="line">addAll(int index, Collection c): ...</span><br><span class="line">get(int index): 取得指定位置元素</span><br><span class="line">indexOf(Obejct o): 返回对象o在集合中第一次出现的位置</span><br><span class="line">lastIndexOf(Object o): ...</span><br><span class="line">remove(int index): 删除并返回指定位置的元素</span><br><span class="line">set(int index, Object o): 替换指定位置元素</span><br><span class="line">subList(int fromIndex, int endIndex): 返回子集合</span><br></pre></td></tr></table></figure></li></ol><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ol><li>ArrayList是List接口的可变数组的实现, 它封装了一个动态增长的、允许再分配的Object[]数组; 并允许包括 null 在内的所有元素;</li><li>由于 Arraylist底层使用的是数组, 所以其 读取数据效率高,插入删除特定位置效率低</li><li>ArrayList不是线程同步的, 即线程不安全;</li></ol><h3 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h3><ol><li><p>Vector是一种老的动态数组, 是线程同步的, 效率很低, 一般不赞成使用;</p><blockquote><p>其实 ArrayList 和 Vector 在用法上完全相同, 但由于Vector是一个古老的集合(从jdk1.0就有了), 那时候java还没有提供系统的集合框架, 所以在Vector里提供了一些方法名很长的方法(例如:addElement(Object obj)), 实际上这个方法和add(Object obj)没什么区别;<br> 从jdk1.2以后, Java提供了系统的集合框架, 就将Vector改为实现List接口, 作为List的实现之一, 从而导致Vector里有一些重复的方法;<br> Vector里有一些功能重复的方法, 这些方法中方法名更短的是属于后来新增的方法, 更长的是原先vector的方法, 而后来ArrayList是作为List的主要实现类, 看过的Java思想编程中也提到了<strong>Vector有很多缺点, 尽量少用Vector实现类</strong></p></blockquote></li><li><p>Vector的子类<code>Stack</code>: Stack类表示后进先出(LIFO)的对象堆栈</p><ul><li>由于 Vector是通过数组实现的, 这就意味着, Stack也是通过数组实现的, 而非链表</li><li><code>Deque</code> 接口及其实现提供了 LIFO 堆栈操作 更完整和更一致的集合, 应该优先使用此集合, 而非Stack类。例如: <code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</code></li></ul></li><li><blockquote><p>Vector类 和 Stack类 这两个都是jdk1.0的过时API, <strong>应该避免使用</strong><br> jdk1.5新增了很多多线程情况下使用的集合类, 位于java.util.concurrent<br> 如果你说, Vector是同步的, 你要在多线程使用, 那你应该使用 java.util.concurrent.CopyOnWriteArrayList 等, 而不是Vector<br> 如果你要使用Stack做类似的业务, 那么非线程的你可以选择linkedList, 多线程情况你可以选择 java.util.concurrent.ConcurrentLinkedDeque 或者java.util.concurrent.ConcurrentLinkedQueue</p></blockquote></li><li><p>多线程情况下, 应尽量使用java.util.concurrent包下的类;</p></li><li><p>摘自: <a href="https://www.cnblogs.com/devin-ou/p/7989451.html" target="_blank" rel="noopener">https://www.cnblogs.com/devin-ou/p/7989451.html</a></p></li></ol><h3 id="Vector类-amp-ArrayList类"><a href="#Vector类-amp-ArrayList类" class="headerlink" title="Vector类 &amp; ArrayList类"></a>Vector类 &amp; ArrayList类</h3><ol><li>它们都是基于数组实现</li><li>Vector可以设置增长因子, 而ArrayList不可以 (类允许设置默认的增长长度, 默认扩容方式为原来的2倍)</li><li>Vector的方法都是同步的(Synchronized), 是线程安全的(thread-safe), 而ArrayList的方法不是, 由于线程的同步必然要影响性能, 因此, ArrayList的性能比Vector好</li></ol><p>详细: <a href="https://blog.csdn.net/weixin_37766296/article/details/80315375" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37766296/article/details/80315375</a></p><h3 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3><ol><li>LinkedList底层使用的是双向循环链表数据结构(插入, 删除效率特别高);</li><li>LinkedList实现了List接口, 允许 <code>null</code> 元素, 此外LinkedList提供额外的get, remove, insert方法在LinkedList的首部或尾部, <strong>这些操作使LinkedList可被用作堆栈(stack), 队列(queue)或双向队列(deque)</strong></li><li>当数据特别多, 而且经常需要插入删除元素时建议选用 LinkedList; 一般程序只用Arraylist就够用了, 因为一般数据量都不会蛮大, Arraylist是使用最多的集合类;</li><li>注意LinkedList没有同步方法, 如果多个线程同时访问一个List, 则必须自己实现访问同步, 一种解决方法是在创建List时构造一个同步的List:  <code>List list = Collections.synchronizedList(new LinkedList(…));</code></li></ol><h3 id="ArrayList类-amp-LinkedList类"><a href="#ArrayList类-amp-LinkedList类" class="headerlink" title="ArrayList类 &amp; LinkedList类"></a>ArrayList类 &amp; LinkedList类</h3><ol><li>Arraylist 底层使用的是数组(存读数据效率高, 插入删除特定位置效率低), LinkedList底层使用的是双向循环链表数据结构(插入, 删除效率特别高)</li><li>在各种Lists中, 最好的做法是以ArrayList作为缺省选择; 当插入、删除频繁时, 使用LinkedList();</li></ol><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><ol><li><p>Set 接口存储一组<strong>唯一</strong>, <strong>无序</strong>的对象 (判断两个对象是否相同则是根据<code>equals</code>方法)</p></li><li><p>Set接口下我们通常使用的实现类有: <code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code>及其子类<code>Stack</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├Set</span><br><span class="line">│--├HashSet </span><br><span class="line">│--├TreeSet </span><br><span class="line">│--└LinkedSet</span><br></pre></td></tr></table></figure></li></ol><h3 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h3><ol><li>HashSet是Set接口的典型实现, HashSet使用HASH算法来存储集合中的元素, 因此具有良好的存取和查找性能; 当向HashSet集合中存入一个元素时, HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值, 然后根据该HashCode值决定该对象在HashSet中的存储位置;</li><li>该类不允许出现重复元素, 不保证集合中元素的顺序, 允许包含值为null的元素, 但最多只能一个(当然了, 元素不能重复);</li><li>HashSet集合判断两个元素相等的标准是两个对象通过 <code>equals()</code> 方法比较相等, 并且两个对象的hashCode()方法的返回值相等;</li><li>HashSet不是同步的, 多线程访问同一步HashSet对象时, 需要手工同步 </li><li>内部使用 <code>HashMap</code> 来存储数据, 数据存储在HashMap的key中;</li><li><p>HashSet几个重要的方法</p><ul><li><p><code>add(E e)</code> : HashSet的确定性(也可以理解为唯一性), 是通过 HashMap 的 put方法 来保证的, 往HashMap中put数据时, 如果key是一样的, 只会替换key对应的value, 不会新插入一条数据; 所以往HashSet中add相同的元素没有什么用, 这里的相同是通过equals方法保证的, 具体的在HashMap中细说。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E var1) &#123;</span><br><span class="line">    return this.map.put(var1, PRESENT) == null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>remove(Object o)</code> : 简单粗暴, 从HashMap中移除一条数据  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object var1) &#123;</span><br><span class="line">    return this.map.remove(var1) == PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>contains(Object o)</code> </p></li><li><code>iterator()</code></li><li>其他的方法诸如: <code>size()</code>、<code>isEmpty()</code>、<code>contains()</code>、<code>clear()</code>等都完全委托给了HashMap。需要注意的是: HashSet没有提供set、get等方法;</li></ul></li><li><p>摘自: <a href="https://www.cnblogs.com/wlrhnh/p/7256969.html" target="_blank" rel="noopener">https://www.cnblogs.com/wlrhnh/p/7256969.html</a></p></li></ol><h3 id="LinkedHashSet类"><a href="#LinkedHashSet类" class="headerlink" title="LinkedHashSet类"></a>LinkedHashSet类</h3><ol><li>LinkedHashSet继承自HashSet, 内部使用的是LinkHashMap; 这样做的意义或者好处是, LinkedHashSet中的元素顺序是可以保证的, 也就是说遍历序和插入序是一致的;</li><li><a href="https://www.cnblogs.com/wlrhnh/p/7256969.html" target="_blank" rel="noopener">https://www.cnblogs.com/wlrhnh/p/7256969.html</a></li><li></li></ol><h3 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h3><ol><li>可以实现排序等功能的集合, 对象元素添加到集合中时会自动按照某种比较规则将其插入到有序的对象序列中, 并保证该集合元素组成按照 升序 排列;</li><li>TreeSet的内部操作的底层数据是TreeMap, 只是我们操作的是TreeMap的key;</li><li>在对大量信息进行检索的时候, TreeSet 比 ArrayList 更有效率, 能保证在log(n)的时间内完成 ( ?? 不对啊, arraylist的随机读取不是O(1)么?? <strong>其实这句话的意思是, 当你不知道索引时, 查找一个元素, TreeSet自然是O(log(n)), 而ArrayList在不指定索引时, 如果没有搜索算法, 自然是log(n)</strong>) <ul><li>TreeSet 是用树形结构来存储信息的, 每个节点都会保存一下指针对象, 分别指向父节点, 左分支, 右分支, 相比较而言, ArrayList就是一个含有元素的简单数组了, 正因为如此, 它占的内存也要比ArrayList多一些;</li><li>向 TreeSet 插入元素也比 ArrayList 要快一些, 因为当元素插入到ArrayList的任意位置时, 平均每次要移动一半的列表, 需要O(n)的时间, 而TreeSet深度遍历查询花费的实施只需要O(log(n))<br>普遍的都是, set查询慢, 插入快, list查询快, 插入慢</li></ul></li><li>…… </li></ol><h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><ol><li><p>用于模拟 队列 这种数据结构, 实现 <code>FIFO</code> 等数据结构; 通常, 队列不允许随机访问队列中的元素;<br> Queue 接口并未定义阻塞队列的方法, 但这在方法并发编程中是很常见的, 因此Queue的子接口 BlockingQueue接口 定义了那些等待元素出现或等待队列中有可用空间的方法, 这些方法扩展了此接口;<br> Queue 实现通常不允许插入 null 元素, 尽管某些实现(如 LinkedList)并不禁止插入 null, 即使在允许 null 的实现中, 也不应该将 null 插入到 Queue 中, 因为 null 也用作 poll 方法的一个特殊返回值, 表明队列不包含元素;</p></li><li></li></ol><h2 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h2><ol><li></li><li><p> |Collection<br> |　　├List<br> |　　│—├LinkedList<br> |　　│—├ArrayList<br> |　　│—└Vector<br> |　　│　    └Stack<br> |　　├Set<br> |　　│—├HashSet<br> |　　│—├TreeSet<br> |　　│—└LinkedSet<br> |<br> |Map<br> 　　├Hashtable<br> 　　├HashMap<br> 　　└WeakHashMap</p></li></ol><h2 id="Java容器注意事项"><a href="#Java容器注意事项" class="headerlink" title="Java容器注意事项"></a>Java容器注意事项</h2><ol><li></li><li><p>Java容器里只能放对象, 对于基本类型(int, long, float, double等), 需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里, 很多时候拆包装和解包装能够自动完成, 这虽然会导致额外的性能和空间开销, 但简化了设计和编程;</p></li><li><p><strong>集合与数组</strong></p><ul><li>数组: 大小固定, 只能存储相同数据类型的数据; 数组存储的元素可以是同一类基本类型, 也可以是同一类对象;</li><li>集合: 大小可动态扩展, 可以存储不同类型的数据; 集合里只能保存对象;<br>在编程中, 常常需要集中存放多个数据, 虽然数组是个不错的选择, 但数组需要你事先明确知道你将要保存的对象的数量, 数组在初始化时就会指定长度, 并且之后这个数组长度是不可变的;<br>而如果我们需要保存动态增长的数据, 就无法再使用数组了, 此时, java的集合类就是一个很好的设计方案了</li></ul></li><li></li><li><p>可点击查看<a href="/img/javase/JCF.png">Java 集合框架图</a></p></li><li><p>Java 集合框架主要包括两种类型的容器:</p><ul><li>一种是<code>集合(Collection)</code>, 存储元素集合; </li><li>另一种是<code>图(Map)</code>, 存储键/值对映射;</li></ul></li></ol><h2 id="Collection接口-1"><a href="#Collection接口-1" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>Collection接口定义了存取一组对象的方法, 其子接口Set和List分别定义了存储方式</p><ul><li>List接口: 有序可重复, 长度可变</li><li>Set接口: 无序, 不可重复</li></ul><ol><li>ArrayList 底层是数组, 查询快, 修改,插入删除慢</li><li>LinkedList 底层是链表, 查询慢, 修改,插入,删除快</li><li>Vector: 线程安全的, 效率低</li><li></li></ol><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><ol><li><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1></li><li><p>无序键值对, 键唯一</p></li><li><p>Collection接口体系中一些常用的实现类有:</p><ul><li><strong>ArrayList</strong>: 实现了List接口, 它是以<strong>数组</strong>的方式来实现的, 数组的特性是可以使用索引的方式来快速定位对象的位置, 因此对于快速的随机访问, 使用ArrayList实现执行效率上会比较好; </li><li><strong>LinkedList</strong>: 是采用<strong>链表</strong>的方式来实现List接口的, 由于是采用链表实现的, 因此在进行 <code>insert</code> 和 <code>remove</code> 动作时在效率上要比 <code>ArrayList</code> 要好得多! 适合用来实现 <code>Stack(堆栈)</code> 与 <code>Queue(队列)</code>, 前者先进后出, 后者是先进先出<br>若要从数组中删除或插入某一个对象, 需要移动后面的数组元素, 从而会重新调整索引顺序, 调整索引顺序会消耗一定的时间, 所以速度上就会比LinkedList要慢许多; 相反, 若要从链表中删除或插入某一个对象, 只需要改变前后对象的引用即可!</li><li>Arraylist底层使用的是数组(存读数据效率高, 插入删除特定位置效率低), LinkedList底层使用的是双向循环链表数据结构(插入, 删除效率特别高)。学过数据结构这门课后我们就知道采用链表存储, 插入, 删除元素时间复杂度不受元素位置的影响, 都是近似O(1)而数组为近似O(n), 因此当数据特别多, 而且经常需要插入删除元素时建议选用LinkedList.一般程序只用Arraylist就够用了, 因为一般数据量都不会蛮大, Arraylist是使用最多的集合类。</li></ul></li><li><h2 id="Arraylist-与-LinkedList-异同"><a href="#Arraylist-与-LinkedList-异同" class="headerlink" title="Arraylist 与 LinkedList 异同"></a>Arraylist 与 LinkedList 异同</h2></li><li>相同点:<ul><li>ArrayList 和 LinkedList 都是不同步的, 也就是不保证线程安全;</li><li></li></ul></li><li>不同:<br> Arraylist 底层使用的是Object数组; LinkedList 底层使用的是双向链表数据结构(JDK1.6之前为循环链表, JDK1.7取消了循环。注意双向链表和双向循环链表的区别)</li><li><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2></li><li>Map是java集合的另一个根接口, Map体系中一些常用的实现类如下:<ul><li></li><li></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JCF简介&quot;&gt;&lt;a href=&quot;#JCF简介&quot; class=&quot;headerlink&quot; title=&quot;JCF简介&quot;&gt;&lt;/a&gt;JCF简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;JCF(Java Collection Framework)&lt;/strong&gt; 主
      
    
    </summary>
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>20. 数组</title>
    <link href="http://blog.renyimin.com/2018/12/18/JAVA/2018-12-18-20/"/>
    <id>http://blog.renyimin.com/2018/12/18/JAVA/2018-12-18-20/</id>
    <published>2018-12-18T14:07:26.000Z</published>
    <updated>2018-12-22T06:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>数组的长度是固定的, 当添加的元素超过了数组的长度时, 需要对数组重新定义, 比较麻烦<br>Java内部就提供了集合类, 能存储任意对象, 长度是可以改变的, 会随着元素的增加而增加, 减少而减少</p><p>数组既可以存储基本类型数据, 有可以存储引用类型数据, 基本数据类型存储的是值, 引用数据类型存储的是地址值<br>集合中只能存储引用类型数据(对象) 当然, 也可以存储基本数据类型, 但是在存储的时候会自动装箱变对象</p><p>集合的底层其实还是用数组做的</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>有序, 有索引, 可以存储重复值</p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>数组实现</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>链表实现</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>数组实现</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>无序, 无索引, 不可以存储重复值</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>哈希算法</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>二叉树算法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数组的长度是固定的, 当添加的元素超过了数组的长度时, 需要对数组重新定义, 比较麻烦&lt;br&gt;Java内部就提供了集合类, 能存储任意对象, 长度是可以改变的, 会随着元素的增加而增加, 减少而减少&lt;/p&gt;
&lt;p&gt;数组既可以存储基本类型数据, 有可以存储引用类型数据, 基本
      
    
    </summary>
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>15. 时间处理相关类</title>
    <link href="http://blog.renyimin.com/2018/12/18/JAVA/2018-12-18-16/"/>
    <id>http://blog.renyimin.com/2018/12/18/JAVA/2018-12-18-16/</id>
    <published>2018-12-18T04:17:13.000Z</published>
    <updated>2018-12-22T06:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-util-Date"><a href="#java-util-Date" class="headerlink" title="java.util.Date"></a>java.util.Date</h2><ol><li></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java-util-Date&quot;&gt;&lt;a href=&quot;#java-util-Date&quot; class=&quot;headerlink&quot; title=&quot;java.util.Date&quot;&gt;&lt;/a&gt;java.util.Date&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;

      
    
    </summary>
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>15. 字符串相关类</title>
    <link href="http://blog.renyimin.com/2018/12/17/JAVA/2018-12-17-15/"/>
    <id>http://blog.renyimin.com/2018/12/17/JAVA/2018-12-17-15/</id>
    <published>2018-12-17T05:21:26.000Z</published>
    <updated>2018-12-22T06:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-lang-String"><a href="#java-lang-String" class="headerlink" title="java.lang.String"></a>java.lang.String</h2><ol><li><p>String 类是不可改变的, 所以你一旦创建了 String 对象, 它的值就无法改变了, 当你需要改变时, 其实会创建出新的 String 对象</p></li><li><p>如下, String 对象经过循环后, 会创建多个不同的对象; (而可变字符串 StringBuilder对象 则始终都是一个)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;String:&quot;);</span><br><span class="line">        String s1 = new String(&quot;a&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            System.out.println(s1);</span><br><span class="line">            System.out.println(System.identityHashCode(s1));</span><br><span class="line">            s1 = s1 + i;</span><br><span class="line">            System.out.println(System.identityHashCode(s1));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;StringBuilder:&quot;);</span><br><span class="line">        StringBuilder s2 = new StringBuilder(&quot;a&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            System.out.println(s2);</span><br><span class="line">            System.out.println(System.identityHashCode(s2));</span><br><span class="line">            s2.append(i);</span><br><span class="line">            System.out.println(System.identityHashCode(s2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串字面量 和 new String 的区别:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s0 = new String(&quot;a&quot;);</span><br><span class="line">String s01 = &quot;a&quot;;</span><br><span class="line">System.out.println(System.identityHashCode(s0));    // 1627674070</span><br><span class="line">System.out.println(System.identityHashCode(s01));   // 1360875712</span><br><span class="line">System.out.println(System.identityHashCode(&quot;a&quot;));   // 1360875712</span><br><span class="line">System.out.println(s0 == s01);   // false</span><br><span class="line">System.out.println(s01 == &quot;a&quot;);   // true</span><br></pre></td></tr></table></figure></li></ol><h2 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer, StringBuilder"></a>StringBuffer, StringBuilder</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java-lang-String&quot;&gt;&lt;a href=&quot;#java-lang-String&quot; class=&quot;headerlink&quot; title=&quot;java.lang.String&quot;&gt;&lt;/a&gt;java.lang.String&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Strin
      
    
    </summary>
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>05. 版本部分回退</title>
    <link href="http://blog.renyimin.com/2018/12/16/git/2018-12-16-05/"/>
    <id>http://blog.renyimin.com/2018/12/16/git/2018-12-16-05/</id>
    <published>2018-12-16T09:10:06.000Z</published>
    <updated>2018-12-16T09:17:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li>假设你正在A分支上进行开发, 此时对 1,2,3 三份文件做了修改, 然后直接 <code>git add .</code>, <code>git commit -m &quot;&quot;</code> 进行了提交, 但是提交后发现, 文件3 是不需要修改的, 你需要将该文件恢复之前版本</li><li>如果直接进行版本回退, 1,2,3 这三个文件的改动都会被回退, 如果改动内容比较少, 你可以这样做; 但是如果这个功能对三个文件进行的改动非常大, 你总不能重来一遍吧, 即便是可以通过编辑器本身的history功能可以找到文件的修改版本, 但这种经方法还是比较low</li><li>所以你需要的是能够将某次commit中的部分文件进行版本回退的功能 </li></ol><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;假设你正在A分支上进行开发, 此时对 1,2,3 三份文件做了修改, 然后直接 &lt;code&gt;git add .&lt;/code&gt;, 
      
    
    </summary>
    
      <category term="git" scheme="http://blog.renyimin.com/categories/git/"/>
    
    
      <category term="git" scheme="http://blog.renyimin.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>04. git stash</title>
    <link href="http://blog.renyimin.com/2018/12/16/git/2018-12-16-04/"/>
    <id>http://blog.renyimin.com/2018/12/16/git/2018-12-16-04/</id>
    <published>2018-12-16T08:53:02.000Z</published>
    <updated>2018-12-16T09:09:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li>在使用git时, 经常会出现 你正在A分支进行开发, 但是突然有个小需求需要紧急切换到B分支进行开发, 遇到这种情况, 我以前的做法通常如下:<ul><li>把A分支上上榜为完成开发的代码直接 commit</li><li>然后checkout到B分支进行开发</li></ul></li><li>上面方式存在的问题是: 本来我每次commit, 都希望是一次比较完整的功能点提交, 而上述操作可能会出现, 某个功能块是尚未完成就直接进行了一次无意义的commit, 显得比较low了, 此时就应该使用 <code>git stash</code> 了<ul><li>先将A分支目前的工作现场保暂存起来</li><li>然后checkout到B分支进行开发工作</li><li>B分支上的工作开发完成后, 在checkout到A分支, 将之前暂存的开发内容恢复到工作区即可</li></ul></li></ol><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><ol><li><code>git stash</code> 可以用来保存工作现场</li><li><code>git stash list</code> 可以用来查看保存的工作现场列表</li><li>恢复工作现场:<ul><li><code>git stash apply</code> : 恢复时不删除stash中的内容, 需要通过 <code>git stash drop stash@{0}</code> 手动删除<br>例 <code>git stash apply stash@{0}</code></li><li><code>git stash pop</code> : 恢复的同时也将stash内容删除掉 </li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在使用git时, 经常会出现 你正在A分支进行开发, 但是突然有个小需求需要紧急切换到B分支进行开发, 遇到这种情况, 我以前的
      
    
    </summary>
    
      <category term="git" scheme="http://blog.renyimin.com/categories/git/"/>
    
    
      <category term="git" scheme="http://blog.renyimin.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>10. Intellij IDE快捷键</title>
    <link href="http://blog.renyimin.com/2018/12/16/JAVA/2018-12-16-10/"/>
    <id>http://blog.renyimin.com/2018/12/16/JAVA/2018-12-16-10/</id>
    <published>2018-12-16T03:00:26.000Z</published>
    <updated>2018-12-22T06:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><code>main</code> 函数快捷键: 先敲出 main, 然后 <code>command+j</code>, 回车</li><li><code>System.out.println</code> 快捷键: 先敲出 <code>sout</code>, 会自动弹出一个匹配列表, 选择第一项即可</li><li>get, set 方法生成: 光标移动到属性名上, 按 <code>Command + n</code> </li><li>查看某个类的继承结构: <code>Ctrl+h</code><br> <img src="/img/javase/intellij-keys-01.png" width="500/"></li><li>annotate 注释: 在显示行号的位置右击, 选中 Annotate, 即可查看当前行代码的commit、author和date</li><li>查看类的继承结构: <code>Navigate</code> =&gt; <code>Type Hierarchy</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt; 函数快捷键: 先敲出 main, 然后 &lt;code&gt;command+j&lt;/code&gt;, 回车&lt;/li&gt;
&lt;li&gt;&lt;code&gt;System.out.println&lt;/code&gt; 快捷键: 先敲出 &lt;code&gt;sout&lt;/code
      
    
    </summary>
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>03. git push 时出现 &quot;Merge branch &#39;master&#39; of ...&quot;</title>
    <link href="http://blog.renyimin.com/2018/12/14/git/2018-12-14-03/"/>
    <id>http://blog.renyimin.com/2018/12/14/git/2018-12-14-03/</id>
    <published>2018-12-14T06:16:39.000Z</published>
    <updated>2018-12-19T02:16:32.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>当我们在使用git进行协同开发时, 假设 develop 为大家的一条协同分支: 当你在本地进行开发完后, 会将自己的分支合并到develop并 <code>git push</code> 到远端</p><ul><li>如果此时在你之前并没有其他人对develop进行过commit并push到远端, 你是可以直接push成功的, 但这种情况一般不多, 毕竟多人协同开发现在很普遍</li><li>与上面相对的是, 在你push之前, 很可能已经有其他人对develop进行过commit并push到远端, 所以你经常会出现 push 不成功的问题, 如下:<br><img src="/img/git/push_failed.png"></li></ul></li><li><p>此时一般常见做法是 先 <code>git pull</code>, 然后再 <code>git push</code>, 但在 <code>git pull</code> 时, 其实还分两种情况</p><ul><li><p>一种是远端和本地产生了冲突:<br><img src="/img/git/push_failed_conflict.png"><br>此时你需要在本地解决冲突, 并重新进行 commit, push<br><img src="/img/git/push_s_01.png"><br>最终的分支结构如下:<br><img src="/img/git/push_s_02.png"></p></li><li><p>另外一种是远端虽然有改动, 但是和本地没有冲突<br>此时虽然没有提示冲突, 但依然push失败, 当你执行pull时, 会直接弹出如下编辑框<br><img src="/img/git/git-pull-no-conflict.png"><br>如果你wq保存编辑页, 你会发现git pull自动进行了ff自动合并<br><img src="/img/git/git-pull-no-conflict.png"><br>最终的分支结构如下:<br><img src="/img/git/merge-remote.png"></p></li></ul></li><li><p>可以发现, 当 <code>git pull</code> 时, 会将远端与本地进行一次 <code>git merge</code>, 此时</p><ul><li>可能会无冲突自动完成 fast-farward 合并 (此时会出现一个 <code>Merge branch &#39;master&#39; of ...</code> commit点)</li><li>也可能需要解决冲突再手动提交 (此时是自己手动打上的 commit点)</li></ul></li><li><p>如何在 <code>git push</code> 时避免出现 <code>Merge branch &#39;master&#39; of ...</code> ?</p><ul><li>方案一: (比较low的做法)在 <code>git pull</code> 弹出编辑页面时, 对commit点的日志内容进行修改 ; 或者先 <code>git fetch</code> 然后 <code>git merge</code>, 在本地编写commit点日志信息 (简单来说 <code>git pull</code> = <code>git fetch</code> + <code>git merge</code>)<br>上面的做法并没有解决实际问题, 还会有一个合并时的commit点</li><li>方案二: (比较巧) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"># 主要是此处, 将协作分支master rebase 到自己的dev分支</span><br><span class="line">git checkout dev</span><br><span class="line">git rebase master</span><br><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line">git push origin feature</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>方案二测试</strong>:</p><ul><li>两个分支的初始基点一致<br><img src="/img/git/merge-remote-01.png"></li><li>两个分支分别进行两次提交, 构造冲突:<br><img src="/img/git/merge-remote-02.png"></li><li>然后在dev分支rebase来合并master分支内容 (master可以先pull, 这是不会有冲突的)<br><img src="/img/git/merge-remote-03.png"></li><li>查看两分支<br><img src="/img/git/merge-remote-04.png"></li><li>最后再在master分支<code>merge</code>去合并dev分支的内容, 此时自然也不会有冲突了</li><li>最终的分支都是直线向上<br><img src="/img/git/merge-remote-05.png"></li></ul></li><li><p>出现类似: “Merge remote-tracking branch ‘remotes/origin/develop’” :<br> ?? git pull 和 git pull origin master ??</p></li></ol><p>参考:</p><ul><li><a href="https://www.cnblogs.com/Sinte-Beuve/p/9195018.html" target="_blank" rel="noopener">https://www.cnblogs.com/Sinte-Beuve/p/9195018.html</a></li></ul><p><a href="https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches" target="_blank" rel="noopener">https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;当我们在使用git进行协同开发时, 假设 develop 为大家的一条协同分支: 当你在本地进行开发完后, 会将自己的分支合并到develop并 &lt;code&gt;git push&lt;/code&gt; 到远端&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果此时在你之前并没有其他人对d
      
    
    </summary>
    
      <category term="git" scheme="http://blog.renyimin.com/categories/git/"/>
    
    
      <category term="git" scheme="http://blog.renyimin.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>02. 选择 merge 还是 rebase?</title>
    <link href="http://blog.renyimin.com/2018/12/12/git/2018-12-12-02/"/>
    <id>http://blog.renyimin.com/2018/12/12/git/2018-12-12-02/</id>
    <published>2018-12-12T09:01:23.000Z</published>
    <updated>2018-12-14T06:27:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-rebase-介绍"><a href="#git-rebase-介绍" class="headerlink" title="git rebase 介绍"></a>git rebase 介绍</h2><ol><li>rebase: 变基, 即改变分支的根基;</li><li>从某种程度来说, <code>git rebase</code> 和 <code>git merge</code> 都可以完成类似的合并工作, 但实际上两者有着本质的不同;</li><li><p>假设你的项目有 mywork, origin 两个分支, 如果你想让 mywork 的分支历史看起来像没有经过任何合并一样, 你可以用 <code>git rebase</code> (虽然 <code>git merge</code> 也可以实现, 但是一旦合并遇到冲突时, 还是会出现分叉) </p><ul><li>如下命令: 会把你的 origin 分支从 mywork 切出来后的每个提交(commit)取消掉, 并且把它们临时保存为补丁(patch)(这些补丁放到”.git/rebase”目录中), 然后把 origin 分支更新到最新的 mywork 分支, 最后把保存的这些补丁应用到 mywork 分支上。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout mywork</span><br><span class="line">$ git rebase origin</span><br></pre></td></tr></table></figure></li></ul></li><li><p>具体如下图:<br> <img src="/img/git/gitrebase.png"></p></li></ol><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><h3 id="主分支没有commit时"><a href="#主分支没有commit时" class="headerlink" title="主分支没有commit时"></a>主分支没有commit时</h3><ol><li><code>git init</code> 初始化一个仓库, 在默认的 master分支创建一个index.php文件并提交 (新建分支的话, 必须要保证初始分支的仓库中是有内容的) (下面做了两次提交)<br> <img src="/img/git/rebase01.png"></li><li><p><code>git log --graph</code> 查看master日志<br> <img src="/img/git/rebase02.png"></p></li><li><p>新建并切换到 dev 分支, 对index.php文件做改动并提交 (不修改同一行,先不构造冲突)</p></li><li><p><code>git log --graph</code> 查看dev日志<br> <img src="/img/git/rebase03.png"></p></li><li><p><code>git rebase</code> 合并<br> <img src="/img/git/rebase04.png"></p></li><li><p>发现效果和之前的 <code>git merge</code> fast-forward无冲突时 貌似没什么区别<br> <img src="/img/git/rebase05.png"></p></li></ol><h3 id="主分支有commit且出现冲突时"><a href="#主分支有commit且出现冲突时" class="headerlink" title="主分支有commit且出现冲突时"></a>主分支有commit且出现冲突时</h3><ol><li><p>接着上面的例子, master 和 dev 分别修改同一行内容, 构造冲突<br> <img src="/img/git/rebase10.png"></p></li><li><p>切换到 master 分支, <code>git rebase</code> 合并dev分支<br> <img src="/img/git/rebase11.png"></p></li><li><p>如上 <code>git rebase</code> 在出现冲突时, Git会停止rebase并会让你去解决冲突, 在解决完冲突后, 用 <code>git add</code> 命令去更新这些内容的索引(index), 然后, 你无需执行 <code>git-commit</code>, 只要执行: <code>git rebase --continue</code> （当然, 无冲突时, 直接 <code>git rebase</code> 就直接完成了合并）<br> <img src="/img/git/rebase12.png"></p></li><li><p>发现好像之前master上的那次提交的信息(时间, 日志等信息)都在, 但是取而代之的是一个新的commit_id, <strong>rebase会修改 根基之后 的提交历史</strong><br> <img src="/img/git/rebase13.png"></p></li></ol><h3 id="主分支有commit但无冲突"><a href="#主分支有commit但无冲突" class="headerlink" title="主分支有commit但无冲突"></a>主分支有commit但无冲突</h3><ol><li>经过测试, 即便无冲突, master分支的新commit也会丢失</li><li>测试如下:<ul><li>master, dev两个分支基点相同<br><img src="/img/git/rebase-no-conflict-01.png"></li><li>master, dev两个分支各自做改动, 但是改动并不不冲突<br><img src="/img/git/rebase-no-conflict-02.png"></li><li>发现master进行 <code>git rebase dev</code> 直接就合并成功了, 虽然没有冲突, 但是master的commit历史确实还是被改掉了!!<br><img src="/img/git/rebase-no-conflict-03.png"></li></ul></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>不要在master和其他协作分支上使用 <code>git rebase</code>, 它会修改提交历史;</li><li>当使用git做合并操作时, 如果没有冲突, 则 <code>git merge(fast-forward)</code> 和 <code>git rebase</code> 效果一样都是直线, 而<code>git merge --no-ff</code>会出现分叉和新提交点;</li><li>当使用git做合并操作时, 如果出现冲突, 则 <code>git merge(fast-forward)</code> 和 <code>git merge --no-ff</code> 一样都会出现分叉和新提交点, <code>git rebase</code>则不同, 它是直线, 但会修改历史提交点;</li></ol><h2 id="rebase-使用技巧"><a href="#rebase-使用技巧" class="headerlink" title="rebase 使用技巧"></a>rebase 使用技巧</h2><ol><li><code>git rebase</code> 由于会改变历史提交点, 所以一定不能用在协作分支上</li><li>使用rebase既可以保证分支直线美观, 也可以保证在<code>git push</code>时不出现类似 “Merge remote-tracking branch…” 问题</li><li>通常如下来使用, 下文在解决 类似 “Merge remote-tracking branch…” 问题时, 会有详细过程: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"># 主要是此处, 将协作分支master rebase 到自己的dev分支</span><br><span class="line">git checkout dev</span><br><span class="line">git rebase master</span><br><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line">git push origin feature</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;git-rebase-介绍&quot;&gt;&lt;a href=&quot;#git-rebase-介绍&quot; class=&quot;headerlink&quot; title=&quot;git rebase 介绍&quot;&gt;&lt;/a&gt;git rebase 介绍&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;rebase: 变基, 即改变分支的根基
      
    
    </summary>
    
      <category term="git" scheme="http://blog.renyimin.com/categories/git/"/>
    
    
      <category term="git" scheme="http://blog.renyimin.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>01. git merge 对比 fast-forward 与 --no-ff</title>
    <link href="http://blog.renyimin.com/2018/12/12/git/2018-12-12-01/"/>
    <id>http://blog.renyimin.com/2018/12/12/git/2018-12-12-01/</id>
    <published>2018-12-12T05:32:54.000Z</published>
    <updated>2018-12-14T06:17:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-merge-介绍"><a href="#git-merge-介绍" class="headerlink" title="git merge 介绍"></a>git merge 介绍</h2><ol><li><p>在使用 git merge 进行分支合并时, 可以直接使用如下两种方式 </p><ul><li><code>git merge</code> (fast-forward)</li><li><code>git merge --no-ff</code></li></ul></li><li><p>这两者的区别如下:<br> <img src="/img/git/git-merge.png" width="480/"></p></li><li><p>但是需要注意的是 <code>git merge</code> 的一个特例: 当合并出现冲突时, 其实是无法执行快速合并的,需要解决冲突后再进行一次提交, 所以效果和 <code>git merge --no-ff</code> 是一样的, 也就是还会出现分叉 (可以参考<a href="https://backlog.com/git-tutorial/cn/stepup/stepup2_7.html" target="_blank" rel="noopener">此文</a>)</p></li></ol><h2 id="fast-forward"><a href="#fast-forward" class="headerlink" title="fast-forward"></a>fast-forward</h2><ol><li><code>git init</code> 初始化一个仓库, 在默认的 master分支创建一个index.php文件并提交 (新建分支的话, 必须要保证初始分支的仓库中是有内容的) (下面做了两次提交)<br> <img src="/img/git/test00.png"></li><li><p><code>git log --graph</code> 查看master日志<br> <img src="/img/git/test01.png"></p></li><li><p>新建并切换到 dev 分支, 对index.php文件做改动并提交<br> <img src="/img/git/test02.png"></p></li><li><p><code>git log --graph</code> 查看dev日志<br> <img src="/img/git/test03.png"></p></li><li><p>切换到master分支进行 Fast-forward 合并<br> <img src="/img/git/test04.png"></p></li><li><p>最终可以看到, master分支只是简单地将dev分支的那次提交合进自己的分支内 (不会在graph图中保留dev分支线)<br> <img src="/img/git/test05.png"></p></li><li>即便是在dev分支做了多次提交, master分支也只是简单地将dev分支的多次提交合进自己的分支内 (不会保留dev分支)<br> <img src="/img/git/test06.png"></li></ol><h2 id="—no-ff"><a href="#—no-ff" class="headerlink" title="—no-ff"></a>—no-ff</h2><ol><li><code>git init</code> 初始化一个仓库, 在默认的 master分支创建一个index.php文件并提交 (新建分支的话, 必须要保证初始分支的仓库中是有内容的) (下面做了两次提交)<br> <img src="/img/git/test10.png"></li><li><p><code>git log --graph</code> 查看master日志<br> <img src="/img/git/test11.png"></p></li><li><p>新建并切换到 dev 分支, 对index.php文件做改动并提交<br> <img src="/img/git/test12.png"></p></li><li><p><code>git log --graph</code> 查看dev日志<br> <img src="/img/git/test13.png"></p></li><li><p>切换到master分支进行 —no-ff 合并 (相比 FastForward, 这里还会弹出编辑界面, 允许你对本次合并进行说明)<br> <img src="/img/git/test14.png"></p></li><li><p>最终可以看到:</p><ul><li>master分支并没有将dev上的两次提交合到自己的分支上</li><li>而是<strong>在graph图中保留了dev分支线</strong></li><li>并且将这次合并当做一次dev向master的提交, 在master上生成一个新的commit</li><li>此时master的分支的commit点已经比dev上的commit要更新一步<br><img src="/img/git/test15.png"></li></ul></li><li><p>此时如果不把master的提交分支合并到dev, 而是在dev上继续做两次提交, 然后再在master上进行 —no-ff 合并, 效果如下: 红色框表示—no-ff合并时所进行的新commit及备注日志<br> <img src="/img/git/test16.png"></p></li><li><p>现在如果把master的提交合并到dev<br> <img src="/img/git/test17.png"></p></li><li><p>如果在master切出新的分支, 然后再新分支上进行提交, 再回到master进行 —no-ff 合并, 效果依然如下图:<br> <img src="/img/git/test18.png"></p></li></ol><h2 id="ff-冲突导致的例外"><a href="#ff-冲突导致的例外" class="headerlink" title="ff 冲突导致的例外"></a>ff 冲突导致的例外</h2><ol><li><p>重新创建本地仓库, 对master进行两次提交;</p></li><li><p>新建并切换到dev分支, 并修改文件:<br> <img src="/img/git/test22.png"></p></li><li><p>切换回master分支, 修改dev上修改的同一行内容, 构造冲突:<br> <img src="/img/git/test21.png"></p></li><li><p>此时, 即便是在master上使用 fast-forward 合并dev, 由于有冲突, 还是会进行一次提交:<br> <img src="/img/git/test23.png"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;git-merge-介绍&quot;&gt;&lt;a href=&quot;#git-merge-介绍&quot; class=&quot;headerlink&quot; title=&quot;git merge 介绍&quot;&gt;&lt;/a&gt;git merge 介绍&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在使用 git merge 进行分支合并时
      
    
    </summary>
    
      <category term="git" scheme="http://blog.renyimin.com/categories/git/"/>
    
    
      <category term="git" scheme="http://blog.renyimin.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>04. 基础面向对象知识</title>
    <link href="http://blog.renyimin.com/2018/12/10/JAVA/2018-12-10-04/"/>
    <id>http://blog.renyimin.com/2018/12/10/JAVA/2018-12-10-04/</id>
    <published>2018-12-10T14:33:32.000Z</published>
    <updated>2018-12-22T06:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>可以理解类为模板, 对象为实物</p><h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><ol><li>没有名字的对象<ul><li><code>Car c = new Car();</code> 就是有名字的对象;</li><li>匿名对象其实就是定义对象的简写格式: <code>new Car();</code></li></ul></li><li>当对象对方法仅进行一次调用的时候, 就可以简化成使用匿名对象调用 <code>new Car().run();</code> </li></ol><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ol><li>函数名与类名相同: 在Java中, 由于构造方法和类名同名, 所以子类无法进行重写, 但是可以重载 (php由于构造方法名为与类名无关的 __construct, 所以可以重写)</li><li>不用定义返回值类型 (这个函数是没有返回值的, 甚至连 void都不要写)</li><li>在创建对象时就会自动调用构造函数 ( 因为创建对象的时候一定会调用构造函数, 所以可以利用这个特性给对象进行初始化 )</li><li><p>一个类中如果没有定义过构造函数, 那么该类中会有一个默认的空参数构造函数(在你编译过的.class文件中就有一个默认的空参数构造函数的)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Demo</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">就这么个简单的类, 其实在编译完之后, 生成的.class文件中其实是 :</span><br><span class="line">class Demo</span><br><span class="line">&#123;</span><br><span class="line">   Demo()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果一个类中指定了构造函数, 那么类中的默认构造函数就没有了, 此时.class文件中保存的是你自己写的构造函数</p></li><li><strong>构造函数和一般函数的区别</strong> :<ul><li>在new创建对象时, 构造函数会被调用并且只被调用一次(可以对对象进行初始化); 而一般函数在对象创建之后, 在需要函数功能时才调用;</li><li>在new创建对象时, 构造函数会被调用并且只被调用一次; 而一般函数在对象创建后, 可以被调用多次;</li><li><strong>普通函数不能调用构造函数</strong> ; 构造函数是用来给对象初始化的 ;</li><li><strong>普通的函数也可以用类名作为自己的函数名</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void  Person()     // 加了void这个返回类型后, 就成了一般函数了</span><br><span class="line">&#123;</span><br><span class="line">     name = &quot;baby&quot;;</span><br><span class="line">     age = 1;</span><br><span class="line">     System.out.println(&quot;person run&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h2><ol><li><p>如下, 子类对象被创建时, 会访问子类的构造函数, 但是下面会发现父类的构造函数也运行了</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Fu</span><br><span class="line">&#123;</span><br><span class="line">    Fu()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;fu run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Zi extends Fu</span><br><span class="line">&#123;</span><br><span class="line">    Zi()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;zi run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ExtendsDemo</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        new Zi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其原因是<strong>在子类的构造函数中第一行有一个默认的隐式语句</strong>: <code>super()</code><br> (这点和php不同, php只有显示指定了 <code>parent::__construct()</code> 才会调用父类的构造函数)</p></li><li><p>其实子类中<strong>所有的构造函数</strong>默认都会访问父类中的空参数的构造函数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Fu</span><br><span class="line">&#123;</span><br><span class="line">    Fu()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;fu run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fu(int age)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;fu age:&quot; + age + &quot;run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Zi extends Fu</span><br><span class="line">&#123;</span><br><span class="line">    Zi()</span><br><span class="line">    &#123;</span><br><span class="line">        // super(); // 调用的就是父类中的空参数的构造函数</span><br><span class="line">        System.out.println(&quot;zi run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zi(int age)</span><br><span class="line">    &#123;</span><br><span class="line">        // super(); // 调用的就是父类中的空参数的构造函数</span><br><span class="line">        System.out.println(&quot;zi age:&quot; + age + &quot; run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ExtendsDemo</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        new Zi();</span><br><span class="line">        new Zi(100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 结果:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fu run # 父类无参构造函数</span><br><span class="line">zi run</span><br><span class="line">fu run # 父类无参构造函数</span><br><span class="line">zi age:100 run</span><br></pre></td></tr></table></figure></li><li><p>如果父类中没有定义空参数构造函数, 则子类的构造函数必须用 <code>super</code> 明确要调用父类中的哪个构造函数</p></li><li><p>如果子类构造函数中还使用了 <code>this()</code> 调用了子类自己的构造函数, 那么子类的这个构造函数中的 <code>super()</code> 就没有了, 因为 <code>super()</code> 和 <code>this()</code> 只能有一个</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Zi extends Fu</span><br><span class="line">&#123;</span><br><span class="line">    Zi()</span><br><span class="line">    &#123;</span><br><span class="line">        // super(); // 调用的就是父类中的空参数的构造函数</span><br><span class="line">        System.out.println(&quot;zi run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zi(int age)</span><br><span class="line">    &#123;</span><br><span class="line">        this();</span><br><span class="line">        // super(); // 调用的就是父类中的空参数的构造函数</span><br><span class="line">        System.out.println(&quot;zi age:&quot; + age + &quot; run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ExtendsDemo</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        new Zi();</span><br><span class="line">        new Zi(100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 结果: </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fu run</span><br><span class="line">zi run</span><br><span class="line"></span><br><span class="line">fu run  // 并没有出现两次</span><br><span class="line">zi run</span><br><span class="line">zi age:100 run</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>: <code>super()</code> 语句必须要定义在子类构造函数的第一行, 因为父类的初始化动作要先完成 (不然会提示错误)</p></li></ol><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><ol><li>当子类和父类中的成员(变量或方法)重名的时候, 用 <code>super</code> 区分父类</li><li><code>this</code> 和 <code>super</code> 的用法很相似<ul><li><code>super</code> 的用法跟 <code>this</code> 类似, <code>this</code> 代表对本类对象的引用, 指向本类已经创建的对象; 而 <code>super</code> 代表对父类对象的引用, 指向父类对象</li><li>静态方法中不可以出现 <code>super</code>, <code>this</code> 关键字</li></ul></li><li>在子类的<code>构造函数</code>中, 第一行会隐式地执行一个: <code>super()</code></li></ol><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><ol><li>this 是在类的成员函数中使用, 代表的是当前对象;</li><li><p>成员变量和局部变量重名的话, 必须用 <code>this</code> 来给成员变量做引用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Person(name)</span><br><span class="line">&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>: 在一般情况下, 如果在类方法中的成员属性和局部变量不重名的情况下, 其实成员属性前是不用写<code>this.</code>的, 因为Java默认就是用的<code>this.</code> ( 这点和PHP不同 )</p></li><li><code>this()</code> 用法 ??</li></ol><h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><ol><li>static是一个修饰符, 用于修饰成员 (成员变量和成员函数)</li><li>被static修饰后的成员具备以下特点 :<ul><li>随着类的加载而加载 ;</li><li>优先于对象存在 ; (因为它是随着类的加载而加载的, 而类加载的时候还没有对象的)</li><li>被该类的所有对象所共享 ;</li><li>多了一种调用方式, 可以直接被类名调用 ; (因为static成员存在的时候只有类存在, 对象尚未存在)</li><li><strong>static修饰的数据是共享数据, 对象中存储的是对象自己特有数据</strong></li></ul></li><li>使用注意:<ul><li>静态方法只能访问静态成员(成员变量和成员函数)</li><li>静态方法中不可以写 <code>this</code>, <code>super</code>关键字;</li><li>之前我们一开始写的main主函数就是静态的;</li></ul></li></ol><h2 id="成员变量与静态变量的区别"><a href="#成员变量与静态变量的区别" class="headerlink" title="成员变量与静态变量的区别"></a>成员变量与静态变量的区别</h2><ol><li><p>生命周期的不同:</p><ul><li>成员变量: 随着对象的创建而存在, 随着对象的被回收而释放;</li><li>静态变量: 随着类的加载而加载, 随着类的消失而消失; (那类什么时候消失呢 ? 一般情况下, 虚拟机结束了, 类就消失了)</li></ul></li><li><p>调用方式不同:</p><ul><li>成员变量: 只能被对象调用;</li><li>静态变量: 可以被对象调用, 也可以被类名调用; (一般就用类名调用)</li></ul></li><li><p>别名不同:</p><ul><li>成员变量: 也称为实例变量;     </li><li>静态变量: 称为类变量;</li></ul></li><li><p>数据的存储位置不一样:</p><ul><li>成员变量: 存储在<strong>堆内存</strong>的对象中, 所以是对象的特有数据;</li><li>静态变量: 存储在于<strong>方法区</strong>(也叫共享数据区)的静态区中, 所以也叫对象的共享数据; </li></ul></li><li><p>静态方法只能调用静态变量, 不能调用成员变量 (但是, 非静态方法是可以访问静态成员)</p><ul><li>因为静态方法在类被加载的时候就被加载了,可能还没有对象的时候, 就已经可以用类名来访问了 (<code>Person.show();</code>)</li><li>如果它里面有成员变量的话, 由于此时还没有对象, 而成员变量是每个对象所特有的, 如果对象没有创建, 自然无法使用成员变量</li></ul></li></ol><h2 id="静态方法和实例方法"><a href="#静态方法和实例方法" class="headerlink" title="静态方法和实例方法"></a>静态方法和实例方法</h2><ol><li><p>静态成员函数</p><ul><li>提供给外部调用的函数应该是非静态的还是静态的呢?<br>函数是否需要设置为静态函数, 只用参考该函数是否有访问到对象中的特有数据, 如果访问到了对象的特有数据的话, 那就不能用static来进行修饰了 (因为静态方法只能调用静态成员)</li><li>简单来说就是 : 该函数是否需要访问非静态的成员, 如果需要访问非静态成员, 那么该功能就不能是静态的(因为静态方法只能调用静态成员) </li></ul></li><li><p>如果创建的对象仅仅是为了去调用没有访问特有数据的非静态方法, 那么这个对象的创建除了浪费空间这个坏处之外, 没有别的任何好处了; 此时这个方法完全可以设置为static, 然后使用类名来调用, 而不用创建对象, 不浪费空间<br> (对象的创建是为了访问特有数据的, 没有访问特有数据, 干嘛要创建对象呢)</p></li></ol><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><ol><li>静态代码块随着类的加载而执行, 而且只执行一次 ;</li><li><strong>静态代码块的作用</strong> :<ul><li>用于给<strong>类</strong>进行一些初始化工作 ;</li><li>一般如果一个类里面都是静态成员, 这个类是不需要创建对象的, 直接用类名调用成员即可, 但此时因为没有创建对象, 所以不会执行构造函数, 那么如何进行一些初始化工作呢?<br><strong>如果此时还要进行一些初始化工作, 那就要靠静态代码块了!!!!</strong></li></ul></li><li>示例: 静态代码块只被调用了一次, 只是第一次创建对象的时候被调用了, 后面就不会再被执行了 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class StaticCode</span><br><span class="line">&#123;</span><br><span class="line">    static int num;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        num = 10;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void show()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class StaticCodeDemo</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        new StaticCode();</span><br><span class="line">        new StaticCode().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h2><ol><li><p>没有名字的普通代码块, 如下的代码块就没有名字, 可以看到在创建对象的时候, 无名代码块就被加载到了, 并且创建几次对象就加载几次</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ConstructBlock &#123;</span><br><span class="line"></span><br><span class="line">    // 构造代码块</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;构造代码块被执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ConstructBlock()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;构造方法被执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConstructBlockDemo</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        new ConstructBlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结果:</span><br><span class="line">构造代码块被执行</span><br><span class="line">构造方法被执行</span><br></pre></td></tr></table></figure></li><li><p>无名的普通代码块, 是随着对象的创建而加载的</p></li><li><p>所以构造代码块是可以给对象初始化的, 貌似和构造函数一样了? </p><ul><li>其实<code>构造函数</code>是给对应的对象进行针对性的初始化, 而<code>构造代码块</code>是具备着对象初始化的通用性 ; </li><li>因为初始化的时候, 每个对象传递的值可能不同, 这样的话, 由于类中可能有构造函数的重载, 那么每个对象调用的构造函数可能就不同;<br>但是可能对象在创建的时候都需要初始化一个相同的数据值, 这样的话, 除非给重载的每个构造函数中都初始化上该数据的值, 要不然的话, 创建对象的时候可能就会因为调用的构造函数不同而导致有些进行这个数据的初始化了, 有些对象的创建又没有进行 ; </li><li>所以可以把创建对象的时候, 通用的初始化数据写到构造代码块中 ;</li></ul></li><li><p><strong>注意</strong>: 静态代码块用于给类进行初始化, 构造函数是给对象初始化, 构造代码块是给<strong>对象</strong>进行公共部分初始化</p></li></ol><h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><ol><li>重载: 发生在同一个类中, 指有多个方法的名称相同, 但是参数列表不同, 所谓参数列表不同是指如下几条<ul><li>参数的个数不同</li><li>参数的类型不同</li><li>参数的多类型顺序不同</li><li><strong>重载与方法的返回值类型无关, 与参数名称无关</strong>　　</li></ul></li><li>重写: 发生在父子类中, 方法名、参数列表必须相同, 返回值范围小于等于父类, 抛出的异常范围小于等于父类, 访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。</li></ol><h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h3 id="封装-继承-多态"><a href="#封装-继承-多态" class="headerlink" title="封装,继承,多态"></a>封装,继承,多态</h3><ol><li>封装: 是指隐藏对象的实现细节, 仅对外提供公共访问方式, 提高了代码重用性和健壮性</li><li>继承: 提高了代码的复用性, 让类与类之间产生了关系, 给第三个特征”多态”提供了前提</li><li><p><strong>多态</strong>: </p><ul><li><p>在Java中有两种形式可以实现多态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">继承基类 (基类可以是 普通类 也可以是 抽象类)</span><br><span class="line">实现接口</span><br></pre></td></tr></table></figure></li><li><p>多态具有 <strong>向上转型</strong> 与 <strong>向下转型</strong> 两种转型的概念 </p></li></ul></li></ol><h3 id="向上-下转型"><a href="#向上-下转型" class="headerlink" title="向上/下转型"></a>向上/下转型</h3><ol><li><p><strong>向上转型</strong>: 当有子类对象传递给一个父类引用时, 便是向上转型, 多态本身就是向上转型的过程 </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用格式: 父类类型 变量名 = new 子类类型(); </span><br><span class="line">如: Animal animal = new Cat();</span><br></pre></td></tr></table></figure></li><li><p>什么时候使用向上转型?</p><ul><li>在面向对象编程中, 为了提高扩展性, 你多半都是需要面向抽象(普通基类, 抽象基类 或 接口)编程, 而不是去直接面对具体类型进行编程,  </li><li>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定, 而是在程序运行期间才确定, 即一个引用变量倒底会指向哪个具体类的实例对象, 该引用变量发出的方法调用到底是哪个类中实现的方法, 必须在由程序运行期间才能决定</li></ul></li><li><p><strong>向下转型</strong>: 一个已经向上转型的子类对象可以使用强制类型转换, 将父类引用转为子类引用, 这个过程是向下转型; <strong>注意</strong>: 如果是直接创建父类对象, 是无法向下转型的!(向下转型的前提是首先进行了向上转型)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用格式: 子类类型 变量名 = (子类类型) 父类类型的变量; </span><br><span class="line">如: Animal animal = new Cat();  </span><br><span class="line">Cat cat = (Cat) animal</span><br></pre></td></tr></table></figure></li><li><p>什么时候使用向下转型 </p><ul><li>当你面向抽象编程时, 某个方法依赖的可能是抽象类型而不是具体类型, 这样的话, 在程序运行时, 具体的子类被传递进来时, 可能就需要使用向下转型来使用子类的一些方法或属性(向下转型的前提是首先进行了向上转型)</li><li>(很明显在PHP中, 这种弱类型的向下转型是隐式的, 向上转型也是自动的)</li></ul></li></ol><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ol><li>修饰变量 (表示把变量作为常量)</li><li>修饰方法: 表示方法不能被子类覆盖重写 (但是本类中依然可以重载)</li><li>修饰类: 修饰的类不能有子类, 不能被继承 (比如: Math, String)</li></ol><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h2&gt;&lt;p&gt;可以理解类为模板, 对象为实物&lt;/p&gt;
&lt;h2 id=&quot;匿名对象&quot;&gt;&lt;a href=&quot;#匿名对象&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>03. 变量, 常量 基础</title>
    <link href="http://blog.renyimin.com/2018/12/10/JAVA/2018-12-10-03/"/>
    <id>http://blog.renyimin.com/2018/12/10/JAVA/2018-12-10-03/</id>
    <published>2018-12-10T11:33:32.000Z</published>
    <updated>2018-12-22T06:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ol><li><p>在Java中, 利用关键字 <code>final</code> 指示常量, 例如:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Constants</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        final double CM_PER_INCH = 2.54;</span><br><span class="line">        double paperWidth = 8.5;</span><br><span class="line">        double paperHeight = 11;</span><br><span class="line">        System.out.println(&quot;Paper size in centimeters:&quot;</span><br><span class="line">        + paperWidth * CM_PER_INCH + &quot; by &quot; + paperHeight * CM_PER_INCH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>final 表示这个变量只能被赋值一次, 一旦被赋值后就不能再被更改了 (这可能也就是之前为什么使用final修饰的变量不会自动改变类型)</p></li><li>习惯上, 常量名使用全大写</li></ol><h2 id="类常量"><a href="#类常量" class="headerlink" title="类常量"></a>类常量</h2><ol><li>在Java中, 经常希望某个常量可以在一个类中的多个方法中使用, 通常将这些常量称为类常量;</li><li><p>可以使用关键字 <code>static final</code> 设置一个类常量, 下面是使用类常量的示例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Constants2</span><br><span class="line">&#123;</span><br><span class="line">    final static double CM_PER_INCH = 2.54;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        double paperWidth = 8.5;</span><br><span class="line">        double paperHeight = 11;</span><br><span class="line">        System.out.println(&quot;Paper size in centimeters:&quot;</span><br><span class="line">        + paperWidth * CM_PER_INCH + &quot; by &quot; + paperHeight * CM_PER_INCH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>const 是Java的保留关键字, 但是目前并未使用, 在Java中, 定义常量必须使用 <code>final</code> 关键字;</p></li></ol><h2 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h2><ol><li>形式上: 字符常量是单引号引起的一个字符, 而字符串常量是双引号引起的若干个字符</li><li>含义上: 字符常量相当于一个整形值(ASCII 值),可以参加表达式运算; 而字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小: 字符常量只占2个字节; 字符串常量占若干个字节(至少一个字符结束标志); (注意: char在Java中占两个字节)</li><li>注意: Java要确定每种基本类型所占存储空间的大小。它们的大小并不像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是Java程序比其它大多数语言编写的程序更具可移植性的原因之一。</li></ol><h2 id="局部变量和成员变量"><a href="#局部变量和成员变量" class="headerlink" title="局部变量和成员变量"></a>局部变量和成员变量</h2><ol><li><p>成员变量定义在类中, 整个类中都可以访问; 局部变量定义在函数, 局部代码块中, 只在所属的区域有效;</p></li><li><p>成员变量存在于堆内存的对象中; 局部变量存在于栈内存的方法中;</p></li><li><p>成员变量随着对象的创建而存在, 随着对象的消失而消失; 局部变量随着所属区域的执行而存在, 随着所属区域的结束而释放;</p></li><li><p>成员变量都有默认初始化值(boolean <code>false</code>, char <code>\u0000</code>(null), byte <code>(byte)0</code>, short <code>(short)0</code>, int <code>0</code>, long <code>0L</code>, float <code>0.0f</code>, double <code>0.0d</code>, String <code>null</code>); 局部变量没有默认初始化值, 使用前必须先声明和初始化; </p></li><li><p>成员变量可以被 public,private,static 等修饰符所修饰, 而局部变量不能被访问控制修饰符及 static 所修饰; 但是, 成员变量和局部变量都能被 <code>final</code> 所修饰;</p></li></ol><h2 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode 与 equals"></a>hashCode 与 equals</h2><ol><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/Java相关/Java基础知识.md#9-构造器-constructor-是否可被-override" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/Java相关/Java基础知识.md#9-构造器-constructor-是否可被-override</a></li><li></li></ol><h2 id="为什么Java中只有值传递"><a href="#为什么Java中只有值传递" class="headerlink" title="为什么Java中只有值传递"></a>为什么Java中只有值传递</h2><p>1. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常量&quot;&gt;&lt;a href=&quot;#常量&quot; class=&quot;headerlink&quot; title=&quot;常量&quot;&gt;&lt;/a&gt;常量&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在Java中, 利用关键字 &lt;code&gt;final&lt;/code&gt; 指示常量, 例如:&lt;/p&gt;
 &lt;figure class
      
    
    </summary>
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>05. 基础面向对象知识</title>
    <link href="http://blog.renyimin.com/2018/12/10/JAVA/2018-12-15-05/"/>
    <id>http://blog.renyimin.com/2018/12/10/JAVA/2018-12-15-05/</id>
    <published>2018-12-10T05:21:26.000Z</published>
    <updated>2018-12-22T06:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ol><li></li><li></li><li><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2></li></ol><h2 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h2><h2 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的"></a>在一个静态方法内调用一个非静态成员为什么是非法的</h2><h2 id="在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>在 Java 中定义一个不做事且没有参数的构造方法的作用</h2><h2 id="import-java和javax有什么区别"><a href="#import-java和javax有什么区别" class="headerlink" title="import java和javax有什么区别"></a>import java和javax有什么区别</h2><h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><ol><li>Object类是所有Java类的根基类, 如果类的声明未使用extends关键字指明其基类, 则默认基类为Object类;</li><li>位于 <code>package java.lang;</code> 内</li><li><code>__toString()</code> : <ul><li>默认返回包名 + 类名 + @ + 哈希码</li><li>可以重写</li></ul></li><li></li></ol><h2 id="继承-vs-组合"><a href="#继承-vs-组合" class="headerlink" title="继承 vs 组合"></a>继承 vs 组合</h2><ol><li>“is-a” 关系使用继承</li><li>“has-a” 关系使用组合</li><li>从代码复用角度来看, 两个设计都能实现代码复用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;h2 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>01. 认识 Spring Boot</title>
    <link href="http://blog.renyimin.com/2018/12/07/Spring%20boot/2018-12-07-01/"/>
    <id>http://blog.renyimin.com/2018/12/07/Spring boot/2018-12-07-01/</id>
    <published>2018-12-07T05:42:15.000Z</published>
    <updated>2018-12-07T05:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-简介"><a href="#Spring-简介" class="headerlink" title="Spring 简介"></a>Spring 简介</h2><ol><li>spring是一个一站式的轻量级java开发框架, 核心是控制反转(IOC)和面向切面(AOP), 针对于开发的WEB层(springMvc)、业务层(Ioc)、持久层(jdbcTemplate)等都提供了多种配置解决方案;</li></ol><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><ol><li>springMvc是spring基础之上的一个MVC框架,  主要处理web开发的路径映射和视图渲染,  属于spring框架中WEB层开发的一部分;</li><li>springMvc属于一个企业WEB开发的MVC框架, 涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等, XML、config等配置相对比较繁琐复杂;<h2 id="Spring-Boot简介"><a href="#Spring-Boot简介" class="headerlink" title="Spring Boot简介"></a>Spring Boot简介</h2></li><li>Spring 诞生时是 Java 企业版(Java Enterprise Edition,    JEE,    也称 J2EE)的</li></ol><p>轻量级代替品。无需开发重量级的 Enterprise JavaBean(EJB),    Spring 为企业级</p><p>Java 开发提供了一种相对简单的方法,    通过依赖注入和面向切面编程,    用简单的Java 对象(Plain Old Java Object,    POJO)实现了 EJB 的功能。</p><p>虽然 Spring 的组件代码是轻量级的,    但它的配置却是重量级的。</p><p>第一阶段：xml配置</p><p>在Spring 1.x时代,    使用Spring开发满眼都是xml配置的Bean,    随着项目的扩大,    我们需要把xml配置文件放到不同的配置文件里,    那时需要频繁的在开发的类和配置文件之间进行切换</p><p>第二阶段：注解配置</p><p>在Spring 2.x 时代,    随着JDK1.5带来的注解支持,    Spring提供了声明Bean的注解(例如@Component、@Service),    大大减少了配置量。主要使用的方式是应用的基本配置(如数据库配置)用xml,    业务配置用注解</p><p>第三阶段：java配置</p><p>Spring 3.0 引入了基于 Java 的配置能力,    这是一种类型安全的可重构配置方式,    可以代替 XML。我们目前刚好处于这个时代,    Spring4.x和Spring Boot都推荐使用Java配置。</p><h2 id="所有这些配置都代表了开发时的损耗。-因为在思考-Spring-特性配置和解决业务问题之间需要进行思维切换-所以写配置挤占了写应用程序逻辑的时间。除此之外-项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了-你还要知道这些库的哪个版本和其他库不会有冲突-这难题实在太棘手。并且-依赖管理也是一种损耗-添加依赖不是写应用程序代码。一旦选错了依赖的版本-随之而来的不兼容问题毫无疑问会是生产力杀手。"><a href="#所有这些配置都代表了开发时的损耗。-因为在思考-Spring-特性配置和解决业务问题之间需要进行思维切换-所以写配置挤占了写应用程序逻辑的时间。除此之外-项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了-你还要知道这些库的哪个版本和其他库不会有冲突-这难题实在太棘手。并且-依赖管理也是一种损耗-添加依赖不是写应用程序代码。一旦选错了依赖的版本-随之而来的不兼容问题毫无疑问会是生产力杀手。" class="headerlink" title="所有这些配置都代表了开发时的损耗。 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换,    所以写配置挤占了写应用程序逻辑的时间。除此之外,    项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了,    你还要知道这些库的哪个版本和其他库不会有冲突,    这难题实在太棘手。并且,    依赖管理也是一种损耗,    添加依赖不是写应用程序代码。一旦选错了依赖的版本,    随之而来的不兼容问题毫无疑问会是生产力杀手。"></a>所有这些配置都代表了开发时的损耗。 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换,    所以写配置挤占了写应用程序逻辑的时间。除此之外,    项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了,    你还要知道这些库的哪个版本和其他库不会有冲突,    这难题实在太棘手。并且,    依赖管理也是一种损耗,    添加依赖不是写应用程序代码。一旦选错了依赖的版本,    随之而来的不兼容问题毫无疑问会是生产力杀手。</h2><p>作者：cnn0314<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/m0_37106742/article/details/64438892" target="_blank" rel="noopener">https://blog.csdn.net/m0_37106742/article/details/64438892</a><br>版权声明：本文为博主原创文章,    转载请附上博文链接！</p><ol><li>Spring Boot是由Pivotal团队提供的全新框架, 其设计目的是用来简化新Spring应用的初始搭建以及开发过程; </li></ol><p><a href="https://blog.csdn.net/forezp/article/details/81040925" target="_blank" rel="noopener">https://blog.csdn.net/forezp/article/details/81040925</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-简介&quot;&gt;&lt;a href=&quot;#Spring-简介&quot; class=&quot;headerlink&quot; title=&quot;Spring 简介&quot;&gt;&lt;/a&gt;Spring 简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;spring是一个一站式的轻量级java开发框架, 核心是控制反转(IO
      
    
    </summary>
    
      <category term="Swoole" scheme="http://blog.renyimin.com/categories/Swoole/"/>
    
    
      <category term="Swoole" scheme="http://blog.renyimin.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>02. 基本数据类型 相关</title>
    <link href="http://blog.renyimin.com/2018/12/05/JAVA/2018-12-05-02/"/>
    <id>http://blog.renyimin.com/2018/12/05/JAVA/2018-12-05-02/</id>
    <published>2018-12-05T11:40:16.000Z</published>
    <updated>2018-12-22T06:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="8种基本数据类型"><a href="#8种基本数据类型" class="headerlink" title="8种基本数据类型"></a>8种基本数据类型</h2><h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><ol><li><strong>byte</strong>: Java中最小的数据类型, 在内存中占8位( bit), 即1个字节, 取值范围-128~127, 默认值 <code>0</code>    (对应包装类 <code>Byte</code>)</li><li><strong>short</strong>: 短整型在内存中占16位, 即2个字节, 取值范围-32768~32717, 默认值<code>0</code>    (对应包装类 <code>Short</code>)</li><li><strong>int</strong>: 整型, 用于存储整数, 在内在中占32位, 即4个字节, 取值范围-2147483648~2147483647, 默认值 <code>0</code>    (对应包装类 <code>Integer</code>)</li><li><strong>long</strong>: 长整型, 在内存中占64位, 即8个字节-2^63~2^63-1, 默认值 <code>0L</code>    (对应包装类 <code>Long</code>)</li><li><strong>float</strong>: 浮点型, 在内存中占32位, 即4个字节, 用于存储带小数点的数字(与double的区别在于float类型有效小数点只有6~7位), 默认值 <code>0.0</code>    (对应包装类 <code>Float</code>)</li><li><strong>double</strong>: 双精度浮点型, 用于存储带有小数点的数字, 在内存中占64位, 即8个字节, 默认值 <code>0.0</code>    (对应包装类 <code>Boolean</code>)</li></ol><h3 id="非数值类型"><a href="#非数值类型" class="headerlink" title="非数值类型"></a>非数值类型</h3><ol><li><strong>char</strong>: 字符型, 用于存储单个字符, 占16位, 即2个字节, 取值范围0~65535, 默认值为 <code>空字符</code></li><li><strong>boolean</strong>: 布尔类型, 占1个字节, 用于判断真或假(仅有两个值, 即true、false), 默认值 <code>false</code></li></ol><p><strong>注意: Java不支持无符号数据类型; byte, short, int和long都是有符号数据类型。</strong></p><h2 id="基本类型的类型转换"><a href="#基本类型的类型转换" class="headerlink" title="基本类型的类型转换"></a>基本类型的类型转换</h2><ol><li><p>首先回顾一下 Java 中的 8 种基本数据类型, 以及它们的占内存的容量大小和表示的范围, 如下图所示<br> <img src="/img/javase/type-conversion.png" width="500/"></p></li><li><p>布尔类型boolean占有一个字节, 由于其本身所代表的特殊含义, boolean类型与其他基本类型不能进行类型的转换, <strong>既不能进行自动类型的提升, 也不能强制类型转换</strong>, 否则, 将编译出错;</p></li><li><p>Java中甚至没有提供检测基本类型的方法 (typeof), 因此, <strong>使用基本类型的包装类型比较多</strong>! </p></li></ol><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><ol><li><p>自动类型转换包括:</p><ul><li>数字表示范围小的数据类型可以自动转换成范围大的数据类型</li><li>特例情况下, 数字表示范围大的数据类型也可以自动转换成范围小的数据类型</li></ul></li><li><p>数字表示范围小的数据类型可以自动转换成范围大的数据类型</p><ul><li><p>这点比较好理解, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long l = 100;   // 整型字面量数字常量赋值给 表示范围更大的long型</span><br><span class="line"></span><br><span class="line">int i = 200;</span><br><span class="line">long ll = i;</span><br></pre></td></tr></table></figure></li><li><p>注意: 范围小的数据类型自动转换成范围大的数据类型时, <strong>也可能出现数据精度丢失</strong>, 如下 int 转 float 就出现了精度丢失</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float b = 2147483646;</span><br><span class="line">System.out.println(b);  // 2.14748365E9 精度丢失</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>特例</strong>: </p><ul><li><p>也可以将数字表示范围大的整型常量字面量 直接赋给表示范围小的 byte, short, char等类型变量, <strong>而不需要强制类型转换, 只要不超出其表数范围</strong>; </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int count = 100000000;</span><br><span class="line">int price = 1999;</span><br><span class="line">long totalPrice = count * price;</span><br></pre></td></tr></table></figure><p>编译虽然没任何问题, 但结果却输出的是负数, 这是因为两个 int 相乘得到的结果是 int, 相乘的结果超出了 int 的代表范围, 这种情况, 一般把第一个数据转换成范围大的数据类型再和其他的数据进行运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int count = 100000000;</span><br><span class="line">int price = 1999;</span><br><span class="line">long totalPrice = (long) count * price; // 注意不能写成 long totalPrice = (long) (count * price); 因为 (count * price) 首先就已经超出了int的范围</span><br></pre></td></tr></table></figure></li><li><p>但是仅限于 字面量, 如果是整型变量, 则需要使用强制类型转换, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">short s1 = 1;// 整型字面量可以赋值给 short 类型</span><br><span class="line"> </span><br><span class="line">short s2 = 1;</span><br><span class="line">s2 = s2 + 1;</span><br><span class="line">// s2+1运算中的操作数s2会被自动提升为int类型</span><br><span class="line">// s2+1运算结果会成为int类型, 再赋值给short类型的s2时, 编译器会报告需要强制转换类型的错误</span><br><span class="line">// 需要改为 s2=(short)(s2+1); 结果就是short类型</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol><li>自动转换具体如下图: 实线表示自动转换时不会造成数据丢失, 虚线则可能会出现数据丢失问题<br> <img src="/img/javase/type-conversion02.png" width="450/"></li></ol><h3 id="自动类型提升-final修饰"><a href="#自动类型提升-final修饰" class="headerlink" title="自动类型提升 (final修饰)"></a>自动类型提升 (final修饰)</h3><ol><li><p>所谓类型提升就是指在多种不同数据类型的表达式中, 类型会自动向范围表示大的值的数据类型提升</p></li><li><p>类型提升规则:</p><ul><li>所有的byte,short,char型的值将被提升为int型</li><li>如果两个操作数其中有一个是double类型, 另一个操作就会转换为double类型</li><li>否则, 如果其中一个操作数是float类型, 另一个将会转换为float类型</li><li>否则, 如果其中一个操作数是long类型, 另一个会转换为long类型</li><li>否则, 两个操作数都转换为int类型</li><li>被final修饰的变量不会自动改变类型, 当2个final修饰相操作时, 结果会根据左边变量的类型而转化。</li></ul></li><li><p>测试</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byte b1=1,b2=2,b3,b6,b8;</span><br><span class="line">final byte b4=4,b5=6,b7;</span><br><span class="line">b3=(b1+b2);  // 根据上述规则, b1会转换成int, b2会转换int, 所以结果是int, 而b3是byte, 所以Type mismatch: cannot convert from int to byte</span><br><span class="line">b6=b4+b5;    // 根据上述规则, b4,b5都是final不会转换int, 所以结果是byte, b6也是byte, 所以Type mismatch: cannot convert from int to byte</span><br><span class="line">b8=(b1+b4);  // 根据上述规则, b1会转换成int, b4不会转换int, 所以结果是int, 而b8是byte , 所以Type mismatch: cannot convert from int to byte</span><br><span class="line">b7=(b2+b5);  // 根据上述规则, b2会转换成int, b5不会转换int, 所以结果是int, 而b7是byte , 所以Type mismatch: cannot convert from int to byte</span><br></pre></td></tr></table></figure></li></ol><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ol><li>一般是大容量类型转小容量类型时会用, 又称为造型, 用于显示的转换一个数值的类型, 在有可能丢失信息的情况下进行的转换时通过造型来完成, 但可能造成精度降低或溢出</li><li>强制类型转换的语法格式: <code>(type) var</code>, 运算符<code>()</code>中的type表示将值var想要转换成的目标数据类型<ul><li>当将大容量类型强制转换成小容量类型, 而又超出了目标类型的表示范围, 就会被截断成为一个完全不同的值, 例: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = 300; </span><br><span class="line">byte y = (byte)x; //值为44</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><ol><li><p>Java语言是一个面向对象的语言, 但是Java中的基本数据类型却是不面向对象的, 也就不具有对象的性质, 这在实际使用时存在很多的不便, 为了解决这个不足, 以便与其他对象”接轨”, 在设计类时为每个基本数据类型设计了一个对应的类进行代表, 这八个和基本数据类型对应的类统称为<strong>包装类(Wrapper Class)</strong>, 有些地方也翻译为外覆类或数据类型类</p><ul><li>它相当于将基本类型”包装起来”, 使得基本类型具有了对象的性质, 并且为其添加了属性和方法, 丰富了基本类型的操作</li><li>包装类均位于 java.lang 包</li><li><strong>使用集合类型Collection时, 就一定要使用包装类型而非基本类型</strong></li><li><strong>java也没有检测基本类型的方法, 但是可以用instanceof检测包装类型</strong></li></ul></li><li><p>包装类型: <strong>Integer</strong>、<strong>Long</strong>、<strong>Short</strong>、<strong>Byte</strong>、<strong>Character</strong>、<strong>Double</strong>、<strong>Float</strong>、<strong>Boolean</strong>、<strong>BigInteger</strong>、<strong>BigDecmail</strong></p><ul><li>其中 <strong>BigInteger、BigDecimal 没有相对应的基本类型</strong>, 主要应用于高精度的运算</li><li>BigInteger 支持任意精度的整数</li><li>BigDecimal 支持任意精度带小数点的运算, 主要用于金钱的计算上</li></ul></li><li><p>基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成 (JDK5的新特性)</p></li><li><p><strong>包装类型与基本类型异同</strong></p><ul><li>声明方式不同, 基本类型不使用new关键字, 而包装类型需要使用new关键字来在堆中分配存储空间</li><li>存储方式及位置不同, 基本类型是直接将变量值存储在栈中, 而包装类型是将对象放在堆中, 然后通过引用来使用</li><li>初始值不同, 基本类型的初始值如int为0, boolean为false, 而包装类型的初始值为 null</li><li>使用方式不同, 基本类型直接赋值直接使用就好, 而包装类型在集合如Collection、Map时会使用到</li></ul></li></ol><h2 id="引用类型-Array"><a href="#引用类型-Array" class="headerlink" title="引用类型 Array"></a>引用类型 Array</h2><ol><li>数组可以存放多个类型统一的数据(可以是基本类型也可以是引用类型)</li><li>数组创建的格式 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class arr &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 一个数组一旦在内存中创建了, 数组的长度就不能发生变化</span><br><span class="line">        /**</span><br><span class="line">         * 静态创建数组: 指定数组内容, 但不显示指定长度</span><br><span class="line">         * - 虽然没有指定长度,但系统会自动识别</span><br><span class="line">         * - 虽然直接指定了具体元素的内容, 但在内存中仍然有默认值被替换的过程</span><br><span class="line">         * - 静态创建数组有如下几种格式</span><br><span class="line">         */</span><br><span class="line">        // 1. 标准格式</span><br><span class="line">        int[] age1 = new int[]&#123;1,2,3,4,5&#125;;</span><br><span class="line">        // 2. 标准格式拆两步</span><br><span class="line">        int[] age2;</span><br><span class="line">        age2 = new int[]&#123;1,2,3,4,5&#125;;</span><br><span class="line">        // 3. 简便格式 (1.虽然没有new, 但内存中仍然会开辟堆空间;2.简便格式不能拆两步)</span><br><span class="line">        int[] age3 = &#123;1,2,3,4&#125;;</span><br><span class="line">        System.out.println(age3);</span><br><span class="line">        System.out.println(age3[0]);</span><br><span class="line">        System.out.println(age3[1]);</span><br><span class="line">        System.out.println(age3[2]);</span><br><span class="line">        // 如下超过数组索引范围就会报错</span><br><span class="line">        // System.out.println(age3[5]);</span><br><span class="line">        // 4. 静态创建数组的间便格式还可以如下,但推荐上一种, 因为它将类型 int[](整型数组) 与 变量名分开了</span><br><span class="line">        int a1[] = &#123;1,2,3&#125;;</span><br><span class="line">        System.out.println(a1);</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">         * 动态创建数组:显示指定数组长度, 但不指定长度</span><br><span class="line">         */</span><br><span class="line">        int[] age4 = new int[5];</span><br><span class="line">        // 拆两步格式</span><br><span class="line">        int[] age5;</span><br><span class="line">        age5 = new int[5];</span><br><span class="line">        age5[0] = 1;</span><br><span class="line">        age5[1] = 2;</span><br><span class="line">        age5[2] = 3;</span><br><span class="line">        // 如下超过数组索引范围就会报错</span><br><span class="line">        // age5[5] = 4;</span><br><span class="line">        System.out.println(age5);</span><br><span class="line">        System.out.println(age5[0]);</span><br><span class="line">        System.out.println(age5[1]);</span><br><span class="line">        System.out.println(age5[2]);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="引用类型-String"><a href="#引用类型-String" class="headerlink" title="引用类型 String"></a>引用类型 String</h2><h3 id="熟悉String类型"><a href="#熟悉String类型" class="headerlink" title="熟悉String类型"></a>熟悉String类型</h3><ol><li><p>Java没有内置的字符串类型, 而是在标准Java类库中提供了一个预定义类, 叫做String;</p></li><li><p>每个用双引号括起来的字符串都是String类的一个实例;</p></li><li><p>截取子串: String类的 <code>substring(起始位置, 结束位置)</code> (不包括结束位置)</p></li><li><p>拼接串: 和绝大多数程序设计语言一样, Java 允许使用 <code>+</code> 连接两个字符串;<br> <strong>当将一个字符串与一个非字符串的值进行拼接时, 后者会被转换成字符串(任何Java对象都可以转换成一个字符串)</strong></p></li><li><p><strong>不可变字符串</strong>: String对象一旦被创建就是固定不变的了, 对String对象的任何改变都不影响到原对象, 相关的任何change操作都会生成新的对象;</p><ul><li>String没有提供用于修改字符串的方法, 如果一个字符串s的值为 ‘Hello’, 你希望将其内容修改为 ‘Help!’, 在Java中你是不能直接将s的最后两个位置的字符修改为 ‘p’ 和 ‘!’,</li><li><p>在Java中要实现上述操作, 需要首先提取需要的字符, 然后再批接上要替换的字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;Hello&quot;;</span><br><span class="line">String s2 = &quot;Hello&quot;;</span><br><span class="line">// 一开始两个String的引用是一样的, 都是Hello这个字符串对象的引用</span><br><span class="line">System.out.println(System.identityHashCode(s1));// 992136656</span><br><span class="line">System.out.println(System.identityHashCode(s2));// 992136656</span><br><span class="line">System.out.println(System.identityHashCode(&quot;Hello&quot;));// 992136656</span><br><span class="line"></span><br><span class="line">// 字符串经过拼接整理后, 其实就是另一个新的字符串对象了</span><br><span class="line">s1 = s1.substring(0, 3) + &quot;p!&quot;;</span><br><span class="line">System.out.println(s1);// Help!</span><br><span class="line">System.out.println(s2);// Hello</span><br><span class="line">System.out.println(System.identityHashCode(s1));// 511833308</span><br></pre></td></tr></table></figure></li><li><p>Java虽然不能修改一个字符串中的字符, 但是可以修改字符串变量, 让它<strong>引用另外一个字符串</strong>; (如上述例子, 其实s指向了一个新的字符串引用) </p></li></ul></li></ol><h3 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h3><ol><li>虽然看起来修改一个代码单元要比创建一个新字符串更加简洁, 但不可变字符串有一个优点: 编译器可以让字符串共享;</li><li>JVM为了提升性能和减少内存开销, 避免字符串的重复创建, 维护了一块特殊的内存空间, 即字符串池(String Pool)</li></ol><h3 id="检测字符串是否相等"><a href="#检测字符串是否相等" class="headerlink" title="检测字符串是否相等"></a>检测字符串是否相等</h3><ol><li><p>注意: Java中, 你一定不能使用 <code>==</code> 来检测两个字符串是否相等, 这个运算符只能确定两个字符串是否在同一个位置上, 即只能判断两个字符串的引用是否相同; 而Java中完全有可能将两个内容相等的字符串放在不同的位置上;</p></li><li><p>如果虚拟机始终将相同的字符串共享, 就可以使用 <code>==</code> 运算符检测两个字符串是否相等, 但实际上只有字符串常量是共享的, 而 <code>+</code>, <code>substring</code> 等操作产生的结果并不是共享的;<br> 因此千万不要使用 <code>==</code> 检测字符串的相等行, 以免在程序中出现糟糕的bug, 而且从表面上看, 这种bug很像随机产生的间歇性错误;</p></li><li><p>在Java中可以使用 <code>s.equals(t)</code> 方法来检测两个字符串是否相等 (相等返回true, 不相等则返回false, s与t可以是字符串常量,也可以是字符串变量)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s12 = &quot;你好!&quot;;</span><br><span class="line">String s1 = &quot;你&quot;;</span><br><span class="line">String s2 = &quot;好!&quot;;</span><br><span class="line">String s1_s2 = s1 + s2;</span><br><span class="line">System.out.println(s12);//你好!</span><br><span class="line">// System.identityHashCode可以获取对象的内存地址</span><br><span class="line">System.out.println(System.identityHashCode(s12));//511833308</span><br><span class="line">System.out.println(s1_s2);//你好!</span><br><span class="line">System.out.println(System.identityHashCode(s1_s2)); //1297685781</span><br><span class="line">System.out.println(s12 == s1_s2);//false</span><br><span class="line">System.out.println(s12.equals(s1_s2));//true</span><br></pre></td></tr></table></figure></li><li><p>如果检测两个字符串是否相等而不区分大小写, 可以使用 equalsIgnoreCase 方法: <code>&quot;Hello&quot;.equalsIgnoreCase(&quot;Hello&quot;)</code></p></li></ol><h2 id="main-主函数"><a href="#main-主函数" class="headerlink" title="main 主函数"></a>main 主函数</h2><ol><li><p>格式是固定的, 被jvm所识别和调用</p><ul><li><code>public</code> : 因为权限必须是最大的;</li><li><code>static</code>: 不需要对象的, 直接用主函数所属类名调用即可;</li><li><code>void</code>: 主函数没有具体的返回值; </li><li><code>main</code>: 函数名, 不是关键字, 只是jvm识别的固定的名字;</li><li><code>String[] args</code>: 这是主函数的参数列表, 是一个数组类型的参数, 而且元素都是字符串类型;</li></ul></li><li><p>虚拟机在运行的时候, 可以给主函数传值, 只不过一般情况下不传</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;8种基本数据类型&quot;&gt;&lt;a href=&quot;#8种基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;8种基本数据类型&quot;&gt;&lt;/a&gt;8种基本数据类型&lt;/h2&gt;&lt;h3 id=&quot;数值型&quot;&gt;&lt;a href=&quot;#数值型&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>01. 基础入门</title>
    <link href="http://blog.renyimin.com/2018/12/02/JAVA/2018-12-02-01/"/>
    <id>http://blog.renyimin.com/2018/12/02/JAVA/2018-12-02-01/</id>
    <published>2018-12-02T00:52:28.000Z</published>
    <updated>2018-12-22T06:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三大体系"><a href="#三大体系" class="headerlink" title="三大体系"></a>三大体系</h2><ol><li><p><strong>JAVASE(J2SE)</strong>: 标准版(Standard Edition), 开发个人计算机上的应用 (基础)  (Java5.0版本后, 进行了更名, J2SE-&gt;JAVASE)</p></li><li><p><strong>JAVAEE(J2EE)</strong>: 企业版(Enterprise Edition), Java EE是在JavaSE的基础上构建的, 提供Web服务、组建模型、管理和通信API, 主要针对企业应用的开发(例如, 电子商务网站、ERP系统), 这也是我们主要面对的版本</p></li><li><p><strong>JAVAME(J2ME)</strong>: 微缩版, (例如, 蜂窝电话和可视电话、数字机顶盒、汽车导航系统等等)</p></li></ol><h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><ol><li><p>Java语言的一个非常重要的特点就是与平台的无关性, Java是通过在JVM中运行Java程序实现跨平台特性的, Java语言使用JVM屏蔽了与具体平台相关的信息, 使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码 (.class字节码文件), 就可以在多种平台上不加修改地运行, <strong>Java虚拟机在执行字节码时,把字节码解释成具体平台上的机器指令执行</strong>。</p></li><li><p><strong>注意</strong>: JVM 并是不跨平台的, 所以我们需要根据具体的平台安装不同版本的JVM虚拟机(下载不同版本的JDK即可)<br> <img src="/img/javase/jvm01.png" width="400/"></p></li></ol><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><ol><li><p>Java程序的运行必须经过 <strong>编写</strong>, <strong>编译</strong>, <strong>运行</strong>三个步骤</p><ul><li>Java文件编写完之后, 要以 <code>.java</code> 为文件名后缀, 这样得到的就是Java的源代码/源程序, Java的源程序文件操作系统是不能识别的;</li><li>Java源代码需要被编译成Java虚拟机能识别的 <code>.class字节码文件</code><br>此过程需要使用JDK里面的 <code>javac.exe编译器工具</code> 对Java源文件进行编译 </li><li>然后由JVM把javac.exe编译好的.class字节码解释成机器码后运行<br>通过 <code>Java.exe命令</code> 开始启动JVM对编译后的.class类文件进行解释, 不用写.class后缀, 写上类名即文件名即可</li></ul></li><li><p><strong>字节码文件</strong> 是一种和任何具体机器环境及操作系统环境无关的中间代码, 它是一种二进制文件, 是Java源文件由Java编译器编译后生成的目标代码文件<br> 编程人员和计算机都无法直接读懂字节码文件, 它必须由专用的Java解释器来解释执行, 因此Java是一种在编译基础上进行解释运行的语言</p></li><li><p><strong>Java解释器</strong> 负责将字节码文件翻译成具体硬件环境和操作系统平台下的机器代码, 以便执行 (Java程序不能直接运行在现有的操作系统平台上, 它必须在被称为Java虚拟机的软件平台之上解释后才能在操作系统上运行)</p></li><li><p><strong>Java虚拟机(JVM)</strong> 是运行Java程序的软件环境, <strong>Java解释器</strong>就是JVM的一部分: 在运行Java程序时, 首先会启动JVM, 然后由它来负责解释执行Java的字节码(Java字节码只能运行于JVM之上), 利用JVM就可以把Java字节码程序和具体的硬件平台以及操作系统环境分隔开来</p></li></ol><h2 id="采用字节码的好处"><a href="#采用字节码的好处" class="headerlink" title="采用字节码的好处"></a>采用字节码的好处</h2><p>Java 语言通过字节码的方式, 在一定程度上解决了传统解释型语言执行效率低的问题, 同时又保留了解释型语言可移植的特点<br>所以 Java 程序运行时比较高效, 而且由于字节码并不专对一种特定的机器, 因此, Java程序无须重新编译便可在多种不同的计算机上运行</p><h2 id="JVM-JRE-JDK的区别"><a href="#JVM-JRE-JDK的区别" class="headerlink" title="JVM,JRE,JDK的区别"></a>JVM,JRE,JDK的区别</h2><ol><li>JVM(Java Virtual Machine Java): JVM 负责将字节码转换为特定机器代码, 提供了内存管理/垃圾回收和安全机制等, 是实现跨平台的核心</li><li>JRE(Java Runtime Envrionment): 普通用户而只需要安装 JRE(Java Runtime Environment)来运行 Java 程序 (JRE中会包含JVM), 而程序开发者必须安装JDK来编译、调试程序</li><li>JDK (Java Development kit): 顾名思义它是给开发者提供的开发工具箱, 是给程序开发者用的, 它除了包括完整的 JRE(Java运行环境), 还包含了其他供开发者使用的工具包, 作为开发者, 我们要下的就是JDK<br> <img src="/img/javase/jvm-jre-jdk.png" width="400/"></li></ol><h2 id="两个基础命令"><a href="#两个基础命令" class="headerlink" title="两个基础命令"></a>两个基础命令</h2><ol><li><p><strong>javac.exe</strong> 命令是个编译器, 这个命令是用来把.java的源代码编译成.class这个中间字节码文件的; javac.exe这个编译器是在JDK中才有的; </p></li><li><p>JRE中的 <strong>java.exe</strong> 命令用来调用JVM去解析经过javac.exe编译后的.class字节码文件的;</p></li><li><p>JRE在运行.class文件的时候是利用JRE中包含的JVM来解析.class文件的, JRE只是个运行环境, 它不需要把.java源文件编译成.class字节码文件, 所以不需要有javac.exe; </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;三大体系&quot;&gt;&lt;a href=&quot;#三大体系&quot; class=&quot;headerlink&quot; title=&quot;三大体系&quot;&gt;&lt;/a&gt;三大体系&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;JAVASE(J2SE)&lt;/strong&gt;: 标准版(Standard Edition),
      
    
    </summary>
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="http://blog.renyimin.com/tags/JAVASE/"/>
    
  </entry>
  
</feed>
