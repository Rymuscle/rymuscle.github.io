<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lant&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.renyimin.com/"/>
  <updated>2017-10-24T10:47:50.000Z</updated>
  <id>http://blog.renyimin.com/</id>
  
  <author>
    <name>Lant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Restful API 安全性相关知识 (持续完善中...)</title>
    <link href="http://blog.renyimin.com/2016/07/19/restful--01--%E5%AE%89%E5%85%A8/"/>
    <id>http://blog.renyimin.com/2016/07/19/restful--01--安全/</id>
    <published>2016-07-19T04:21:08.000Z</published>
    <updated>2017-10-24T10:47:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>曾经在公司做过一个简单的 <code>前后端分离</code> 小项目, 由于项目整体业务比较简单, 所以也让我有时间重新对restful api的接口安全行知识进行了简单地梳理;<br>当然, 文章会随着以后的积累不断进行调整和优化, 也希望大家能够多提出一些宝贵的意见一起进行交流 ;</p><h2 id="Restful-API-–-接口安全性-整套方案可以参考微信公众平台"><a href="#Restful-API-–-接口安全性-整套方案可以参考微信公众平台" class="headerlink" title="Restful API – 接口安全性(整套方案可以参考微信公众平台)"></a>Restful API – 接口安全性(整套方案可以参考微信公众平台)</h2><p>1.Restful API的安全性包括的内容其实比较多, 目前我所了解的主要有:<br><code>客户端的身份认证</code> : 判断请求来源是否合法;<br><code>敏感数据的加密, 防篡改</code> : HTTPS, 数据加密, 签名;<br><code>replay的防范</code> : 防止重放攻击, 在冗余重放时间(服务器间时间误差)内结合nonce参数来保证;<br><code>api请求速率限制</code> : 为防止恶意调用(例如，限制每个用户的API的使用是在?秒内最多?次的API调用，当然速率要调整好)。</p><h2 id="微信公众平台上有很多涉及到接口交互安全性的地方可供参考-同时可参考微信开放平台PHP对接的demo文件"><a href="#微信公众平台上有很多涉及到接口交互安全性的地方可供参考-同时可参考微信开放平台PHP对接的demo文件" class="headerlink" title="微信公众平台上有很多涉及到接口交互安全性的地方可供参考 (同时可参考微信开放平台PHP对接的demo文件):"></a>微信公众平台上有很多涉及到接口交互安全性的地方可供参考 (同时可参考微信开放平台PHP对接的demo文件):</h2><p>1.微信公众平台配置服务器时设置的 <code>url</code>, <code>token</code> 以及生成 <code>EncodingAESKey</code> 是为了让你确保你的公众平台服务器能够安全地 <code>接收</code> 来自微信服务器的请求，当然, <a href="http://blog.csdn.net/zhutulang/article/details/50614042" target="_blank" rel="external">你也可以选择不进行校验</a>, 不过对于你的服务器来说当然就是比较危险的, 因为一旦你的接口地址泄露, 就有可能被恶意调用;</p><ul><li>开发者的服务器通过调用微信服务器上的基础接口, 对外提供了很多可能包含用户资料的接口, 这样就要防止外部恶意窃取和调用;</li></ul><p>2.而开发者服务器可以通过微信公众平台的 <code>AppID</code> 和 <code>AppSecret</code> 获取 <code>access_token</code>(全局access_token, 微信有还有一个授权access_token), 这个是 <code>微信服务器</code> 授予 <code>开发者服务器</code> 的token, 为了限制有这个令牌的服务器才被授权可以调用微信服务器的接口; </p><ul><li><p><a href="http://blog.renyimin.com/2016/03/24/OAuth-07/">属于OAuth的 Client Credentials Grant 授权方案(客户端以自己的名义, 而不是以用户的名义, 向”服务提供商”进行认证)</a>, 获取access_token的接口如下:<br><code>https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</code></p></li><li><p>如果你们公司有 <code>数据中心</code>, <code>支付中心</code>, <code>用户中心</code> 等比较核心的服务来为公司的各个系统提供接口支持, 那你可能就需要有一个后台 <code>授权服务系统</code>, 专门管理这些服务中心的接口对内部系统的授权, 可以为每个系统生成 <code>APPID</code>, <code>APP_SECRET</code><br>然后各系统使用 <code>APPID</code>, <code>APP_SECRET</code> 到 <code>授权服务系统</code> 申请access_token,然后使用access_token来决定是否能调用本服务中的接口;</p></li></ul><p>3.OAuth网页授权 (授权码模式, 客户端是以用户的名义 向”服务提供商”进行认证)</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h2><ul><li>为什么开发者服务器调用微信服务器接口的时候, 不采用上一种方式呢?<br>其接口本身就是开放出来供客户端服务器使用的, 都是基础的功能性的接口, 一般是由能提供access_token的开发者服务器调用;<br>不用对参数做过多校验, 只要开发者服务器被授权就可以调用;</li></ul><ul><li>微信公众平台并没有通过APPID和APPSECRET来对客户端(我们自己的开发者服务器)进行校验, 而是通过 <code>Token</code> 来识别调用我们的开发者服务器的, 这个token是自主设置，与公众平台wiki中常提的access_token不是一回事, 这个token只用于验证开发者服务器;</li><li>另外, 微信公众平台使用了APPID来对传输的内容进行加密;</li><li><a href="http://www.cnblogs.com/technology/p/wenxin_security.html" target="_blank" rel="external">注意</a>: 服务器url和token为了保证在泄露之后不被别人利用, 我们还需要对ToUserName进行校验, 验证ToUserName是否和你的公众号匹配, 否则你的公众平台服务器上的功能有可能被他人使用;)</li><li>微信的签名是使用 <code>SHA1</code> 生成的(<a href="">参考 密码相关</a>);</li></ul><p>3.</p><p><a href="https://segmentfault.com/q/1010000011674185?_ea=2728292" target="_blank" rel="external">https://segmentfault.com/q/1010000011674185?_ea=2728292</a></p><h2 id="客户端身份认证"><a href="#客户端身份认证" class="headerlink" title="客户端身份认证"></a>客户端身份认证</h2><ol><li><code>HTTP Basic</code><br><code>HTTP Digest</code><br><code>API KEY</code><br><code>Oauth</code><br><code>JWT</code></li></ol><p>下面就简单聊聊这些认证方式:</p><h3 id="HTTP-Basic"><a href="#HTTP-Basic" class="headerlink" title="HTTP Basic"></a>HTTP Basic</h3><p>可以网上自行搜索, 基本上不会采用, 因为安全性比较低;</p><h3 id="HTTP-Digest"><a href="#HTTP-Digest" class="headerlink" title="HTTP Digest"></a>HTTP Digest</h3><p>想了解可以网上自行搜索, 以后可能会进行补充, 暂时未做学习;</p><h3 id="API-KEY"><a href="#API-KEY" class="headerlink" title="API KEY"></a>API KEY</h3><h3 id="OAUTH2"><a href="#OAUTH2" class="headerlink" title="OAUTH2"></a>OAUTH2</h3><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>openid可以主要参考微信公众平台的: <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432" target="_blank" rel="external">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432</a></p><p>重点: <a href="http://blog.csdn.net/degwei/article/details/51489391" target="_blank" rel="external">http://blog.csdn.net/degwei/article/details/51489391</a><br><a href="http://wiki.connect.qq.com/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_server-side" target="_blank" rel="external">http://wiki.connect.qq.com/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_server-side</a><br><a href="http://wiki.open.qq.com/wiki/website/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7OpenID_OAuth2.0" target="_blank" rel="external">http://wiki.open.qq.com/wiki/website/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7OpenID_OAuth2.0</a><br>参考: <a href="http://www.searchsoa.com.cn/showcontent_75305.htm" target="_blank" rel="external">http://www.searchsoa.com.cn/showcontent_75305.htm</a></p><p>WSSE(WS-Security)<br>参考文档 : <a href="https://www.ibm.com/developerworks/cn/webservices/ws-secure/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/webservices/ws-secure/</a></p><p><a href="http://php-di.org/" target="_blank" rel="external">http://php-di.org/</a></p><p>UnionID<br>AppName<br>AppID<br>AppSecret(AppKey)<br>    当应用通过OpenAPI调用腾讯开放平台资源时需要的加密串，用来验证应用的合法性。AppKey在创建应用时分配<br>OpenID<br>    OpenID是与APP通信的用户key，跳转到应用首页后，URL后会带该参数。根据APPID以及QQ号码生成，不同的appid下同一个QQ号生成的OpenID是不一样的（目前不接受同一个开发者名下的不同应用之间对于同一个用户的OpenID的互通）。<br>    OpenID在每个应用中都是唯一，作为用户的唯一标识，访问OpenAPI时必需传入OpenID。 </p><p>qq开放平台的专业术语解释:<br><a href="http://wiki.open.qq.com/wiki/%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD#1.3_AppKey" target="_blank" rel="external">http://wiki.open.qq.com/wiki/%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD#1.3_AppKey</a></p><blockquote><blockquote><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">参考 阮一峰</a></p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;曾经在公司做过一个简单的 &lt;code&gt;前后端分离&lt;/code&gt; 小项目, 由于项目整体业务比较简单, 所以也让我有时间重新对restful 
      
    
    </summary>
    
      <category term="Restful" scheme="http://blog.renyimin.com/categories/Restful/"/>
    
    
      <category term="Restful" scheme="http://blog.renyimin.com/tags/Restful/"/>
    
  </entry>
  
  <entry>
    <title>API Gateway</title>
    <link href="http://blog.renyimin.com/2016/06/17/restful--02--/"/>
    <id>http://blog.renyimin.com/2016/06/17/restful--02--/</id>
    <published>2016-06-17T12:21:08.000Z</published>
    <updated>2017-10-17T07:34:55.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Restful" scheme="http://blog.renyimin.com/categories/Restful/"/>
    
    
      <category term="Restful" scheme="http://blog.renyimin.com/tags/Restful/"/>
    
  </entry>
  
  <entry>
    <title>API Gateway</title>
    <link href="http://blog.renyimin.com/2016/06/17/restful--01--api%20gateway/"/>
    <id>http://blog.renyimin.com/2016/06/17/restful--01--api gateway/</id>
    <published>2016-06-17T12:21:08.000Z</published>
    <updated>2017-10-17T07:37:03.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Restful" scheme="http://blog.renyimin.com/categories/Restful/"/>
    
      <category term="API Gateway" scheme="http://blog.renyimin.com/categories/Restful/API-Gateway/"/>
    
    
      <category term="API Gateway" scheme="http://blog.renyimin.com/tags/API-Gateway/"/>
    
      <category term="Restful" scheme="http://blog.renyimin.com/tags/Restful/"/>
    
  </entry>
  
  <entry>
    <title>Encrypt Decrypt</title>
    <link href="http://blog.renyimin.com/2016/05/30/Encrypt%20and%20Decrypt/"/>
    <id>http://blog.renyimin.com/2016/05/30/Encrypt and Decrypt/</id>
    <published>2016-05-30T07:37:39.000Z</published>
    <updated>2017-10-24T04:51:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见的加密算法可以分成三类"><a href="#常见的加密算法可以分成三类" class="headerlink" title="常见的加密算法可以分成三类"></a>常见的加密算法可以分成三类</h1><p><code>对称加密算法</code><br><code>非对称加密算法</code><br><code>Hash算法</code></p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>指加密和解密使用相同密钥的加密算法;<br>对称加密算法的优点在于加解密的高速度和使用长密钥时的难破解性;<br>假设两个用户需要使用对称加密方法加密然后交换数据, 则用户最少需要2个密钥并交换使用, 如果企业内用户有n个, 则整个企业共需要n×(n-1)个密钥, 密钥的生成和分发将成为企业信息部门的恶梦;<br>对称加密算法的安全性取决于加密密钥的保存情况, 但要求企业中每一个持有密钥的人都保守秘密是不可能的, 他们通常会有意无意的把密钥泄漏出去——如果一个用户使用的密钥被入侵者所获得, 入侵者便可以读取该用户密钥加密的所有文档, 如果整个企业共用一个加密密钥, 那整个企业文档的保密性便无从谈起;</p><p>常见的对称加密算法: DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES ;</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>指加密和解密使用不同密钥的加密算法，也称为公私钥加密;<br>假设两个用户要加密交换数据, 双方交换公钥, 使用时一方用对方的公钥加密, 另一方即可用自己的私钥解密;<br>如果企业中有n个用户，企业需要生成n对密钥，并分发n个公钥。由于公钥是可以公开的，用户只要保管好自己的私钥即可，因此加密密钥的分发将变得十分简单。同时，由于每个用户的私钥是唯一的，其他用户除了可以可以通过信息发送者的公钥来验证信息的来源是否真实，还可以确保发送者无法否认曾发送过该信息。<br>非对称加密的缺点是加解密速度要远远慢于对称加密, 在某些极端情况下，甚至能比非对称加密慢上1000倍 ;</p><p>常见的非对称加密算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）</p><h2 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h2><p>Hash算法特别的地方在于它是一种单向算法, 用户可以通过Hash算法对目标信息生成一段特定长度的唯一的Hash值，却不能通过这个Hash值重新获得目标信息。因此Hash算法常用在<code>不可还原的密码存储</code>、<code>信息完整性校验</code>等。<br>常见的Hash算法: MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常见的加密算法可以分成三类&quot;&gt;&lt;a href=&quot;#常见的加密算法可以分成三类&quot; class=&quot;headerlink&quot; title=&quot;常见的加密算法可以分成三类&quot;&gt;&lt;/a&gt;常见的加密算法可以分成三类&lt;/h1&gt;&lt;p&gt;&lt;code&gt;对称加密算法&lt;/code&gt;&lt;br&gt;&lt;co
      
    
    </summary>
    
      <category term="密码" scheme="http://blog.renyimin.com/categories/%E5%AF%86%E7%A0%81/"/>
    
    
      <category term="密码" scheme="http://blog.renyimin.com/tags/%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Laravel-install-01</title>
    <link href="http://blog.renyimin.com/2016/04/15/Laravel-install-01/"/>
    <id>http://blog.renyimin.com/2016/04/15/Laravel-install-01/</id>
    <published>2016-04-15T08:34:13.000Z</published>
    <updated>2017-09-19T04:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="通过Composer下载安装"><a href="#通过Composer下载安装" class="headerlink" title="通过Composer下载安装"></a>通过Composer下载安装</h4><p>可以在终端中通过Composer的==create-project==命令来创建一个新的Laravel项目:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">composer create-project laravel/laravel [项目目录名] [项目版本号] --prefer-dist</div><div class="line"></div><div class="line">如果不写laravel下载下来后放置项目的目录名, 则默认为laravel;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">比如要下载Laravel的LTS版本(目前是Laravel5.1), 操作如下:</div><div class="line"></div><div class="line">composer create-project laravel/laravel vip 5.1.33 --prefer-dist</div><div class="line"></div><div class="line">或者</div><div class="line"></div><div class="line">composer create-project laravel/laravel vip 5.1.* --prefer-dist</div></pre></td></tr></table></figure><h4 id="应用Key的设置"><a href="#应用Key的设置" class="headerlink" title="应用Key的设置"></a>应用Key的设置</h4><p>如果你是通过Composer或者Laravel安装器安装的话, 该key的值已经通过key:generate命令生成好了;</p><p>(通常, 该字符串应该是32位长, 该key被配置在.env环境文件中(APP_KEY), 如果你还没有将.env.example文件重命名为.env, 现在立即这样做;如果应用key没有被设置, 用户sessions和其它加密数据将会有安全隐患!)</p><p>如果你不是通过composer安装的laravel, 生成key的方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">先创建一个.env文件</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">然后生成应用key:</div><div class="line"></div><div class="line">bogon:laravel renyimin$ php artisan key:generate</div><div class="line">Application key [7a7rsPOdMubimWYQRddpxEiTRuoQMScE] set successfully.</div><div class="line">bogon:laravel renyimin$</div></pre></td></tr></table></figure><p>你如果是使用Composer安装的话, 可以看到:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-06c8fbb330d8f53f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-740d1978831266b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><h4 id="nginx的设置"><a href="#nginx的设置" class="headerlink" title="nginx的设置:"></a>nginx的设置:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$uri $uri/ /index.php?$query_string</div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-2045d4084f87333c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">项目根目录配置到: 项目目录的 public 目录下;</div></pre></td></tr></table></figure><h4 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功:"></a>安装成功:</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/2130662-1d49b5e644607509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;通过Composer下载安装&quot;&gt;&lt;a href=&quot;#通过Composer下载安装&quot; class=&quot;headerlink&quot; title=&quot;通过Composer下载安装&quot;&gt;&lt;/a&gt;通过Composer下载安装&lt;/h4&gt;&lt;p&gt;可以在终端中通过Composer的==cre
      
    
    </summary>
    
      <category term="PHP框架" scheme="http://blog.renyimin.com/categories/PHP%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Laravel" scheme="http://blog.renyimin.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>07 - Client Credentials Grant.</title>
    <link href="http://blog.renyimin.com/2016/03/24/OAuth-07/"/>
    <id>http://blog.renyimin.com/2016/03/24/OAuth-07/</id>
    <published>2016-03-24T13:07:01.000Z</published>
    <updated>2017-10-25T02:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="客户端模式（Client-Credentials-Grant）"><a href="#客户端模式（Client-Credentials-Grant）" class="headerlink" title="客户端模式（Client Credentials Grant）"></a>客户端模式（Client Credentials Grant）</h2><ul><li>也叫客户端证书授权类型的开放式授权<br>1.指客户端以自己的名义, 而不是以用户的名义, 向”服务提供商”进行认证;</li></ul><p>2.严格地说, 客户端模式并不属于OAuth框架所要解决的问题;</p><p>3.<br>在这种模式中, 用户直接向客户端注册, 客户端以自己的名义要求”服务提供商”提供服务, 其实不存在授权问题;</p><h2 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h2><p>1.客户端向认证服务器进行身份认证, 并要求一个访问令牌 ;<br>2.认证服务器确认无误后, 向客户端提供访问令牌 ;</p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">参考 阮一峰</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;客户端模式（Client-Credentials-Grant）&quot;&gt;&lt;a href=&quot;#客户端模式（Client-Credentials-Grant）&quot; class=&quot;headerlink&quot; title=&quot;客户端模式（Client Credentials Grant
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>06 - Password Credentials Grant</title>
    <link href="http://blog.renyimin.com/2016/03/23/OAuth-06/"/>
    <id>http://blog.renyimin.com/2016/03/23/OAuth-06/</id>
    <published>2016-03-23T04:45:07.000Z</published>
    <updated>2017-10-19T09:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="密码模式-Resource-Owner-Password-Credentials-Grant"><a href="#密码模式-Resource-Owner-Password-Credentials-Grant" class="headerlink" title="密码模式(Resource Owner Password Credentials Grant)"></a>密码模式(Resource Owner Password Credentials Grant)</h2><p>用户向客户端提供自己的用户名和密码,客户端使用这些信息, 向”服务商提供商”索要授权;</p><p>在这种模式中, 用户必须把自己的密码给客户端, 但是客户端不得储存密码 ;</p><p>这通常用在用户对客户端高度信任的情况下, 比如客户端是操作系统的一部分, 或者由一个著名公司出品; </p><p>而认证服务器只有在其他授权模式无法执行的情况下, 才能考虑使用这种模式;</p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">参考 阮一峰</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;密码模式-Resource-Owner-Password-Credentials-Grant&quot;&gt;&lt;a href=&quot;#密码模式-Resource-Owner-Password-Credentials-Grant&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>05 - OAuth-implicit-grant</title>
    <link href="http://blog.renyimin.com/2016/03/22/OAuth-05/"/>
    <id>http://blog.renyimin.com/2016/03/22/OAuth-05/</id>
    <published>2016-03-22T12:11:19.000Z</published>
    <updated>2017-10-19T09:45:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简化模式-隐式授权-implicit-grant-type"><a href="#简化模式-隐式授权-implicit-grant-type" class="headerlink" title="简化模式/隐式授权(implicit grant type)"></a>简化模式/隐式授权(implicit grant type)</h2><p>不通过第三方应用程序的服务器, 直接在浏览器中向认证服务器申请令牌, 跳过了”授权码”这个步骤, 因此得名; 所有步骤在浏览器中完成, 令牌对访问者是可见的, 且客户端不需要认证;</p><h2 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h2><p>1.客户端将用户导向认证服务器 ;</p><p>2.用户决定是否给于客户端授权 ;</p><p>3.假设用户给予授权, 认证服务器将用户导向客户端指定的”重定向URI”, 并在URI的Hash部分包含了访问令牌 ;</p><p>4.浏览器向资源服务器发出请求, 其中不包括上一步收到的Hash值 ;</p><p>5.资源服务器返回一个网页, 其中包含的代码可以获取Hash值中的令牌 ;</p><p>6.浏览器执行上一步获得的脚本, 提取出令牌 ;</p><p>7.浏览器将令牌发给客户端 ;</p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">参考 阮一峰</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简化模式-隐式授权-implicit-grant-type&quot;&gt;&lt;a href=&quot;#简化模式-隐式授权-implicit-grant-type&quot; class=&quot;headerlink&quot; title=&quot;简化模式/隐式授权(implicit grant type)&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>04 - 授权码模式各阶段分析 (持续完善中...)</title>
    <link href="http://blog.renyimin.com/2016/03/22/OAuth-04/"/>
    <id>http://blog.renyimin.com/2016/03/22/OAuth-04/</id>
    <published>2016-03-22T11:11:10.000Z</published>
    <updated>2017-10-24T10:00:33.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一阶段-第三方站点将导向授权页"><a href="#第一阶段-第三方站点将导向授权页" class="headerlink" title="第一阶段: 第三方站点将导向授权页"></a>第一阶段: 第三方站点将导向授权页</h4><ol><li><p>第三方应用将用户导向授权页时, 传递的参数如下:</p><ul><li><code>response_type</code>: 表示授权类型, 必选项, 此处由于采用的是授权码模式, 所以值固定为 “code”</li><li><p><code>client_id/AppID</code>: 表示客户端的ID, 必选项<br>由于你可能会有多个站点需要对接OAuth授权服务器, 所以一般在授权服务平台登录之后, 是可以创建多个 <code>应用</code> 的 (不同的站点对接授权服务器中不同的<code>应用</code>);<br>每个<code>应用</code>对应你的一个 <code>第三方站点</code>, 开放平台会为每个<code>应用(第三方站点)</code>生成相应的 <code>AppID</code> 和 <code>AppSecret/AppKey</code>, 主要用来验证应用的合法性;</p></li><li><p><code>redirect_uri</code>: 设定的重定向到<code>第三方站点URI</code>, 必选项</p></li><li><code>scope</code>: 表示申请的权限范围, 可选项</li><li><code>state</code>: 表示客户端的当前状态, 可以指定任意值, 认证服务器会原封不动地返回这个值</li></ul></li><li><p>下面是各开放平台的参数对比:</p><ul><li><p><a href="http://open.weibo.com/wiki/Oauth2/authorize" target="_blank" rel="external">新浪</a><br><img src="/img/oauth/oauth_sina.png" width="500" height="560" alt="sina" align="center"></p></li><li><p><a href="http://wiki.connect.qq.com/%E4%BD%BF%E7%94%A8authorization_code%E8%8E%B7%E5%8F%96access_token" target="_blank" rel="external">QQ</a><br><img src="/img/oauth/oauth_qq.png" width="500" height="560" alt="qq" align="center"></p></li><li><p><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信</a><br><img src="/img/oauth/oauth_wechat.png" width="500" height="560" alt="wechat" align="center"></p></li><li><p><a href="https://developer.github.com/apps/building-integrations/setting-up-and-registering-oauth-apps/about-authorization-options-for-oauth-apps/" target="_blank" rel="external">GitHub</a><br><img src="/img/oauth/oauth_github.png" width="500" height="560" alt="github" align="center"></p></li><li><p><a href="https://doc.open.alipay.com/docs/doc.htm?treeId=193&amp;articleId=105656&amp;docType=1#s5" target="_blank" rel="external">蚂蚁金服</a><br><img src="/img/oauth/oauth_alipay.png" width="500" alt="github" align="center"></p></li></ul></li><li><p>简单测试:</p><ul><li><p>redirect_uri<br>在OAuth服务器中为第三方站点创建 <code>应用</code> 的时候, 设定的回调地址, 无论在认证服务器, 还是在第三方站点, 都会对其进行校验, <code>以防篡改</code>;</p><p>新浪授权传递错误 redirect_uri<br><img src="/img/oauth/jianshu_sina_err01.png" width="450" height="240" alt="github" align="center"></p><p>简书qq授权传递错误 redirect_uri<br><img src="/img/oauth/jianshu_qq_err01.png" width="450" height="200" alt="github" align="center"></p></li><li><p>state<br>第三方站点会对state做校验<br>给了一个新的弹框用来进行授权, 但是如果恶意用户复制出弹框中的url, 之后再修改state并刷新页面, 授权后发现:<br><img src="/img/oauth/zhihu_auth_qq_01.png" width="500" height="100" alt="github" align="center"></p></li></ul></li><li><p>从上面各平台也可以看到, 返回参数相对比较简单;</p><ul><li>返回的code是和授权页登录的用户身份相关的; (后面的access_token也是通过code和用户身份关联起来的)</li></ul></li></ol><h4 id="第二阶段-通过Authorization-Code获取Access-Token"><a href="#第二阶段-通过Authorization-Code获取Access-Token" class="headerlink" title="第二阶段: 通过Authorization Code获取Access Token"></a>第二阶段: 通过Authorization Code获取Access Token</h4><ol><li><p>如果第三方站点的用户在第一阶段的授权页中选择对第三方站点授权, 那么就第三方站点就会收到授权服务器的Authorization Code, 进而进入本阶段;<br>(每个用户在授权后, 第三方站点都需要到授权服务器上为用户获取一个access_token, 这个access_token就是以后第三方站点从授权服务器上获取用户信息的凭证了, 一般在获取到access_token令牌之后, 可以存储到session中)</p></li><li><p>本阶段, 我们在自己的第三方站点中就可以使用第一阶段的Authorization Code获取Access Token:</p><ul><li><p><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信</a><br>(暂不上图, 微信还涉及到了openid, 此处介绍标准OAuth, 因此先不进行介绍)</p></li><li><p><a href="http://wiki.connect.qq.com/%E4%BD%BF%E7%94%A8authorization_code%E8%8E%B7%E5%8F%96access_token" target="_blank" rel="external">qq</a><br><img src="/img/oauth/access_token_qq.png" width="650" height="680" alt="github" align="center"></p></li><li><p>基本上入参就像QQ互联那样大概有5个 (需要对每个参数进行了解);</p></li></ul></li><li><p>本阶段的返回参数比较有讲究, 一般为如下三个</p><ul><li><p>access_token 授权令牌<br>access_token一般在获取到之后, 第三方站点可以将其 <code>保存到用户的session中</code> , 第三方站点之后要获取用户在授权服务器上的资源的时候, 就需要带上当前session中用户的access_token去获取;</p></li><li><p>expires_in    该access token的有效期,单位为秒 (微信公众平台access_token有效期为2小时, qq互联平台为3个月 可以作为参考)<br>设置access_token有效期也是为了定期修改access_token, 以提高安全性;<br>(并且微信对获取access_token这个基础API是有限制的，每天最多请求2000次, 因为有效期为2小时, 每天2000次也足够了;)</p></li><li><p>refresh_token 授权自动续期时使用 (微信公众平台refresh_token有效期为30天, qq互联平台具体不详, 可以作为参考)</p></li></ul></li><li><p>(可选)权限自动续期问题</p><ul><li><p>注意<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信公众平台</a>:<br>  1.若access_token已超时，那么进行refresh_token会获取一个新的access_token，新的超时时间, 并且一旦使用refresh_token来刷新access_token的话, refresh_token的过期时间也会更新(自动延期) ;<br>  2.若access_token未超时，那么进行refresh_token不会改变access_token，但超时时间会刷新，相当于续期access_token ;<br>  这里说的超时时间刷新, 指的自然是第三方站点和授权服务器上的超时时间都要更新了(只不过你如果只是做对接的话, 授权服务器这部分人家已经开发好了, 如果你是授权服务器也是自己开发的话, 那你就需要注意这里了)</p></li><li><p>其实第三方站点在受到授权服务器分配给当前用户的access_token之后, 假设说授权服务器返回access_token的过期时间为7200s(2小时), 那么第三方站点将access_token保存到用户session中, 并设置过期时间为6600s(中间可以有个10分钟的服务器时间差);</p></li><li><p>如果第三方站点在使用access_token为用户获取授权服务器中的资源时, 发现session中的access_token并没有过期, 那么请求后就需要为access_token续期(第三方站点和授权服务器上都要做续期)</p></li><li><p>如果第三方站点在使用access_token为用户获取授权服务器中的资源时, 发现session中的access_token过期, 则就需要使用<code>refresh_token</code>调用<code>生成access_token的api接口</code>重新生成access_token来进行续期；<br>  qq:<br>  <img src="/img/oauth/refresh_token_qq.png" width="650" height="640" alt="github" align="center"></p></li><li><p>这样下来, 基本上第三方站点只有在大于refresh_token的过期时间都没有调用过授权服务器的话, 才需要用户重新登录;</p></li></ul></li></ol><h4 id="第三阶段-比较简单-第三方站点通过access-token获取授权平台资源服务器上的用户资源"><a href="#第三阶段-比较简单-第三方站点通过access-token获取授权平台资源服务器上的用户资源" class="headerlink" title="第三阶段(比较简单): 第三方站点通过access_token获取授权平台资源服务器上的用户资源"></a>第三阶段(比较简单): 第三方站点通过access_token获取授权平台资源服务器上的用户资源</h4><ol><li><p>获取access_token后，进行接口调用，有以下前提：</p><ul><li>access_token有效且未超时；</li><li>微信用户已授权给第三方应用帐号相应接口作用域(scope);<br>也就是在授权服务器上还会使用access_token去检测对应的scope权限是否正确;</li></ul></li><li><p>注意, 使用access_token获取用户资源的时候, 得先知道用户在资源服务器上的身份(比如id):</p><ul><li><a href="http://open.weibo.com/wiki/Oauth2/get_token_info" target="_blank" rel="external">新浪</a>需要使用access_token获取用户信息</li><li><a href="http://wiki.open.qq.com/wiki/website/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_Server-side" target="_blank" rel="external">腾讯</a>需要是使用access_token获取用户openid<br><img src="/img/oauth/tengxunqq_01.png" width="600" height="300" alt="github" align="center"></li><li>而微信公众平台在获取access_token之后, 会同时返回<code>openid</code>表示微信用户在本公众号中的唯一标识;</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;第一阶段-第三方站点将导向授权页&quot;&gt;&lt;a href=&quot;#第一阶段-第三方站点将导向授权页&quot; class=&quot;headerlink&quot; title=&quot;第一阶段: 第三方站点将导向授权页&quot;&gt;&lt;/a&gt;第一阶段: 第三方站点将导向授权页&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;第三方
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>03 - OAuth2的CSRF攻击</title>
    <link href="http://blog.renyimin.com/2016/03/20/OAuth-03/"/>
    <id>http://blog.renyimin.com/2016/03/20/OAuth-03/</id>
    <published>2016-03-20T14:03:21.000Z</published>
    <updated>2017-10-20T01:34:34.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>假设有如下几个角色:<br>受害者 <code>lant</code> ;<br>攻击者 <code>rymuscle</code> ;<br>第三方Web应用 <code>liangren网</code> (它允许用户将其在 <code>sandiruiqi网</code> 的账号 和 <code>liangren网</code> 的账号进行绑定) ;<br>OAuth2服务提供平台 <code>sandiruiqi网</code> ;</p></li><li><p>攻击流程</p><ul><li><p><code>攻击者rymuscle</code> 登录 <code>liangren网</code> 并且选择使用自己的 <code>sandiruiqi网</code> 账号登录 ;</p></li><li><p><code>liangren网</code> 将 <code>攻击者rymuscle</code> 重定向到 <code>sandiruiqi网</code> 的授权页(这时可能需要 <code>攻击者rymuscle</code> 登录过<code>sandiruiqi网</code>), <code>sandiruiqi网</code> 的授权页向 <code>攻击者rymuscle</code> 显示 “是否授权<code>liangren网</code>访问” ;</p></li><li><p><code>攻击者rymuscle</code> 在点击”同意授权”之后, 截获 <code>sandiruiqi网</code> 服务器返回的含有 <code>Authorization Code</code> 参数的HTTP响应 ;</p></li><li><p>然后 <code>攻击者rymuscle</code> 精心构造一个Web页面, 它会触发 <code>liangren网</code> 向 <code>sandiruiqi网</code> 发起<strong>令牌申请</strong>的请求, 而这个请求中的Authorization Code参数正是上一步 <code>攻击者rymuscle</code> 截获到的code ;</p></li><li><p><code>攻击者rymuscle</code> 将这个Web页面放到互联网上, 等待或者诱骗受害者来访问 ;</p></li><li><p>假设正好一个受害者 <code>lant</code> 访问了 <code>攻击者rymuscle</code> 准备的这个Web页面后, 令牌申请流程在 <code>受害者lant</code> 的浏览器里被顺利触发, <code>laingren网</code> 从 <code>sandiruiqi网</code> 那里获取到access_token, 但是这个token以及通过它进一步获取到的用户信息却都是攻击者 <code>攻击者rymuscle</code> 的 ;</p></li><li><p>也就是最终 <code>liangren网</code> 将 <code>攻击者rymuscle</code> 的 <code>sandiruiqi</code> 账号同 <code>lant</code> 的 <code>liangren网</code> 账号关联了起来</p><p>从此以后, <code>lant</code>只要没有察觉到自己最初被悄悄使用了 <code>攻击者rymuscle</code> 的<code>sandiruiqi网</code> 账号登录, 那么他在 <code>liangren网</code> 上的所有资料, 都可以被 <code>攻击者rymuscle</code> 所看到, 并且 <code>攻击者rymuscle</code> 可能在 <code>lant</code> 的账号中做一些非法操作;</p></li></ul></li><li><p>整体时序图分析</p><ul><li><p>先看标准oauth时序图<br><img src="/img/oauth/authorization_code.png" width="635" height="600" alt="qq" align="center"></p></li><li><p>下面是从网上copy的一张图, 从整体上来看, 这次攻击的时序图类似下图:<br><img src="/img/oauth/yihuajiemu_mawei.png" width="635" height="580" alt="sina" align="center"></p></li></ul></li><li><p>可以看到, 攻击的关键点在于:<br>OAuth2的认证流程是分为好几步来完成的, 在标准oauth图的第3步, 第三方应用在收到一个GET请求时, 除了能知道当前用户的cookie, 以及URL中的Authorization Code之外, 难以分辨出这个请求到底是用户本人的意愿, 还是攻击者利用用户的身份伪造出来的请求; 于是乎, 攻击者就能使用移花接木的手段, 提前准备一个含有自己的Authorization Code的请求, 并让受害者的浏览器来接着完成后续的令牌申请流程 ;</p></li><li><p>难点(涉及到了非state参数防御):<br> 尽管这个攻击既巧妙又隐蔽, 但是要成功进行这样的CSRF攻击也是比较困难的 :    </p><ul><li><p>整个攻击必须在短时间内完成, 因为OAuth2提供者颁发的Authorization Code有效期很短, <strong>OAuth2官方推荐的时间是不大于10分钟</strong>, 而一旦Authorization Code过期那么后续的攻击也就不能进行下去了;</p></li><li><p>一个Authorization Code只能被使用一次, 如果OAuth2提供者收到重复的Authorization Code, 它会拒绝当前的令牌申请请求, 不止如此, 根据OAuth2官方推荐, 它还可以把和这个已经使用过的Authorization Code相关联的access_token全部撤销掉, 进一步降低安全风险;</p><p>其实貌似只要做到Authorization Code只能被使用一次, 就可以防止csrf在此处的攻击了, 因为 <code>rymuscle</code> 在攻击的时候, 一旦获得 <code>Authorization Code</code>, 第三方站点服务器就会使用 <code>Authorization Code</code> 去申请access_token, 然后只要标记 <code>Authorization Code</code> 为已经使用, 那么 <code>受害者lant</code> 即使点击 <code>攻击者rymuscle</code> 构造好的链接也没用, 因为连接中的 <code>Authorization Code</code> 已经被标记为使用过了;</p></li><li><p>所以不一定非要使用下面的state参数来进行防御<br><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">比如微信公众平台的OAuth授权: state参数就是可选的</a><br><a href="http://open.weibo.com/wiki/Oauth2/authorize" target="_blank" rel="external">新浪开放平台的OAuth授权, state参数也是可选的</a><br>当然, 他们不一定做的是和此处一样的防御方案, 但明显不依赖于state参数来解决问题;</p></li></ul></li><li><p>state参数防御: 要防止这样的攻击其实很容易, 作为第三方应用的开发者, 只需在OAuth认证过程中加入 <code>state</code> 参数, 并验证它的参数值即可;</p><ul><li><p>在将用户重定向到OAuth2的Authorization Endpoint去的时候, 为用户生成一个随机的字符串, 并作为state参数加入到URL中 ;</p></li><li><p>在收到OAuth2服务提供者返回的Authorization Code请求的时候, 验证接收到的state参数值, 如果是正确合法的请求, 那么此时接受到的参数值应该和上一步提到的为该用户生成的state参数值完全一致, 否则就是异常请求;</p><p>但需要注意 <code>state参数</code> 需要具备下面几个特性:</p></li><li><p>不可预测性: 足够的随机, 使得攻击者难以猜到正确的参数值 ;<br>如果你每次生成的state都被放在一起, 比如一个库/缓存中存在很多state;<br>那么问题就是攻击者还是可以拿着自己的code再加上一个state, 来构造一个链接欺骗用户来点击;(假设state正好就在你的库/缓存中);</p></li><li><p>重点是关联性: state参数值可以和当前用户会话(user session)相互关联的<br>所以应该让state和具体的用户关联起来, 虽然用户还没有登录, 但是也可以让state放到session中 ;<br>然后攻击者要猜测出来一个state的话, 即便是已经生成过了, 但是也得正好攻击的是这个用户;</p></li><li><p>唯一性: 每个用户每次请求生成的state参数值都是唯一的 ;</p></li><li><p>时效性: state参数一旦被使用则立即失效 ;</p></li><li><p>参考 蚂蚁金服开放平台:<br><img src="/img/oauth/state_alipay.png" width="600" height="550" alt="wechat" align="center"></p></li></ul></li><li><p>其实可以结合以上各种方法一起来进行防御!</p></li></ol><blockquote><p><a href="http://insights.thoughtworkers.org/attack-aim-at-oauth2/" target="_blank" rel="external">参考 移花接木</a><br><a href="http://blog.sina.com.cn/s/blog_56b798f801018jyb.html" target="_blank" rel="external">参考 state参数漏洞</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">参考 阮一峰</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;假设有如下几个角色:&lt;br&gt;受害者 &lt;code&gt;lant&lt;/code&gt; ;&lt;br&gt;攻击者 &lt;code&gt;rymuscle&lt;/code&gt; ;&lt;br&gt;第三方Web应用 &lt;code&gt;liangren网&lt;/code&gt; (它允许用户将其在 &lt;code&gt;sandirui
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>02 - 授权码模式简介</title>
    <link href="http://blog.renyimin.com/2016/03/19/OAuth-02/"/>
    <id>http://blog.renyimin.com/2016/03/19/OAuth-02/</id>
    <published>2016-03-19T12:27:36.000Z</published>
    <updated>2017-10-19T07:45:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="授权码模式简介"><a href="#授权码模式简介" class="headerlink" title="授权码模式简介"></a>授权码模式简介</h2><p>1.<strong>授权码模式(authorization code)是功能最完整、流程最严密的授权模式, 它的特点就是通过 <code>客户端的后台服务器</code> 与 <code>&quot;服务提供商&quot;的认证服务器</code> 进行互动 ;</strong> </p><p>2.通常一些开放平台使用的都是授权码模式的授权方法, 如qq互联, 微信开放平台等, 不过各自对OAuth2协议还进行了修改, 如微信和QQ还有OpenID的加入;</p><h2 id="授权码模式运行过程"><a href="#授权码模式运行过程" class="headerlink" title="授权码模式运行过程"></a>授权码模式运行过程</h2><ol><li>运行图<br><img src="/img/oauth/authorization_code.png" width="535" height="500" alt="qq" align="center"></li></ol><h2 id="运行过程分析"><a href="#运行过程分析" class="headerlink" title="运行过程分析"></a>运行过程分析</h2><p>1.向用户取得授权许可<br>对应图中的第1、2、3步;</p><p>2.申请访问令牌<br>access_token令牌的申请<br>对应图中的第4、5步;</p><p>( 一些授权平台对标准oauth2进行了部分修改, 如QQ互联, 在申请完access_token令牌之后, 还有一步是使用<a href="http://wiki.connect.qq.com/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_server-side" target="_blank" rel="external">access_token获取openid</a> )</p><p>3.使用令牌获取用户数据</p><p>这一过程中涉及了不少敏感参数和数据, 例如client_secret相当于是第三方应用自己的密码, access_token某种程度上来讲就是用户的session id, 由于这些参数以及数据极其特殊, 我们当然得确保它们的安全性, HTTPS加密传输以及安全存储是必不可少的防护手段, <strong>不过仅仅做到这些是远远不够的, 因为其实在这个流程里存在一个弱点， 容易被攻击者利用进行CSRF攻击, 稍后讲解 ; </strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;授权码模式简介&quot;&gt;&lt;a href=&quot;#授权码模式简介&quot; class=&quot;headerlink&quot; title=&quot;授权码模式简介&quot;&gt;&lt;/a&gt;授权码模式简介&lt;/h2&gt;&lt;p&gt;1.&lt;strong&gt;授权码模式(authorization code)是功能最完整、流程最严密的授权
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>01 - OAuth(Open Authorization)开放式授权协议</title>
    <link href="http://blog.renyimin.com/2016/03/19/OAuth-01/"/>
    <id>http://blog.renyimin.com/2016/03/19/OAuth-01/</id>
    <published>2016-03-19T03:05:00.000Z</published>
    <updated>2017-10-25T07:01:27.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版"><a href="#OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版" class="headerlink" title="OAuth是一个关于授权(authorization)的开放网络标准, 目前的版本是2.0版"></a>OAuth是一个关于授权(authorization)的开放网络标准, 目前的版本是2.0版</h4><ul><li><p>OAuth之前的传统”授权”比较 简单, 直接, 暴力, 那就是直接提供自己资源服务器的账号和密码给第三方站点, 这种做法弊端太多:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">1.如果用户在每个第三方站点都这样做, 那将会存在严重安全隐患:</div><div class="line">很多第三方网站为了后续的服务, 会保存用户的google账号和密码, 这样很不安全, </div><div class="line">因为难免有些第三方平台会由于自己的安全问题而导致用户的google账号和密码泄露, </div><div class="line">从而导致用户大量信息泄露;</div><div class="line">google为了防止可能存在猪一样的第三方队友, 自然不会让自己的用户使用 如此low的授权方案 去给第三方站点授权 ;</div><div class="line"></div><div class="line">2.用户无法设定 第三方站点的权利范围:</div><div class="line">第三方网站拥有了获取用户在google的资料的权力, </div><div class="line">用户没法限制 第三方网站 获得授权的范围和有效期 ;</div><div class="line"></div><div class="line">3.用户想收回 第三方站点的权利不太方便:</div><div class="line">用户只有修改密码, 才能收回赋予 第三方网站 的权力, </div><div class="line">否则 第三方网站 将会永久拥有用户 Google 账号的权利; </div><div class="line">但是这样做, 又会使得其他所有获得用户授权的第三方应用程序全部失效;</div><div class="line"></div><div class="line">或者, 一些良心第三方可以设置 用户账号 和 google 账号的绑定和解绑,</div><div class="line">但不一定所有第三方都会给你做, 如果不做解绑的话, </div><div class="line">你还真就只有前一种方法能够收回权利;</div></pre></td></tr></table></figure></li><li><p>而OAuth的授权不会让 <code>第三方站点</code> 触及到用户在 <code>google</code> 上的帐号信息(如用户名与密码), 即第三方无需使用用户的google账号与密码就可以获得该用户在 <code>google</code> 上的资源, 因此 OAuth 是安全的, OAuth 是 <code>Open Authorization(开放授权)</code> 的简写;</p></li></ul><h4 id="OAuth2-0协议定义了用于获得授权的-四种主要授权类型"><a href="#OAuth2-0协议定义了用于获得授权的-四种主要授权类型" class="headerlink" title="OAuth2.0协议定义了用于获得授权的 四种主要授权类型"></a>OAuth2.0协议定义了用于获得授权的 四种主要授权类型</h4><h5 id="1-授权码-Authorization-code-模式"><a href="#1-授权码-Authorization-code-模式" class="headerlink" title="1.授权码(Authorization code)模式"></a>1.<a href="http://localhost:4000/2016/03/19/OAuth-authorization-code01/" target="_blank" rel="external">授权码(Authorization code)模式</a></h5><ul><li>授权码模式是功能最完整、流程最严密的授权模式(标准的Server授权模式, 非常适合Server端的Web应用);</li><li>它的特点就是通过客户端的后台服务器, 与”服务提供商”的认证服务器进行互动;<br><img src="/img/oauth/oauth_authorization_code_01.png" width="711" height="514" alt="authorization_code_01" align="center"></li><li><p>运行流程图解</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">用户打开客户端以后，客户端要求用户给予授权。</div><div class="line">用户同意给予客户端授权。</div><div class="line">客户端使用上一步获得的授权，向认证服务器申请令牌。</div><div class="line">认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</div><div class="line">客户端使用令牌，向资源服务器申请获取资源。</div><div class="line">资源服务器确认令牌无误，同意向客户端开放资源</div></pre></td></tr></table></figure></li><li><p>场景: 比如公司需要对接 QQ, 微博, 微信(网页授权) 等登录授权, 或者公司达到可以做自己对外的开放平台;</p></li></ul><h5 id="2-隐式授权模式-Implicit-Grant"><a href="#2-隐式授权模式-Implicit-Grant" class="headerlink" title="2.隐式授权模式(Implicit Grant)"></a>2.隐式授权模式(Implicit Grant)</h5><ul><li>也叫简化模式, 该模式<code>不通过第三方应用程序的服务器</code>, 而是直接在浏览器中向认证服务器申请令牌, 跳过了”授权码”这个步骤, 因此得名;</li><li>所有步骤在浏览器中完成, 令牌对访问者是可见的;</li><li>流程图:<br><img src="/img/oauth/oauth_implict_01.png" width="660" height="570" alt="oauth_implict_01" align="center"></li><li>场景:</li></ul><h5 id="3-用户名密码模式-Resource-Owner-Password-Credentials"><a href="#3-用户名密码模式-Resource-Owner-Password-Credentials" class="headerlink" title="3.用户名密码模式(Resource Owner Password Credentials)"></a>3.用户名密码模式(Resource Owner Password Credentials)</h5><ul><li>用户向客户端提供自己的用户名和密码, 客户端使用这些信息，向”服务商提供商”索要授权 ;</li><li><p><code>认证服务器只有在其他授权模式无法执行的情况下, 才能考虑使用这种模式</code>;<br>(这种模式要求用户提供用户名和密码来交换访问令牌access_token, 该模式仅用于非常值得信任的用户, 例如API提供者本人所写的移动应用。虽然用户也要求提供密码，但并不需要存储在设备上。因为初始验证之后，只需将OAuth的令牌记录下来即可。如果用户希望取消授权，因为其真实密码并没有被记录，因此无需修改密码就可以立即取消授权。token本身也只是得到有限的授权，因此相比最传统的username/password授权，该模式依然更为安全。)</p></li><li><p>流程图:<br><img src="/img/oauth/password_credentials_01.png" width="750" height="387" alt="password_credentials_01" align="center"></p></li></ul><p><img src="/img/oauth/password_credentials_02.png" width="527" height="218" alt="password_credentials_02" align="center"></p><ul><li>场景:<br>在这种模式中, 用户必须把自己的密码给客户端, 但是客户端不得储存密码, 这通常用在 <code>用户对客户端高度信任的情况下</code>, 比如客户端也是系统的一部分;<br>比如当third party application、authorization server、resource owner都是自己公司内的系统, Resource owner对third party application足够信任，所以我们就能采取这种模式来实现;<br>就像: 公司如果有多套内部后台系统, 开发人员和公司管理员可能就要准备多套账号, 比较麻烦, 为了解决这个问题, 可以做一个<code>账号中心</code>系统, 用户在登录各个系统后台的时候, 会先跳转到用户中心进行登录, 一旦登录成功之后, 就会给用户分发一个access_token, 用来在各个系统间作为登录认证 (这也实现了<code>SSO单点登录</code>);<br>(参考: <a href="http://www.cnblogs.com/richieyang/p/4918819.html" target="_blank" rel="external">http://www.cnblogs.com/richieyang/p/4918819.html</a>)</li></ul><h5 id="4-客户端模式-Client-Credentials"><a href="#4-客户端模式-Client-Credentials" class="headerlink" title="4.客户端模式(Client Credentials)"></a>4.客户端模式(Client Credentials)</h5><ul><li><p>客户端模式指客户端<code>以自己的名义, 而不是以单个用户的名义</code>，向”服务提供商”进行认证;<br>严格地说, 客户端模式并不属于OAuth框架所要解决的问题;</p></li><li><p>流程图:<br><img src="/img/oauth/oauth_client_credentials_01.png" width="760" height="165" alt="oauth_client_credentials_01" align="center"></p></li><li><p>服务器 <code>不提供像用户数据这样的重要资源</code> ，仅仅是一些开放的功能性API;<br>例如微信公众平台, Google Storage或Amazon S3 等开放平台提供的基础服务接口;</p></li><li><p>场景:<br>1.你自己实现了一套基础服务的Api(都是些基础功能接口, 并不涉及用户数据这种重要资源), <code>提供给内部其他系统通过认证的方式来调用</code>;<br>2.公司如果实力强悍的话, 也可以将公司开发的基础服务Api公开出来 <code>供外部其他第三方站点服务器</code> 来调用, 比如: 微信公众平台的开放接口其实就是使用这种方式:<br><img src="/img/oauth/oauth_client_credentials_02.png" width="770" height="540" alt="oauth_client_credentials_02" align="center"></p></li></ul><h4 id="客户端模式-Client-Credentials-和-用户密码模式-比较类似"><a href="#客户端模式-Client-Credentials-和-用户密码模式-比较类似" class="headerlink" title="客户端模式(Client Credentials) 和 用户密码模式 比较类似"></a>客户端模式(Client Credentials) 和 用户密码模式 比较类似</h4><p>1.客户端模式: 如果客户端以自己的身份向服务提供商进行认证, 那需要授权中心给各个应用(不管是内部系统还是第三方站点服务器)分配对应的AppID和AppSecret, 然后第三方应用使用这两个信息来想认证服务器申请access_token, 这种场景下, 认证服务器提供的接口都是功能性的基础接口;<br>2.用户密码模式: 如果客户端以单个用户身份向服务提供商进行认证, 只要用户账号密码能通过认证服务器, 认证服务器就会发放access_token, 当然这种场景需要的是<code>几方角色都属于本公司内部</code>;</p><blockquote><p>参考: <a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a><br>参考: <a href="http://www.cnblogs.com/richieyang/p/4918819.html" target="_blank" rel="external">http://www.cnblogs.com/richieyang/p/4918819.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版&quot;&gt;&lt;a href=&quot;#OAuth是一个关于授权-authorization-的开放网络标准-目前的版本是2-0版&quot; class=&quot;headerlink&quot; title=&quot;OA
      
    
    </summary>
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/categories/OAuth2-0/"/>
    
    
      <category term="OAuth2.0" scheme="http://blog.renyimin.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>PHP的Closure学习整理</title>
    <link href="http://blog.renyimin.com/2016/03/10/clusore-introduction/"/>
    <id>http://blog.renyimin.com/2016/03/10/clusore-introduction/</id>
    <published>2016-03-10T06:30:15.000Z</published>
    <updated>2017-09-19T04:55:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要是对网上现存的一些资料做了一些简单地整理, 一方面让自己对基础知识加深印象, 一方面便于日后自己随时回顾!</p><h4 id="JavaScript中的闭包"><a href="#JavaScript中的闭包" class="headerlink" title="JavaScript中的闭包"></a>JavaScript中的闭包</h4><p>在了解PHP的闭包之前, 我们可以先简单了解一下JavaScript的闭包是怎样的?</p><h5 id="Js的作用域"><a href="#Js的作用域" class="headerlink" title="Js的作用域"></a>Js的作用域</h5><p>1.要理解闭包，首先必须理解Javascript的 <strong>变量作用域</strong> ;</p><p>2.变量的作用域无非就是两种: <strong>全局变量</strong> 和 <strong>局部变量</strong> ;</p><p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量:<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var n=999;</div><div class="line">function f1()&#123;</div><div class="line">    alert(n);</div><div class="line">&#125;</div><div class="line">f1(); // 999</div></pre></td></tr></table></figure></p><p>另一方面, 在函数外部自然无法读取函数内的局部变量:<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function f1()&#123;</div><div class="line">    var n=999;  //这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</div><div class="line">&#125;</div><div class="line">alert(n); // error</div></pre></td></tr></table></figure></p><h5 id="如何从外部读取局部变量？"><a href="#如何从外部读取局部变量？" class="headerlink" title="如何从外部读取局部变量？"></a>如何从外部读取局部变量？</h5><p>出于种种原因, 我们有时候需要得到函数内的局部变量, 但是, 前面已经说过了, 正常情况下，这是办不到的, 只有通过变通方法才能实现;</p><p>于是, 我们可以在函数的内部, 再定义一个函数:<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function f1()&#123;</div><div class="line">    var n = 999;</div><div class="line">    function f2()&#123;</div><div class="line">        alert(n); // 999</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在上面的代码中, 函数f2就被包括在函数f1内部, 这时, f1内部的所有局部变量, 对f2都是可见的;<br>但是反过来就不行, f2内部的局部变量, 对f1就是不可见的; </p><p>这就是Javascript语言特有的”链式作用域”结构(chain scope), 子对象会一级一级地向上寻找所有父对象的变量; 所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function f1(a)&#123;</div><div class="line">    var n = &apos;局部变量&apos;;</div><div class="line">    function f2(c)&#123;</div><div class="line">       console.log(n);</div><div class="line">       console.log(a);</div><div class="line">       console.log(c);</div><div class="line">    &#125;</div><div class="line">    return f2;</div><div class="line">&#125;</div><div class="line">var result = f1(&apos;传递给函数的参数,也成了一个局部值&apos;);</div><div class="line">result(&apos;传递给闭包的参数1&apos;);</div><div class="line">console.log(&apos;&apos;);</div><div class="line">result(&apos;传递给闭包的参数2&apos;);</div><div class="line">//结果: </div><div class="line">局部变量    //可以看到我们就从外部取到了函数内部的局部变量</div><div class="line">传递给函数的参数,也成了一个局部值</div><div class="line">传递给闭包的参数1</div><div class="line"></div><div class="line">局部变量    //可以看到我们就从外部取到了函数内部的局部变量</div><div class="line">传递给函数的参数,也成了一个局部值</div><div class="line">传递给闭包的参数2</div></pre></td></tr></table></figure></p><h5 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h5><p>上一节代码中的f2函数, 就是闭包;</p><p>各种专业文献上对 “闭包”（closure）定义非常抽象，很难看懂;</p><p>我的理解是，闭包就是能够读取其他函数内部变量的函数;</p><p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量, 因此可以把闭包简单理解成 <strong>“定义在一个函数内部的函数”</strong> ;</p><p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁;</p><h5 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h5><p>1.闭包可以用在许多地方, 它的最大用处有两个:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">一个是前面提到的可以读取函数内部的变量; </div><div class="line">另一个就是让这些变量的值始终保持在内存中;</div></pre></td></tr></table></figure></p><p>2.怎么来理解上面的话呢？</p><p>之前的代码中, result 这个变量其实就是闭包函数f2, 它一共运行了两次;</p><p>而函数f1中的局部变量一直保存在内存中, 并没有在f1调用后被自动清除;</p><p><strong>原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后被垃圾回收机制（garbage collection）回收;</strong></p><h5 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h5><p>1.由于闭包会使得函数中的变量都被保存在内存中, 内存消耗很大, 所以不能滥用闭包, 否则会造成网页的性能问题, 在IE中可能导致内存泄露, 解决方法是, 在退出函数之前, 将不使用的局部变量全部删除;</p><p>2.闭包会在父函数外部改变父函数内部变量的值; 所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method）, 把内部变量当作它的私有属性（private value）, 这时一定要小心, 不要随便改变父函数内部变量的值;</p><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line">var object = &#123;</div><div class="line">    name : &quot;My Object&quot;,</div><div class="line">    getNameFunc : function()&#123;</div><div class="line">        return function()&#123;</div><div class="line">            return this.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">console.log(object.getNameFunc()());     // The Window</div></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line">var object = &#123;</div><div class="line">    name : &quot;My Object&quot;,</div><div class="line">    getNameFunc : function()&#123;</div><div class="line">        var that = this;</div><div class="line">        return function()&#123;</div><div class="line">            return that.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">console.log(object.getNameFunc()());    // My Object</div></pre></td></tr></table></figure><p>以上参考<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">阮一峰的博客</a>, 阮一峰大哥真的写的很好了, 本人这里只是过一遍, 然后稍微简化了一点点, 修改了一点列子, 便于自己理解;</p><h4 id="PHP的闭包"><a href="#PHP的闭包" class="headerlink" title="PHP的闭包"></a>PHP的闭包</h4><p>1.PHP的<code>闭包</code> 和 <code>匿名函数</code> 是在PHP5.3.0中引入, 这两个特性非常有用, 每个PHP开发者都应该掌握;</p><p>2.闭包是指在创建时, <strong>封装周围状态的函数</strong>, 即便闭包所在的环境不存在了, 闭包中封装的状态依然存在, 这个概念如果你看了之前的JavaScript相关闭包的概念, 应该理解起来不是太难;</p><p>3.匿名函数是没有名称的的函数, 匿名函数可以赋值给变量, 还能像其他任何PHP变量那样传递, 不过匿名函数仍是函数, 因此可以调用, 还可以传入参数, 匿名函数特别适合作为函数或方法的回调;</p><p>4.理论上讲, 闭包和匿名函数是不同的概念, 不过, PHP将其视为相同的概念, 所以一般在PHP中说闭包就是匿名函数, 说匿名函数也是指闭包;</p><p>5.PHP闭包和匿名函数使用的句法虽然和普通函数相同, 但是需要注意的是, 闭包和匿名函数其实是<strong>伪装成函数的对象</strong>, 如果审查PHP闭包或匿名函数, 会发现阀门是Closure类的实例; 闭包和字符串或证书一样, 也是<strong>一等值类型</strong> ;</p><h5 id="创建闭包"><a href="#创建闭包" class="headerlink" title="创建闭包"></a>创建闭包</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$closure = <span class="function"><span class="keyword">function</span> <span class="params">($name)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sprintf(<span class="string">'Hello %s'</span>, $name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var_dump($closure); <span class="comment">//object(Closure)#1 (1) &#123; ["parameter"]=&gt; array(1) &#123; ["$name"]=&gt; string(10) "" &#125; &#125;</span></div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;br/&gt;'</span>;</div><div class="line"><span class="keyword">echo</span> $closure(<span class="string">'Josh'</span>);  <span class="comment">//Hello Josh</span></div></pre></td></tr></table></figure><p>闭包对象的创建就这么简单;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">建议: 之所以能调用$closure变量, 是因为这个变量的值是一个闭包, 而且闭包对象实现了__invoke()魔术方法;</div><div class="line">只要变量名后面有(), PHP就会查找并调用__invoke()方法;</div></pre></td></tr></table></figure><p>通常情况下, 我们会把PHP的闭包对象当做函数和方法的回调来使用; 很多PHP的函数都会用到回调函数, 例如 array_map()和preg_replace_callback();<br>这是使用PHP匿名函数的绝佳时机! 记住, 闭包和其他值一样, 可以作为参数出传入其他PHP函数;</p><h5 id="PHP中闭包的-附加状态"><a href="#PHP中闭包的-附加状态" class="headerlink" title="PHP中闭包的 附加状态"></a>PHP中闭包的 <code>附加状态</code></h5><p>1.之前我们说的 array_map()和preg_replace_callback() 对闭包的使用, 主要是把匿名函数当做回调来使用;<br><strong>下面我们讨论的是如何为PHP闭包附加并封装状态;</strong></p><p><strong>2</strong>.JavaScript开发者可能对PHP的闭包感到奇怪, 因为通过之前对JavaScript中闭包的了解, <strong>它的闭包会自动封装应用的状态</strong>; 而PHP的闭包不会像真正的JS闭包那样自动封装应用的状态;<br><strong>在PHP中, 我们必须手动调用闭包对象的 <code>use关键字</code> , 或者闭包对象的 <code>bindTo()方法</code> 来把状态附加到PHP闭包上;</strong></p><h5 id="use关键字"><a href="#use关键字" class="headerlink" title="use关键字"></a>use关键字</h5><p>使用use关键字附加闭包状态比较常见, 我们先看这种方式;</p><p>使用use关键字把变量附加到闭包上时, 附加的变量会记住附加时赋给它的值:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enclosePerson</span><span class="params">($name)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">($doCommand)</span> <span class="title">use</span> <span class="params">($name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sprintf(<span class="string">'%s, %s'</span>, $name, $doCommand);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$clay = enclosePerson(<span class="string">'Clay'</span>);</div><div class="line"></div><div class="line"><span class="keyword">echo</span> $clay(<span class="string">'get me sweet tea!'</span>);</div></pre></td></tr></table></figure></p><p>在例子中, 具名函数enclosePerson()有个名为$name参数, 这个函数返回一个闭包对象, 而且这个闭包对象封装了$name参数;<br>即便返回的闭包对象已经跳出了enclosePerson()函数的作用域, 闭包对象也会记住$name参数的值, 因为$name变量仍在闭包中;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">使用<span class="keyword">use</span>关键字可以把多个参数传入闭包, 此时要像<span class="title">php</span>函数或方法的参数一样, 使用都好分割多个参数;</div></pre></td></tr></table></figure><h5 id="Closure对象的bindTo-方法"><a href="#Closure对象的bindTo-方法" class="headerlink" title="Closure对象的bindTo()方法"></a>Closure对象的bindTo()方法</h5><p>1.别忘了, php闭包是个对象(Closure对象), 与任何其他PHP对象类似, 每个闭包都可以使用$this关键字获取闭包的内部状态; </p><p>虽然闭包对象的默认状态没什么用, 只不过是有一个__invoke魔术方法和bindTo()方法而已; 但是bindTo()方法为闭包增加了一些有趣的潜力, 我们可以使用这个方法把closure对象内部的状态绑定到其他对象上;</p><p>2.<strong>bindTo()方法的第二个参数很重要, 其作用是指定绑定闭包的那个对象所属的PHP类; 因此, 闭包可以访问绑定闭包的对象中受保护和似有的成员变量;</strong></p><p>3.其实如果经常看一些php框架源码, 你会发现, PHP框架经常使用bindTo()方法把 <code>路由URL所映射的匿名回调函数</code> 绑定到 <code>应用对象上</code>, 这么做可以在这个匿名函数中使用$this关键字引用重要的应用对象:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">protected</span> $routes = [];</div><div class="line">    <span class="keyword">protected</span> $responseStatus = <span class="string">'200 OK'</span>;</div><div class="line">    <span class="keyword">protected</span> $responseContentType = <span class="string">'text/html'</span>;</div><div class="line">    <span class="keyword">protected</span> $responseBody = <span class="string">'Hello world'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addRoute</span><span class="params">($routePath, $routeCallback)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;routes[$routePath] = $routeCallback-&gt;bindTo(<span class="keyword">$this</span>, <span class="keyword">__CLASS__</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">($currentPath)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">foreach</span>(<span class="keyword">$this</span>-&gt;routes <span class="keyword">as</span> $routePath =&gt; $callBack)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> ($routePath === $currentPath) &#123;</div><div class="line">                $callBack();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        header(<span class="string">'HTTP/1.1 '</span> . <span class="keyword">$this</span>-&gt;responseStatus);</div><div class="line">        header(<span class="string">'Content-type: '</span> . <span class="keyword">$this</span>-&gt;responseContentType);</div><div class="line">        header(<span class="string">'Content-length: '</span> . mb_strlen(<span class="keyword">$this</span>-&gt;responseBody));</div><div class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;responseBody;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$app = <span class="keyword">new</span> App();</div><div class="line">$app-&gt;addRoute(<span class="string">'/user/getName'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;responseContentType = <span class="string">'application/json;charset=utf8'</span>;</div><div class="line">    <span class="keyword">$this</span>-&gt;responseBody = <span class="string">'&#123;"name": "renyimin"&#125;'</span>;</div><div class="line">&#125;);</div><div class="line">$app-&gt;dispatch(<span class="string">'/user/getName'</span>);</div><div class="line"></div><div class="line"><span class="comment">//结果返回: &#123;"name": "renyimin"&#125;</span></div></pre></td></tr></table></figure></p><p>上面例子其实就是通过在App应用类中, 使用匿名函数的bindTo()方法将匿名函数绑定到了App对象上, 所以你就可以在绑定路由与其匿名函数的时候, 在匿名函数中来通过$this来调用App对象中的一些受保护的属性, 从而设定本路由的返回信息;</p><blockquote><p>《Modern PHP》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要是对网上现存的一些资料做了一些简单地整理, 一方面让自己对基础知识加深印象, 一方面便于日后自己随时回顾!&lt;/p&gt;
&lt;h4 id=&quot;JavaScript中的闭包&quot;&gt;&lt;a href=&quot;#JavaScript中的闭包&quot; class=&quot;headerlink&quot; title=&quot;J
      
    
    </summary>
    
      <category term="PHP New Features" scheme="http://blog.renyimin.com/categories/PHP-New-Features/"/>
    
      <category term="PHP" scheme="http://blog.renyimin.com/categories/PHP-New-Features/PHP/"/>
    
    
      <category term="Closure(闭包)" scheme="http://blog.renyimin.com/tags/Closure-%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>01 - 认识JWT</title>
    <link href="http://blog.renyimin.com/2016/01/07/JWT-01/"/>
    <id>http://blog.renyimin.com/2016/01/07/JWT-01/</id>
    <published>2016-01-07T02:05:00.000Z</published>
    <updated>2017-10-19T10:11:09.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="JWT" scheme="http://blog.renyimin.com/categories/JWT/"/>
    
    
      <category term="JWT" scheme="http://blog.renyimin.com/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>网络数据通信方式</title>
    <link href="http://blog.renyimin.com/2015/07/10/Data-communication-method01/"/>
    <id>http://blog.renyimin.com/2015/07/10/Data-communication-method01/</id>
    <published>2015-07-10T05:20:16.000Z</published>
    <updated>2017-10-16T03:46:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络中传输的信息都是数字数据, <strong>按照数据在线路上的传输方向</strong>，<code>通信方式</code> 可分为：</p><h2 id="单工通信-Simplex"><a href="#单工通信-Simplex" class="headerlink" title="单工通信(Simplex)"></a>单工通信(Simplex)</h2><h3 id="单向信道-信息流是单方向的"><a href="#单向信道-信息流是单方向的" class="headerlink" title="单向信道,信息流是单方向的"></a>单向信道,信息流是单方向的</h3><p>发送端和接收端的身份是固定的, 发送端只能发送信息, 不能接收信息; 接收端只能接收信息, 不能发送信息 ;</p><h3 id="常见通信"><a href="#常见通信" class="headerlink" title="常见通信"></a>常见通信</h3><p>遥控、遥测, 就是单工通信方式</p><h2 id="半双工通信-Half-Duplex"><a href="#半双工通信-Half-Duplex" class="headerlink" title="半双工通信(Half Duplex)"></a>半双工通信(Half Duplex)</h2><h3 id="双向信道-信息流是双向的"><a href="#双向信道-信息流是双向的" class="headerlink" title="双向信道, 信息流是双向的"></a>双向信道, 信息流是双向的</h3><p>没有固定发送端和接收端, 任何一端都可以发送消息给另一端 ;</p><h3 id="同一时刻只能发送或只能接收数据"><a href="#同一时刻只能发送或只能接收数据" class="headerlink" title="同一时刻只能发送或只能接收数据"></a>同一时刻只能发送或只能接收数据</h3><p>所谓半双工就是指一个时间段内只有一个动作发生 ;</p><h3 id="常见通信-1"><a href="#常见通信-1" class="headerlink" title="常见通信"></a>常见通信</h3><p>对讲机, 微信语音</p><h2 id="全双工通信-Full-Duplex"><a href="#全双工通信-Full-Duplex" class="headerlink" title="全双工通信(Full Duplex)"></a>全双工通信(Full Duplex)</h2><h3 id="双向信道-信息流是双向的-1"><a href="#双向信道-信息流是双向的-1" class="headerlink" title="双向信道, 信息流是双向的"></a>双向信道, 信息流是双向的</h3><p>没有固定发送端和接收端, 任何一端都可以发送消息给另一端 ;</p><h3 id="发送和接收数据可以同时进行"><a href="#发送和接收数据可以同时进行" class="headerlink" title="发送和接收数据可以同时进行"></a>发送和接收数据可以同时进行</h3><p>是指在发送数据的同时也能够接收数据, 可以同时进行 ;<br>(目前的网卡一般都支持全双工)</p><h3 id="常见通信-2"><a href="#常见通信-2" class="headerlink" title="常见通信"></a>常见通信</h3><p>我们平时的打电话通信就是全双工通信，你在说话的同时也能够听到对方的声音 ;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机网络中传输的信息都是数字数据, &lt;strong&gt;按照数据在线路上的传输方向&lt;/strong&gt;，&lt;code&gt;通信方式&lt;/code&gt; 可分为：&lt;/p&gt;
&lt;h2 id=&quot;单工通信-Simplex&quot;&gt;&lt;a href=&quot;#单工通信-Simplex&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="网络" scheme="http://blog.renyimin.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://blog.renyimin.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>polling--&gt;服务推技术--&gt;websocket</title>
    <link href="http://blog.renyimin.com/2015/07/10/websocket01/"/>
    <id>http://blog.renyimin.com/2015/07/10/websocket01/</id>
    <published>2015-07-10T04:40:16.000Z</published>
    <updated>2017-10-16T03:04:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1.传统Web开发下, 我们都是使用http协议在服务器和客户端之间进行通信, 要知道http协议是一种单向的网络协议, 在建立连接之后, 只能是浏览器向服务器发出请求资源后, 服务器才能响应 ; </p><p>注意: <code>服务器是无法主动的推送数据给客户端的</code>, 这也是为了<code>安全</code>起见 ;</p><p>2.既然传统的http请求有上述问题, 那么如下一些现代web开发的场景该如何应对?<br>即时通信系统；<br>即时报价系统；<br>股票的实时行情;</p><p>3.要应对上述应用场景, 目前有很多方案可供选择, 下面将一一介绍;</p><h2 id="传统Ajax短轮训-Polling"><a href="#传统Ajax短轮训-Polling" class="headerlink" title="传统Ajax短轮训(Polling)"></a>传统Ajax短轮训(Polling)</h2><p>1.这种方案主要就是通过浏览器<code>每隔一定时间就去向服务器发送http请求</code>, 服务器受到请求后, 就把最新的数据返回给客户端(浏览器), 浏览器再将数据显示出来 ;</p><p>2.虽然这种方案可以满足需求, 但是却存在很多问题:<br>(1) 可能在一段时间内的多次请求中, 服务器端的数据根本就没有更新过, 这样就导致客户端一直在空转, 这样既浪费了网络带宽, 又浪费了COU的利用率 ;</p><p>(2) 针对第一个问题, 可能有人会觉得, 将客户端请求服务器的时间间隔做适当的调整就可以, 比如调整大一点, 但这样的话, 如果服务器端的数据更新很快的时候, 又不能保证客户端获取数据的实时性 ;</p><h2 id="解决方案-–-服务器推技术"><a href="#解决方案-–-服务器推技术" class="headerlink" title="解决方案 – 服务器推技术"></a>解决方案 – 服务器推技术</h2><h3 id="服务器推技术分两类"><a href="#服务器推技术分两类" class="headerlink" title="服务器推技术分两类"></a>服务器推技术分两类</h3><p>面对上面提到的实时性较高的web应用场景, “服务器推”技术有一些解决方案, 本文将这些解决方案分为两类 :<br>(1)一类需要在浏览器端安装插件,基于套接口传送信息,或是使用 RMI、CORBA 进行远程调用 ;<br>基于客户端套接口的 “服务器推” 技术</p><p>(2)而另一类则无须浏览器安装任何插件、基于 HTTP 长连接 ;<br>Comet </p><h2 id="基于客户端套接口的”服务器推”技术"><a href="#基于客户端套接口的”服务器推”技术" class="headerlink" title="基于客户端套接口的”服务器推”技术"></a>基于客户端套接口的”服务器推”技术</h2><h3 id="Flash-XMLSocket"><a href="#Flash-XMLSocket" class="headerlink" title="Flash XMLSocket"></a>Flash XMLSocket</h3><p>如果你的Web应用的用户可以接受 <code>只有在安装了 Flash 播放器</code> 应用才能正常运行, 那么使用 Flash 的 <code>XMLSocket</code> 就是一个可行的方案:</p><p>这种方案实现的基础是:<br>1.Flash 提供了 XMLSocket 类 ;<br>2.JavaScript 和 Flash 的紧密结合: 在 JavaScript 可以直接调用 Flash 程序提供的接口;</p><p>具体实现方法: 在 HTML 页面中内嵌入一个使用了 XMLSocket 类的 Flash 程序, JavaScript 通过调用此 Flash 程序提供的套接口接口与服务器端的套接口进行通信, JavaScript 在收到服务器端以 XML 格式传送的信息后可以很容易地控制 HTML 页面的内容显示 ;</p><p><strong><em>关于如何去构建充当了 JavaScript 与 Flash XMLSocket 桥梁的 Flash 程序，以及如何在 JavaScript 里调用 Flash 提供的接口，我们可以参考 AFLAX（Asynchronous Flash and XML）项目提供的 Socket Demo 以及 SocketJS（请参见 参考资源）</em></strong></p><p>Javascript 与 Flash 的紧密结合，极大增强了客户端的处理能力。从 Flash 播放器 V7.0.19 开始，已经取消了 XMLSocket 的端口必须大于 1023 的限制。Linux 平台也支持 Flash XMLSocket 方案。但此方案的 <strong>缺点</strong> 在于：<br>(1)客户端必须安装 Flash 播放器；<br>(2)因为 XMLSocket 没有 HTTP 隧道功能，XMLSocket 类不能自动穿过防火墙；<br>(3)因为是使用套接口，需要设置一个通信端口，防火墙、代理服务器也可能对非 HTTP 通道端口进行限制；</p><p>不过这种方案在一些网络聊天室，网络互动游戏中已得到广泛使用。</p><h3 id="Java-Applet-套接口"><a href="#Java-Applet-套接口" class="headerlink" title="Java Applet 套接口"></a>Java Applet 套接口</h3><p>在客户端使用 Java Applet，通过 java.net.Socket 或 java.net.DatagramSocket 或 java.net.MulticastSocket 建立与服务器端的套接口连接, 从而实现”服务器推” ;</p><p>这种方案最大的不足在于 <code>Java applet 在收到服务器端返回的信息后, 无法通过 JavaScript 去更新 HTML 页面的内容</code> ;</p><h2 id="基于HTTP长连接的”服务器推”技术"><a href="#基于HTTP长连接的”服务器推”技术" class="headerlink" title="基于HTTP长连接的”服务器推”技术"></a>基于HTTP长连接的”服务器推”技术</h2><h3 id="Comet-简介"><a href="#Comet-简介" class="headerlink" title="Comet 简介"></a>Comet 简介</h3><p>1.”服务器推” 是一种很早就存在的技术,以前在实现上主要是通过客户端的套接口或是服务器端的远程调用, 因为浏览器技术的发展比较缓慢,没有为”服务器推”的实现提供很好的支持,在纯浏览器的应用中很难有一个完善的方案去实现”服务器推”并用于商业程序; </p><p>2.最近几年, 因为 <code>AJAX 技术的普及</code>, 以及 <code>把 IFrame 嵌在 &quot;htmlfile&quot; 的 ActiveX 组件中可以解决 IE 的加载显示问题</code>，一些受欢迎的应用如 meebo，gmail+gtalk 在实现中使用了这项技术;</p><p>3.Alex Russell(Dojo Toolkit 的项目 Lead)称 <code>基于 HTTP 长连接、无须在浏览器端安装插件的</code> “服务器推”技术为 “Comet”;</p><p>4.目前已经出现了一些成熟的 Comet 应用以及各种开源框架, 一些 Web 服务器如Jetty也在为支持大量并发的长连接进行了很多改进; 关于 Comet 技术最新的发展状况请参考关于 Comet 的 wiki。</p><h3 id="Comet的实现模型有两类"><a href="#Comet的实现模型有两类" class="headerlink" title="Comet的实现模型有两类"></a>Comet的实现模型有两类</h3><p>下面将介绍两种 Comet 应用的实现模型 (都是基于http长连接) :<br>基于 AJAX 的长轮询（long-polling）方式</p><p>基于 Iframe 及 htmlfile 的流(streaming)方式</p><h3 id="基于-AJAX-的长轮询（long-polling）方式"><a href="#基于-AJAX-的长轮询（long-polling）方式" class="headerlink" title="基于 AJAX 的长轮询（long-polling）方式"></a>基于 AJAX 的长轮询（long-polling）方式</h3><p>1.AJAX 的出现使得 JavaScript 可以调用 XMLHttpRequest 对象发出 HTTP 请求，JavaScript 响应处理函数根据服务器返回的信息对 HTML 页面的显示进行更新;</p><p>2.使用 AJAX 实现”服务器推” 与 传统的 AJAX 应用不同之处在于：<br>(1)服务器端会阻塞请求直到有数据传递或超时才返回;<br>(2)客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后,再次发出请求,重新建立连接;<br>(3)当客户端处理接收的数据、重新建立连接时, 服务器端可能有新的数据到达, 这些信息会被服务器端保存直到客户端重新建立连接, 客户端会一次把当前服务器端所有的信息取回;</p><p>3.基于长轮询的服务器推模型如下:<br><img src="/img/websocket/comet_ajax_longpolling.png" width="350" height="280" alt="comet_ajax_longpolling" align="center"></p><p>相对于”短轮询”(poll), 这种长轮询方式也可以称为”拉”(pull);</p><p>这种方案<code>基于 AJAX</code>，具有以下一些优点:<br>请求异步发出;<br>无须安装插件;<br>IE、Mozilla FireFox 都支持 AJAX;</p><h3 id="基于-Iframe-及-htmlfile-的流-streaming-方式"><a href="#基于-Iframe-及-htmlfile-的流-streaming-方式" class="headerlink" title="基于 Iframe 及 htmlfile 的流(streaming)方式"></a>基于 Iframe 及 htmlfile 的流(streaming)方式</h3><p>1.iframe 是很早就存在的一种 HTML 标记, 通过在 HTML 页面里嵌入一个隐蔵帧,然后将这个隐蔵帧的 SRC 属性设为对一个长连接的请求, 服务器端就能源源不断地往客户端输入数据;</p><p>2.基于流方式的服务器推模型<br><img src="/img/websocket/comet_iframe_streaming.png" width="350" height="280" alt="comet_iframe_streaming" align="center"><br>上节提到的 AJAX 方案是在 JavaScript 里处理 XMLHttpRequest 从服务器取回的数据，然后 Javascript 可以很方便的去控制 HTML 页面的显示;</p><p>同样的思路用在 iframe 方案的客户端，iframe 服务器端并不返回直接显示在页面的数据，而是返回对客户端 Javascript 函数的调用，如<code>&lt;script type=&quot;text/javascript&quot;&gt;js_func(&#39;data from server&#39;)&lt;/script&gt;;</code> 服务器端将返回的数据作为客户端 JavaScript 函数的参数传递, 客户端浏览器的 Javascript 引擎在收到服务器返回的 JavaScript 调用时就会去执行代码;</p><p>从图中可以看到,每次数据传送不会关闭连接,连接只会在通信出现错误时或是连接重建时关闭(一些防火墙常被设置为丢弃过长的连接,服务器端可以设置一个超时时间,超时后通知客户端重新建立连接,并关闭原来的连接);</p><p>使用 iframe 请求一个长连接有一个很明显的不足之处:IE、Morzilla Firefox 下端的进度栏都会显示加载没有完成,而且 IE 上方的图标会不停的转动,表示加载正在进行;<br>Google 的天才们使用一个称为“htmlfile”的 ActiveX 解决了在 IE 中的加载显示问题，并将这种方法用到了 gmail+gtalk 产品中。Alex Russell 在 “What else is burried down in the depth’s of Google’s amazing JavaScript?”文章中介绍了这种方法。Zeitoun 网站提供的 comet-iframe.tar.gz，封装了一个基于 iframe 和 htmlfile 的 JavaScript comet 对象，支持 IE、Mozilla Firefox 浏览器，可以作为参考。（请参见 参考资源）</p><h2 id="解决方案-–-WebSocket"><a href="#解决方案-–-WebSocket" class="headerlink" title="解决方案 – WebSocket"></a>解决方案 – WebSocket</h2><p>1.websocket是HTML5中定义的新协议, 它实现了<strong>真正的</strong>长连接, 实现了浏览器与服务器的全双工通信;<br>WebSocket是为解决客户端与服务端实时通信而产生的技术, websocket协议本质上是一个基于tcp的协议，是先通过HTTP/HTTPS协议发起一条特殊的http请求进行握手后, 创建一个用于交换数据的TCP连接, 此后服务端与客户端通过此TCP连接进行实时通信 ;<br>注意:此时不再需要原HTTP协议的参与了 ;</p><p>2.<br><a href="https://www.ibm.com/developerworks/cn/web/wa-lo-comet/#icomments" target="_blank" rel="external">摘自</a><br><a href="http://blog.csdn.net/fhzaitian/article/details/51691946" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;1.传统Web开发下, 我们都是使用http协议在服务器和客户端之间进行通信, 要知道http协议是一种单向的网络协议, 在建立连接之后, 
      
    
    </summary>
    
      <category term="WebSocket" scheme="http://blog.renyimin.com/categories/WebSocket/"/>
    
    
      <category term="WebSocket" scheme="http://blog.renyimin.com/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Ajax请求不能发送 -- WebSocket方案</title>
    <link href="http://blog.renyimin.com/2015/06/07/sameoriginpolicy07-ajax-disabled-websocket/"/>
    <id>http://blog.renyimin.com/2015/06/07/sameoriginpolicy07-ajax-disabled-websocket/</id>
    <published>2015-06-07T02:20:16.000Z</published>
    <updated>2017-09-30T01:44:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信 ;</p><p>下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /chat HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</div><div class="line">Sec-WebSocket-Protocol: chat, superchat</div><div class="line">Sec-WebSocket-Version: 13</div><div class="line">Origin: http://example.com</div></pre></td></tr></table></figure></p><p>上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。<br>正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</div><div class="line">Sec-WebSocket-Protocol: chat</div></pre></td></tr></table></figure></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
      <category term="WebSocket" scheme="http://blog.renyimin.com/categories/CrossDomain/WebSocket/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
      <category term="WebSocket" scheme="http://blog.renyimin.com/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>小结</title>
    <link href="http://blog.renyimin.com/2015/05/30/sameoriginpolicy06-summary/"/>
    <id>http://blog.renyimin.com/2015/05/30/sameoriginpolicy06-summary/</id>
    <published>2015-05-30T13:20:16.000Z</published>
    <updated>2017-09-29T09:22:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jsonp-对比-CORS简单-非简单请求"><a href="#Jsonp-对比-CORS简单-非简单请求" class="headerlink" title="Jsonp 对比 CORS简单/非简单请求"></a>Jsonp 对比 CORS简单/非简单请求</h2><p>都可以方便实现跨域;</p><h3 id="Jsonp"><a href="#Jsonp" class="headerlink" title="Jsonp"></a>Jsonp</h3><p>简单适用, 老式浏览器全部支持, 服务器端改动很小;</p><p>JSONP只能发GET请求;</p><p>JSONP跨子域发送Cookie的话(貌似也就是在跨子域的时候你能发发cookie), 只用设置好<code>cookie的domain属性</code>为顶级域名即可;</p><h3 id="CORS简单请求"><a href="#CORS简单请求" class="headerlink" title="CORS简单请求"></a>CORS简单请求</h3><p>服务端需要设置一些允许选项;</p><p>发送请求为 GET, POST, HEAD ;</p><p>跨子域发送cookie的话(貌似也就是在跨子域的时候你能发发cookie), 不仅需要设置<code>cookie的domain属性</code>, 服务端和客户端都要对<code>Credentials</code> header属性进行设置;</p><p>跨子域的话 服务端 <code>Access-Control-Allow-Origin</code> 不能设置为 * , 否则会提示 :<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Failed to load http:<span class="comment">//test.test.com/index.php?sex=renyimin&amp;age=100: </span></div><div class="line">The value of the <span class="string">'Access-Control-Allow-Origin'</span> header in the response must not be the wildcard <span class="string">'*'</span> when the request<span class="string">'s credentials mode is '</span><span class="keyword">include</span><span class="string">'. </span></div><div class="line"><span class="string">Origin '</span>http:<span class="comment">//www.test.com' is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span></div></pre></td></tr></table></figure></p><h3 id="CORS非简单请求"><a href="#CORS非简单请求" class="headerlink" title="CORS非简单请求"></a>CORS非简单请求</h3><p>服务端需要设置一些允许选项;</p><p>发送其他请求 (PUT) ..</p><p>可以设置自定义header头</p><p>cookie方面和 CORS简单请求一样</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Jsonp-对比-CORS简单-非简单请求&quot;&gt;&lt;a href=&quot;#Jsonp-对比-CORS简单-非简单请求&quot; class=&quot;headerlink&quot; title=&quot;Jsonp 对比 CORS简单/非简单请求&quot;&gt;&lt;/a&gt;Jsonp 对比 CORS简单/非简单请求&lt;/
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>Ajax请求不能发送 -- CORS方案02 (not-so-simple request)</title>
    <link href="http://blog.renyimin.com/2015/05/20/sameoriginpolicy05-ajax-disabled-cors-not-simple/"/>
    <id>http://blog.renyimin.com/2015/05/20/sameoriginpolicy05-ajax-disabled-cors-not-simple/</id>
    <published>2015-05-20T12:10:16.000Z</published>
    <updated>2017-09-29T09:22:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><h3 id="预检请求-preflight-说明"><a href="#预检请求-preflight-说明" class="headerlink" title="预检请求 preflight 说明"></a>预检请求 <code>preflight</code> 说明</h3><ol><li><p>非简单请求是那种对服务器有特殊要求的请求, 比如请求方法是 <code>PUT</code> 或 <code>DELETE</code>, 或者 <code>Content-Type</code> 字段的类型是 <code>application/json</code> ;</p></li><li><p>非简单请求的CORS请求, 会在正式通信之前, 增加一次HTTP查询请求, 称为 <code>&quot;预检&quot;请求(preflight)</code> ;<br> 浏览器先询问服务器, 当前网页所在的域名是否在服务器的许可名单之中, 以及可以使用哪些HTTP动词和头信息字段;<br> 只有得到肯定答复, 浏览器才会发出正式的XMLHttpRequest请求, 否则就报错 ;</p></li><li><p>非简单请求会导致原先的一次请求变成两次, 第一次请求是 <code>预检请求</code> ;</p></li><li><p>“预检”请求用的请求方法是 <code>OPTIONS</code>，表示这个请求是用来<code>询问</code>的，头信息里面，关键字段是Origin，表示请求来自哪个源 ;<br> 即使你的请求方法是 <code>GET</code>, <code>POST</code> 或者 <code>HEAD</code>(只是请求时自定义了一些header首部字段), 你的这个跨域请求也是 <code>非简单请求</code>，此时请求头显示的 ；</p></li></ol><h4 id="非简单请求的例子"><a href="#非简单请求的例子" class="headerlink" title="非简单请求的例子"></a>非简单请求的例子</h4><ol><li><p>www.test.com/index.php<br> 本例子使用 <code>PUT</code> 来进行ajax请求, 满足 <code>非简单请求</code> 的条件 ;<br> 另外, 本例还<code>自定义了请求时的 header 首部字段</code>, 也满足 <code>非简单请求</code> 的条件 ;</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="meta">?&gt;</span></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;Title&lt;/title&gt;</div><div class="line">    &lt;script src=<span class="string">"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=<span class="string">"text/javascript"</span> &gt;</div><div class="line">        $(document).ready(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">            $(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">//序列化name/value</span></div><div class="line">                <span class="keyword">var</span> data = $(<span class="string">"form"</span>).serializeArray();</div><div class="line">                $.ajax(&#123;</div><div class="line">                    <span class="comment">//这里用PUT, 则为 `非简单` 请求</span></div><div class="line">                    type: <span class="string">'PUT'</span>,</div><div class="line">                    url: <span class="string">'http://test.test.com/index.php'</span>,</div><div class="line">                    dataType: <span class="string">'json'</span>,</div><div class="line">                    data: data,</div><div class="line">                    <span class="comment">//或者如果你自定义了一些请求时的 header 首部字段, 那么请求就也是 复杂请求</span></div><div class="line">                    headers: &#123;<span class="string">"custom-header-field"</span> : <span class="string">"test"</span>&#125;,</div><div class="line">                    success: <span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;</div><div class="line">                        console.log(result);</div><div class="line">                    &#125;,</div><div class="line">                    timeout: <span class="number">3000</span></div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form name=<span class="string">"form"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"sex"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"btn"</span> value=<span class="string">"button"</span> /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></li><li><p>test.test.com/index.php</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//服务器允许的 Origin</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.test.com"</span>);</div><div class="line"><span class="comment">//服务器允许的 methods</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Methods: PUT, GET, POST"</span>);</div><div class="line"><span class="comment">//服务器允许设置的头部字段</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Headers: custom-header-field"</span>);</div><div class="line"></div><div class="line">$arguments = file_get_contents(<span class="string">'php://input'</span>);</div><div class="line"><span class="keyword">echo</span> json_encode([<span class="string">'arguments'</span> =&gt; $arguments]);</div></pre></td></tr></table></figure></li><li><p>注意: 像上面例子的复杂跨域请求<br> 必须: 首先和简单请求一样, 服务器端的 <code>Access-Control-Allow-Origin</code> 是必须设置的, 不然首先就跨不了域;</p><p> 必须: 其次, 是使用了 <code>get</code>, <code>post</code>, <code>head</code> 之外方法的 <code>复杂请求</code>, 那么就必须在服务端有对应的 <code>Access-Control-Allow-Method</code>, 否则:<br> <img src="/img/cross-domain/not-simple-error01.png" width="597" height="133" alt="not-simple-error01" align="center"></p><p> 可选: 如果你自定义了 <code>自定义首部字段</code> 的 <code>复杂请求</code>, 那么也要在服务端有对应的 <code>Access-Control-Allow-Headers</code>, 否则:<br> <img src="/img/cross-domain/not-simple-error02.png" width="598" height="150" alt="not-simple-error02" align="center"></p></li><li><p>另外需要关注的是:<br> 如果你设置了自定义的首部字段, 那么即使你的请求类型是get, post, head, 自然也是复杂请求, 此时的HTTP请求方法显示的仍然如下:</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Request Method:OPTIONS</div></pre></td></tr></table></figure></li></ol><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><ol><li><p>上面<code>www.test.com/index.php</code>代码进行ajax请求的时候, HTTP请求的方法是<code>PUT</code>, 所以浏览器会发现, 这是一个非简单请求, 就自动发出一个”预检”请求, 要求服务器确认可以这样请求 ;</p></li><li><p>所以请求应该是包括<code>预检请求</code>和<code>真正的请求</code>两个请求的:<br><img src="/img/cross-domain/2times_request.png" width="600" height="360" alt="2times_request" align="center"></p></li><li><p>下面是这个”预检”请求的HTTP头信息 和 回应信息:<br><img src="/img/cross-domain/preflight01.png" width="700" height="500" alt="preflight01" align="center"></p></li><li><p>可以看到, “预检”请求用的请求方法是OPTIONS, 表示这个请求是用来询问的, 头信息里面, 关键字段是Origin, 表示请求来自哪个源;<br>除了Origin字段，”预检”请求的头信息包括两个特殊字段:<br>(1)<code>Access-Control-Request-Method</code><br>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT ;<br>(2)<code>Access-Control-Request-Headers</code><br>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段, 上例是X-Custom-Header ;</p></li></ol><h4 id="预检响应"><a href="#预检响应" class="headerlink" title="预检响应"></a>预检响应</h4><ol><li><p>从下面预检请求的截图中，可以看到预检请求的回应中, 服务器收到”预检”请求以后, 检查了 <code>Origin</code>、<code>Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code> 字段以后，确认允许跨源请求，就可以做出回应 ;<br> <img src="/img/cross-domain/preflight01.png" width="700" height="500" alt="preflight01" align="center"></p><p> 并且预检请求部分是不会真的发送数据的:<br> <img src="/img/cross-domain/preflight02.png" width="400" height="150" alt="preflight02" align="center"></p></li><li><p>上面的HTTP回应中，关键的是 <code>Access-Control-Allow-Origin</code> 字段，表示 <code>http://www.test.com</code> 可以请求数据, <strong>该字段也可以设为星号</strong>，表示同意任意跨源请求 ;</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http:<span class="comment">//www.test.com</span></div><div class="line">或者</div><div class="line">Access-Control-Allow-Origin: *</div></pre></td></tr></table></figure></li><li><p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段 ; 这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 <code>XMLHttpRequest</code> 对象的 <code>onerror</code> 回调函数捕获;<br> 控制台会打印出如下的报错信息 ;</p><p><img src="/img/cross-domain/no-simple-error01.png" width="650" height="150" alt="no-simple-error01" align="center"></p></li><li><p>服务器还可能回应的其他CORS相关字段如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Methods: GET, POST, PUT</div><div class="line">Access-Control-Allow-Headers: X-Custom-Header</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Max-Age: 1728000</div></pre></td></tr></table></figure><p> （1）Access-Control-Allow-Methods<br> 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。<br> （2）Access-Control-Allow-Headers<br> 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。<br> （3）Access-Control-Allow-Credentials<br> 该字段与简单请求时的含义相同。<br> （4）Access-Control-Max-Age<br> 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p></li><li><p>cookie方面, 其实和CORS简单请求是一样的要求<br> www.test.com/index.php</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">setcookie(<span class="string">'address'</span>, json_encode([<span class="string">'city'</span> =&gt; <span class="string">'yuncheng'</span>, <span class="string">'town'</span> =&gt; <span class="string">'xiaoliang'</span>]), <span class="number">0</span>, <span class="string">'/'</span>, <span class="string">'.test.com'</span>);</div><div class="line"><span class="meta">?&gt;</span></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;Title&lt;/title&gt;</div><div class="line">    &lt;script src=<span class="string">"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=<span class="string">"text/javascript"</span> &gt;</div><div class="line">        $(document).ready(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">            $.ajaxSetup(&#123;crossDomain: <span class="keyword">true</span>, xhrFields: &#123;withCredentials: <span class="keyword">true</span>&#125;&#125;);</div><div class="line">            $(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">//序列化name/value</span></div><div class="line">                <span class="keyword">var</span> data = $(<span class="string">"form"</span>).serializeArray();</div><div class="line">                $.ajax(&#123;</div><div class="line">                    <span class="comment">//这里用PUT, 则为 `非简单` 请求</span></div><div class="line">                    type: <span class="string">'PUT'</span>,</div><div class="line">                    url: <span class="string">'http://test.test.com/index.php'</span>,</div><div class="line">                    dataType: <span class="string">'json'</span>,</div><div class="line">                    data: data,</div><div class="line">                    <span class="comment">//或者如果你自定义了一些请求时的 header 首部字段, 那么请求就也是 复杂请求</span></div><div class="line">                    headers: &#123;<span class="string">"custom-header-field"</span> : <span class="string">"test"</span>&#125;,</div><div class="line">                    success: <span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;</div><div class="line">                        console.log(result);</div><div class="line">                    &#125;,</div><div class="line">                    timeout: <span class="number">3000</span></div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form name=<span class="string">"form"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"sex"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"btn"</span> value=<span class="string">"button"</span> /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></li></ol><pre><code>test.test.com<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//服务器允许的 Origin (如果要发送cookie的话复杂请求也不能为*)</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.test.com"</span>);</div><div class="line"><span class="comment">//服务器允许的 methods</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Methods: PUT, GET, POST"</span>);</div><div class="line"><span class="comment">//服务器允许设置的头部字段</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Headers: custom-header-field"</span>);</div><div class="line"><span class="comment">//要跨子域发cookie, 这个自然不能少</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Credentials: true"</span>);</div><div class="line"></div><div class="line">$arguments = file_get_contents(<span class="string">'php://input'</span>);</div><div class="line">$address = $_COOKIE[<span class="string">'address'</span>];</div><div class="line"><span class="keyword">echo</span> json_encode([<span class="string">'arguments'</span> =&gt; $arguments, <span class="string">'cookie'</span> =&gt; $address]);</div></pre></td></tr></table></figure></code></pre><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">参考 CORS</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;非简单请求&quot;&gt;&lt;a href=&quot;#非简单请求&quot; class=&quot;headerlink&quot; title=&quot;非简单请求&quot;&gt;&lt;/a&gt;非简单请求&lt;/h2&gt;&lt;h3 id=&quot;预检请求-preflight-说明&quot;&gt;&lt;a href=&quot;#预检请求-preflight-说明&quot; class
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
  <entry>
    <title>Ajax请求不能发送 -- CORS方案01 (simple request)</title>
    <link href="http://blog.renyimin.com/2015/05/19/sameoriginpolicy04-ajax-disabled-cors-simple/"/>
    <id>http://blog.renyimin.com/2015/05/19/sameoriginpolicy04-ajax-disabled-cors-simple/</id>
    <published>2015-05-19T04:45:07.000Z</published>
    <updated>2017-09-29T09:21:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CORS说明"><a href="#CORS说明" class="headerlink" title="CORS说明"></a>CORS说明</h2><ol><li><p>CORS是一个W3C标准, 全称是 “跨域资源共享 “(Cross-origin resource sharing), 通俗说就是我们所熟知的跨域请求 ;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">众所周知，在以前，跨域可以采用 `代理`、`JSONP` 等方式，而在Modern浏览器面前，这些终将成为过去式，因为有了CORS ;</div><div class="line">CORS在最初接触的时候只大概了解到，通过服务器端设置Access-Control-Allow-Origin响应头，即可使指定来源像访问同源接口一样访问跨域接口，但其实CORS的规范定义远不止这些 ;</div></pre></td></tr></table></figure></li><li><p>它允许 <code>浏览器</code> 向 <code>跨源服务器</code> 发出XMLHttpRequest请求, 从而克服了AJAX只能同源使用的限制 ;</p></li><li><p>CORS需要浏览器和服务器同时支持 (目前, 所有浏览器都支持该功能, IE浏览器不能低于IE10) ;</p></li><li><p>整个CORS通信过程都是浏览器自动完成, 不需要用户参与 ;<br> 对于开发者来说, CORS通信与同源的AJAX通信没有差别, 代码完全一样, 浏览器一旦发现AJAX的请求是跨源的, 就会自动添加一些附加的头信息, 有时还会多出一次附加的请求, 但用户不会有感觉;</p><p> <strong> 因此，其实实现CORS通信的关键是服务器, 只要服务器实现了CORS接口，就可以跨源通信 </strong></p></li></ol><h3 id="CORS的两类请求"><a href="#CORS的两类请求" class="headerlink" title="CORS的两类请求"></a>CORS的两类请求</h3><ol><li><p>浏览器将CORS请求分成两类: 简单请求(simple request) 和 非简单请求(not-so-simple request)</p></li><li><p>以下为<code>非简单请求</code>的情况 :</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">请求以 GET, HEAD 或者 POST 以外的方法发起请求 ;</div><div class="line"></div><div class="line">或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型, 比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求 ;</div><div class="line"></div><div class="line">使用自定义请求头（比如添加诸如 X-PINGOTHER）</div></pre></td></tr></table></figure></li></ol><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><h3 id="先看代码案例"><a href="#先看代码案例" class="headerlink" title="先看代码案例"></a>先看代码案例</h3><ol><li><p>客户端代码<br> www.test.com/index.html : </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">   &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">   &lt;title&gt;Title&lt;/title&gt;</div><div class="line">   &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">   &lt;script type=&quot;text/javascript&quot; &gt;</div><div class="line">       $(document).ready(function()&#123;</div><div class="line">           $(&quot;#btn&quot;).click(function(k) &#123;</div><div class="line">               var data = $(&quot;form&quot;).serializeArray();//序列化name/value</div><div class="line">               $.ajax(&#123;</div><div class="line">                   type: &apos;GET&apos;,  //这里用GET</div><div class="line">                   url: &apos;http://test.test.com/index.php&apos;,</div><div class="line">                   dataType: &apos;json&apos;,  //类型</div><div class="line">                   data: data,</div><div class="line">                   success: function (result) &#123;//返回的json数据</div><div class="line">                       console.log(result); //回调输出</div><div class="line">                   &#125;,</div><div class="line">                   timeout: 3000</div><div class="line">               &#125;);</div><div class="line">           &#125;);</div><div class="line">       &#125;);</div><div class="line">   &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form name=&quot;form&quot;&gt;</div><div class="line">   &lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt;</div><div class="line">   &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;</div><div class="line">   &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></li><li><p>服务端代码<br>test.test.com/index.php : </p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.test.com"</span>);</div><div class="line"><span class="keyword">echo</span> json_encode([<span class="string">'name'</span> =&gt; <span class="string">'lant'</span>, <span class="string">'age'</span> =&gt; <span class="number">100</span>]);</div></pre></td></tr></table></figure></li></ol><h3 id="基本流程分析"><a href="#基本流程分析" class="headerlink" title="基本流程分析"></a>基本流程分析</h3><h4 id="浏览器直接发出CORS请求"><a href="#浏览器直接发出CORS请求" class="headerlink" title="浏览器直接发出CORS请求"></a>浏览器直接发出CORS请求</h4><p>对于简单请求，浏览器直接发出CORS请求, 具体来说, 就是在头信息之中, 自动增加一个Origin字段 ;</p><h4 id="浏览器识别出跨域AJAX简单请求"><a href="#浏览器识别出跨域AJAX简单请求" class="headerlink" title="浏览器识别出跨域AJAX简单请求"></a>浏览器识别出跨域AJAX简单请求</h4><p>浏览器发现这次跨源AJAX请求是简单请求, 就自动在头信息之中, 添加一个Origin字段:<br><img src="/img/cross-domain/ajax-simple-cors.png" width="670" height="420" alt="ajax-simple-cors" align="center"></p><p><strong>上面的头信息中, <code>Origin字段</code> 用来说明本次请求来自哪个源(协议 + 域名 + 端口), 服务器根据这个值, 决定是否同意这次请求 </strong>;</p><h4 id="浏览器添加的Origin源不在服务器设置的许可范围"><a href="#浏览器添加的Origin源不在服务器设置的许可范围" class="headerlink" title="浏览器添加的Origin源不在服务器设置的许可范围"></a>浏览器添加的Origin源不在服务器设置的许可范围</h4><p>如果Origin源, 不在许可范围内, 服务器让然会返回一个正常的HTTP回应, 不过浏览器会发现, 这个回应的头信息并没有包含 <code>Access-Control-Allow-Origin</code> 字段(详见下文), 就知道出错了, 从而抛出一个错误, 被XMLHttpRequest的onerror回调函数捕获; <strong>注意, 这种错误无法通过状态码识别, 因为HTTP回应的状态码有可能是200</strong> ;<br><img src="/img/cross-domain/ajax-simple-cors02.png" width="590" height="260" alt="ajax-simple-cors02" align="center"></p><h4 id="浏览器添加的Origin源在服务器设置的许可范围内"><a href="#浏览器添加的Origin源在服务器设置的许可范围内" class="headerlink" title="浏览器添加的Origin源在服务器设置的许可范围内"></a>浏览器添加的Origin源在服务器设置的许可范围内</h4><ol><li><p>当然, 如果 <code>Origin源在服务器设置的许可范围内</code> , 服务器返回的响应, 就会多出如下个头信息字段(当然也不一定是所有都包含, <strong>具体还得看服务器如何进行设置</strong>) :</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://api.bob.com</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Expose-Headers: FooBar</div><div class="line">Content-Type: text/html; charset=utf-8</div></pre></td></tr></table></figure></li><li><p><strong>重点分析</strong>:<br>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头:<br>(1) <code>Access-Control-Allow-Origin</code><br>服务器要设置ajax请求可以跨域, 该字段是必须的, 它的值要么是请求时Origin字段的值，要么是一个<em>，表示接受任意域名的请求;<br>(2) <code>Access-Control-Allow-Credentials</code><br>该字段可选, 它的值是一个布尔值，表示是否允许发送Cookie, <em>*默认情况下，Cookie不包括在CORS请求之中</em></em>, 设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器;<br>注意, 这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。<br>(3) <code>Access-Control-Expose-Headers</code><br>该字段可选, CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p></li></ol><h4 id="服务器端的具体设置"><a href="#服务器端的具体设置" class="headerlink" title="服务器端的具体设置"></a>服务器端的具体设置</h4><ol><li>服务器在设置的时候, 其实就是通过header函数设置上面的三个选项!</li><li><p>比如之前的例子中, 如果服务器只是简单的为了实现跨域, 直接设置如下选项即可:</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.test1.com"</span>);</div><div class="line"><span class="keyword">echo</span> json_encode([<span class="string">'name'</span> =&gt; <span class="string">'lant'</span>, <span class="string">'age'</span> =&gt; <span class="number">100</span>]);</div></pre></td></tr></table></figure></li></ol><h3 id="withCredentials-属性"><a href="#withCredentials-属性" class="headerlink" title="withCredentials 属性"></a>withCredentials 属性</h3><h4 id="CORS请求默认不发送Cookie和HTTP认证信息-Jsonp是会发送cookie信息的"><a href="#CORS请求默认不发送Cookie和HTTP认证信息-Jsonp是会发送cookie信息的" class="headerlink" title="CORS请求默认不发送Cookie和HTTP认证信息 (Jsonp是会发送cookie信息的)"></a>CORS请求默认不发送<code>Cookie</code>和<code>HTTP认证信息</code> (Jsonp是会发送cookie信息的)</h4><ol><li><p>之前在介绍<code>Access-Control-Allow-Credentials</code>选项的时候提到, CORS请求默认不发送Cookie和HTTP认证信息; 如果要把Cookie发到服务器:</p><p> 一方面要 <strong>服务器同意指定Access-Control-Allow-Credentials字段</strong> :</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Credentials: <span class="keyword">true</span></div><div class="line"><span class="comment">//php中设置如下:</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Credentials: true"</span>);</div></pre></td></tr></table></figure><p> 另一方面, 开发者必须在AJAX请求中打开 <code>withCredentials</code> 属性:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.withCredentials = true;</div><div class="line">//jquery中设置withCredentials的代码如下:</div><div class="line">$.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;);</div></pre></td></tr></table></figure></li><li><p>需要以上两方面都做到才可以</p><p> 否则，即使服务器同意发送Cookie，浏览器也不会发送, 或者，服务器要求设置Cookie，浏览器也不会处理 ;</p><p> 但是, 如果省略 <code>withCredentials</code> 设置, 有的浏览器还是会一起发送Cookie, 这时, 可以显式关闭 <code>withCredentials</code> ;</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.withCredentials = <span class="keyword">false</span>;</div></pre></td></tr></table></figure></li><li><p><strong>需要注意的是</strong>:<br> <strong>如果要发送Cookie, <code>Access-Control-Allow-Origin</code> 就不能设为星号<code>*</code>, 必须指定明确的、与请求网页一致的域名</strong> ; </p><p> <strong>同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传, 其他域名的Cookie并不会上传, 且(跨源)原网页代码中的document.cookie也无法读取服务器域名下的Cookie ;</strong></p></li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>域1中的代码(www.test.com/index.php)：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传, 其他域名的Cookie并不会上传, 且(跨源)原网页代码中的document.cookie也无法读取服务器域名下的Cookie</span></div><div class="line">setcookie(<span class="string">'address'</span>, json_encode([<span class="string">'city'</span> =&gt; <span class="string">'yuncheng'</span>, <span class="string">'town'</span> =&gt; <span class="string">'xiaoliang'</span>]), <span class="number">0</span>, <span class="string">'/'</span>, <span class="string">'.test.com'</span>);</div><div class="line"><span class="meta">?&gt;</span></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;Title&lt;/title&gt;</div><div class="line">    &lt;script src=<span class="string">"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=<span class="string">"text/javascript"</span> &gt;</div><div class="line">        $(document).ready(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">            $.ajaxSetup(&#123;crossDomain: <span class="keyword">true</span>, xhrFields: &#123;withCredentials: <span class="keyword">true</span>&#125;&#125;);</div><div class="line"></div><div class="line">            $(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">(k)</span> </span>&#123;</div><div class="line">                <span class="keyword">var</span> data = $(<span class="string">"form"</span>).serializeArray();<span class="comment">//序列化name/value</span></div><div class="line">                $.ajax(&#123;</div><div class="line">                    type: <span class="string">'GET'</span>,  <span class="comment">//这里用GET</span></div><div class="line">                    url: <span class="string">'http://test.test.com/index.php'</span>,</div><div class="line">                    dataType: <span class="string">'json'</span>,  <span class="comment">//类型</span></div><div class="line">                    data: data,</div><div class="line">                    success: <span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;<span class="comment">//返回的json数据</span></div><div class="line">                        console.log(result); <span class="comment">//回调输出</span></div><div class="line">                    &#125;,</div><div class="line">                    timeout: <span class="number">3000</span></div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form name=<span class="string">"form"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"sex"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span>&gt;</div><div class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"btn"</span> value=<span class="string">"button"</span> /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p><p>域2中的代码(test.test.comindex.php):<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.test.com"</span>);</div><div class="line">header(<span class="string">"Access-Control-Allow-Credentials: true"</span>);</div><div class="line">$address = $_COOKIE[<span class="string">'address'</span>];</div><div class="line"><span class="keyword">echo</span> json_encode([<span class="string">'name'</span> =&gt; <span class="string">'lant'</span>, <span class="string">'age'</span> =&gt; <span class="number">100</span>, <span class="string">'address'</span> =&gt; $address]);</div></pre></td></tr></table></figure></p><p>效果:<br><img src="/img/cross-domain/cors-cookie.png" width="590" height="260" alt="cors-cookie" align="center"></p><h4 id="两个注意"><a href="#两个注意" class="headerlink" title="两个注意"></a>两个注意</h4><ol><li><p>如果域1中在html中设置了 <code>withCredentials</code> 为 true :</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;);</div></pre></td></tr></table></figure><p> 那么在对应的ajax请求的域2中必须设置</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">header(<span class="string">"Access-Control-Allow-Credentials: true"</span>);</div></pre></td></tr></table></figure><p> 否则, 报错如下:<br> <img src="/img/cross-domain/haha-server-withCredentials.png" width="500" height="160" alt="haha-server-withCredentials" align="center"></p></li><li><p>如果两边都不设置 <code>withCredentials</code> 属性的话, 也就是默认请求不带cookie, 那么即使请求方域1中设置了domain属性为 <code>.test.com</code> 的cookie值, 服务方(test.test.com)中也获取不到cookie, 因为域1默认请求就没有带cookie ;</p></li></ol><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">参考 CORS</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CORS说明&quot;&gt;&lt;a href=&quot;#CORS说明&quot; class=&quot;headerlink&quot; title=&quot;CORS说明&quot;&gt;&lt;/a&gt;CORS说明&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;CORS是一个W3C标准, 全称是 “跨域资源共享 “(Cross-origin reso
      
    
    </summary>
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/categories/CrossDomain/"/>
    
    
      <category term="CrossDomain" scheme="http://blog.renyimin.com/tags/CrossDomain/"/>
    
  </entry>
  
</feed>
