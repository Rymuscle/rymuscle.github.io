<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>22. JCF - Java集合框架 | Lant&#39;s</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="JAVASE">
    <meta name="description" content="JCF简介 JCF(Java Collection Framework) 主要是由一组精心设计的接口、类和隐含在其中的数据结构及算法所组成, 通过它们可以对Java对象进行存储、获取、操作和转换等功能;   虽然称为框架, 但这些接口和类是以库的方式工作: 所有的集合类都位于 java.util 包下, 是用来存放对象的容器, 后来为了处理多线程环境下的并发安全问题, java5还在 java.u">
<meta name="keywords" content="JAVASE">
<meta property="og:type" content="article">
<meta property="og:title" content="22. JCF - Java集合框架">
<meta property="og:url" content="http://blog.renyimin.com/2018/12/19/JAVA/2018-12-19-22/index.html">
<meta property="og:site_name" content="Lant&#39;s">
<meta property="og:description" content="JCF简介 JCF(Java Collection Framework) 主要是由一组精心设计的接口、类和隐含在其中的数据结构及算法所组成, 通过它们可以对Java对象进行存储、获取、操作和转换等功能;   虽然称为框架, 但这些接口和类是以库的方式工作: 所有的集合类都位于 java.util 包下, 是用来存放对象的容器, 后来为了处理多线程环境下的并发安全问题, java5还在 java.u">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://blog.renyimin.com/img/javase/jcf-01.gif">
<meta property="og:image" content="http://blog.renyimin.com/img/javase/collection-list01.png">
<meta property="og:updated_time" content="2018-12-29T06:30:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="22. JCF - Java集合框架">
<meta name="twitter:description" content="JCF简介 JCF(Java Collection Framework) 主要是由一组精心设计的接口、类和隐含在其中的数据结构及算法所组成, 通过它们可以对Java对象进行存储、获取、操作和转换等功能;   虽然称为框架, 但这些接口和类是以库的方式工作: 所有的集合类都位于 java.util 包下, 是用来存放对象的容器, 后来为了处理多线程环境下的并发安全问题, java5还在 java.u">
<meta name="twitter:image" content="http://blog.renyimin.com/img/javase/jcf-01.gif">
    
        <link rel="alternate" type="application/atom+xml" title="Lant&#39;s" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.6.13">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand4.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpeg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Lant</h5>
          <a href="mailto:18625036504@163.com" title="18625036504@163.com" class="mail">18625036504@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">22. JCF - Java集合框架</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h5 class="subtitle">
            
                <time datetime="2018-12-19T02:17:23.000Z" itemprop="datePublished" class="page-time">
  2018-12-19
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/JAVASE/">JAVASE</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#JCF简介"><span class="post-toc-number">1.</span> <span class="post-toc-text">JCF简介</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#JCF框架结构"><span class="post-toc-number">2.</span> <span class="post-toc-text">JCF框架结构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Collection接口"><span class="post-toc-number">3.</span> <span class="post-toc-text">Collection接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#List接口"><span class="post-toc-number">4.</span> <span class="post-toc-text">List接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ArrayList"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">ArrayList</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vector类"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">Vector类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vector类-amp-ArrayList类"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">Vector类 &amp; ArrayList类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#LinkedList类"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">LinkedList类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ArrayList类-amp-LinkedList类"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">ArrayList类 &amp; LinkedList类</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Set接口"><span class="post-toc-number">5.</span> <span class="post-toc-text">Set接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashSet-类"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">HashSet 类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#LinkedHashSet类"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">LinkedHashSet类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TreeSet类"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">TreeSet类</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Queue接口"><span class="post-toc-number">6.</span> <span class="post-toc-text">Queue接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Map-接口"><span class="post-toc-number">7.</span> <span class="post-toc-text">Map 接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Java容器注意事项"><span class="post-toc-number">8.</span> <span class="post-toc-text">Java容器注意事项</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Collection接口-1"><span class="post-toc-number">9.</span> <span class="post-toc-text">Collection接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#"><span class="post-toc-number">9.1.</span> <span class="post-toc-text"> </span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Map接口"><span class="post-toc-number"></span> <span class="post-toc-text">Map接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Arraylist-与-LinkedList-异同"><span class="post-toc-number">1.</span> <span class="post-toc-text">Arraylist 与 LinkedList 异同</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Map"><span class="post-toc-number">2.</span> <span class="post-toc-text">Map</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-JAVA/2018-12-19-22"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">22. JCF - Java集合框架</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-12-19 10:17:23" datetime="2018-12-19T02:17:23.000Z"  itemprop="datePublished">2018-12-19</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/JAVASE/">JAVASE</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="JCF简介"><a href="#JCF简介" class="headerlink" title="JCF简介"></a>JCF简介</h2><ol>
<li><p><strong>JCF(Java Collection Framework)</strong> 主要是由一组精心设计的接口、类和隐含在其中的数据结构及算法所组成, 通过它们可以对Java对象进行存储、获取、操作和转换等功能; </p>
</li>
<li><p>虽然称为框架, 但这些接口和类是以库的方式工作: 所有的集合类都位于 <code>java.util</code> 包下, 是用来存放对象的容器, 后来为了处理多线程环境下的并发安全问题, java5还在 <code>java.util.concurrent</code> 包下提供了一些多线程支持的集合类;</p>
</li>
<li><p><strong>Java集合</strong>就像一种容器, 可以动态第把多个对象的引用放入容器中, 所以也叫<strong>Java容器</strong>, 这些容器可以用于存储数量不等的多个对象, 还可以用于保存具有映射关系的关联数组; </p>
</li>
<li><p>总之, JCF提供了各种集合的接口和实现它们的类; 用来存放数据对象并实现对其数据对象的各种操作;</p>
</li>
</ol>
<h2 id="JCF框架结构"><a href="#JCF框架结构" class="headerlink" title="JCF框架结构"></a>JCF框架结构</h2><ol>
<li><p>下面是一比较常见的Java集合框架图<br> <img src="/img/javase/jcf-01.gif" width="500/"></p>
</li>
<li><p>从上图来看, 其实Java集合框架主要包括两种类型的容器: Collection和Map, 它们是Java集合框架的根接口, 这两个接口又包含了一些子接口或实现类</p>
<ul>
<li>Collection: 一个独立元素的序列, 这些元素会遵循一定的规则</li>
<li>Map: 一组成对的 “键值对” 对象, 允许你使用键来查找值</li>
</ul>
</li>
<li><p>Java的集合类也主要由 Collection和Map 这两个根接口派生而出, 不过Java不提供直接继承自Collection的集合类, Java提供的集合类都是实现自Collection的 <code>子接口</code> 如 <code>List</code>, <code>Set</code>, <code>Queue</code> </p>
</li>
</ol>
<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><ol>
<li><p>Collection是最基本的集合接口, 一个Collection代表一组Object(即Collection的元素Elements); 一些Collection允许相同的元素而另一些不行, 一些能排序而另一些不行;</p>
</li>
<li><p>Collection 接口下又有 3 种子接口 List、Set 和 Queue, 再下面是一些抽象类, 最后是具体实现类, 常用的有 <code>ArrayList</code>、<code>LinkedList</code>、<code>HashSet</code>、<code>LinkedHashSet</code>、<code>HashMap</code>、<code>LinkedHashMap</code> 等等</p>
</li>
<li></li>
<li><p>Collection中的几个主要实现类 (中间省略一些实现和继承关系)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|Collection </span><br><span class="line">|   ├List </span><br><span class="line">|   │--├LinkedList </span><br><span class="line">|   │--├ArrayList </span><br><span class="line">|   │--└Vector </span><br><span class="line">|   │　    └Stack </span><br><span class="line">|   ├Set</span><br><span class="line">|   │--├HashSet </span><br><span class="line">|   │--├TreeSet </span><br><span class="line">|   │--└LinkedSet </span><br><span class="line">|   │</span><br><span class="line">|   ├Queue</span><br><span class="line">|   │--├PriorityQueue</span><br><span class="line">|   │--├Deque</span><br><span class="line">|   │   ├ArrayDeque</span><br><span class="line">|   │   └LinkedList</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>List, Set,Map三者的区别及总结:</strong></p>
<ul>
<li><p>List:对付顺序的好帮手<br>List接口存储一组不唯一(可以有多个元素引用相同的对象), 有序的对象</p>
</li>
<li><p>Set:注重独一无二的性质<br>不允许重复的集合, 不会有多个元素引用相同的对象</p>
</li>
<li><p>Map: 用Key来搜索的专家<br>使用键值对存储;<br>Map会维护与Key有关联的值, 两个Key可以引用相同的对象, 但Key不能重复, 典型的Key是String类型, 但也可以是任何对象;</p>
</li>
</ul>
</li>
</ol>
<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><ol>
<li>List 接口存储一组不唯一, 有序(插入顺序)的对象 <ul>
<li>该接口是一个 <strong>有序的</strong> Collection</li>
<li>使用此接口能够精确的控制每个元素插入的位置</li>
<li>能够通过索引(元素在List中位置, 类似于数组的下标)来访问List中的元素, 第一个元素的索引为0</li>
<li>允许有相同的元素 </li>
</ul>
</li>
<li><p>List接口下我们通常使用的实现类有: <code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code>及其子类<code>Stack</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├List </span><br><span class="line">│--├LinkedList </span><br><span class="line">│--├ArrayList </span><br><span class="line">│--└Vector (已过时)</span><br><span class="line">│　    └Stack</span><br></pre></td></tr></table></figure>
</li>
<li><p>List子接口的操作有<br> <img src="/img/javase/collection-list01.png" width="450/"></p>
</li>
<li>List子接口是<strong>有序</strong>集合, 所以与Set相比, 增加了与索引位置相关的操作: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(int index, Object o): 在指定位置插入元素</span><br><span class="line">addAll(int index, Collection c): ...</span><br><span class="line">get(int index): 取得指定位置元素</span><br><span class="line">indexOf(Obejct o): 返回对象o在集合中第一次出现的位置</span><br><span class="line">lastIndexOf(Object o): ...</span><br><span class="line">remove(int index): 删除并返回指定位置的元素</span><br><span class="line">set(int index, Object o): 替换指定位置元素</span><br><span class="line">subList(int fromIndex, int endIndex): 返回子集合</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ol>
<li>ArrayList是List接口的可变数组的实现, 它封装了一个动态增长的、允许再分配的Object[]数组; 并允许包括 null 在内的所有元素;</li>
<li>由于 Arraylist底层使用的是数组, 所以其 读取数据效率高,插入删除特定位置效率低</li>
<li>ArrayList不是线程同步的, 即线程不安全;</li>
</ol>
<h3 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h3><ol>
<li><p>Vector是一种老的动态数组, 是线程同步的, 效率很低, 一般不赞成使用;</p>
<blockquote>
<p>其实 ArrayList 和 Vector 在用法上完全相同, 但由于Vector是一个古老的集合(从jdk1.0就有了), 那时候java还没有提供系统的集合框架, 所以在Vector里提供了一些方法名很长的方法(例如:addElement(Object obj)), 实际上这个方法和add(Object obj)没什么区别;<br> 从jdk1.2以后, Java提供了系统的集合框架, 就将Vector改为实现List接口, 作为List的实现之一, 从而导致Vector里有一些重复的方法;<br> Vector里有一些功能重复的方法, 这些方法中方法名更短的是属于后来新增的方法, 更长的是原先vector的方法, 而后来ArrayList是作为List的主要实现类, 看过的Java思想编程中也提到了<strong>Vector有很多缺点, 尽量少用Vector实现类</strong></p>
</blockquote>
</li>
<li><p>Vector的子类<code>Stack</code>: Stack类表示后进先出(LIFO)的对象堆栈</p>
<ul>
<li>由于 Vector是通过数组实现的, 这就意味着, Stack也是通过数组实现的, 而非链表</li>
<li><code>Deque</code> 接口及其实现提供了 LIFO 堆栈操作 更完整和更一致的集合, 应该优先使用此集合, 而非Stack类。例如: <code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</code></li>
</ul>
</li>
<li><blockquote>
<p>Vector类 和 Stack类 这两个都是jdk1.0的过时API, <strong>应该避免使用</strong><br> jdk1.5新增了很多多线程情况下使用的集合类, 位于java.util.concurrent<br> 如果你说, Vector是同步的, 你要在多线程使用, 那你应该使用 java.util.concurrent.CopyOnWriteArrayList 等, 而不是Vector<br> 如果你要使用Stack做类似的业务, 那么非线程的你可以选择linkedList, 多线程情况你可以选择 java.util.concurrent.ConcurrentLinkedDeque 或者java.util.concurrent.ConcurrentLinkedQueue</p>
</blockquote>
</li>
<li><p>多线程情况下, 应尽量使用java.util.concurrent包下的类;</p>
</li>
<li><p>摘自: <a href="https://www.cnblogs.com/devin-ou/p/7989451.html" target="_blank" rel="noopener">https://www.cnblogs.com/devin-ou/p/7989451.html</a></p>
</li>
</ol>
<h3 id="Vector类-amp-ArrayList类"><a href="#Vector类-amp-ArrayList类" class="headerlink" title="Vector类 &amp; ArrayList类"></a>Vector类 &amp; ArrayList类</h3><ol>
<li>它们都是基于数组实现</li>
<li>Vector可以设置增长因子, 而ArrayList不可以 (类允许设置默认的增长长度, 默认扩容方式为原来的2倍)</li>
<li>Vector的方法都是同步的(Synchronized), 是线程安全的(thread-safe), 而ArrayList的方法不是, 由于线程的同步必然要影响性能, 因此, ArrayList的性能比Vector好</li>
</ol>
<p>详细: <a href="https://blog.csdn.net/weixin_37766296/article/details/80315375" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37766296/article/details/80315375</a></p>
<h3 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3><ol>
<li>LinkedList底层使用的是双向循环链表数据结构(插入, 删除效率特别高);</li>
<li>LinkedList实现了List接口, 允许 <code>null</code> 元素, 此外LinkedList提供额外的get, remove, insert方法在LinkedList的首部或尾部, <strong>这些操作使LinkedList可被用作堆栈(stack), 队列(queue)或双向队列(deque)</strong></li>
<li>当数据特别多, 而且经常需要插入删除元素时建议选用 LinkedList; 一般程序只用Arraylist就够用了, 因为一般数据量都不会蛮大, Arraylist是使用最多的集合类;</li>
<li>注意LinkedList没有同步方法, 如果多个线程同时访问一个List, 则必须自己实现访问同步, 一种解决方法是在创建List时构造一个同步的List:  <code>List list = Collections.synchronizedList(new LinkedList(…));</code></li>
</ol>
<h3 id="ArrayList类-amp-LinkedList类"><a href="#ArrayList类-amp-LinkedList类" class="headerlink" title="ArrayList类 &amp; LinkedList类"></a>ArrayList类 &amp; LinkedList类</h3><ol>
<li>Arraylist 底层使用的是数组(存读数据效率高, 插入删除特定位置效率低), LinkedList底层使用的是双向循环链表数据结构(插入, 删除效率特别高)</li>
<li>在各种Lists中, 最好的做法是以ArrayList作为缺省选择; 当插入、删除频繁时, 使用LinkedList();</li>
</ol>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><ol>
<li><p>Set 接口存储一组<strong>唯一</strong>, <strong>无序</strong>的对象 (判断两个对象是否相同则是根据<code>equals</code>方法)</p>
</li>
<li><p>Set接口下我们通常使用的实现类有: <code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code>及其子类<code>Stack</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├Set</span><br><span class="line">│--├HashSet </span><br><span class="line">│--├TreeSet </span><br><span class="line">│--└LinkedSet</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h3><ol>
<li>HashSet是Set接口的典型实现, HashSet使用HASH算法来存储集合中的元素, 因此具有良好的存取和查找性能; 当向HashSet集合中存入一个元素时, HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值, 然后根据该HashCode值决定该对象在HashSet中的存储位置;</li>
<li>该类不允许出现重复元素, 不保证集合中元素的顺序, 允许包含值为null的元素, 但最多只能一个(当然了, 元素不能重复);</li>
<li>HashSet集合判断两个元素相等的标准是两个对象通过 <code>equals()</code> 方法比较相等, 并且两个对象的hashCode()方法的返回值相等;</li>
<li>HashSet不是同步的, 多线程访问同一步HashSet对象时, 需要手工同步 </li>
<li>内部使用 <code>HashMap</code> 来存储数据, 数据存储在HashMap的key中;</li>
<li><p>HashSet几个重要的方法</p>
<ul>
<li><p><code>add(E e)</code> : HashSet的确定性(也可以理解为唯一性), 是通过 HashMap 的 put方法 来保证的, 往HashMap中put数据时, 如果key是一样的, 只会替换key对应的value, 不会新插入一条数据; 所以往HashSet中add相同的元素没有什么用, 这里的相同是通过equals方法保证的, 具体的在HashMap中细说。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E var1) &#123;</span><br><span class="line">    return this.map.put(var1, PRESENT) == null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>remove(Object o)</code> : 简单粗暴, 从HashMap中移除一条数据  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object var1) &#123;</span><br><span class="line">    return this.map.remove(var1) == PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>contains(Object o)</code> </p>
</li>
<li><code>iterator()</code></li>
<li>其他的方法诸如: <code>size()</code>、<code>isEmpty()</code>、<code>contains()</code>、<code>clear()</code>等都完全委托给了HashMap。需要注意的是: HashSet没有提供set、get等方法;</li>
</ul>
</li>
<li><p>摘自: <a href="https://www.cnblogs.com/wlrhnh/p/7256969.html" target="_blank" rel="noopener">https://www.cnblogs.com/wlrhnh/p/7256969.html</a></p>
</li>
</ol>
<h3 id="LinkedHashSet类"><a href="#LinkedHashSet类" class="headerlink" title="LinkedHashSet类"></a>LinkedHashSet类</h3><ol>
<li>LinkedHashSet继承自HashSet, 内部使用的是LinkHashMap; 这样做的意义或者好处是, LinkedHashSet中的元素顺序是可以保证的, 也就是说遍历序和插入序是一致的;</li>
<li><a href="https://www.cnblogs.com/wlrhnh/p/7256969.html" target="_blank" rel="noopener">https://www.cnblogs.com/wlrhnh/p/7256969.html</a></li>
<li></li>
</ol>
<h3 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h3><ol>
<li>可以实现排序等功能的集合, 对象元素添加到集合中时会自动按照某种比较规则将其插入到有序的对象序列中, 并保证该集合元素组成按照 升序 排列;</li>
<li>TreeSet的内部操作的底层数据是TreeMap, 只是我们操作的是TreeMap的key;</li>
<li>在对大量信息进行检索的时候, TreeSet 比 ArrayList 更有效率, 能保证在log(n)的时间内完成 ( ?? 不对啊, arraylist的随机读取不是O(1)么?? <strong>其实这句话的意思是, 当你不知道索引时, 查找一个元素, TreeSet自然是O(log(n)), 而ArrayList在不指定索引时, 如果没有搜索算法, 自然是log(n)</strong>) <ul>
<li>TreeSet 是用树形结构来存储信息的, 每个节点都会保存一下指针对象, 分别指向父节点, 左分支, 右分支, 相比较而言, ArrayList就是一个含有元素的简单数组了, 正因为如此, 它占的内存也要比ArrayList多一些;</li>
<li>向 TreeSet 插入元素也比 ArrayList 要快一些, 因为当元素插入到ArrayList的任意位置时, 平均每次要移动一半的列表, 需要O(n)的时间, 而TreeSet深度遍历查询花费的实施只需要O(log(n))<br>普遍的都是, set查询慢, 插入快, list查询快, 插入慢</li>
</ul>
</li>
<li>…… </li>
</ol>
<h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><ol>
<li><p>用于模拟 队列 这种数据结构, 实现 <code>FIFO</code> 等数据结构; 通常, 队列不允许随机访问队列中的元素;<br> Queue 接口并未定义阻塞队列的方法, 但这在方法并发编程中是很常见的, 因此Queue的子接口 BlockingQueue接口 定义了那些等待元素出现或等待队列中有可用空间的方法, 这些方法扩展了此接口;<br> Queue 实现通常不允许插入 null 元素, 尽管某些实现(如 LinkedList)并不禁止插入 null, 即使在允许 null 的实现中, 也不应该将 null 插入到 Queue 中, 因为 null 也用作 poll 方法的一个特殊返回值, 表明队列不包含元素;</p>
</li>
<li></li>
</ol>
<h2 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h2><ol>
<li></li>
<li><p> |Collection<br> |　　├List<br> |　　│—├LinkedList<br> |　　│—├ArrayList<br> |　　│—└Vector<br> |　　│　    └Stack<br> |　　├Set<br> |　　│—├HashSet<br> |　　│—├TreeSet<br> |　　│—└LinkedSet<br> |<br> |Map<br> 　　├Hashtable<br> 　　├HashMap<br> 　　└WeakHashMap</p>
</li>
</ol>
<h2 id="Java容器注意事项"><a href="#Java容器注意事项" class="headerlink" title="Java容器注意事项"></a>Java容器注意事项</h2><ol>
<li></li>
<li><p>Java容器里只能放对象, 对于基本类型(int, long, float, double等), 需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里, 很多时候拆包装和解包装能够自动完成, 这虽然会导致额外的性能和空间开销, 但简化了设计和编程;</p>
</li>
<li><p><strong>集合与数组</strong></p>
<ul>
<li>数组: 大小固定, 只能存储相同数据类型的数据; 数组存储的元素可以是同一类基本类型, 也可以是同一类对象;</li>
<li>集合: 大小可动态扩展, 可以存储不同类型的数据; 集合里只能保存对象;<br>在编程中, 常常需要集中存放多个数据, 虽然数组是个不错的选择, 但数组需要你事先明确知道你将要保存的对象的数量, 数组在初始化时就会指定长度, 并且之后这个数组长度是不可变的;<br>而如果我们需要保存动态增长的数据, 就无法再使用数组了, 此时, java的集合类就是一个很好的设计方案了</li>
</ul>
</li>
<li></li>
<li><p>可点击查看<a href="/img/javase/JCF.png">Java 集合框架图</a></p>
</li>
<li><p>Java 集合框架主要包括两种类型的容器:</p>
<ul>
<li>一种是<code>集合(Collection)</code>, 存储元素集合; </li>
<li>另一种是<code>图(Map)</code>, 存储键/值对映射;</li>
</ul>
</li>
</ol>
<h2 id="Collection接口-1"><a href="#Collection接口-1" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>Collection接口定义了存取一组对象的方法, 其子接口Set和List分别定义了存储方式</p>
<ul>
<li>List接口: 有序可重复, 长度可变</li>
<li>Set接口: 无序, 不可重复</li>
</ul>
<ol>
<li>ArrayList 底层是数组, 查询快, 修改,插入删除慢</li>
<li>LinkedList 底层是链表, 查询慢, 修改,插入,删除快</li>
<li>Vector: 线程安全的, 效率低</li>
<li></li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><ol>
<li><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1></li>
<li><p>无序键值对, 键唯一</p>
</li>
<li><p>Collection接口体系中一些常用的实现类有:</p>
<ul>
<li><strong>ArrayList</strong>: 实现了List接口, 它是以<strong>数组</strong>的方式来实现的, 数组的特性是可以使用索引的方式来快速定位对象的位置, 因此对于快速的随机访问, 使用ArrayList实现执行效率上会比较好; </li>
<li><strong>LinkedList</strong>: 是采用<strong>链表</strong>的方式来实现List接口的, 由于是采用链表实现的, 因此在进行 <code>insert</code> 和 <code>remove</code> 动作时在效率上要比 <code>ArrayList</code> 要好得多! 适合用来实现 <code>Stack(堆栈)</code> 与 <code>Queue(队列)</code>, 前者先进后出, 后者是先进先出<br>若要从数组中删除或插入某一个对象, 需要移动后面的数组元素, 从而会重新调整索引顺序, 调整索引顺序会消耗一定的时间, 所以速度上就会比LinkedList要慢许多; 相反, 若要从链表中删除或插入某一个对象, 只需要改变前后对象的引用即可!</li>
<li>Arraylist底层使用的是数组(存读数据效率高, 插入删除特定位置效率低), LinkedList底层使用的是双向循环链表数据结构(插入, 删除效率特别高)。学过数据结构这门课后我们就知道采用链表存储, 插入, 删除元素时间复杂度不受元素位置的影响, 都是近似O(1)而数组为近似O(n), 因此当数据特别多, 而且经常需要插入删除元素时建议选用LinkedList.一般程序只用Arraylist就够用了, 因为一般数据量都不会蛮大, Arraylist是使用最多的集合类。</li>
</ul>
</li>
<li><h2 id="Arraylist-与-LinkedList-异同"><a href="#Arraylist-与-LinkedList-异同" class="headerlink" title="Arraylist 与 LinkedList 异同"></a>Arraylist 与 LinkedList 异同</h2></li>
<li>相同点:<ul>
<li>ArrayList 和 LinkedList 都是不同步的, 也就是不保证线程安全;</li>
<li></li>
</ul>
</li>
<li>不同:<br> Arraylist 底层使用的是Object数组; LinkedList 底层使用的是双向链表数据结构(JDK1.6之前为循环链表, JDK1.7取消了循环。注意双向链表和双向循环链表的区别)</li>
<li><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2></li>
<li>Map是java集合的另一个根接口, Map体系中一些常用的实现类如下:<ul>
<li></li>
<li></li>
</ul>
</li>
</ol>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        

        
    </div>
    <footer>
        <a href="http://blog.renyimin.com">
            <img src="/img/avatar.jpeg" alt="Lant">
            Lant
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVASE/">JAVASE</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.renyimin.com/2018/12/19/JAVA/2018-12-19-22/&title=《22. JCF - Java集合框架》 — Lant's&pic=http://blog.renyimin.com/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.renyimin.com/2018/12/19/JAVA/2018-12-19-22/&title=《22. JCF - Java集合框架》 — Lant's&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.renyimin.com/2018/12/19/JAVA/2018-12-19-22/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《22. JCF - Java集合框架》 — Lant's&url=http://blog.renyimin.com/2018/12/19/JAVA/2018-12-19-22/&via=http://blog.renyimin.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.renyimin.com/2018/12/19/JAVA/2018-12-19-22/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
      <div class="waves-block waves-effect prev">
        <a href="/2018/12/18/JAVA/2018-12-18-20/" id="post-prev" class="post-nav-link">
          <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i>Prev </div>
          <h4 class="title">20. 数组</h4>
        </a>
      </div>
    
  
    <div class="waves-block waves-effect next">
      <a href="/2018/12/19/JAVA/2018-12-19-23/" id="post-next" class="post-nav-link">
        <div class="tips">Next<i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">23. HashMap 和 Hashtable 的区别</h4>
      </a>
    </div>
  
</nav>



    











<section class="comments" id="comments">
    <div id="gitment_thread"></div>
    <link rel="stylesheet" href="//unpkg.com/gitment/style/default.css">
    <script src="//unpkg.com/gitment/dist/gitment.browser.js"></script>
    <script>
        var gitment = new Gitment({
            owner: 'rymuscle',
            repo: 'rymuscle.github.io',
            oauth: {
                client_id: '49b906f6d47dbab8d929',
                client_secret: '17fd73f24f616a09d4c09bca9480e0deba75a9a2',
            },
        })
        gitment.render('comments')
    </script>
</section>




</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        赞赏支持
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="bottom">
        <p><span>Lant &copy; 2016 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.renyimin.com/2018/12/19/JAVA/2018-12-19-22/&title=《22. JCF - Java集合框架》 — Lant's&pic=http://blog.renyimin.com/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.renyimin.com/2018/12/19/JAVA/2018-12-19-22/&title=《22. JCF - Java集合框架》 — Lant's&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.renyimin.com/2018/12/19/JAVA/2018-12-19-22/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《22. JCF - Java集合框架》 — Lant's&url=http://blog.renyimin.com/2018/12/19/JAVA/2018-12-19-22/&via=http://blog.renyimin.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.renyimin.com/2018/12/19/JAVA/2018-12-19-22/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACL0lEQVR42u3aS07DUAwF0O5/02WKBE2v7RQR52SEICTvZGD593jE1/PF9f2vP+9PnnP8+5MvDAyMyzKeh1d+0OMn9N6V3I+BgXEfxqsIdnxPDqv+V342DAwMjPxleUqXBGIMDAyMHuO4+Eyqy94HwsDAwMgLy2qDLD9i3oY7oRbHwMC4IKOazP3lzx+Zb2BgYFyK8SxeeTCtFqh5kP3laRgYGKsZk7FikjLm7blk5Pkm9cTAwFjKqJapedmZBOI8NL9JWDEwMFYz8iWJfOiYH7S6qPEmQGNgYCxl5MXqZGBQHRuc1m7DwMBYx0jCaK/F32ux5W04DAyM3Yx8FWyyHhEtdcXxszlxxcDAuDhjMrCsJoKTEWZzvoGBgXFxRt58r5a4vbSvdz8GBsbdGJNE8KykM18yw8DAuANj3iwrhMW4lE0+EwYGxn0Y1TBXfVkeXkdDTQwMjNsw8oZXb9BYbeoVgjUGBsZqRvnPg+2sfObYS0kxMDDuw6i+YL7lkaeDhbUwDAyMdYzesXpDzWaZWs1zMTAwljKSJYneGGCyQJaXtRgYGLsZecHZGxWU1yYG58TAwNjHmDTxe4PPXqB/8zQMDIzVjF6Yy0PzpAyuPg0DA2M3Iy9We+E4CbIfqcUxMDDWMZLQ2RtV5iOE0YfAwMDAKIa/SfqYJ46jgIuBgbGaUV35Sj5B7x4MDIy7MXpFbJWdHDT/xKe12zAwMP49Iy8dJ8G3Gl57Cx8YGBjrGF+paR3zGwXhkgAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.6.13"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.6.13" async></script>










<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
