<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>12. JCF - Java集合框架 | Lant&#39;s</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="JavaSE">
    <meta name="description" content="JCF JCF(Java Collection Framework, Java集合框架) 是由一组精心设计的接口、类和隐含在其中的数据结构及算法所组成, 通过它们可以对Java对象进行存储、获取、操作和转换等功能; 所有的集合类都位于 java.util 包下, 后来为了处理多线程环境下的并发安全问题, java5还在 java.util.concurrent 包下提供了一些多线程支持的集合类 (">
<meta name="keywords" content="JavaSE">
<meta property="og:type" content="article">
<meta property="og:title" content="12. JCF - Java集合框架">
<meta property="og:url" content="http://blog.renyimin.com/2018/12/15/JavaSE/2018-12-15-12/index.html">
<meta property="og:site_name" content="Lant&#39;s">
<meta property="og:description" content="JCF JCF(Java Collection Framework, Java集合框架) 是由一组精心设计的接口、类和隐含在其中的数据结构及算法所组成, 通过它们可以对Java对象进行存储、获取、操作和转换等功能; 所有的集合类都位于 java.util 包下, 后来为了处理多线程环境下的并发安全问题, java5还在 java.util.concurrent 包下提供了一些多线程支持的集合类 (">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://blog.renyimin.com/img/javase/jcf-01.gif">
<meta property="og:updated_time" content="2019-01-30T06:33:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="12. JCF - Java集合框架">
<meta name="twitter:description" content="JCF JCF(Java Collection Framework, Java集合框架) 是由一组精心设计的接口、类和隐含在其中的数据结构及算法所组成, 通过它们可以对Java对象进行存储、获取、操作和转换等功能; 所有的集合类都位于 java.util 包下, 后来为了处理多线程环境下的并发安全问题, java5还在 java.util.concurrent 包下提供了一些多线程支持的集合类 (">
<meta name="twitter:image" content="http://blog.renyimin.com/img/javase/jcf-01.gif">
    
        <link rel="alternate" type="application/atom+xml" title="Lant&#39;s" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.6.13">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand4.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpeg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Lant</h5>
          <a href="mailto:18625036504@163.com" title="18625036504@163.com" class="mail">18625036504@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">12. JCF - Java集合框架</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h5 class="subtitle">
            
                <time datetime="2018-12-15T03:17:23.000Z" itemprop="datePublished" class="page-time">
  2018-12-15
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/JavaSE/">JavaSE</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#JCF"><span class="post-toc-number">1.</span> <span class="post-toc-text">JCF</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Collection接口"><span class="post-toc-number">2.</span> <span class="post-toc-text">Collection接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#List接口"><span class="post-toc-number">3.</span> <span class="post-toc-text">List接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ArrayList"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">ArrayList</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vector"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">Vector</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#LinkedList"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">LinkedList</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Queue接口"><span class="post-toc-number">4.</span> <span class="post-toc-text">Queue接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Deque接口"><span class="post-toc-number">5.</span> <span class="post-toc-text">Deque接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Set接口"><span class="post-toc-number">6.</span> <span class="post-toc-text">Set接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashSet"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">HashSet</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#LinkedHashSet"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">LinkedHashSet</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TreeSet"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">TreeSet</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#自然顺序-Comparable"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">自然顺序(Comparable)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定制排序"><span class="post-toc-number">6.5.</span> <span class="post-toc-text">定制排序 ??</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Map-接口"><span class="post-toc-number">7.</span> <span class="post-toc-text">Map 接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#小知识点"><span class="post-toc-number">8.</span> <span class="post-toc-text">小知识点</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-JavaSE/2018-12-15-12"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">12. JCF - Java集合框架</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-12-15 11:17:23" datetime="2018-12-15T03:17:23.000Z"  itemprop="datePublished">2018-12-15</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/JavaSE/">JavaSE</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="JCF"><a href="#JCF" class="headerlink" title="JCF"></a>JCF</h2><ol>
<li><p>JCF(Java Collection Framework, Java集合框架) 是由一组精心设计的接口、类和隐含在其中的数据结构及算法所组成, 通过它们可以对Java对象进行存储、获取、操作和转换等功能; 所有的集合类都位于 <code>java.util</code> 包下, 后来为了处理多线程环境下的并发安全问题, java5还在 <code>java.util.concurrent</code> 包下提供了一些多线程支持的集合类 (Java集合 也叫 Java容器)</p>
</li>
<li><p>常见的Java集合框架图<br> <img src="/img/javase/jcf-01.gif" width="500/"></p>
</li>
<li><p>点击查看<a href="/img/javase/JCF.png">Java 集合框架图</a></p>
</li>
<li><p>Java集合框架大体包含两种类型的容器: <code>Collection</code> 和 <code>Map</code>, 它们是Java集合框架的根接口</p>
<ul>
<li><code>Collection</code>: 一个独立元素的序列, 这些元素会遵循一定的规则</li>
<li><code>Map</code>: 一组成对的 “键值对” 对象, 允许你使用键来查找值</li>
</ul>
</li>
</ol>
<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><ol>
<li><p>Collection是最基本的集合接口, Collection 接口下又有 3 种子接口 <code>List</code>、<code>Set</code> 和 <code>Queue</code>, 再下面是一些抽象类, 最后是具体实现类,常用的有 <code>ArrayList</code>、<code>LinkedList</code>、<code>HashSet</code>、<code>LinkedHashSet</code>、<code>HashMap</code>、<code>LinkedHashMap</code> 等等</p>
</li>
<li><p>Collection中的几个主要实现类</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|Collection </span><br><span class="line">|   ├List           // 有序, 可重复</span><br><span class="line">|   │--├ArrayList</span><br><span class="line">|   │--├LinkedList </span><br><span class="line">|   │--└Vector </span><br><span class="line">|   │　    └Stack </span><br><span class="line">|   ├Set            // 无序, 不可重复</span><br><span class="line">|   │--├HashSet </span><br><span class="line">|   │--├TreeSet </span><br><span class="line">|   │--└LinkedSet </span><br><span class="line">|   │</span><br><span class="line">|   ├Queue</span><br><span class="line">|   │--├PriorityQueue</span><br><span class="line">|   │--├Deque</span><br><span class="line">|   │   ├ArrayDeque</span><br><span class="line">|   │   └LinkedList</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><ol>
<li><p>实现 List 接口的类: 可以用来存放 <strong>有序, 可重复</strong> 的一组对象, 能够通过索引(元素在List中位置, 类似于数组的下标)来访问List中的元素, 第一个元素的索引为0</p>
</li>
<li><p>List接口下常用的实现类有: <code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code>及其子类<code>Stack</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├List </span><br><span class="line">│--├ArrayList   // 底层用 数组 实现</span><br><span class="line">│--├LinkedList  // 底层用 双向循环链表 实现</span><br><span class="line">│--└Vector (已过时)</span><br><span class="line">│　    └Stack</span><br></pre></td></tr></table></figure>
</li>
<li><p>List接口是<strong>有序</strong>集合, 所以与Set接口相比, 增加了一些与索引位置相关的操作;</p>
</li>
</ol>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ol>
<li><p>底层使用的是数组, 它封装了一个动态增长的、允许再分配的 Object[] 数组 (允许包括 null 在内的所有元素)</p>
</li>
<li><p>由于 Arraylist 底层使用的是数组, 所以其 读取数据效率高,插入删除特定位置效率低</p>
</li>
<li><p>ArrayList 不是线程同步的, 即线程不安全</p>
</li>
</ol>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ol>
<li><p>Vector是一种老的动态数组, 与ArrayList一样都是基于数组实现, 它是线程同步的, 效率很低, 一般不赞成使用</p>
<blockquote>
<p>其实 ArrayList 和 Vector 在用法上完全相同, 但由于Vector是一个古老的集合(从jdk1.0就有了), 那时候java还没有提供系统的集合框架, 所以在Vector里提供了一些方法名很长的方法(例如:addElement(Object obj)), 实际上这个方法和add(Object obj)没什么区别;<br> 从jdk1.2以后, Java提供了系统的集合框架, 就将Vector改为实现List接口, 作为List的实现之一, 从而导致Vector里有一些重复的方法;<br> Vector里有一些功能重复的方法, 这些方法中方法名更短的是属于后来新增的方法, 更长的是原先vector的方法, 而后来ArrayList是作为List的主要实现类, 看过的Java思想编程中也提到了<strong>Vector有很多缺点, 尽量少用Vector实现类</strong></p>
</blockquote>
</li>
<li><p>Vector的子类 <code>Stack</code>: Stack类表示后进先出(LIFO)的对象堆栈; 由于 Vector是通过数组实现的, 这就意味着, Stack也是通过数组实现的, 而非链表</p>
</li>
<li><p><strong>与 ArrayList 的差异</strong></p>
<ul>
<li>Vector可以设置增长因子, 而ArrayList不可以 (类允许设置默认的增长长度, 默认扩容方式为原来的2倍)</li>
<li>Vector的方法都是同步的(Synchronized), 是线程安全的(thread-safe), 而ArrayList的方法不是, 由于线程的同步必然要影响性能, 因此, ArrayList的性能比Vector好</li>
</ul>
</li>
</ol>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ol>
<li><p>LinkedList 底层使用的是双向循环链表数据结构(插入, 删除效率特别高)</p>
</li>
<li><p>LinkedList 实现了List接口, 允许 <code>null</code> 元素, 此外LinkedList提供额外的get, remove, insert方法在LinkedList的首部或尾部, <strong>这些操作使LinkedList可被用作堆栈(stack), 队列(queue)或双向队列(deque)</strong></p>
</li>
<li><p>当数据特别多, 而且经常需要插入删除元素时建议选用 LinkedList; 一般程序只用Arraylist就够用了, 因为一般数据量都不会蛮大, Arraylist是使用最多的集合类</p>
</li>
<li><p>注意: LinkedList没有同步方法, 如果多个线程同时访问一个List, 则必须自己实现访问同步, 一种解决方法是在创建List时构造一个同步的List:  <code>List list = Collections.synchronizedList(new LinkedList(…));</code></p>
</li>
<li><p><strong>与 ArrayList 的差异</strong></p>
<ul>
<li>Arraylist 底层使用的是数组(存读数据效率高, 插入删除特定位置效率低), LinkedList底层使用的是双向循环链表数据结构(插入, 删除效率特别高)</li>
<li>在各种Lists中, 最好的做法是以ArrayList作为缺省选择; 当插入、删除频繁时, 使用LinkedList();</li>
</ul>
</li>
</ol>
<h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><ol>
<li><p>用于模拟 队列 这种数据结构, 实现 <code>FIFO</code> 等数据结构; 通常, 队列不允许随机访问队列中的元素;</p>
</li>
<li><p>Queue 接口并未定义阻塞队列的方法, 但这在方法并发编程中是很常见的, 因此Queue的子接口 <code>BlockingQueue接口</code> 定义了那些等待元素出现或等待队列中有可用空间的方法, 这些方法扩展了此接口;</p>
</li>
<li><p>Queue 实现通常不允许插入 null 元素, 尽管某些实现(如 LinkedList)并不禁止插入 null, 即使在允许 null 的实现中, 也不应该将 null 插入到 Queue 中, 因为 null 也用作 poll 方法的一个特殊返回值, 表明队列不包含元素;</p>
</li>
</ol>
<h2 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque接口"></a>Deque接口</h2><ol>
<li><p>Deque 是 Queue 的子接口, 提供了 LIFO 堆栈操作更完整和更一致的集合, Queue是一种队列形式, 而Deque则是双向队列,它支持从两个端点方向检索和插入元素</p>
</li>
<li><p>Deque接口是一种比 Stack和Vector 更为丰富的抽象数据形式, 因为它同时实现了以上两者, 应该优先使用此集合, 而非Stack类</p>
<blockquote>
<p>Vector类 和 Stack类 这两个都是jdk1.0的过时API, <strong>应该避免使用</strong><br> jdk1.5新增了很多多线程情况下使用的集合类, 位于java.util.concurrent<br> 如果你说, Vector是同步的, 你要在多线程使用, 那你应该使用 java.util.concurrent.CopyOnWriteArrayList 等, 而不是Vector<br> 如果你要使用Stack做类似的业务, 那么非线程的你可以选择linkedList, 多线程情况你可以选择 java.util.concurrent.ConcurrentLinkedDeque 或者java.util.concurrent.ConcurrentLinkedQueue</p>
</blockquote>
</li>
<li><p>同Queue一样, Deque的实现也可以划分成 通用实现 和 并发实现, 通用实现主要有两个实现类 <code>ArrayDeque</code> 和 <code>LinkedList</code></p>
</li>
<li><p>ArrayDeque 是个可变数组, 它是在Java 6之后新添加的, 而LinkedList是一种链表结构的list</p>
<ul>
<li>LinkedList要比ArrayDeque更加灵活, 因为它也实现了List接口的所有操作, 并且可以插入null元素, 这在ArrayDeque中是不允许的</li>
<li><p>从效率来看, ArrayDeque要比LinkedList在两端增删元素上更为高效, 因为没有在节点创建删除上的开销</p>
</li>
<li><p>最适合使用LinkedList的情况是迭代队列时删除当前迭代的元素<br>此外LinkedList可能是在遍历元素时最差的数据结构, 并且 LinkedList 也占用更多的内存(因为LinkedList是通过链表连接其整个队列)</p>
</li>
<li><p>总体ArrayDeque要比LinkedList更优越, 在大队列的测试上有3倍与LinkedList的性能, 最好的是给ArrayDeque一个较大的初始化大小, 以避免底层数组扩容时数据拷贝的开销</p>
</li>
<li><p>LinkedBlockingDeque是Deque的并发实现, 在队列为空的时候, 它的takeFirst, takeLast会阻塞等待队列处于可用状态</p>
</li>
</ul>
</li>
<li><p>多线程情况下, 应尽量使用java.util.concurrent包下的类;</p>
</li>
<li><p>摘自: <a href="https://www.cnblogs.com/devin-ou/p/7989451.html" target="_blank" rel="noopener">https://www.cnblogs.com/devin-ou/p/7989451.html</a></p>
</li>
</ol>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><ol>
<li><p>Set 接口存储一组 <strong>唯一, 无序</strong>的对象</p>
</li>
<li><p>Set接口下我们通常使用的实现类有: <code>HashSet</code>, <code>TreeSet</code>, <code>LinkedSet</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├Set</span><br><span class="line">│--├HashSet </span><br><span class="line">│--├TreeSet </span><br><span class="line">│--└LinkedSet</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ol>
<li><p>HashSet是Set接口的典型实现, HashSet使用HASH算法来存储集合中的元素, 因此<strong>具有良好的存取和查找性能</strong></p>
<ul>
<li>HashSet不允许出现重复元素, 不保证集合中元素的顺序, 允许包含值为 null 的元素,但最多只能一个(当然了, 元素不能重复)</li>
<li>HashSet不是同步的, 多线程访问同一步HashSet对象时, 需要手工同步 </li>
<li>内部使用 <code>HashMap</code> 来存储数据, 数据存储在 HashMap 的 key中</li>
</ul>
</li>
<li><p>HashSet集合判断两个元素相等的标准</p>
<ul>
<li>通过 <code>hashCode()</code> 检查 HashSet 对应位置是否有值<br>没有值, 则将元素对象直接存入<br>有值, 需要使用 <code>equals()</code> 检测两个对象是否相等, 如果相等则不放入 </li>
<li>如果 HashSet 对应位置 有值, 但是 <code>equals()</code> 不相等?<br>正常情况下, 我们要保证 <code>hashCode()</code> 和 <code>equals()</code> 是同步的 (即, hashcode()相同时, 对应位置的元素与当前元素通过 <code>equals()</code> 的结果也应该是相同的) </li>
</ul>
</li>
<li><p>如果要将自定义的类的对象, 添加到HashSet集合中, 需要为自定义类提供 <code>equals()</code> 和 <code>hashCode()</code> 两个方法的重写, 否则, 属性相同的两个对象会存多个到HashSet中 ((像String等类已经提供并重写了这两个方法, 所以你可以直接往set中存储字符串))</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class hset &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set hashSet = new HashSet();</span><br><span class="line">        hashSet.add(&quot;AAA&quot;);</span><br><span class="line">        hashSet.add(&quot;BBB&quot;);</span><br><span class="line">        hashSet.add(123);</span><br><span class="line">        hashSet.add(new Person(&quot;rym&quot;, 100));</span><br><span class="line">        hashSet.add(new Person(&quot;rym&quot;, 100));</span><br><span class="line">        Person p = new Person(&quot;rym&quot;, 100);</span><br><span class="line">        hashSet.add(p);</span><br><span class="line">        hashSet.add(p);</span><br><span class="line">        // 如果Person类中缺少任何一个方法, hashSet结果都是 6 个元素</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public Person(String name, Integer age)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        return Objects.equals(name, person.name) &amp;&amp;</span><br><span class="line">                Objects.equals(age, person.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line"></span><br><span class="line">        return Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HashSet几个重要的方法</p>
<ul>
<li><p><code>add(E e)</code> : HashSet的确定性(也可以理解为唯一性), 是通过 HashMap 的 put方法 来保证的, 往HashMap中put数据时, 如果key是一样的, 只会替换key对应的value, 不会新插入一条数据; 所以往HashSet中add相同的元素没有什么用, 这里的相同是通过equals方法保证的, 具体的在HashMap中细说</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E var1) &#123;</span><br><span class="line">    return this.map.put(var1, PRESENT) == null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>remove(Object o)</code> : 简单粗暴, 从HashMap中移除一条数据  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object var1) &#123;</span><br><span class="line">    return this.map.remove(var1) == PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>contains(Object o)</code> </p>
</li>
<li><code>iterator()</code></li>
<li>其他的方法诸如: <code>size()</code>、<code>isEmpty()</code>、<code>contains()</code>、<code>clear()</code> 等都完全委托给了HashMap, 需要注意的是: HashSet没有提供set、get等方法;</li>
</ul>
</li>
</ol>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><ol>
<li><p>LinkedHashSet 继承自 HashSet, 内部使用的是 <code>LinkHashMap</code> (使得LinkedHashSet中的元素顺序是可以保证的, 即 遍历序 和 插入序 一致, HashSet 和 HashMap 都不保证顺序, Linkxxx 能使用链表保证顺序)</p>
</li>
<li><p>相比 HashSet, LinkedHashSet 在迭代访问Set中的全部元素时, 性能比HashSet好(HashSet每个元素都需要用hashcode映射, 而LinkedHashed直接可以通过链表指针遍历即可), 但是插入时性能稍微逊色于HashSet(因为LinkedHashSet还要维护链表来保证遍历顺序和插入顺序一致)</p>
</li>
<li><p>和 HashSet 一样需要依赖 <code>hashCode()</code> 和 <code>equals()</code> 方法保证元素的唯一性</p>
</li>
<li><p>LinkedHashSet 非线程安全</p>
</li>
</ol>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ol>
<li><p>TreeSet 是 Set 的一个子类, TreeSet集合可以用来对 对象元素 进行排序, 同样它也可以保证元素的唯一性</p>
</li>
<li><p>TreeSet集合 添加元素报错:</p>
<ul>
<li><p>如下, 会报类型转换异常 <code>Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set treeSet = new TreeSet();</span><br><span class="line">treeSet.add(123);</span><br><span class="line">treeSet.add(&quot;AAA&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义类会报异常: <code>Exception in thread &quot;main&quot; java.lang.ClassCastException: Person cannot be cast to java.lang.Comparable</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set treeSet = new TreeSet();</span><br><span class="line">treeSet.add(new Person(&quot;renyimin&quot;, 100));</span><br><span class="line">treeSet.add(new Student(&quot;renyimin&quot;, 100));</span><br><span class="line">System.out.println(treeSet);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>上述原因在于我们没有告诉TreeSet如何来对元素进行比较, 如果不指定, 就会抛出这个异常</p>
</li>
<li><p>TreeSet的内部操作的底层数据是 <code>TreeMap</code> (只是我们操作的是 TreeMap的key)</p>
</li>
<li><p>在对大量信息进行检索的时候, TreeSet 比 ArrayList 更有效率, 能保证在log(n)的时间内完成 ( ?? 不对啊, arraylist的随机读取不是O(1)么?? <strong>其实这句话的意思是, 当你不知道索引时, 查找一个元素, TreeSet自然是O(log(n)), 而ArrayList在不指定索引时, 如果没有搜索算法, 自然是log(n)</strong>) </p>
<ul>
<li>TreeSet 是用树形结构来存储信息的, 每个节点都会保存一下指针对象, 分别指向父节点, 左分支, 右分支, 相比较而言, ArrayList就是一个含有元素的简单数组了, 正因为如此, 它占的内存也要比ArrayList多一些;</li>
<li>向 TreeSet 插入元素也比 ArrayList 要快一些, 因为当元素插入到ArrayList的任意位置时, 平均每次要移动一半的列表, 需要O(n)的时间, 而TreeSet深度遍历查询花费的实施只需要O(log(n))</li>
</ul>
</li>
</ol>
<h3 id="自然顺序-Comparable"><a href="#自然顺序-Comparable" class="headerlink" title="自然顺序(Comparable)"></a>自然顺序(Comparable)</h3><ol>
<li><p>对象所对应的类必须实现 <code>java.lang.Comparable</code> 接口, 并重写 <code>compareTo(Object obj)</code></p>
</li>
<li><p><code>compareTo()</code> 方法的返回值说明: 在此方法中指明用自定义类的哪个属性进行排序, 当向TreeSet中添加元素时, 首先按照 compareTo() 进行比较, 一旦返回0, 虽然可能只是compareTo()方法中比较的这个元素相同, 但程序会认为这两个对象是相同的, 后一个对象就不会添加进来</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public int compareTo(Person o) &#123;</span><br><span class="line">    return 0;                //当compareTo方法返回0的时候集合中只有一个元素</span><br><span class="line">    return 1;                //当compareTo方法返回正数的时候集合会怎么存就怎么取</span><br><span class="line">    return -1;               //当compareTo方法返回负数的时候集合会倒序存储</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么返回0, 只会存一个元素, 返回-1会倒序存储, 返回1会怎么存就怎么取呢?</p>
<blockquote>
<p>原因在于TreeSet底层其实是一个二叉树结构, 且每插入一个新元素(第一个除外)都会调用<code>compareTo()</code>方法去和上一个插入的元素作比较, 并按二叉树的结构进行排列:</p>
<ul>
<li>如果将<code>compareTo()</code>返回值写死为0, 元素值每次比较, 都认为是相同的元素, 这时就不再向TreeSet中插入除第一个外的新元素, 所以TreeSet中就只存在插入的第一个元素</li>
<li>如果将<code>compareTo()</code>返回值写死为1, 元素值每次比较, 都认为新插入的元素比上一个元素大, 于是二叉树存储时, 会存在根的右侧, 读取时就是正序排列的</li>
<li>如果将<code>compareTo()</code>返回值写死为-1, 元素值每次比较, 都认为新插入的元素比上一个元素小, 于是二叉树存储时, 会存在根的左侧, 读取时就是倒序序排列的</li>
</ul>
</blockquote>
</li>
<li><p><code>compareTo()</code> 、<code>hashCode()</code>、<code>equals()</code> 三者要保持一致<br> 与HashSet不同, TreeSet插入元素时的判断标准其实只需要实现Comparable接口的compareTo()方法就可以了, 但是一般情况了, 推荐同时重写实现equals()这个方法, 原因在于 我们无法确认后面 会不会用到equals()方法, 比如可能会要把这个类的实例加入到HashSet中? 这是可能出现的; 另外, 我们当然不希望出现compareTo()方法得到的结果为0, 但是equals()方法得到的却是flase这样的奇怪情况出现, 所以一般实现compareTo()时会同时重写equals()来保证两个方法的结果一致, 不产生冲突。</p>
</li>
<li><p>示例:</p>
<ul>
<li>按照年龄来排序:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class hset &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set treeSet = new TreeSet();</span><br><span class="line">        // 两个age相同, name差为负数, 所以结果会倒序</span><br><span class="line">        Person p1 = new Person(&quot;rym&quot;, 100);</span><br><span class="line">        Person p2 = new Person(&quot;aym&quot;, 100);</span><br><span class="line">        treeSet.add(p1);</span><br><span class="line">        treeSet.add(p2);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person implements Comparable&lt;Person&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public Person(String name, Integer age)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Person o) &#123;</span><br><span class="line">        int num = this.age - o.age; // 年龄是比较的主要条件</span><br><span class="line">        return num == 0 ? this.name.compareTo(o.name) : num;    //姓名是比较的次要条件</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        return Objects.equals(name, person.name) &amp;&amp;</span><br><span class="line">                Objects.equals(age, person.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序 ??"></a>定制排序 ??</h3><ol>
<li>类需要实现 Comparator接口 </li>
<li>需要重写 compare() 方法, 指明是按照哪个属性进行排序的</li>
<li>示例 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class hset &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1.创建一个实现了Comparator接口类的对象</span><br><span class="line">        Comparator com = new Comparator() &#123;</span><br><span class="line">            //2.向TreeSet中添加Person类的对象，在此compare()方法中，指明是按照Customer的哪个属性进行排序的</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Object o1, Object o2) &#123;</span><br><span class="line">                if(o1 instanceof Person &amp;&amp; o2 instanceof Person)&#123;</span><br><span class="line">                    Person p1 = (Person)o1;</span><br><span class="line">                    Person p2 = (Person)o2;</span><br><span class="line">                    int i = p1.getAge().compareTo(p2.getAge());</span><br><span class="line">                    if(i == 0)&#123;</span><br><span class="line">                        return p1.getName().compareTo(p2.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    return i;</span><br><span class="line">                &#125;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //3.将此对象作为形参传递给TreeSet的构造器中</span><br><span class="line">        TreeSet&lt;Person&gt; set = new TreeSet&lt;Person&gt;(com);</span><br><span class="line">        //4.向TreeSet中添加Comparator接口中的compare方法中涉及的类的对象</span><br><span class="line">        Person p1 = new Person(&quot;rym&quot;, 100);</span><br><span class="line">        Person p2 = new Person(&quot;aym&quot;, 100);</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person implements Comparable&lt;Person&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public Person(String name, Integer age)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Person o) &#123;</span><br><span class="line">        int num = this.age - o.age; // 年龄是比较的主要条件</span><br><span class="line">        return num == 0 ? this.name.compareTo(o.name) : num;    //姓名是比较的次要条件</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        return Objects.equals(name, person.name) &amp;&amp;</span><br><span class="line">                Objects.equals(age, person.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h2><ol>
<li><p>用Key来搜索的专家, 使用键值对存储; Map会维护与Key有关联的值, 两个Key可以引用相同的对象, 但Key不能重复, 典型的Key是String类型, 但也可以是任何对象;</p>
</li>
<li><p>Java 自带了各种 Map 类, 这些 Map 类可归为三种类型</p>
<ul>
<li><p>通用Map: 用于在应用程序中管理映射, 通常在 <code>java.util</code> 程序包中实现<br>HashMap、Hashtable、Properties、LinkedHashMap、IdentityHashMap、TreeMap、WeakHashMap、ConcurrentHashMap</p>
</li>
<li><p>专用Map: 通常我们不必亲自创建此类Map, 而是通过某些其他类对其进行访问<br>java.util.jar.Attributes、javax.print.attribute.standard.PrinterStateReasons、java.security.Provider、java.awt.RenderingHints、javax.swing.UIDefaults</p>
</li>
<li><p>自行实现Map: 一个用于帮助我们实现自己的Map类的抽象类<br>AbstractMap</p>
</li>
</ul>
</li>
<li><p>类型区别</p>
<ul>
<li><p>HashMap: 最常用的Map, 它根据键的HashCode值存储数据, 根据键可以直接获取它的值, 具有很快的访问速度; HashMap最多只允许一条记录的键为Null(多条会覆盖), 允许多条记录的值为 Null, 非同步</p>
</li>
<li><p>TreeMap: 能够把它保存的记录根据键(key)排序, 默认是按升序排序, 也可以指定排序的比较器, 当用Iterator 遍历TreeMap时, 得到的记录是排过序的; TreeMap不允许key的值为null, 非同步</p>
</li>
<li><p>Hashtable: 与 HashMap类似, 不同的是:key和value的值均不允许为null; 它支持线程的同步, 即任一时刻只有一个线程能写Hashtable, 因此也导致了Hashtale在写入时会比较慢</p>
</li>
<li><p>LinkedHashMap: 保存了记录的插入顺序, 在用Iterator遍历LinkedHashMap时, 先得到的记录肯定是先插入的, 在遍历的时候会比HashMap慢, key和value均允许为空, 非同步的</p>
</li>
</ul>
</li>
<li><p>摘自: <a href="https://baike.xsoftlab.net/view/250.html#paragraph_1" target="_blank" rel="noopener">https://baike.xsoftlab.net/view/250.html#paragraph_1</a></p>
</li>
</ol>
<h2 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h2><ol>
<li><p>Java容器里只能放对象, 对于基本类型(int, long, float, double等), 需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里, 很多时候拆包装和解包装能够自动完成, 这虽然会导致额外的性能和空间开销, 但简化了设计和编程;</p>
</li>
<li><p>集合与数组</p>
<ul>
<li>数组: 大小固定, 只能存储相同数据类型的数据; 数组存储的元素可以是同一类基本类型, 也可以是同一类对象;</li>
<li>集合: 大小可动态扩展, 可以存储不同类型的数据; 集合里只能保存对象;<br>在编程中, 常常需要集中存放多个数据, 虽然数组是个不错的选择, 但数组需要你事先明确知道你将要保存的对象的数量, 数组在初始化时就会指定长度, 并且之后这个数组长度是不可变的;<br>而如果我们需要保存动态增长的数据, 就无法再使用数组了, 此时, java的集合类就是一个很好的设计方案了</li>
</ul>
</li>
</ol>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        

        
    </div>
    <footer>
        <a href="http://blog.renyimin.com">
            <img src="/img/avatar.jpeg" alt="Lant">
            Lant
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaSE/">JavaSE</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.renyimin.com/2018/12/15/JavaSE/2018-12-15-12/&title=《12. JCF - Java集合框架》 — Lant's&pic=http://blog.renyimin.com/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.renyimin.com/2018/12/15/JavaSE/2018-12-15-12/&title=《12. JCF - Java集合框架》 — Lant's&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.renyimin.com/2018/12/15/JavaSE/2018-12-15-12/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《12. JCF - Java集合框架》 — Lant's&url=http://blog.renyimin.com/2018/12/15/JavaSE/2018-12-15-12/&via=http://blog.renyimin.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.renyimin.com/2018/12/15/JavaSE/2018-12-15-12/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
      <div class="waves-block waves-effect prev">
        <a href="/2018/12/15/JavaEE/2019-01-28-01/" id="post-prev" class="post-nav-link">
          <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i>Prev </div>
          <h4 class="title">01. Intellij IDEA 搭建Spring Boot项目</h4>
        </a>
      </div>
    
  
    <div class="waves-block waves-effect next">
      <a href="/2018/12/16/git/2018-12-16-04/" id="post-next" class="post-nav-link">
        <div class="tips">Next<i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">04. git stash</h4>
      </a>
    </div>
  
</nav>



    











<section class="comments" id="comments">
    <div id="gitment_thread"></div>
    <link rel="stylesheet" href="//unpkg.com/gitment/style/default.css">
    <script src="//unpkg.com/gitment/dist/gitment.browser.js"></script>
    <script>
        var gitment = new Gitment({
            owner: 'rymuscle',
            repo: 'rymuscle.github.io',
            oauth: {
                client_id: '49b906f6d47dbab8d929',
                client_secret: '17fd73f24f616a09d4c09bca9480e0deba75a9a2',
            },
        })
        gitment.render('comments')
    </script>
</section>




</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        赞赏支持
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="bottom">
        <p><span>Lant &copy; 2016 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.renyimin.com/2018/12/15/JavaSE/2018-12-15-12/&title=《12. JCF - Java集合框架》 — Lant's&pic=http://blog.renyimin.com/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.renyimin.com/2018/12/15/JavaSE/2018-12-15-12/&title=《12. JCF - Java集合框架》 — Lant's&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.renyimin.com/2018/12/15/JavaSE/2018-12-15-12/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《12. JCF - Java集合框架》 — Lant's&url=http://blog.renyimin.com/2018/12/15/JavaSE/2018-12-15-12/&via=http://blog.renyimin.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.renyimin.com/2018/12/15/JavaSE/2018-12-15-12/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACIUlEQVR42u3aSW7DMBAEQP//08kDjMjdQzmAyNIpQCyZpcN4ttcrvn7eruv/Xn/+/d7357y+cWFgYDyWkXz99Rckd+VPbp+AgYFxDiMJhUnEy8P09V352TAwMDCSBG4lKUzCMQYGBsYKoy1Tk/CNgYGBsVLE5k2x68bc+ivDwMA4jZF33f//76/MNzAwMB7F+Cmv65B6bypZnAoDA2NrRtv0n/ESTJv2YWBgnMnID5Qkc7N72yWPV/v+MDAwHstojzVr9LcLZ8OWHwYGxnaMvAWfp3H3JnzFLwYGBsamjLsa97Ox4uyX4c9vwcDA2JqxXojOXkr+hLoix8DA2Ihx77JXcrjZ+tcHMAYGxtaMWWtsFljbojd5BRgYGCcw/qfsXMnfbtsWwcDAeCwjCbWzdHAlsUtabBgYGOcw8uSvDYv5SLIdnf6ZGmJgYGzKuHfNog3idw0PMDAwTmCsr1O0IbttwxVJJwYGxgGM/GpDcHvXDImBgbErYxZeW95d6eaHphsGBsbWjFmKlrfYZk234XgAAwNjU0a7ftEe9PqVzZp3RRWOgYHxWMascE3C30qZWlMxMDC2ZrTl4jUpTwHbUN4OODEwMPZjrKxEtAF3JQWsa3EMDIztGHngu+vQs5HAh1IWAwMDYyGZS0akbVgvJhUYGBjHM2ajzbzCjhp5GBgYBzDy5a18tDBbpEiSRQwMjNMY3w6j64XrypgBAwPj4YxfrWCTYQUGiaIAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.6.13"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.6.13" async></script>










<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
