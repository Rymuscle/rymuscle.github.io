<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>05.镜像 - Dockerfile常见指令详解 | Lant&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Docker">
    <meta name="description" content="FROM 指定基础镜像 所谓定制镜像, 是以一个镜像为基础, 在其上进行定制。FROM 就用来指定基础镜像, 因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 格式: FROM 镜像名[:标签]  MAINTAINER 指定镜像的作者和联系方式信息(执行docker inspect image 输出中有相应的字段记录该信息) 格式:MAINTAINER autho">
<meta name="keywords" content="Docker">
<meta property="og:type" content="article">
<meta property="og:title" content="05.镜像 - Dockerfile常见指令详解">
<meta property="og:url" content="http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/index.html">
<meta property="og:site_name" content="Lant&#39;s Blog">
<meta property="og:description" content="FROM 指定基础镜像 所谓定制镜像, 是以一个镜像为基础, 在其上进行定制。FROM 就用来指定基础镜像, 因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 格式: FROM 镜像名[:标签]  MAINTAINER 指定镜像的作者和联系方式信息(执行docker inspect image 输出中有相应的字段记录该信息) 格式:MAINTAINER autho">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-03-13T12:47:06.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="05.镜像 - Dockerfile常见指令详解">
<meta name="twitter:description" content="FROM 指定基础镜像 所谓定制镜像, 是以一个镜像为基础, 在其上进行定制。FROM 就用来指定基础镜像, 因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 格式: FROM 镜像名[:标签]  MAINTAINER 指定镜像的作者和联系方式信息(执行docker inspect image 输出中有相应的字段记录该信息) 格式:MAINTAINER autho">
    
        <link rel="alternate" type="application/atom+xml" title="Lant&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.6.13">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpeg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Lant</h5>
          <a href="mailto:564613464@qq.com" title="564613464@qq.com" class="mail">564613464@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/rymuscle" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">05.镜像 - Dockerfile常见指令详解</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">05.镜像 - Dockerfile常见指令详解</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-10-13T02:25:07.000Z" itemprop="datePublished" class="page-time">
  2017-10-13
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Docker/">Docker</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FROM-指定基础镜像"><span class="post-toc-number">1.</span> <span class="post-toc-text">FROM 指定基础镜像</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#MAINTAINER"><span class="post-toc-number">2.</span> <span class="post-toc-text">MAINTAINER</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#RUN-执行命令"><span class="post-toc-number">3.</span> <span class="post-toc-text">RUN 执行命令</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ENV-设置环境变量"><span class="post-toc-number">4.</span> <span class="post-toc-text">ENV 设置环境变量</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ARG-构建参数"><span class="post-toc-number">5.</span> <span class="post-toc-text">ARG 构建参数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#WORKDIR-切换工作目录"><span class="post-toc-number">6.</span> <span class="post-toc-text">WORKDIR 切换工作目录</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#USER-指定当前用户"><span class="post-toc-number">7.</span> <span class="post-toc-text">USER 指定当前用户</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#VOLUME-定义匿名卷"><span class="post-toc-number">8.</span> <span class="post-toc-text">VOLUME 定义匿名卷</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#EXPOSE-声明端口"><span class="post-toc-number">9.</span> <span class="post-toc-text">EXPOSE 声明端口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CMD-容器启动命令"><span class="post-toc-number">10.</span> <span class="post-toc-text">CMD 容器启动命令</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ENTRYPOINT-入口点"><span class="post-toc-number">11.</span> <span class="post-toc-text">ENTRYPOINT 入口点</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#COPY-复制文件"><span class="post-toc-number">12.</span> <span class="post-toc-text">COPY 复制文件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ADD-更高级的复制文件"><span class="post-toc-number">13.</span> <span class="post-toc-text">ADD 更高级的复制文件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HEALTHCHECK-健康检查"><span class="post-toc-number">14.</span> <span class="post-toc-text">HEALTHCHECK 健康检查</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ONBUILD-为他人做嫁衣裳"><span class="post-toc-number">15.</span> <span class="post-toc-text">ONBUILD 为他人做嫁衣裳</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-docker/2017-10-13-05-docker"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">05.镜像 - Dockerfile常见指令详解</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-10-13 10:25:07" datetime="2017-10-13T02:25:07.000Z"  itemprop="datePublished">2017-10-13</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Docker/">Docker</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h2><ol>
<li>所谓定制镜像, <strong>是以一个镜像为基础, 在其上进行定制</strong>。<code>FROM</code> 就用来指定基础镜像, 因此一个 Dockerfile 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</li>
<li>格式: <code>FROM 镜像名[:标签]</code></li>
</ol>
<h2 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h2><ol>
<li>指定镜像的作者和联系方式信息(执行<code>docker inspect image</code> 输出中有相应的字段记录该信息)</li>
<li>格式:<code>MAINTAINER author &quot;e-mail&quot;</code> 指定作者名和E-mail</li>
</ol>
<h2 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h2><ol>
<li><p><code>RUN</code>指令是用来执行<code>命令行命令</code>的。(由于命令行的强大能力, RUN指令在定制镜像时是最常用的指令之一)</p>
</li>
<li><p>其格式有两种：</p>
<ul>
<li>shell 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样, 如: <code>RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code></li>
<li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code> , 这更像是函数调用中的格式, 如: <code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code>。</li>
</ul>
</li>
<li><p>虽然RUN就像Shell脚本一样可以执行命但是我们也不能像Shell脚本一样把每个命令对应一个RUN, 因为每一个RUN的行为, 就像手工建立commit镜像的过程一样:新建立一层，在其上执行这些命令, 执行结束后, commit 这一层的修改, 构成新的镜像。</p>
<ul>
<li><p>像下面的这种写法，创建了 7 层镜像, 这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。<strong>结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。这是很多初学 Docker 的人常犯的一个错误</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN apt-get update</div><div class="line">RUN apt-get install -y gcc libc6-dev make</div><div class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</div><div class="line">RUN mkdir -p /usr/src/redis</div><div class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</div><div class="line">RUN make -C /usr/src/redis</div><div class="line">RUN make -C /usr/src/redis install</div></pre></td></tr></table></figure>
</li>
<li><p>上面的 Dockerfile 正确的写法应该是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN buildDeps=&apos;gcc libc6-dev make&apos; \</div><div class="line">    &amp;&amp; apt-get update \</div><div class="line">    &amp;&amp; apt-get install -y $buildDeps \</div><div class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \</div><div class="line">    &amp;&amp; mkdir -p /usr/src/redis \</div><div class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</div><div class="line">    &amp;&amp; make -C /usr/src/redis \</div><div class="line">    &amp;&amp; make -C /usr/src/redis install \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</div><div class="line">    &amp;&amp; rm redis.tar.gz \</div><div class="line">    &amp;&amp; rm -r /usr/src/redis \</div><div class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</div></pre></td></tr></table></figure>
<blockquote>
<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层, 这只是一层的事情。<br><strong>在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建</strong>。<br>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，因为<strong>镜像是多层存储，每一层的东西并不会在下一层被删除</strong>，会一直跟随着镜像。<br>因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h2><ol>
<li>这个指令很简单,就是设置环境变量而已,无论是后面的其它指令,如RUN,还是运行时的应用,都可以直接使用这里定义的环境变量。</li>
<li><code>ENV</code>设置环境变量格式有两种:<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
</li>
<li>下面例子中演示了”设置环境变量”, “如何换行”, 以及对”含有空格的值用双引号括起来”的办法, 这和Shell下的行为是一致的 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ENV VERSION=1.0 DEBUG=on \</div><div class="line">NAME=&quot;Happy Feet&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h2><ol>
<li><p>构建参数和ENV的效果一样, 都是设置环境变量。所不同的是,<code>ARG</code>所设置的环境变量,在将来容器运行时是<strong>不会存在</strong>这些环境变量的;但是不要因此就使用ARG保存密码之类的信息, 因为 <code>docker history</code> 还是可以看到所有值的;</p>
</li>
<li><p>Dockerfile 中的ARG指令是定义参数名称及其默认值, 该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖</p>
</li>
<li><p>格式: <code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
</li>
</ol>
<h2 id="WORKDIR-切换工作目录"><a href="#WORKDIR-切换工作目录" class="headerlink" title="WORKDIR 切换工作目录"></a>WORKDIR 切换工作目录</h2><ol>
<li>使用 <code>WORKDIR</code> 指令可以来指定接下来之后各层的工作目录, <strong>如该目录不存在, WORKDIR 会帮你建立目录</strong>。</li>
<li>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code></li>
<li><p>之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写, 这种错误的理解还可能会导致出现下面这样的错误:</p>
<ul>
<li><p>如果将下面这个 Dockerfile 进行构建镜像运行后, 会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 hello </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RUN cd /app #第一层 `RUN cd /app` 的执行仅仅是当前进程的工作目录变更, 一个内存上的变化而已, 其结果不会造成任何文件变更。</div><div class="line">RUN echo &quot;hello&quot; &gt; world.txt #而到第二层的时候, 启动的是一个全新的容器, 跟第一层的容器更完全没关系, 自然不可能继承前一层构建过程中的内存变化</div></pre></td></tr></table></figure>
</li>
<li><p>原因其实很简单, 在Shell中, 上面连续的两行是同一个进程执行环境, 而在 Dockerfile 中, 这两行 RUN 命令的执行环境根本不同, 是两个完全不同的容器。(这就是对 Dokerfile 构建分层存储的概念不了解所导致的错误)</p>
</li>
<li>之前说过每一个RUN都是启动一个容器、执行命令、然后提交存储层文件变更</li>
</ul>
</li>
</ol>
<h2 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h2><ol>
<li><p><code>USER</code> 指令和 WORKDIR 相似, <strong>都是改变环境状态并影响以后的层</strong> (<code>WORKDIR</code>是改变工作目录, 而<code>USER</code>则是改变之后层执行RUN,CMD以及ENTRYPOINT这类命令时的身份)。</p>
</li>
<li><p>格式: <code>USER &lt;用户名&gt;</code></p>
</li>
<li><p>注意: USER只是帮助你切换到指定用户而已, <strong>这个用户必须是事先建立好的, 否则无法切换</strong>。</p>
</li>
<li><p>如果以root执行的脚本, 在执行期间希望改变身份, 比如希望以某个已经建立好的用户来运行某个服务进程, 不要使用 <code>su</code> 或者 <code>sudo</code>, 这些都需要比较麻烦的配置, 而且在TTY缺失的环境下经常出错。</p>
<ul>
<li>建议使用 <code>gosu</code> ，可以从其<a href="https://github.com/tianon/gosu" target="_blank" rel="external">项目网站</a>看到进一步的信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</div><div class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</div><div class="line"># 下载 gosu</div><div class="line">RUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot; \</div><div class="line">    &amp;&amp; chmod +x /usr/local/bin/gosu \</div><div class="line">    &amp;&amp; gosu nobody true</div><div class="line"># 设置 CMD，并以另外的用户执行</div><div class="line">CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ]</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h2><ol>
<li><p>容器运行时应该尽量保持<code>容器存储层</code>不发生写操作, 对于像数据库这类需要保存动态数据的应用, 其数据库文件应该保存于<code>卷(volume)</code>中。</p>
</li>
<li><p>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在Dockerfile中, 可以事先指定某些目录挂载为匿名卷, 这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
</li>
<li><p>格式为: <code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></p>
</li>
<li><p><code>VOLUME /data</code> : 容器中的 “/data” 目录就会在运行时自动挂载为匿名卷, 任何向 /data 中写入的信息都不会记录进容器存储层。<br>当然，运行时可以覆盖这个挂载设置。比如:<code>docker run -d -v mydata:/data xxxx</code> 在这行命令中, 就使用了 mydata 这个命名卷挂载到了 /data 这个位置, 替代了 Dockerfile 中定义的匿名卷的挂载配置。</p>
</li>
</ol>
<h2 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h2><ol>
<li><p><code>EXPOSE</code>指令是声明运行时为容器提供的映射端口, 这<strong>只是一个声明, 并不会自动在宿主进行端口映射</strong>。</p>
</li>
<li><p>格式为:<code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p>
</li>
<li><p>在 Dockerfile 中写入这样的声明有两个好处</p>
<ul>
<li>一个是帮助镜像使用者理解这个镜像服务的守护端口, 以方便配置映射;</li>
<li>另一个用处则是在运行时使用随机端口映射时, 也就是 <code>docker run -P</code> 时, 会自动随机映射 <code>EXPOSE</code> 的端口。</li>
</ul>
</li>
<li><p>要将 <code>EXPOSE</code> 和 在运行时使用<code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来</p>
<ul>
<li><code>-p</code> 是映射宿主端口和容器端口, 换句话说, 就是将容器的对应端口服务公开给外界访问;</li>
<li>而 <code>EXPOSE</code> 仅仅是声明, 容器打算使用什么端口而已, <strong>并不会自动在宿主进行端口映射</strong>;</li>
</ul>
</li>
</ol>
<h2 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h2><ol>
<li><p><code>CMD</code> 指令的格式和 RUN 相似，也是两种格式:</p>
<ul>
<li>shell 格式: <code>CMD &lt;命令&gt;</code></li>
<li>exec 格式: <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
</ul>
</li>
<li><p>但是如果指定了 <code>ENTRYPOINT</code> 指令，用 CMD 指定的就是具体的参数 <code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。</p>
</li>
<li><p>Docker不是虚拟机, 容器就是进程, 那么在启动容器的时候, CMD 指令就是用于指定默认的容器主进程的启动命令的。</p>
<ul>
<li><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令<br>比如ubuntu镜像默认的CMD是<code>/bin/bash</code>, 如果我们直接 <code>docker run -it ubuntu</code> 的话, 会直接进入 bash ;<br>我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>, 这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了, 输出了系统版本信息。 </p>
</li>
<li><p>在指令格式上, 一般推荐使用 <code>exec</code> 格式, 这类格式在解析时会被解析为JSON数组，因此一定要使用双引号, 而不要使用单引号。</p>
</li>
<li><p>如果使用 shell 格式的话，实际的命令会被包装为<code>sh -c</code>的参数的形式进行执行。比如 <code>CMD echo $HOME</code> 在实际执行中，会将其变更为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code><br>这就是为什么我们可以使用环境变量的原因, 因为这些环境变量会被shell进行解析处理。</p>
</li>
</ul>
</li>
<li><p>Docker不是虚拟机, 容器中的应用都应该以前台执行, 而不是像虚拟机、物理机里面那样, 用 <code>upstart/systemd</code> 去启动后台服务, <strong>容器内没有后台服务的概念</strong>。</p>
<ul>
<li><p>一些初学者将 CMD 写为 <code>CMD service nginx start</code>, 然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。<br>这就是因为没有搞明白前台、后台的概念, 没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
</li>
<li><p>对于容器而言, 其启动程序就是容器应用进程, 容器就是为了主进程而存在的，主进程退出, 容器就失去了存在的意义, 从而退出, 其它辅助进程不是它需要关心的东西。<br>而使用 <code>service nginx start</code> 命令，则是希望upstart来以后台守护进程形式启动nginx服务, <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>, 因此主进程实际上是sh, 那么当 <code>service nginx start</code> 命令结束后, sh也就结束了, sh 作为主进程退出了, 自然就会令容器退出。</p>
</li>
<li><p>正确的做法是直接执行nginx可执行文件，并且要求以前台形式运行。比如: <code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code></p>
</li>
</ul>
</li>
</ol>
<h2 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h2><ol>
<li><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样, 都是在指定容器启动程序及参数。 </p>
<ul>
<li>ENTRYPOINT 在运行时也可以被替代, 不过比CMD要略显繁琐, 需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定;</li>
<li>当指定了 ENTRYPOINT 后, <strong>CMD 的含义就发生了改变</strong>, 不再是直接的运行其命令, 而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令, 换句话说实际执行时, 将变为:<code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code></li>
</ul>
</li>
<li><p><code>ENTRYPOINT</code> 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。</p>
</li>
<li><p>有了<code>CMD</code>后, 为什么还要有<code>ENTRYPOINT</code>? 这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处? <a href="https://yeasy.gitbooks.io/docker_practice/content/image/dockerfile/entrypoint.html" target="_blank" rel="external">参考书中</a></p>
<ul>
<li>场景一：让镜像变成像命令一样使用</li>
<li>场景二：应用运行前的准备工作</li>
</ul>
</li>
</ol>
<h2 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h2><ol>
<li><p>和RUN指令一样, 也有两种格式:</p>
<ul>
<li><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
</li>
<li><p>COPY 指令将从 <code>构建上下文目录</code> 中 <code>&lt;源路径&gt;</code>目录/ 复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如:<code>COPY package.json /usr/src/app/</code></p>
<ul>
<li>&lt;源路径&gt; 可以是多个, 甚至可以是通配符</li>
<li>&lt;目标路径&gt; 可以是容器内的绝对路径, 也可以是相对于工作目录的相对路径(工作目录可以用 <code>WORKDIR</code> 指令来指定)。</li>
<li>目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</li>
</ul>
</li>
<li><p>此外, 还需要注意一点, 使用 COPY 指令, 源文件的各种元数据都会保留。比如读、写、执 行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
</li>
</ol>
<h2 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h2><ol>
<li><p><code>ADD</code> 指令 和 <code>COPY</code> 的格式和性质基本一致, 但是在 COPY 基础上增加了一些功能:</p>
<ul>
<li><p>比如 &lt;源路径&gt; 可以是一个 URL , 这种情况下, Docker 引擎会试图去下载这个链接的文件放 到 &lt;目标路径&gt; 去, 下载后的文件权限自动设置为 600 , 如果这并不是想要的权限, 则需要增加额外的一层 RUN 进行权限调整<br>另外, 如果下载的是个压缩包, 需要解压缩, 也一样, 还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令, 然后使用 wget 或 者 curl 工具下载, 处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并 不实用，而且不推荐使用。</p>
</li>
<li><p>如果 &lt;源路径&gt; 为一个tar压缩文件的话,压缩格式为 gzip , bzip2 以及 xz 的情况下, ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去<br>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。</p>
</li>
</ul>
</li>
<li><p>在 Docker 官方的最佳实践文档中要求，尽可能的使用 COPY ，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。<strong>最适合使用ADD 的场合，就是所提及的需要自动解压缩的场合</strong>。</p>
</li>
<li><p>另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD 。</p>
</li>
</ol>
<h2 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h2><h2 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h2><ol>
<li><p>格式：<code>ONBUILD &lt;其它指令&gt;</code></p>
</li>
<li><p><code>ONBUILD</code> 是一个特殊的指令, 它后面跟的是其它指令, 比如 RUN, COPY 等, 而这些指令, 在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像, 去构建下一级镜像的时候才会被执行。</p>
</li>
<li><p>Dockerfile 中的其它指令都是为了定制当前镜像而准备的, 唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p>
</li>
<li><p>假设我们要制作Node.js所写的应用的镜像, 我们都知道Node.js使用npm进行包管理, 所有依赖、配置、启动信息等会放到package.json文件里。</p>
<ul>
<li>在拿到程序代码后, 需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。</li>
<li><p>然后就可以通过 <code>npm start</code> 来启动应用, 因此, 一般来说会这样写 Dockerfile:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FROM node:slim</div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">COPY ./package.json /app</div><div class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ]</div><div class="line">COPY . /app/</div><div class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</div></pre></td></tr></table></figure>
</li>
<li><p>把这个 Dockerfile 放到 Node.js 项目的根目录, 构建好镜像后, 就可以直接拿来启动容器运行。</p>
</li>
</ul>
</li>
<li><p>但是如果我们还有第二个 Node.js 项目也差不多呢？好吧, 那就再把这个Dockerfile复制到第二个项目里。那如果有第三个项目呢?再复制么?文件的副本越多,版本控制就越困难,让我们继续看这样的场景维护的问题。</p>
<ul>
<li>如果第一个Node.js项目在开发过程中, 发现这个Dockerfile里存在问题,比如敲错字了、或者需要安装额外的包, 然后开发人员修复了这个 Dockerfile, 再次构建, 问题解决。</li>
<li>第一个项目没问题了,但是第二个项目呢?虽然最初 Dockerfile 是复制、粘贴自第一个项目的,但是并不会因为第一个项目修复了 Dockerfile, 而第二个项目的 Dockerfile 就会被自动修复。</li>
</ul>
</li>
<li><p>那么我们可不可以做一个基础镜像, 然后各个项目使用这个基础镜像呢? 这样基础镜像更新, 各个项目不用同步Dockerfile的变化, 重新构建后就继承了基础镜像的更新?</p>
<ul>
<li><p>其实是可以的, 那么上面的这个 Dockerfile 就会变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FROM node:slim</div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</div></pre></td></tr></table></figure>
</li>
<li><p>这里我们把项目相关的构建指令拿出来, 放到子项目里去。假设这个基础镜像的名字为my-node的话, 各个项目内的自己的 Dockerfile 就变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FROM my-node</div><div class="line">COPY ./package.json /app</div><div class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ]</div><div class="line">COPY . /app/</div></pre></td></tr></table></figure>
<p>基础镜像变化后, 各个项目都用这个 Dockerfile 重新构建镜像, 会继承基础镜像的更新。</p>
</li>
</ul>
</li>
<li><p>此时问题只解决了一半, 如果这个Dockerfile里面有些东西需要调整, 比如 npm install 都需要加一些参数, 那怎么办?</p>
<ul>
<li>这一行 RUN 是不可能放入基础镜像的, 因为涉及到了当前项目的 ./package.json, 难道又要一个个修改么?</li>
<li>所以说, 这样制作基础镜像, 只解决了原来的 Dockerfile 的前4条指令的变化问题, 而后面三条指令的变化则完全没办法处理。</li>
</ul>
</li>
<li><p><code>ONBUILD</code> 可以解决这个问题, 用ONBUILD重新写一下基础镜像的 Dockerfile:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FROM node:slim</div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">ONBUILD COPY ./package.json /app</div><div class="line">ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]</div><div class="line">ONBUILD COPY . /app/</div><div class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这次我们回到原始的 Dockerfile，但是这次将项目相关的指令加上 ONBUILD，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 Dockerfile 就变成了简单地：<code>FROM my-node</code>, 只有这么一行。<br>当在各个项目目录中, 用这个只有一行的 Dockerfile 构建镜像时, 之前基础镜像的那三行 ONBUILD 就会开始执行, 成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>, 生成应用镜像。</p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        

        
    </div>
    <footer>
        <a href="http://blog.renyimin.com">
            <img src="/img/avatar.jpeg" alt="Lant">
            Lant
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/&title=《05.镜像 - Dockerfile常见指令详解》 — Lant's Blog&pic=http://blog.renyimin.com/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/&title=《05.镜像 - Dockerfile常见指令详解》 — Lant's Blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《05.镜像 - Dockerfile常见指令详解》 — Lant's Blog&url=http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/&via=http://blog.renyimin.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
      <div class="waves-block waves-effect prev">
        <a href="/2017/10/12/docker/2017-10-12-04-docker/" id="post-prev" class="post-nav-link">
          <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i>Prev </div>
          <h4 class="title">04.定制镜像 - Dockerfile脚本</h4>
        </a>
      </div>
    
  
    <div class="waves-block waves-effect next">
      <a href="/2017/10/14/docker/2017-10-14-06-docker/" id="post-next" class="post-nav-link">
        <div class="tips">Next<i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">06.其他方法定制 -- (镜像/容器 的 导入导出)</h4>
      </a>
    </div>
  
</nav>



    











<section class="comments" id="comments">
    <div id="gitment_thread"></div>
    <link rel="stylesheet" href="//unpkg.com/gitment/style/default.css">
    <script src="//unpkg.com/gitment/dist/gitment.browser.js"></script>
    <script>
        var gitment = new Gitment({
            owner: 'rymuscle',
            repo: 'rymuscle.github.io',
            oauth: {
                client_id: '49b906f6d47dbab8d929',
                client_secret: '17fd73f24f616a09d4c09bca9480e0deba75a9a2',
            },
        })
        gitment.render('comments')
    </script>
</section>




</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        赞赏支持
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Lant &copy; 2016 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/&title=《05.镜像 - Dockerfile常见指令详解》 — Lant's Blog&pic=http://blog.renyimin.com/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/&title=《05.镜像 - Dockerfile常见指令详解》 — Lant's Blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《05.镜像 - Dockerfile常见指令详解》 — Lant's Blog&url=http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/&via=http://blog.renyimin.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.renyimin.com/2017/10/13/docker/2017-10-13-05-docker/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACv0lEQVR42u3a0WojMQwF0Pz/T2dhnwrdOFeS1XThzFPppDM+DtjqtR6P+Hr+vR6t6/nlOt9NPvnYuPDw8PAGr3/1mvNvzi/+fjcfaDKeNyPBw8PDW+Odh/Xqj/PpSKbpPB3nz7z8PR4eHt5HedWXJVNQLbvx8PDw/ndeXi6PhngcDx4eHt6neEkYUeXlT8ivxawFDw8PL+ZVD8B+w8+L53t4eHh4g1P16nF+75As2VqaWwgeHh7eAi+PWSdtAfN2hHwk0X8MeHh4eGNefqifPy4JLHqlc7OxAA8PD+8Sr1dAJyVvryWrOtFvqHh4eHjLvF6z1EZYnB+qvdk88PDw8NZ41TI32UiqoW0+kuQthYwZDw8Pr8irLsr5EHvLenK3uXng4eHhXeL1NoZ86JMG02RbWimp8fDw8IphRN7MNI9Z86nsNYTh4eHhbfDypba6WFdbB3JMtdzHw8PDu8vLF/ckWs3vThjlpis8PDy8q7zqEVS1CK6GGvlGUmjnwsPDw7vKyxflW0Xz3aX/TQSMh4eHt8brBQTVVoB5aFtu4cLDw8Nb4E2GVR1KbwOoblHJpOPh4eHd4vXK66S9oDCv55O6+Al4eHh4e7ze4dM8tqjebX5veHh4eAu8akh6K4TtBcTlGBcPDw/vB3m3ooFqK0AeeRSaD/Dw8PCu8iYh7PkFk0ChOikvFXh4eHjLvN4joqP6gFqdlKikxsPDw1vg5WVrEkNUF/FJAZ1HIXh4eHh3ec/i1SuU80OsvNSO4l08PDy8BV5+9YaYF+vVeLd6CIeHh4d3l5dvBnlhPSmFkwkqfD94eHh4a7z565PWgVGPQ2/TwsPDw/soL1+y880jj3GbGxIeHh7er+f1SuS7U/CPMAIPDw9vgdcrhfPWgbylYNLadTnGxcPDw6ulrOVD/d6xWa8VoNkigIeHhzfl/QEJhLtgXAyBRAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.6.13"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.6.13" async></script>










</body>
</html>
