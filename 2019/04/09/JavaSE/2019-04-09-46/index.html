<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>46. 两种I/O多路复用模式 Reactor, Proactor | Lant&#39;s</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Java,IO">
    <meta name="description" content="概述 在高性能的I/O设计中, 有两个比较著名的模式 Reactor 和 Proactor (其中 Reactor 模式用于同步I/O操作, 而 Proactor 模式则运用于异步I/O操作)  这两种模式的 中心思想 即是众所周知的 I/O 多路复用 (select、poll、epoll、kqueue 等) 这两种模式中都需要一个 事件多路分解器(Event Demultiplexer) 的支持">
<meta name="keywords" content="Java,IO">
<meta property="og:type" content="article">
<meta property="og:title" content="46. 两种I&#x2F;O多路复用模式 Reactor, Proactor">
<meta property="og:url" content="http://blog.renyimin.com/2019/04/09/JavaSE/2019-04-09-46/index.html">
<meta property="og:site_name" content="Lant&#39;s">
<meta property="og:description" content="概述 在高性能的I/O设计中, 有两个比较著名的模式 Reactor 和 Proactor (其中 Reactor 模式用于同步I/O操作, 而 Proactor 模式则运用于异步I/O操作)  这两种模式的 中心思想 即是众所周知的 I/O 多路复用 (select、poll、epoll、kqueue 等) 这两种模式中都需要一个 事件多路分解器(Event Demultiplexer) 的支持">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://blog.renyimin.com/img/IO/reactor-0.png">
<meta property="og:image" content="http://blog.renyimin.com/img/IO/reactor-01.png">
<meta property="og:image" content="http://blog.renyimin.com/img/IO/reactor-02.png">
<meta property="og:image" content="http://blog.renyimin.com/img/IO/reactor-03.png">
<meta property="og:updated_time" content="2019-09-12T10:08:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="46. 两种I&#x2F;O多路复用模式 Reactor, Proactor">
<meta name="twitter:description" content="概述 在高性能的I/O设计中, 有两个比较著名的模式 Reactor 和 Proactor (其中 Reactor 模式用于同步I/O操作, 而 Proactor 模式则运用于异步I/O操作)  这两种模式的 中心思想 即是众所周知的 I/O 多路复用 (select、poll、epoll、kqueue 等) 这两种模式中都需要一个 事件多路分解器(Event Demultiplexer) 的支持">
<meta name="twitter:image" content="http://blog.renyimin.com/img/IO/reactor-0.png">
    
        <link rel="alternate" type="application/atom+xml" title="Lant&#39;s" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.6.13">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand4.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpeg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Lant</h5>
          <a href="mailto:18625036504@163.com" title="18625036504@163.com" class="mail">18625036504@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">46. 两种I/O多路复用模式 Reactor, Proactor</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h5 class="subtitle">
            
                <time datetime="2019-04-09T11:52:37.000Z" itemprop="datePublished" class="page-time">
  2019-04-09
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/">Java</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/IO/">IO</a></li></ul></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#概述"><span class="post-toc-number">1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Reactor"><span class="post-toc-number">2.</span> <span class="post-toc-text">Reactor</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#单Reactor单线程模型"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">单Reactor单线程模型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#单Reactor多线程模型"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">单Reactor多线程模型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#主从Reactor多线程模型"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">主从Reactor多线程模型</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#小结"><span class="post-toc-number">3.</span> <span class="post-toc-text">小结</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#常见架构的进程-线程模型"><span class="post-toc-number">4.</span> <span class="post-toc-text">常见架构的进程/线程模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Netty-的线程模型"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">Netty 的线程模型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Tomcat-的线程模型"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">Tomcat 的线程模型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Nginx-的进程模型"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">Nginx 的进程模型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Redis-的线程模型"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">Redis 的线程模型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Swoole-的进程模型"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">Swoole 的进程模型</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#参考"><span class="post-toc-number">5.</span> <span class="post-toc-text">参考</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Proactor"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">Proactor</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#php-实现-reactor"><span class="post-toc-number">6.</span> <span class="post-toc-text">php 实现 reactor</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-JavaSE/2019-04-09-46"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">46. 两种I/O多路复用模式 Reactor, Proactor</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-04-09 19:52:37" datetime="2019-04-09T11:52:37.000Z"  itemprop="datePublished">2019-04-09</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/">Java</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/IO/">IO</a></li></ul></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol>
<li><p>在高性能的I/O设计中, 有两个比较著名的模式 <code>Reactor</code> 和 <code>Proactor</code> (其中 Reactor 模式用于同步I/O操作, 而 Proactor 模式则运用于异步I/O操作)</p>
</li>
<li><p>这两种模式的 中心思想 即是众所周知的 I/O 多路复用 (select、poll、epoll、kqueue 等)<br> 这两种模式中都需要一个 <code>事件多路分解器(Event Demultiplexer)</code> 的支持, 它可以将来自事件源的I/O事件 分发到对应的 事件处理器(Event Handler)上 (比如Java中的 Selector 支持, 操作系统的 select 系统调用支持, 如果要自己实现Synchronous Event Demultiplexer可能不会有那么高效)</p>
</li>
</ol>
<p>这里完全搞不清楚, 事件多路分解器 和 dispatcher 到底哪个是用来分发事件的 ?</p>
<h1 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h1><ol>
<li><p>Reactor模式是处理并发I/O比较常见的一种模式, 中心思想就是 将所有 需要处理的事件 及 事件处理器(或回调函数) 注册到一个中心I/O多路复用器上, 同时主线程阻塞在多路复用器上; 一旦有I/O事件到来或是准备就绪(区别在于多路复用器是边沿触发还是水平触发), 多路复用器返回并将相应I/O事件分发到对应的处理器中</p>
</li>
<li><p>Reactor模型有三个重要的组件:</p>
<ul>
<li>事件多路分解器: 将多路复用器中返回的就绪事件分到对应的处理函数中</li>
<li>多路复用器(事件多路分解器内部使用的): 由操作系统提供, 在linux上一般是select, poll, epoll等系统调用</li>
<li>事件处理器: 负责处理特定事件的处理函数</li>
</ul>
</li>
<li><p>Reactor模型类图<br><img src="/img/IO/reactor-0.png"></p>
</li>
</ol>
<p><a href="http://www.blogjava.net/DLevin/archive/2015/09/02/427045.html" target="_blank" rel="noopener">http://www.blogjava.net/DLevin/archive/2015/09/02/427045.html</a> ?</p>
<ul>
<li><p><code>Handle</code>: 即操作系统中的句柄, 是对资源在操作系统层面上的一种抽象, 它可以是打开的文件、一个连接(Socket)、Timer等 (由于Reactor模式一般使用在网络编程中, 因而这里一般指Socket Handle, 即一个网络连接(Connection, 在Java NIO中的Channel), 这个Channel注册到 <code>Synchronous Event Demultiplexer</code>(事件分解器) 中, 以监听Handle中发生的事件<br>  对ServerSocketChannnel可以是CONNECT事件, 对SocketChannel可以是READ、WRITE、CLOSE等事件</p>
</li>
<li><p><code>Synchronous Event Demultiplexer</code>: 阻塞等待一系列的 Handle 中的事件到来, 这个模块一般使用操作系统的 select, poll, epoll 来实现, 在Java NIO中用Selector来封装, 当Selector.select()返回时, 可以调用Selector的selectedKeys()方法获取Set<selectionkey>, 一个SelectionKey表达一个有事件发生的Channel以及该Channel上的事件类型<br>  同步事件多路分解器一般都是由操作系统来支持, 如支持IO复用的select,epoll,poll等, 通过监听IO事件集合, 根据事件类型将具体事件交由具体 (如, nginx 在 windows 只支持 select 不支持 epoll, epoll 是内核层面的东西,Windows 是不可支持的)</selectionkey></p>
</li>
<li><p><code>Initiation Dispatcher</code>: 用于管理 Event Handler, 即 EventHandler 的容器, 用以注册、移除EventHandler等, 另外, 它还作为Reactor模式的入口调用 <code>Synchronous Event Demultiplexer</code> 的select方法以阻塞等待事件返回, 当阻塞等待返回时, 根据事件发生的Handle将其分发给对应的Event Handler处理, 即回调EventHandler中的handle_event()方法</p>
</li>
<li><p><code>Event Handler</code>: 定义事件处理方法 handle_event(), 以供InitiationDispatcher回调使用</p>
</li>
<li><p><code>Concrete Event Handler</code>: 事件EventHandler接口, 实现特定事件处理逻辑</p>
</li>
</ul>
<ol>
<li>模块交互<br>   1）我们注册Concrete Event Handler到Initiation Dispatcher中。<br>   2）Initiation Dispatcher调用每个Event Handler的get_handle接口获取其绑定的Handle。<br>   3）Initiation Dispatcher调用handle_events开始事件处理循环。在这里，Initiation Dispatcher会将步骤2获取的所有Handle都收集起来，使用Synchronous Event Demultiplexer来等待这些Handle的事件发生。<br>  4）当某个（或某几个）Handle的事件发生时，Synchronous Event Demultiplexer通知Initiation Dispatcher。<pre><code>5）Initiation Dispatcher根据发生事件的Handle找出所对应的Handler。
6）Initiation Dispatcher调用Handler的handle_event方法处理事件。
</code></pre><h2 id="单Reactor单线程模型"><a href="#单Reactor单线程模型" class="headerlink" title="单Reactor单线程模型"></a>单Reactor单线程模型</h2></li>
<li><p>Reactor线程负责多路分离套接字, accept新连接, 并分派请求到handler (Redis使用单Reactor单进程的模型)<br><img src="/img/IO/reactor-01.png"></p>
</li>
<li><p>消息处理流程：</p>
<ul>
<li>Reactor 对象通过 select 监控连接事件, 收到事件后通过 dispatch 进行转发</li>
<li>如果是连接建立的事件, 则由acceptor接受连接, 并创建handler处理后续事件</li>
<li>如果不是建立连接事件, 则Reactor会分发调用Handler来响应</li>
<li>handler会完成 read-&gt;业务处理-&gt;send的完整业务流程</li>
</ul>
</li>
<li><p>单Reactor单线程模型只是在代码上进行了组件的区分, 但是整体操作还是单线程, 不能充分利用硬件资源。handler业务处理部分没有异步。</p>
</li>
<li><p>对于一些小容量应用场景, 可以使用单Reactor单线程模型。但是对于高负载、大并发的应用场景却不合适, 主要原因如下：</p>
<ul>
<li>即便Reactor线程的CPU负荷达到100%, 也无法满足海量消息的编码、解码、读取和发送</li>
<li>当Reactor线程负载过重之后, 处理速度将变慢, 这会导致大量客户端连接超时, 超时之后往往会进行重发, 这更加重Reactor线程的负载, 最终会导致大量消息积压和处理超时, 成为系统的性能瓶颈</li>
<li>一旦Reactor线程意外中断或者进入死循环, 会导致整个系统通信模块不可用, 不能接收和处理外部消息, 造成节点故障<br>为了解决这些问题, 演进出 单Reactor多线程模型</li>
</ul>
</li>
</ol>
<h2 id="单Reactor多线程模型"><a href="#单Reactor多线程模型" class="headerlink" title="单Reactor多线程模型"></a>单Reactor多线程模型</h2><ol>
<li><p>该模型在事件处理器(Handler)部分采用了多线程(线程池)<br><img src="/img/IO/reactor-02.png"></p>
</li>
<li><p>消息处理流程</p>
<ul>
<li>Reactor对象通过Select监控客户端请求事件, 收到事件后通过dispatch进行分发</li>
<li>如果是建立连接请求事件, 则由acceptor通过accept处理连接请求, 然后创建一个Handler对象处理连接完成后续的各种事件</li>
<li>如果不是建立连接事件, 则Reactor会分发调用连接对应的Handler来响应</li>
<li>Handler只负责响应事件, 不做具体业务处理, 通过Read读取数据后, 会分发给后面的Worker线程池进行业务处理</li>
<li>Worker线程池会分配独立的线程完成真正的业务处理, 将响应结果发给Handler进行处理</li>
<li>Handler收到响应结果后通过send将响应结果返回给Client</li>
</ul>
</li>
<li><p>相对于第一种模型来说, 在处理业务逻辑, 也就是获取到IO的读写事件之后, 交由线程池来处理, handler收到响应后通过send将响应结果返回给客户端, 这样可以降低Reactor的性能开销, 从而更专注的做事件分发工作了, 提升整个应用的吞吐</p>
</li>
<li><p>但是这个模型存在的问题：</p>
<ul>
<li>多线程数据共享和访问比较复杂, 如果子线程完成业务处理后, 把结果传递给主线程Reactor进行发送, 就会涉及共享数据的互斥和保护机制</li>
<li>Reactor承担所有事件的监听和响应, 只在主线程中运行, 可能会存在性能问题 (例如并发百万客户端连接, 或者服务端需要对客户端握手进行安全认证, 但是认证本身非常损耗性能)</li>
<li>为了解决性能问题, 产生了第三种主从Reactor多线程模型</li>
</ul>
</li>
</ol>
<h2 id="主从Reactor多线程模型"><a href="#主从Reactor多线程模型" class="headerlink" title="主从Reactor多线程模型"></a>主从Reactor多线程模型</h2><ol>
<li>比起第二种模型, 它是将Reactor分成两部分:<br> mainReactor 负责监听 server socket, 用来处理网络IO连接建立操作, 将建立的socketChannel指定注册给subReactor<br> subReactor 主要做和建立起来的socket做数据交互和事件业务处理操作, 通常, subReactor 个数上可与CPU个数等同<br> (Nginx、Swoole、Memcached和Netty都是采用这种实现)<br> <img src="/img/IO/reactor-03.png"></li>
</ol>
<ol>
<li>消息处理流程：<ul>
<li>从主线程池中随机选择一个Reactor线程作为acceptor线程, 用于绑定监听端口, 接收客户端连接</li>
<li>acceptor 线程接收客户端连接请求之后创建新的 SocketChannel, 将其注册到主线程池的其它 Reactor 线程上, 由其负责接入认证、IP黑白名单过滤、握手等操作</li>
<li>步骤2完成之后, 业务层的链路正式建立, 将 SocketChannel 从主线程池的 Reactor线程的多路复用器上摘除, 重新注册到Sub线程池的线程上, 并创建一个Handler用于处理各种连接事件</li>
<li>当有新的事件发生时, SubReactor 会调用连接对应的Handler进行响应</li>
<li>Handler 通过Read读取数据后, 会分发给后面的Worker线程池进行业务处理</li>
<li>Worker 线程池会分配独立的线程完成真正的业务处理, 如何将响应结果发给Handler进行处理</li>
<li>Handler 收到响应结果后通过Send将响应结果返回给Client</li>
</ul>
</li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Reactor模型具有如下的优点:</p>
<ul>
<li>响应快, 不必为单个同步时间所阻塞, 虽然Reactor本身依然是同步的</li>
<li>编程相对简单, 可以最大程度的避免复杂的多线程及同步问题, 并且避免了多线程/进程的切换开销</li>
<li>可扩展性, 可以方便地通过增加 Reactor 实例个数来充分利用CPU资源</li>
<li>可复用性, Reactor 模型本身与具体事件处理逻辑无关, 具有很高的复用性</li>
</ul>
<h1 id="常见架构的进程-线程模型"><a href="#常见架构的进程-线程模型" class="headerlink" title="常见架构的进程/线程模型"></a>常见架构的进程/线程模型</h1><h2 id="Netty-的线程模型"><a href="#Netty-的线程模型" class="headerlink" title="Netty 的线程模型"></a>Netty 的线程模型</h2><h2 id="Tomcat-的线程模型"><a href="#Tomcat-的线程模型" class="headerlink" title="Tomcat 的线程模型"></a>Tomcat 的线程模型</h2><h2 id="Nginx-的进程模型"><a href="#Nginx-的进程模型" class="headerlink" title="Nginx 的进程模型"></a>Nginx 的进程模型</h2><h2 id="Redis-的线程模型"><a href="#Redis-的线程模型" class="headerlink" title="Redis 的线程模型"></a>Redis 的线程模型</h2><h2 id="Swoole-的进程模型"><a href="#Swoole-的进程模型" class="headerlink" title="Swoole 的进程模型"></a>Swoole 的进程模型</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/wskwbog/p/10725372.html" target="_blank" rel="noopener">https://www.cnblogs.com/wskwbog/p/10725372.html</a><br><a href="https://cloud.tencent.com/developer/article/1488120" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1488120</a></p>
<ol>
<li>Reactor 模式 说明你可以进行读写操作了</li>
<li>Reactor关注的是I/O操作的就绪事件, 而Proactor关注的是I/O操作的完成事件<h2 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h2></li>
<li>Proactor模式下说明已经完成读写操作了, 具体内容在给定缓冲区中, 可以对这些内容进行其他操作了</li>
</ol>
<p>在Reactor中, 事件分离器负责等待文件描述符或socket为读写操作准备就绪, 然后将就绪事件传递给对应的处理器, 最后由处理器负责完成实际的读写工作。</p>
<p>而在Proactor模式中, 处理器或者兼任处理器的事件分离器, 只负责发起异步读写操作。IO操作本身由操作系统来完成。传递给操作系统的参数需要包括用户定义的数据缓冲区地址和数据大小, 操作系统才能从中得到写出操作所需数据, 或写入从socket读到的数据。事件分离器捕获IO操作完成事件, 然后将事件传递给对应处理器。比如, 在windows上, 处理器发起一个异步IO操作, 再由事件分离器等待IOCompletion事件。典型的异步模式实现, 都建立在操作系统支持异步API的基础之上, 我们将这种实现称为“系统级”异步或“真”异步, 因为应用程序完全依赖操作系统执行真正的IO工作。</p>
<p>Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的, Reactor中需要应用程序自己读取或者写入数据, 而Proactor模式中, 应用程序不需要进行实际的读写过程, 它只需要从缓存区读取或者写入即可, 操作系统会读取缓存区或者写入缓存区到真正的IO设备.</p>
<h1 id="php-实现-reactor"><a href="#php-实现-reactor" class="headerlink" title="php 实现 reactor"></a>php 实现 reactor</h1><p><a href="https://www.jianshu.com/p/0bc0830875bc" target="_blank" rel="noopener">https://www.jianshu.com/p/0bc0830875bc</a></p>
<p><a href="https://blog.csdn.net/u014730165/article/details/85044285" target="_blank" rel="noopener">https://blog.csdn.net/u014730165/article/details/85044285</a>  ？</p>
<p><a href="https://blog.csdn.net/u014730165/article/details/85089085" target="_blank" rel="noopener">https://blog.csdn.net/u014730165/article/details/85089085</a></p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        

        
    </div>
    <footer>
        <a href="http://blog.renyimin.com">
            <img src="/img/avatar.jpeg" alt="Lant">
            Lant
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IO/">IO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.renyimin.com/2019/04/09/JavaSE/2019-04-09-46/&title=《46. 两种I/O多路复用模式 Reactor, Proactor》 — Lant's&pic=http://blog.renyimin.com/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.renyimin.com/2019/04/09/JavaSE/2019-04-09-46/&title=《46. 两种I/O多路复用模式 Reactor, Proactor》 — Lant's&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.renyimin.com/2019/04/09/JavaSE/2019-04-09-46/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《46. 两种I/O多路复用模式 Reactor, Proactor》 — Lant's&url=http://blog.renyimin.com/2019/04/09/JavaSE/2019-04-09-46/&via=http://blog.renyimin.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.renyimin.com/2019/04/09/JavaSE/2019-04-09-46/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
      <div class="waves-block waves-effect prev">
        <a href="/2019/04/09/JavaSE/2019-04-09-45/" id="post-prev" class="post-nav-link">
          <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i>Prev </div>
          <h4 class="title">45. IO 多路复用 select 、poll、epoll</h4>
        </a>
      </div>
    
  
    <div class="waves-block waves-effect next">
      <a href="/2019/04/09/JavaSE/2019-04-09-47/" id="post-next" class="post-nav-link">
        <div class="tips">Next<i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">47. Java IO 体系</h4>
      </a>
    </div>
  
</nav>



    











<section class="comments" id="comments">
    <div id="gitment_thread"></div>
    <link rel="stylesheet" href="//unpkg.com/gitment/style/default.css">
    <script src="//unpkg.com/gitment/dist/gitment.browser.js"></script>
    <script>
        var gitment = new Gitment({
            owner: 'rymuscle',
            repo: 'rymuscle.github.io',
            oauth: {
                client_id: '49b906f6d47dbab8d929',
                client_secret: '17fd73f24f616a09d4c09bca9480e0deba75a9a2',
            },
        })
        gitment.render('comments')
    </script>
</section>




</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        赞赏支持
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="bottom">
        <p><span>Lant &copy; 2016 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.renyimin.com/2019/04/09/JavaSE/2019-04-09-46/&title=《46. 两种I/O多路复用模式 Reactor, Proactor》 — Lant's&pic=http://blog.renyimin.com/img/avatar.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.renyimin.com/2019/04/09/JavaSE/2019-04-09-46/&title=《46. 两种I/O多路复用模式 Reactor, Proactor》 — Lant's&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.renyimin.com/2019/04/09/JavaSE/2019-04-09-46/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《46. 两种I/O多路复用模式 Reactor, Proactor》 — Lant's&url=http://blog.renyimin.com/2019/04/09/JavaSE/2019-04-09-46/&via=http://blog.renyimin.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.renyimin.com/2019/04/09/JavaSE/2019-04-09-46/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACI0lEQVR42u3aUY7DIBAEUd//0s4BIkj1gCOZKX+tnKzheaXeAea68HV/XaP7o2/On/z9tOuJS4YMGa9lkEnMB5hPff6c0R0+NxkyZPRhkCgcTZ18h4xCxh3elyFDhgz8aF4a8qCXIUOGjBqDDEYiNQ16GTJkdGbUgo+EKb//p7W4DBkyXsjg0/r/z4+cb8iQIeNVjDu8+HYbCc1ts5IhQ8bRDB5w/HGETZo24tJThgwZhzLSYK1Nen0j7wdMhgwZRzN4KqcNE0+8iKW/kgwZMl7LqNWSJKB31a0oamXIkHE0g4RjrSFjpXLjh50yZMjowODb9LVhavVpHNkyZMg4mpEuWfmkV+I1PUaVIUPG2Qy+BOWL4bTNYmXrTYYMGX0YvIWChG9a8KVbgcNuERkyZBzKKP4CPh6oHXymJakMGTI6MHgZt2tpSsYt9ozIkCHjUMZKSZe2fO0qH2XIkNGTwTf303aKWv0Wt3fIkCGjDYMvUK/wSlso0uNMGTJkdGCsxO760pQvm+OeERkyZBzKmA/A2ybW4zV4fTJkyGjDSGORN2fUvh8ci8qQIeNQxh1eaNtrIWSLVBkyZBzNSJeL61QerLzclCFDRgdG2pLFN+D2loAyZMiQEbQ14G0ygk//A/xYysqQIUNGeGBA8LUXd/EPZMiQ0Zixd3Mt5W0LXBkyZLyKwY8weYtGrZGCFIsyZMjoxuBLRxLKtditzUGGDBkNGB8n6SLg5TAvRwAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.6.13"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.6.13" async></script>










</body>
</html>
