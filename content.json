{"meta":{"title":"Lant's Blog","subtitle":null,"description":null,"author":"Lant","url":"http://blog.renyimin.com"},"pages":[{"title":"分类","date":"2017-09-17T02:40:28.000Z","updated":"2017-09-18T09:08:09.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.renyimin.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-09-17T02:40:21.000Z","updated":"2017-09-18T09:08:03.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.renyimin.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL锁 - 01","slug":"2018-01-02-mysql_locks-01","date":"2018-01-02T13:08:27.000Z","updated":"2018-01-10T01:35:22.000Z","comments":true,"path":"2018/01/02/2018-01-02-mysql_locks-01/","link":"","permalink":"http://blog.renyimin.com/2018/01/02/2018-01-02-mysql_locks-01/","excerpt":"","text":"参考: http://blog.csdn.net/tanga842428/article/details/52748531 前言 之前已经学习了事务及事务在高并发下所面临的问题, 并且介绍了事务的隔离级别是如何解决这些问题的; 那这些问题已经通过事务解决了, 为什么还要学习锁的相关知识? 我们之前介绍的事务的隔离级别，其实它的核心就是锁; 虽然之前也了解到事务的最隔离级别是可以解决 丢失更新 的问题;高级别如果在非事务场景中, 要能在高并发的时候解决非事务下(不使用事务)的 丢失更新 的问题, （乐观,悲观锁的使用） 所以我们也需要对锁有一定的认识; 常见锁相关的词 在学习锁相关知识之前, 先看一些关于锁的名词: 锁冲突 锁等待 锁争用 死锁 两段锁 2PL (https://www.cnblogs.com/rainwang/p/4429211.html) 表级锁(MYISAM, INNODB引擎) 意向锁(意向共享锁, 意向排他锁) 行级锁(记录锁) (INNODB引擎) 页级锁(BDB引擎) 共享锁(S锁)(读锁) 排他锁(X锁)(写锁) 记录锁 Gap Locks(间隙锁) next-key锁 自动锁 显示锁 乐观锁 悲观锁 自旋锁: 传统的互斥锁，只要一检测到锁被其他线程所占用了，就立刻放弃cpu时间片，把cpu留给其他线程，这就会产生一次上下文切换。当系统压力大的时候，频繁的上下文切换会导致sys值过高。自旋锁，在检测到锁不可用的时候，首先cpu忙等一小会儿，如果还是发现不可用，再放弃cpu，进行切换。互斥锁消耗cpu sys值，自旋锁消耗cpu usr值。 递归锁: 如果在同一个线程中，对同一个互斥锁连续加锁两次，即第一次加锁后，没有释放，继续进行对这个锁进行加锁，那么如果这个互斥锁不是递归锁，将导致死锁。可以把递归锁理解为一种特殊的互斥锁。 死锁: 构成死锁有四大条件，其中有一个就是加锁顺序不一致，如果能保证不同类型的锁按照某个特定的顺序加锁，就能大大降低死锁发生的概率，之所以不能完全消除，是因为同一种类型的锁依然可能发生死锁。另外，对同一个锁连续加锁两次，如果是非递归锁，也将导致死锁。http://mysql.taobao.org/monthly/2017/01/01/ (DML锁和DDL锁：http://www.hollischuang.com/archives/909) 锁冲突线程1将A上锁后, 线程2又对A上锁, 锁不能共存否则会出现锁冲突; (共享锁和共享锁可以共存, 共享锁和排它锁不能共存, 排它锁和排他锁也不可以共存) 死锁 死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候; 比如: 线程1锁住了A, 然后尝试对B进行加锁, 于此同时线程2已经锁住了B, 接着尝试对A进行加锁, 这时死锁就发生了, 线程1永远得不到B, 线程2也永远得不到A, 并且它们永远也不会知道发生了这样的事情; 为了得到彼此的对象(A和B), 它们将永远阻塞下去, 这种情况就是一个死锁; 有多种方法可以避免死锁, 这里只介绍常见的三种: 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表, 可以大大降低死锁机会; 在同一个事务中, 尽可能做到一次锁定所需要的所有资源, 减少死锁产生概率; 对于非常容易产生死锁的业务部分, 可以尝试使用升级锁定颗粒度, 通过表级锁定来减少死锁产生的概率; 表级锁 表级锁是MySQL中锁定粒度最大的一种锁, 表示对当前操作的整张表加锁, 它实现简单, 资源消耗较少, 被大部分MySQL引擎支持, 最常使用的MYISAM与INNODB引擎都支持表级锁定, 但INNODB默认采用的是行级锁, 表级锁定分为表共享读锁(共享锁)与表独占写锁(排他锁); (意向锁就属于表锁) 特点: 加锁快(开销小) 锁定粒度大(出现锁冲突(即:锁等待)的概率最高, 并发度最低) MYISAM引擎默认就是表级锁 (另外, 由于MYISAM引擎不支持事务, 每次操作执行完后会立即提交, 也就是每次操作只加一个锁, 其他操作只用等待就行; 而在InnoDB中, 锁是逐步获得的, 就造成了死锁的可能) 页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁, 表级锁加锁速度快,但冲突多,行级锁冲突少,但加锁速度慢, 所以取了折衷的页级, 一次锁定相邻的一组记录; (BDB支持页级锁) 特点: 加锁时间和开销界于表锁和行锁之间 锁定粒度界于表锁和行锁之间, 并发度一般 BDB引擎使用的就是页级锁, 会出现死锁 行级锁 行级锁是Mysql中锁定粒度最细的一种锁, 只对当前操作的行进行加锁, 行级锁能大大减少数据库操作的冲突, 因为其加锁粒度最小, 但行级锁加锁的开销也最大。行级锁分为共享锁 和 排他锁; 特点: 加锁慢, 开销大 锁定粒度最小(发生锁冲突的概率最低, 并发度也最高) INNODB引擎使用行锁, 支持事务, 会出现死锁 Innodb中的行锁与表锁注意事项 前面提到过, Innodb引擎中既支持行锁也支持表锁, 那么什么时候会锁住整张表, 什么时候或只锁住一行? InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的; InnoDB这种行锁实现特点意味着: 只有通过索引条件检索数据, InnoDB才使用行级锁, 否则, InnoDB将使用表锁!(不过, 在实际应用中, 一般在做更改的时候, 都是使用主键进行筛选, 所以自然是行锁) 在实际应用中, 要特别注意InnoDB行锁的这一特性, 不然的话, 可能导致大量的锁冲突, 从而影响并发性能; 在不通过索引条件查询的时候,InnoDB 确实使用的是表锁,而不是行锁; 由于 MySQL 的行锁是针对索引加的锁, 而不是针对记录加的锁, 所以虽然是访问不同行的记录, 但是如果是使用相同的索引键, 是会出现锁冲突的, 应用设计的时候要注意这一点;(也就是Innodb引擎中, 写操作即使是操作不同的行, 也可能由于使用一样的索引而导致锁冲突) 当表有多个索引的时候, 不同的事务可以使用不同的索引锁定不同的行, 另外, 不论是使用主键索引、唯一索引或普通索引, InnoDB 都会使用行锁来对数据加锁; 即便在条件中使用了索引字段, 但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的, 如果 MySQL 认为全表扫效率更高, 比如对一些很小的表, 它就不会使用索引, 这种情况下 InnoDB 将使用表锁, 而不是行锁;因此, 在分析锁冲突时, 别忘了检查 SQL 的执行计划, 以确认是否真正使用了索引; 行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。 共享锁(Share Lock) 共享锁又称读锁, 是读取操作创建的锁。 其他事务可以并发读取数据, 但不能对数据进行修改(获取数据上的排他锁), 直到已释放所有共享锁; (也就是共享锁只可以和共享锁共存) 如果事务T对数据A加上共享锁后, 则其他事务只能对A再加共享锁, 不能加排他锁, 获准共享锁的事务只能读数据, 不能修改数据; 对于一般的select语句, InnoDB不会加任何锁, 当然, 也可以显示手动去自己加: SELECT ... LOCK IN SHARE MODE; 在查询语句后面增加LOCK IN SHARE MODE, Mysql会对查询结果中的每行都加共享锁, 当没有其他线程对查询结果集中的任何一行使用排他锁时, 可以成功申请共享锁, 否则会被阻塞; 其他线程也可以读取使用了共享锁的表, 而且这些线程读取的是同一个版本的数据; 排他锁(Xclusive Lock) 排他锁又称写锁, 如果事务T对数据A加上排他锁后, 则其他事务不能再对A加任任何类型的锁; 获准排他锁的事务既能读数据, 又能修改数据。 对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁(X), 当然, 也可以显示手动去自己加: SELECT ... FOR UPDATE; 在查询语句后面增加FOR UPDATE, Mysql会对查询结果中的每行都加排他锁, 当没有其他线程对查询结果集中的任何一行使用排他锁时, 可以成功申请排他锁, 否则会被阻塞; 意向锁 (不用干预) 意向锁是表级锁, 其设计目的主要是为了在一个事务中揭示下一行将要被请求锁的类型; InnoDB中的两个表锁: 意向共享锁(IS): 表示事务准备给数据行加入共享锁, 也就是说一个数据行加共享锁前必须先取得该表的IS锁; 意向排他锁(IX): 类似上面, 表示事务准备给数据行加入排他锁, 说明事务在一个数据行加排他锁前必须先取得该表的IX锁; 3.意向锁是InnoDB自动加的,不需要用户干预; 4.显示加共享锁或排他锁: 共享锁：SELECT ... LOCK IN SHARE MODE; 排他锁：SELECT ... FOR UPDATE; 共享锁和意向共享锁，排他锁与意向排他锁的区别 共享锁和排他锁: 系统在特定的条件下会自动添加共享锁或者排他锁, 也可以手动添加共享锁或者排他锁; 意向共享锁和意向排他锁都是系统自动添加和自动释放的, 整个过程无需人工干预; 共享锁和排他锁都是锁的行记录,意向共享锁和意向排他锁锁定的是表。 间隙锁 间隙锁是innodb中 行锁 的一种，但是这种锁锁住的却不止一行数据, 他锁住的是多行, 是一个数据范围; 通过生活中的一个小场景来认识间隙锁: a,b,c 三个人依次站成一排, 此时, 新来了一个d, 如何让新来的d不站在小红旁边? 其实只要将b和它前面的a之间的空隙封锁; 再将b和它后面的c之间的空隙封锁; 那么d就不能站到b的旁边了; 这里的a, b, c, d 如果对应到数据表中, 那就是就是一条条记录； 他们之间的空隙也就是间隙, 而封锁他们之间间隙的锁, 就叫做间隙锁; (http://www.jianshu.com/p/bf862c37c4c9) next-key锁 MYISAM 和 INNODB相比:MYISAM不会出现死锁(因为MYISAM没有事务)","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/tags/MySQL/"}]},{"title":"mysql(InnoDB)事务隔离级别(REPEATABLE READ) 与 锁,MVCC","slug":"2017-12-31-mysql_transaction-05","date":"2017-12-31T08:01:47.000Z","updated":"2018-01-02T01:32:58.000Z","comments":true,"path":"2017/12/31/2017-12-31-mysql_transaction-05/","link":"","permalink":"http://blog.renyimin.com/2017/12/31/2017-12-31-mysql_transaction-05/","excerpt":"","text":"REPEATABLE READ(可重复读) 之前已经了解到, 该隔离级别可以解决不可重复读问题 (当然, 也能解决脏读问题), 那么如果单纯用锁来实现, 可能会是如下这样子: 既然REPEATABLE READ 隔离级别可以解决脏读, 不可重复读的问题, 也就是它既可以让事务只能读其他事务已提交的的记录, 又能在同一事务中保证多次读取的数据即使被其他事务修改, 也是一致的。 解决脏读问题: 试想一下, 当在事务A中读取数据D的时候, 假设D之前已经在事务B中了, 并且事务B中对数据D做了修改, 但是事务B还没有完成(commit/rollback), 那如何让事务A无法读取数据D呢? 当事务B在对数据D做写操作的时候, 假设给数据D加上了行级的排他锁(X lock), 那事务A自然只能阻塞等事务A完成后才能读取数据D了, 这样就解决了脏读问题。 解决 不可重复读问题: 试想一下, 当在事务A中第一次读取了数据D之后, 直接给该数据D加S共享锁, 那其他事务自然只能阻塞等事务A完成后才能对数据D做修改操作了, 这样就解决了不可重复读, 在事务A中多次读取数据D, 都是一样的。 上面使用S锁+X锁确实可以实现 READ COMMITTED 隔离级别的效果, 也就避免了脏读问题和不可重复读问题, 当然, 这里的问题仍然是低效！！！！ 因为 MySQL 在事务隔离级别Read committed 、Repeatable Read下，InnoDB 存储引擎采用非锁定的一致性读－－即读取数据不用加锁，即采用的是MVCC中一致性非锁定读模式, 所以, InnoDB的做法是: 读不影响写，写不影响读。 读不影响写: 当数据正在执行读操作时，其他事务的写操作不会因此去等待当前事务行上S锁的释放，而是会去读取行的一个快照数据。 写不影响读：当数据正在执行写操作时，其他事务的读操作不会因此去等待当前事务行上X锁的释放，而是会去读取行的一个快照数据。 所以总结来看, READ UNCOMMITTED 和 REPEATABLE READ 这两个隔离级别都是使用 写用排他锁 + 读用MVCC, 区别可以参考 MySQL-InnoDB-MVCC多版本并发控制 MySQL官方文档 慕课mark_rock同学手记 美团技术博客","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"http://blog.renyimin.com/tags/事务/"},{"name":"MVCC","slug":"MVCC","permalink":"http://blog.renyimin.com/tags/MVCC/"},{"name":"隔离级别与锁","slug":"隔离级别与锁","permalink":"http://blog.renyimin.com/tags/隔离级别与锁/"}]},{"title":"mysql(InnoDB)事务隔离级别(READ COMMITTED) 与 锁,MVCC","slug":"2017-12-31-mysql_transaction-04","date":"2017-12-31T02:01:47.000Z","updated":"2018-01-02T01:33:33.000Z","comments":true,"path":"2017/12/31/2017-12-31-mysql_transaction-04/","link":"","permalink":"http://blog.renyimin.com/2017/12/31/2017-12-31-mysql_transaction-04/","excerpt":"","text":"READ COMMITTED(提交读) 了解了之前 READ UNCOMMITTED 隔离级别是如何加锁的, 并且在文章中, 已经知道 READ COMMITTED 隔离级别可以解决脏读的问题, 那接下来, 对于 READ COMMITTED 隔离级别, 试想一下如果让你用锁来设计, 你会怎么做? 既然READ COMMITTED 隔离级别可以解决脏读的问题, 也就是他可以让事务只能读其他事务已提交的的记录。 如果用锁机制来实现该隔离级别: 试想一下, 当在事务A中读取数据D的时候, 假设D之前已经在事务B中了, 并且事务B中对数据D做了修改, 但是事务B还没有完成(commit/rollback), 那如何让事务A无法读取数据D呢? 当事务B在对数据D做写操作的时候, 假设给数据D加上了行级的排他锁(X lock), 那事务A自然只能阻塞等事务A完成后才能读取数据D了! 数据库这样做的话确实实现了READ COMMITTED隔离级别的效果, 也就避免了脏读, 但问题是这是一种很低效的做法, 因为对于大部分应用来说, 读操作是多于写操作的, 当写操作加锁时, 那么读操作全部被阻塞, 这样在大用户量高并发的情况下, 会直接降低数据库的读效率。 那么, 既然用锁机制实现该隔离级别是低效的做法, 数据库是如何做的? 之前在相关MVCC的文章中可以得到答案: 数据库是使用了 排他锁+MVCC 的机制来实现该隔离级别的, 而不是单纯的使用锁或者单纯的使用MVCC READ COMMITTED与锁 测试 数据表结构如下: 1234567891011mysql&gt; select * from test_transaction;+----+---------------+-----+--------+--------------------+| id | user_name | age | gender | desctiption |+----+---------------+-----+--------+--------------------+| 1 | 金刚狼 | 127 | 2 | 我有一双铁爪 || 2 | 钢铁侠-rym | 120 | 1 | 我有一身铁甲 || 3 | 绿巨人 | 0 | 2 | 我有一身肉 |+----+---------------+-----+--------+--------------------+3 rows in set (0.00 sec) mysql&gt; 重新设置客户端1事务隔离级别为read committed: SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; 1234567891011121314151617181920mysql&gt; SELECT @@SESSION.tx_isolation;+------------------------+| @@SESSION.tx_isolation |+------------------------+| REPEATABLE-READ |+------------------------+1 row in set (0.00 sec) mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;Query OK, 0 rows affected (0.00 sec) mysql&gt; SELECT @@SESSION.tx_isolation;+------------------------+| @@SESSION.tx_isolation |+------------------------+| READ-COMMITTED |+------------------------+1 row in set (0.00 sec) mysql&gt; 再重新打开一个客户端2并设置事务隔离级别为read committed; 在客户端1中打开事务, 然后更改数据, 先不提交; 然后在客户端2中打开事务, 读取客户端1中尚未提交的那条被修改数据 结果发现在客户端2中可以正常读取到那条数据, 只不过, 那条数据并不是被客户端1事务中修改后的数据, 而是最初的稳定数据, 这就避免了脏读!! 对于该隔离级别修改数据时使用的锁类型, 其分析方法, 和之前一篇MySQL(INNODB引擎)事务READ UNCOMMITTED隔离级别和锁的关系 是一样的： 可以在客户端1的事务在修改数据并且未提交时, 在客户端2中对同一数据进行修改, 然后在客户端2阻塞阶段通过查看表的加锁情况: select * from information_schema.INNODB_LOCKS;,事务状态: select * from information_schema.INNODB_TRX;,进行分析, 结果就不展示了, 可以自行测试一下, 该隔离级别修改数据时使用的也是排他锁, 并且客户端2的修改语句会锁等待~(和之前分析READ UNCOMMITTED隔离级别一样, 既然使用了排他锁, 竟然别的事务还能读取, 这特么不就又违反了排他锁的特性么? 还是那句话, 另一个事务在读取的时候并不会加锁, 而是用的MVCC机制读取的镜像) 小结: InnoDB在该隔离级别(READ COMMITTED)写数据是使用排他锁, 读取数据不加锁而是使用了MVCC机制, 这样就可以大大提高并发读写效率, 写不影响读, 因为读并未加锁, 读的是记录的镜像版本!! MySQL官方文档 慕课mark_rock同学手记 美团技术博客","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"http://blog.renyimin.com/tags/事务/"},{"name":"MVCC","slug":"MVCC","permalink":"http://blog.renyimin.com/tags/MVCC/"},{"name":"隔离级别与锁","slug":"隔离级别与锁","permalink":"http://blog.renyimin.com/tags/隔离级别与锁/"}]},{"title":"mysql(InnoDB)事务隔离级别(READ UNCOMMITTED) 与 锁","slug":"2017-12-29-mysql_transaction-02","date":"2017-12-29T11:12:11.000Z","updated":"2018-01-04T01:56:07.000Z","comments":true,"path":"2017/12/29/2017-12-29-mysql_transaction-02/","link":"","permalink":"http://blog.renyimin.com/2017/12/29/2017-12-29-mysql_transaction-02/","excerpt":"","text":"前言先针对自己以前错误的思维做个记录, 可以直接跳过 由于以前看到很多资料在谈到并发控制的时候, 都会提到用锁来控制并发, MySQL也不例外, 也有很多和锁相关的概念(留到后面会单独整理一篇笔记出来), 所以一提到高并发产生的问题, 我会不自觉地提出一个疑问: 现在并发出问题了, 那怎么用锁的相关知识来解决?; 而且近期一段时间也一直在看很多有关MySQL锁相关的资料,书籍, 于是乎 死锁, 锁冲突, 行锁,表锁, 读锁, 写锁, 乐观锁, 悲观锁 ……等等 N多锁相关的名词(后面的笔记会把所有自己遇到的, 全部整理并进行分析), 大量的篇幅, 高深晦涩的描述, 直接导致我意识里认为嗯, 锁真tm高大上, 真tm高端, 肯定tm就是它了; 于是就进入了思想误区, 认为在解决脏读,不可重复读,幻读的资料中, 应该大篇幅的描述如何用锁相关的知识来解决这些问题, 然而略失落了, 资料倒是提了点儿锁的知识, 但更多的是用事务的哪个隔离级别来解决这些问题, 锁哪儿去了? 尤其是在分析脏读,不可重复读,幻读这几个问题的时候, 一上去就全乱了, 比如 脏读, 如果总是以MySQL锁的相关知识作为前提来分析, 就会陷入误区 ‘事务A读取数据的时候肯定会加S锁的, 事务B自然是无法对未完成的事务A中的数据进行修改的, 我Ca, 这种脏读的场景根本就不成立嘛!‘, 那为什么不提锁, 而是用隔离级别来解决。 ………… 晕了几天之后,终于稍微醒了点…… 参考美团技术博客 显然, 事务隔离级别的核心就是锁, 各隔离级别使用了不同的加锁策略，在分析之前的几个高并发事务问题的时候, 隔离级别(锁)自然是不能作为前置知识点的, 而是最终问题的解决方案! “READ UNCOMMITTED与锁”的困惑(未提交读) 在READ UNCOMMITTED级别, 事务中的修改, 即使还没有提交, 对其他事务也都是可见的; 也就是说事务可以读取未提交的数据, 这也就造成了 脏读(Dirty Read) 的出现。 这个级别会导致很多问题, 而且从性能上来说, READ COMMITTED 并不会比其他的级别好太多, 却缺乏其他级别的很多好处, 在实际应用中一般很少使用。 虽然很少使用, 但还是有必要了解一下, 它这个隔离级别究竟是怎么隔离的, 竟然还能容许很多问题的存在？ (老兄亏你还算个隔离级别, 怎么办事儿的…) 网上相关资料五花八门, 下面列几个出来(希望你看完不要激动): 美团技术博客: segmentfault一篇文章 CSDN一篇文章 CSDN一篇文章 说实话, 资料查到这份儿上, 我已经快崩溃了, 就READ UNCOMMITTED这个隔离级别: 有说读写都不加锁的 有说’修改完数据立即加S锁的, 修改时撤掉S锁’ 有说’写加S锁,事务结束释放’的 有说’写加X锁,事务结束释放’的 行啦, 不查了, 再查就崩溃了, 自己去测一下吧!!! 本次测试是使用MAMP PRO中mysql5.6版本 先准备一张测试表test_transaction: 1234567891011121314DROP TABLE IF EXISTS `test_transaction`;CREATE TABLE `test_transaction` ( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;, `user_name` char(20) NOT NULL COMMENT &apos;姓名&apos;, `age` tinyint(3) NOT NULL COMMENT &apos;年龄&apos;, `gender` tinyint(1) NOT NULL COMMENT &apos;1:男, 2:女&apos;, `desctiption` text NOT NULL COMMENT &apos;简介&apos;, PRIMARY KEY (`id`), KEY `name_age_gender_index` (`user_name`,`age`,`gender`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;INSERT INTO `test_transaction` VALUES (1, &apos;金刚狼&apos;, 127, 1, &apos;我有一双铁爪&apos;);INSERT INTO `test_transaction` VALUES (2, &apos;钢铁侠&apos;, 120, 1, &apos;我有一身铁甲&apos;);INSERT INTO `test_transaction` VALUES (3, &apos;绿巨人&apos;, 0, 2, &apos;我有一身肉&apos;); 如下: 123456789mysql&gt; select * from test_transaction;+----+-----------+-----+--------+--------------------+| id | user_name | age | gender | desctiption |+----+-----------+-----+--------+--------------------+| 1 | 金刚狼 | 127 | 2 | 我有一双铁爪 || 2 | 钢铁侠 | 120 | 1 | 我有一身铁甲 || 3 | 绿巨人 | 0 | 2 | 我有一身肉 |+----+-----------+-----+--------+--------------------+3 rows in set (0.00 sec) READ UNCOMMITTED与锁 测试演示该隔离级别脏读效果 先查看当前会话(当前客户端)事务的隔离级别: SELECT @@SESSION.tx_isolation; 可以看到: REPEATABLE READ 是InnoDB存储引擎的默认事务隔离级别 123456789mysql&gt; SELECT @@SESSION.tx_isolation;+------------------------+| @@SESSION.tx_isolation |+------------------------+| REPEATABLE-READ |+------------------------+1 row in set (0.00 sec) mysql&gt; 重新设置当前客户端事务隔离级别为read uncommitted: SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; 注意, 此时只是当前会话端的隔离级别被改, 其余客户端连接自然还是默认的REPEATABLE READ隔离级别 接下来将客户端2的事务隔离级别也设置为read uncommitted; 客户端1开启事务,并执行一个查询’读取数据’: 1234567891011121314151617181920mysql&gt; SELECT @@SESSION.tx_isolation;+------------------------+| @@SESSION.tx_isolation |+------------------------+| READ-UNCOMMITTED |+------------------------+1 row in set (0.00 sec) mysql&gt; begin;Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from test_transaction where id=2;+----+-----------+-----+--------+--------------------+| id | user_name | age | gender | desctiption |+----+-----------+-----+--------+--------------------+| 2 | 钢铁侠 | 120 | 1 | 我有一身铁甲 |+----+-----------+-----+--------+--------------------+1 row in set (0.00 sec) mysql&gt; 注意, 客户端1此时的事务并未提交 客户端2开启事务, 并修改客户端1查询的数据 123456789101112131415mysql&gt; SELECT @@SESSION.tx_isolation;+------------------------+| @@SESSION.tx_isolation |+------------------------+| READ-UNCOMMITTED |+------------------------+1 row in set (0.00 sec) mysql&gt; begin;Query OK, 0 rows affected (0.00 sec) mysql&gt; update test_transaction set user_name=&apos;钢铁侠-托尼&apos; where id=2;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; 此时发现, 客户端2可以对客户端1正在读取的记录进行修改, 而根据锁相关知识, 如果说客户端1在读取记录的时候加了S锁, 那么客户端2是不能加X锁对该记录进行更改的, 所以可以得出结论: 要么是客户端1读取记录的时候没有加S锁, 要么是客户端2更改该记录的时候没有加X锁(这样即使客户端1加了S锁,对它这个不加锁的事务也无可奈何), 那么究竟是哪种情况导致的? 下面继续进行分析… 注意, 客户端2此时的事务也并未提交 切换到客户端1, 再次查询数据, 发现数据已经变成了’钢铁侠-托尼’; 然后客户端2 rollback 事务, 再到客户端1中查询,发现user_name又变成了’钢铁侠’, 那之前独到’钢铁侠-托尼’就是脏数据了, 这就是一次 脏读 测试,分析该隔离级别如何加锁 重新构造测试条件 客户端1开启事务, 然后对数据做修改 1234567mysql&gt; begin;Query OK, 0 rows affected (0.00 sec) mysql&gt; update test_transaction set user_name=&apos;钢铁侠-rymuscle&apos; where id=2;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; 注意, 客户端1此时的事务并未提交 客户端2开启事务, 对相同的数据行做修改 12345mysql&gt; begin;Query OK, 0 rows affected (0.00 sec) mysql&gt; update test_transaction set user_name=&apos;钢铁侠-rym&apos; where id=2;....阻塞等待了 最终会如下: 注意: 在上面的过程, 在客户端2阻塞阶段, 你可以通过一个新的客户端来分析, 客户端2在锁等待的情况下的 加锁情况 和 事务状态: 查看表的加锁情况: select * from information_schema.INNODB_LOCKS; 事务状态 select * from information_schema.INNODB_TRX; 所以, READ UNCOMMITTED 隔离级别下, 写操作是会加锁的, 而且是X排他锁, 直到客户端1事务完成, 锁才释放, 客户端2才能进行写操作 接下来你肯定会纳闷 “既然该隔离级别下事务在修改数据的时候加的是x锁, 并且是事务完成后才释放, 那之前的测试客户端2在事务中修改完数据之后, 为什么事务还没完成, 也就是x锁还在, 结果客户端1却能读取到客户端2修改的数据”？这完全不符合排他锁的特性啊(要知道,排他锁会阻塞除当前事务之外的其他事务的读,写操作) 其实网上已经有人在sqlserver的官网上找到了相关资料: 12345ansactions running at the READ UNCOMMITTED level do not issue shared locks to prevent other transactions from modifying data read by the current transaction. READ UNCOMMITTED transactions are also not blocked by exclusive locks that would prevent the current transaction from reading rows that have been modified but not committed by other transactions. When this option is set, it is possible to read uncommitted modifications, which are called dirty reads. Values in the data can be changed and rows can appear or disappear in the data set before the end of the transaction. This option has the same effect as setting NOLOCK on all tables in all SELECT statements in a transaction. This is the least restrictive of the isolation levels. 翻译翻译, 在思考思考, 其实说的是在 READ UNCOMMITTED 级别运行的事务不会发出共享锁来防止其他事务修改当前事务读取的数据, 既然不加共享锁了, 那么当前事务所读取的数据自然就可以被其他事务来修改。而且当前事务要读取其他事务未提交的修改, 也不会被排他锁阻止, 因为排他锁会阻止其他事务再对其锁定的数据加读写锁, 但是可笑的是, 事务在该隔离级别下去读数据的话根本什么锁都不加, 这就让排他锁无法排它了, 因为它连锁都没有。这就导致了事务可以读取未提交的修改, 称为脏读。 所以可以得出: READ UNCOMMITTED隔离级别下, 读不会加任何锁。而写会加排他锁，并到事务结束之后释放。 参考资料:-《高性能MySQL》 MySQL官方文档 慕课mark_rock同学手记 美团技术博客","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"http://blog.renyimin.com/tags/事务/"},{"name":"隔离级别与锁","slug":"隔离级别与锁","permalink":"http://blog.renyimin.com/tags/隔离级别与锁/"}]},{"title":"MySQL-InnoDB-MVCC多版本并发控制","slug":"2017-12-28-mysql_mvcc","date":"2017-12-28T13:07:12.000Z","updated":"2018-01-09T07:57:31.000Z","comments":true,"path":"2017/12/28/2017-12-28-mysql_mvcc/","link":"","permalink":"http://blog.renyimin.com/2017/12/28/2017-12-28-mysql_mvcc/","excerpt":"","text":"(Multiversion Concurrency Control) 前言最近正在啃《高性能MySQL》这本书, 当看到事务相关知识时, 决定对该知识点稍微深入一下,《高性能MySQL》中在介绍事务相关知识点时, 显然不是特别深入, 很多比较底层的知识点并没有太多的深入, 当然此处并不是要对本书做什么评判, 言归正传, 这里主要先说一下本人在啃相关知识点时的曲折之路: 首先是事务相关ACID特性, 之前已经有相关笔记进行过介绍, 这里不再重复; 接下来是高并发事务相关的问题, 像是 脏读, 不可重复读, 幻读, 更新丢失等问题之前也有相关笔记; 再下来就是MySQL应对高并发事务是如何给出解决方案的(其中包含各个隔离级别的简介); 然后就是各个隔离级别的具体介绍及与锁的关系, 也就是在这部分知识点, 发现了之前并没有过多关心的知识点 MVCC多版本并发控制, 然后一发不可收拾了… 入题下面先引用一些前辈们比较优秀的文章: 阿里数据库内核’2017/12’月报中对MVCC的解释是:多版本控制: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。&lt;高性能MySQL&gt;中对MVCC的部分介绍 MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。基于提升并发性能的考虑, 它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL, 包括Oracle,PostgreSQL等其他数据库系统也都实现了MVCC, 但各自的实现机制不尽相同, 因为MVCC没有一个统一的实现标准。 可以认为MVCC是行级锁的一个变种, 但是它在很多情况下避免了加锁操作, 因此开销更低。虽然实现机制有所不同, 但大都实现了非阻塞的读操作，写操作也只锁定必要的行。 MVCC的实现方式有多种, 典型的有乐观(optimistic)并发控制 和 悲观(pessimistic)并发控制。 MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。从书中可以了解到: MVCC是被Mysql中 事务型存储引擎InnoDB 所支持的; 应对高并发事务, MVCC比单纯的加锁更高效; MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作; MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现; 各数据库中MVCC实现并不统一 但是书中提到 “InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的”(网上也有很多此类观点), 但其实并不准确, 可以参考MySQL官方文档, 可以看到, InnoDB存储引擎在数据库每行数据的后面添加了三个字段, 不是两个!! 相关概念1.read view, 快照snapshot 淘宝数据库内核月报/2017/10/01/此文虽然是以PostgreSQL进行的说明, 但并不影响理解, 在”事务快照的实现”该部分有细节需要注意: 事务快照是用来存储数据库的事务运行情况。一个事务快照的创建过程可以概括为： 查看当前所有的未提交并活跃的事务，存储在数组中 选取未提交并活跃的事务中最小的XID，记录在快照的xmin中 选取所有已提交事务中最大的XID，加1后记录在xmax中根据不同的情况，赋值不同的satisfies，创建不同的事务快照注意: 上文中在PostgreSQL中snapshot的概念, 对应MySQL中, 其实就是你在网上看到的read view,快照这些概念;比如何登成就有关于Read view的介绍;而 此文 却仍是使用快照来介绍; 2.read view 主要是用来做可见性判断的, 比较普遍的解释便是”本事务不可见的当前其他活跃事务”, 但正是该解释, 可能会造成一节理解上的误区, 所以此处提供两个参考, 供给大家避开理解误区: read view中的高水位low_limit_id可以参考 “https://github.com/zhangyachen/zhangyachen.github.io/issues/68“, “https://www.zhihu.com/question/66320138(呵呵一笑百媚生)” 如果单纯按照https://www.jianshu.com/p/fd51cb8dc03b中的的read view介绍来理解, 在rc级别下算法可能就会出错! 其实上面第1点中加粗部分也是相关高水位的介绍( 注意进行了+1 ) 3.另外, 对于read view快照的生成时机, 也非常关键, 正是因为生成时机的不同, 造成了RC,RR两种隔离级别的不同可见性, 可以参考 http://www.sohu.com/a/194511597_610509, https://www.cnblogs.com/digdeep/p/4947694.html 两篇文章; 在innodb中(默认repeatable read级别), 事务在begin/start transaction之后的第一条select读操作后, 会创建一个快照(read view), 将当前系统中活跃的其他事务记录记录起来; 在innodb中(默认repeatable committed级别), 事务中每条select语句都会创建一个快照(read view); 参考1234With REPEATABLE READ isolation level, the snapshot is based on the time when the first read operation is performed. 使用REPEATABLE READ隔离级别，快照是基于执行第一个读操作的时间。With READ COMMITTED isolation level, the snapshot is reset to the time of each consistent read operation.使用READ COMMITTED隔离级别，快照被重置为每个一致的读取操作的时间。 4.undo-log 可以参考数据库内核月报2015/04/01 前言 Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。 Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作（例如bug#69812）。 大多数对数据的变更操作包括INSERT/DELETE/UPDATE，其中INSERT操作在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除（谁会对刚插入的数据有可见性需求呢！！），而对于UPDATE/DELETE则需要维护多版本信息，在InnoDB里，UPDATE和DELETE操作产生的Undo日志被归成一类，即update_undo 另外, 在回滚段中的undo logs分为: insert undo log 和 update undo log insert undo log : 事务对insert新记录时产生的undolog, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。 update undo log : 事务对记录进行delete和update操作时产生的undo log, 不仅在事务回滚时需要, 一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。 5.InnoDB存储引擎在数据库每行数据的后面添加了三个字段 6字节的事务ID(DB_TRX_ID)字段: 用来标识最近一次对本行记录做修改(insert|update)的事务的标识符, 即最后一次修改(insert|update)本行记录的事务id。 至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted, 并非真正删除。 7字节的回滚指针(DB_ROLL_PTR)字段: 指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。 如果一行记录被更新, 则 undo log record 包含 ‘重建该行记录被更新之前内容’ 所必须的信息。 6字节的DB_ROW_ID字段: 包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。 结合聚簇索引的相关知识点, 我的理解是, 如果我们的表中没有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 但聚簇索引会使用DB_ROW_ID的值来作为主键; 如果我们有自己的主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID 了 。 关于聚簇索引, 《高性能MySQL》中的篇幅对我来说已经够用了, 稍后会整理一下以前的学习笔记, 然后更新上来。 6.可见性比较算法（这里每个比较算法后面的描述是建立在rr级别下，rc级别也是使用该比较算法,此处未做描述）设要读取的行的最后提交事务id(即当前数据行的稳定事务id)为 trx_id_current当前新开事务id为 new_id当前新开事务创建的快照read view 中最早的事务id为up_limit_id, 最迟的事务id为low_limit_id(注意这个low_limit_id=未开启的事务id=当前最大事务id+1)比较: 1.trx_id_current &lt; up_limit_id, 这种情况比较好理解, 表示, 新事务在读取该行记录时, 该行记录的稳定事务ID是小于, 系统当前所有活跃的事务, 所以当前行稳定数据对新事务可见, 跳到步骤5. 2.trx_id_current &gt;= trx_id_last, 这种情况也比较好理解, 表示, 该行记录的稳定事务id是在本次新事务创建之后才开启的, 但是却在本次新事务执行第二个select前就commit了，所以该行记录的当前值不可见, 跳到步骤4。 3.trx_id_current &lt;= trx_id_current &lt;= trx_id_last, 表示: 该行记录所在事务在本次新事务创建的时候处于活动状态，从up_limit_id到low_limit_id进行遍历，如果trx_id_current等于他们之中的某个事务id的话，那么不可见, 调到步骤4,否则表示可见。 4.从该行记录的 DB_ROLL_PTR 指针所指向的回滚段中取出最新的undo-log的版本号, 将它赋值该 trx_id_current，然后跳到步骤1重新开始判断。 5.将该可见行的值返回。 案例分析1.下面是一个非常简版的演示事务对某行记录的更新过程, 当然, InnoDB引擎在内部要做的工作非常多:2.下面是一套比较算法的应用过程也可参考https://github.com/zhangyachen/zhangyachen.github.io/issues/68中的案例 当前读和快照读1.MySQL的InnoDB存储引擎默认事务隔离级别是RR(可重复读), 是通过 “行排他锁+MVCC” 一起实现的, 不仅可以保证可重复读, 还可以部分防止幻读, 而非完全防止; 2.为什么是部分防止幻读, 而不是完全防止? 效果: 在如果事务B在事务A执行中, insert了一条数据并提交, 事务A再次查询, 虽然读取的是undo中的旧版本数据(防止了部分幻读), 但是事务A中执行update或者delete都是可以成功的!! 因为在innodb中的操作可以分为当前读(current read)和快照读(snapshot read): 3.快照读(snapshot read) 简单的select操作(当然不包括 select … lock in share mode, select … for update) 4.当前读(current read) 官网文档 Locking Reads select … lock in share mode select … for update insert update delete在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。innodb在快照读的情况下并没有真正的避免幻读, 但是在当前读的情况下避免了不可重复读和幻读!!! 小结 一般我们认为MVCC有下面几个特点： 每行数据都存在一个版本，每次数据更新时都更新该版本 修改时Copy出当前版本, 然后随意修改，各个事务之间无干扰 保存时比较版本号，如果成功(commit)，则覆盖原记录, 失败则放弃copy(rollback) 就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道, 因为这看起来正是，在提交的时候才能知道到底能否提交成功 而InnoDB实现MVCC的方式是: 事务以排他锁的形式修改原始数据 把修改前的数据存放于undo log，通过回滚指针与主数据关联 修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback） 二者最本质的区别是: 当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？ Innodb的实现真算不上MVCC, 因为并没有实现核心的多版本共存, undo log 中的内容只是串行化的结果, 记录了多个事务的过程, 不属于多版本共存。但理想的MVCC是难以实现的, 当事务仅修改一行记录使用理想的MVCC模式是没有问题的, 可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的MVCC就无能为力了。 比如, 如果事务A执行理想的MVCC, 修改Row1成功, 而修改Row2失败, 此时需要回滚Row1, 但因为Row1没有被锁定, 其数据可能又被事务B所修改, 如果此时回滚Row1的内容，则会破坏事务B的修改结果，导致事务B违反ACID。 这也正是所谓的 第一类更新丢失 的情况。 也正是因为InnoDB使用的MVCC中结合了排他锁, 不是纯的MVCC, 所以第一类更新丢失是不会出现了, 一般说更新丢失都是指第二类丢失更新。 参考 最初读的一篇文章 关于read view创建时机: http://www.sohu.com/a/194511597_610509 https://www.cnblogs.com/digdeep/p/4947694.html https://www.zhihu.com/question/265280455/answer/292022808 关于比较算法 low_limit_id 高水位事务: https://github.com/zhangyachen/zhangyachen.github.io/issues/68 https://www.zhihu.com/question/66320138 https://www.zhihu.com/question/265280455/answer/292022808 大咖问答:https://www.zhihu.com/inbox/4577674200 更多可以参考数据库内核月报: https://yq.aliyun.com/articles/303200?spm=5176.100240.searchblog.9.271fd153pQ9FgV 官方文档","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"http://blog.renyimin.com/tags/事务/"},{"name":"MVCC","slug":"MVCC","permalink":"http://blog.renyimin.com/tags/MVCC/"}]},{"title":"MySQL(INNODB引擎)高并发事务问题及解决方案","slug":"2017-12-27-mysql_transaction-01","date":"2017-12-27T13:01:07.000Z","updated":"2018-01-09T06:48:45.000Z","comments":true,"path":"2017/12/27/2017-12-27-mysql_transaction-01/","link":"","permalink":"http://blog.renyimin.com/2017/12/27/2017-12-27-mysql_transaction-01/","excerpt":"","text":"事务的概念 事务 可以理解为一个 独立的工作单元, 在这个独立的工作单元中, 有一组操作; 放在事务(独立工作单元)中的多个操作, 要么全部执行成功, 要么全部执行失败。 不免俗套, 这还是通过最经典的银行转账应用来解释一下 假设有两个角色 ‘Iron Man’(余额500), ‘Wolverine’(余额15), 现在 Iron Man 通过该银行应用给 Wolverine 转账100元, 那么本次转账操作至少需要三个步骤: 123检查`Iron Man`余额`&gt;=100`元从`Iron Man`余额中`-100`元给`Wolverine`余额`+100`元 注意: 上面的三个步骤的操作必须打包在一个事务中, 从而可以作为一个 独立的工作单元 来执行。在这个 独立工作单元(即事务) 中的这三个操作, 只要有任何一个操作失败, 则事务就整体就是失败的, 那就必须回滚所有的步骤。 假设第二步操作成功, 但是第三步操作失败, 那么整个事务也就应该是失败的, 那就必须将第二步的操作也回滚。(到这里我们也看到了事务最基本的特性之一: 保证数据的一致性) 要知道, 在真实的高并发场景下, 事务需要做的事情其实很多很多, 因为高并发会出现很多意想不到的问题, 接下来会分析这些问题。 事务的ACID特性在分析高并发事务的问题前, 我们要先知道事务的几个标准特性, 因为一个运行良好的事务处理系统必须具备这些标准特性, 而且这些问题的解决离不开事务的这几个标准特性!!! Atomicity 原子性 一个事务必须被视为一个不可分割的最小工作单元, 整个事务中的所有操作要么全部提交成功, 要么全部失败回滚。对于一个事务来说, 不能只成功执行其中的一部分操作, 这就是事务的原子性。 Consistency 一致性 虽然可数据表中的数据可能一直在变化, 但是事务的一致性特性会保证 数据库总是从一个一致性的状态 转换到 另一个一致性的状态; 比如在之前的转账例子: 123转账前的一致性状态是: &apos;Iron Man&apos;(余额500), &apos;Wolverine&apos;(余额15)转账成功后的一致性状态是: &apos;Iron Man&apos;(余额400), &apos;Wolverine&apos;(余额115)转账如果失败的话, 一致性的状态应该回滚到转账前的状态: &apos;Iron Man&apos;(余额500), &apos;Wolverine&apos;(余额15) Isolation 隔离性 通常来说, 一个事务所做的修改在最终提交以前, 对其他事务是不可见的;比如在之前的转账例子中, 在执行完成第二步, 但是第三步还没开始的时候, 此时有另一个账户汇总的程序开始运行, 那么这个程序所拿到的A账户余额应该是没有被 -100 的余额才对 后面我们还会详细讨论事务隔离性的 隔离级别, 到时候就知道这里为什么说通常来说对其他事务是不可见的; (也就是还有特例, 比如最低隔离级别 READ UNCOMMITTED, 对其他事务的可见就造成了脏读问题的出现) 事务有四种隔离级别(从低到高: READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE) Durability 持久性 一旦事务被最终提交, 则在事务这个独立单元中的所有操作所做的修改将会 永久保存到数据库中; (这里所说的永久可以理解为 被事务修改的数据 是真正存放到了表中, 而不是存放在了诸如临时表之类的地方。) 高并发事务的问题在并发量比较大的时候, 很容易出现 多个事务同时进行 的情况。假设有两个事务正在同时进行, 值得注意的是: 它们两者之间是互相不知道对方的存在的, 各自都对自身所处的环境过分乐观, 从而并没有对自己所操作的数据做一定的保护处理, 所以最终导致了一些问题的出现;接下来, 在分析高并发事务的问题时, 你可能已经了解了一些关于锁的概念, 但是在分析这些问题的时候, 先不要带入锁的概念, 本小节只会列出问题, 并直接告诉你各个问题是使用事务隔离性的哪个隔离级别解决掉的, 锁是解决方案, 如果带入锁的概念, 是无法去分析这些问题的。所以本节不需要带入锁!以后将会有文章分析这些解决方案(各隔离级别)具体是如何解决问题的。 脏读 如果mysql中一个事务A读取了另一个并行事务B未最终提交的写数据, 那事务A的这次读取就是脏读。(因为事务A读取的是’脏数据’, 是’非持久性’的数据) 之所以说是’非持久性数据’, ‘脏数据’, 是因为事务B最终可能会因为内部其他后续操作的失败或者系统后续突然崩溃等原因, 导致事务最终整体提交失败, 那么事务A此时读取到的数据在表中其实会被回滚, 那事务A拿到的自然就是脏的数据了。 图示: 事务A在T4阶段读取库存为20, 这个库存其实就属于脏数据, 因为事务B最终会回滚这个数据, 所以如果事务A使用库存20进行后续的操作, 就会引发问题, 因为事务A拿到的数据已经和表中的真实数据不一致了。 那么这个问题如何解决呢? 在MySQL中, 其实事务已经用自身特性（隔离性的 – READ COMMITED或以上隔离级别）解决了这个问题; READ COMMITED级别保证了, 只要是当前语句执行前已经提交的数据都是可见的。注意和REPEATABLE READ级别的区!!! 不可重复读 假设现在上面的 脏读问题 已经被完全解决了, 那就意味着事务中每次读取到的数据都是 持久性 的数据(被别的事务最终 提交/回滚 完成后的数据)。 但是你还需要知道的是: 解决了脏读问题, 只是能保证你在事务中每次读到的数据都是持久性的数据而已!!!! 如果在一个事务中多次读取同一个数据, 正好在两次读取之间, 另外一个事务确实已经完成了对该数据的修改并提交, 那问题就来了: 可能会出现多次读取结果不一致的现象。 那么这个问题如何解决呢? 在MySQL中, 其实事务已经用自身特性（隔离性的 – REPEATABLE READ或以上隔离级别）解决了这个问题; REPEATABLE READ级别保证了, 只要是当前事务执行前已经提交的数据都是可见的。注意和READ COMMITED级别的区!!! 幻读 由于很多人(当然也包括本人), 容易搞混 不可重复读 和 幻读, 这两者确实非常相似。 但 不可重复读 主要是说多次读取一条记录, 发现该记录中某些列值被修改过。 而 幻读 主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计), 发现结果不一致(标准档案一般指记录增多, 记录的减少应该也算是幻读)。(可以参考MySQL官方文档对 Phantom Rows 的介绍) 其实对于 幻读, MySQL的InnoDB引擎默认的RR级别已经通过MVCC自动帮我们解决了（并非完全解决）, 所以该级别下, 你也模拟不出幻读的场景; 退回到 RC 隔离级别的话, 你又容易把幻读和不可重复读搞混淆, 所以这可能就是比较头痛的点吧! 具体可以参考《高性能MySQL》对 RR 隔离级别的描述, 理论上RR级别是无法解决幻读的问题, 但是由于InnoDB引擎的RR级别还使用了MVCC, 所以也就避免了幻读的出现! 幻读的延伸MVCC虽然解决了幻读问题, 但严格来说只能说是部分解决幻读问题, 接下来进行演示: 打开客户端1查看隔离级别及初始数据 12345678910111213141516171819mysql&gt; SELECT @@SESSION.tx_isolation;+------------------------+| @@SESSION.tx_isolation |+------------------------+| REPEATABLE-READ |+------------------------+1 row in set (0.00 sec) mysql&gt; select * from test_transaction;+----+-----------+-----+--------+--------------------+| id | user_name | age | gender | desctiption |+----+-----------+-----+--------+--------------------+| 1 | 金刚狼 | 127 | 1 | 我有一双铁爪 || 2 | 钢铁侠 | 120 | 1 | 我有一身铁甲 || 3 | 绿巨人 | 0 | 2 | 我有一身肉 |+----+-----------+-----+--------+--------------------+3 rows in set (0.00 sec) mysql&gt; 打开客户端2查看隔离级别及初始数据 12345678910111213141516171819mysql&gt; SELECT @@SESSION.tx_isolation;+------------------------+| @@SESSION.tx_isolation |+------------------------+| REPEATABLE-READ |+------------------------+1 row in set (0.00 sec) mysql&gt; select * from test_transaction;+----+-----------+-----+--------+--------------------+| id | user_name | age | gender | desctiption |+----+-----------+-----+--------+--------------------+| 1 | 金刚狼 | 127 | 1 | 我有一双铁爪 || 2 | 钢铁侠 | 120 | 1 | 我有一身铁甲 || 3 | 绿巨人 | 0 | 2 | 我有一身肉 |+----+-----------+-----+--------+--------------------+3 rows in set (0.00 sec) mysql&gt; 在客户端2中开启事务, 然后查询数据 1234567891011121314mysql&gt; begin;Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from test_transaction;+----+-----------+-----+--------+--------------------+| id | user_name | age | gender | desctiption |+----+-----------+-----+--------+--------------------+| 1 | 金刚狼 | 127 | 1 | 我有一双铁爪 || 2 | 钢铁侠 | 120 | 1 | 我有一身铁甲 || 3 | 绿巨人 | 0 | 2 | 我有一身肉 |+----+-----------+-----+--------+--------------------+3 rows in set (0.00 sec) mysql&gt; 在客户端1中插入一条id为4的新数据 (直接自动提交) 1234567891011121314mysql&gt; insert into test_transaction (`id`,`user_name`,`age`,`gender`,`desctiption`) values (4, &apos;死侍&apos;, 18, 0, &apos;A bad boy&apos;);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from test_transaction;+----+-----------+-----+--------+--------------------+| id | user_name | age | gender | desctiption |+----+-----------+-----+--------+--------------------+| 1 | 金刚狼 | 127 | 1 | 我有一双铁爪 || 2 | 钢铁侠 | 120 | 1 | 我有一身铁甲 || 3 | 绿巨人 | 0 | 2 | 我有一身肉 || 4 | 死侍 | 18 | 0 | A bad boy |+----+-----------+-----+--------+--------------------+4 rows in set (0.00 sec) mysql&gt; 在客户端2事务中再次查询数据, 发现数据没有变化(表示可以重复读, 并且克服了幻读)!! 但是在客户端2事务中插入一条id为4的新数据, 发现提示数据已经存在!!! 12345678910111213141516171819202122232425262728mysql&gt; begin;Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from test_transaction;+----+-----------+-----+--------+--------------------+| id | user_name | age | gender | desctiption |+----+-----------+-----+--------+--------------------+| 1 | 金刚狼 | 127 | 1 | 我有一双铁爪 || 2 | 钢铁侠 | 120 | 1 | 我有一身铁甲 || 3 | 绿巨人 | 0 | 2 | 我有一身肉 |+----+-----------+-----+--------+--------------------+3 rows in set (0.00 sec)mysql&gt; select * from test_transaction;+----+-----------+-----+--------+--------------------+| id | user_name | age | gender | desctiption |+----+-----------+-----+--------+--------------------+| 1 | 金刚狼 | 127 | 1 | 我有一双铁爪 || 2 | 钢铁侠 | 120 | 1 | 我有一身铁甲 || 3 | 绿巨人 | 0 | 2 | 我有一身肉 |+----+-----------+-----+--------+--------------------+3 rows in set (0.00 sec)mysql&gt; insert into test_transaction (`id`,`user_name`,`age`,`gender`,`desctiption`) values (4, &apos;死侍&apos;, 18, 0, &apos;A bad boy&apos;);1062 - Duplicate entry &apos;4&apos; for key &apos;PRIMARY&apos;mysql&gt; //并且, 此时`update/delete`也是可以操作这条在事务中看不到的记录的! 那么这是什么问题呢? 可以参考MySQL官方文档 – 一致性非阻塞读 The snapshot of the database state applies to SELECT statements within a transaction, not necessarily to DML statements. If you insert or modify some rows and then commit that transaction, a DELETE or UPDATE statement issued from another concurrent REPEATABLE READ transaction could affect those just-committed rows, even though the session could not query them. If a transaction does update or delete rows committed by a different transaction, those changes do become visible to the current transaction.个人认为应该翻译为: 数据库状态的快照适用于事务中的SELECT语句, 而不一定适用于所有DML语句。 如果您插入或修改某些行, 然后提交该事务, 则从另一个并发REPEATABLE READ事务发出的DELETE或UPDATE语句就可能会影响那些刚刚提交的行, 即使该事务无法查询它们。 如果事务更新或删除由不同事务提交的行, 则这些更改对当前事务变得可见。 因此不少资料将MVCC并发控制中的读操作分成两类: 快照读 (snapshot read) 与 当前读 (current read)。 快照读, 读取专门的快照 (对于RC，快照（ReadView）会在每个语句中创建。对于RR，快照是在事务启动时创建的) 1简单的select操作即可(不需要加锁,如: select ... lock in share mode, select ... for update) 针对的也是select操作 当前读, 读取最新版本的记录, 没有快照。 在InnoDB中，当前读取根本不会创建任何快照。 12select ... lock in share modeselect ... for update 针对如下操作, 会让如下操作阻塞: 123insertupdatedelete 在RR级别下, 快照读是通过MVVC(多版本控制)和undo log来实现的, 当前读是通过手动加record lock(记录锁)和gap lock(间隙锁)来实现的。所以从上面的显示来看，如果需要实时显示数据，还是需要通过加锁来实现。这个时候会使用next-key技术来实现。 当然, 使用隔离性的最高隔离级别SERIALIZABLE也可以解决幻读, 但该隔离级别在实际中很少使用! 更新丢失 最后聊一下高并发事务的另一个问题 – 丢失更新问题, 该问题和之前几个问题需要区分开, 因为解决方案不是一类! 第一类丢失更新: A事务撤销时, 把已经提交的B事务的更新数据覆盖了。 不过, 通过后面MVCC相关文章最后的小结你会了解到, 这类更新丢失问题是不会出现的, 因为InnoDB存储引擎的隔离级别都使用了排他锁, 即使是 MVCC也不是纯MVCC, 也用到了排他锁! 这样的话事务A在未完成的时候, 其他事务是无法对事务A涉及到的数据做修改并提交的。 第二类丢失更新: A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失。 此类更新丢失问题, 无法依靠前三种隔离级别来解决, 只能用最高隔离级别 Serializable 或者手动使用乐观锁, 悲观锁来解决。 当然, 更新操作不是在所有情况下都会导致丢失更新问题, 如果你更改的最终状态是确定的, 而不是类似递减或者递增, 那是不会造成丢失更新问题的!! 最高隔离级别Serializable在实际应用场景中并不被采用, 对于手动使用乐观锁, 悲观锁的方案, 将会在以后关于锁的文章中一并给出! 参考资料: 淘宝数据库内核6月报 《高性能MySQL》 美团技术博客 MySQL官方文档","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"http://blog.renyimin.com/tags/事务/"}]},{"title":"Laravel-Facade","slug":"2017-03-10-Laravel-Facade","date":"2017-03-10T13:13:05.000Z","updated":"2018-01-10T12:28:29.000Z","comments":true,"path":"2017/03/10/2017-03-10-Laravel-Facade/","link":"","permalink":"http://blog.renyimin.com/2017/03/10/2017-03-10-Laravel-Facade/","excerpt":"","text":"代码追踪 以获取配置项的 Illuminate\\Support\\Facades\\Config 追踪Facade? 追踪到 Illuminate\\Support\\Facades 123456789101112131415161718192021public static function __callStatic($method, $args) &#123; $instance = static::getFacadeRoot(); if (! $instance) &#123; throw new RuntimeException(&apos;A facade root has not been set.&apos;); &#125; switch (count($args)) &#123; case 0: return $instance-&gt;$method(); case 1: return $instance-&gt;$method($args[0]); case 2: return $instance-&gt;$method($args[0], $args[1]); case 3: return $instance-&gt;$method($args[0], $args[1], $args[2]); case 4: return $instance-&gt;$method($args[0], $args[1], $args[2], $args[3]); default: return call_user_func_array([$instance, $method], $args); &#125; &#125; 这也就是为什么使用Facade的类可以直接使用静态调用的方式来调用方法, 正是Facade中的 __callStatic 方法生效了!","categories":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.renyimin.com/categories/Laravel/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.renyimin.com/tags/Laravel/"},{"name":"Facade","slug":"Facade","permalink":"http://blog.renyimin.com/tags/Facade/"}]},{"title":"OOP - Prototype","slug":"2016-07-13-OOP-Prototype","date":"2016-06-08T12:13:17.000Z","updated":"2018-01-16T06:34:10.000Z","comments":true,"path":"2016/06/08/2016-07-13-OOP-Prototype/","link":"","permalink":"http://blog.renyimin.com/2016/06/08/2016-07-13-OOP-Prototype/","excerpt":"","text":"前言Sunny软件公司一直使用自行开发的一套OA(Office Automatic, 办公自动化)系统进行日常工作办理, 但在使用过程中, 越来越多的人对工作周报的创建和编写模块产生了抱怨。追其原因, Sunny软件公司的OA管理员发现, 由于某些岗位每周工作存在重复性, 工作周报内容都大同小异, 如下图工作周报示意图。 这些周报只有一些小地方存在差异，但是现行系统每周默认创建的周报都是空白报表，用户只能通过重新输入或不断复制粘贴来填写重复的周报内容，极大降低了工作效率，浪费宝贵的时间。如何快速创建相同或者相似的工作周报，成为Sunny公司OA开发人员面临的一个新问题。 Sunny公司的开发人员通过对问题进行仔细分析, 决定按照如下思路对工作周报模块进行重新设计和实现： - 除了允许用户创建新周报外，还允许用户将创建好的周报保存为模板; - 用户在再次创建周报时，可以创建全新的周报，还可以选择合适的模板复制生成一份相同的周报，然后对新生成的周报根据实际情况进行修改，产生新的周报; - 只要按照如上两个步骤进行处理，工作周报的创建效率将得以大大提高。这个过程让我们想到平时经常进行的两个电脑基本操作：复制和粘贴，通过对已有对象的复制和粘贴，我们可以创建大量的相同对象。 如何在一个面向对象系统中实现对象的复制和粘贴呢？本篇介绍的原型模式正为解决此类问题而诞生。 原型模式 在使用原型模式时，我们需要首先创建一个原型对象，再通过复制这个原型对象来创建更多同类型的对象。原型模式的定义如下： 原型模式(Prototype Pattern): 使用原型实例指定创建对象的种类, 并且通过拷贝这些原型创建新的对象, 原型模式是一种对象创建型模式; 原型模式的工作原理很简单: 将一个原型对象传给那个要发动创建的对象, 这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的。原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。 需要注意的是通过克隆方法所创建的对象是全新的对象, 它们在内存中拥有新的地址, 通常对克隆所产生的对象进行修改对原型对象不会造成任何影响, 每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。 PHP中的拷贝有 深拷贝 和 浅拷贝，先来分析一下这两者的区别 浅拷贝: 被拷贝对象的所有变量都含有与原对象相同的值, 而且对其他对象的引用仍然是指向原来的对象, 即浅拷贝只负责当前对象实例, 对引用的对象不做拷贝。 深拷贝: 被拷贝对象的所有的变量都含有与原来对象相同的值, 除了那些引用其他对象的变量, 那些引用其他对象的变量将指向一个被拷贝的新对象，而不再是原来那些被引用的对象。(即深拷贝把要拷贝的对象所引用的对象也拷贝了一次。而这种对被引用到的对象拷贝叫做间接拷贝)。 在决定以深拷贝的方式拷贝一个对象的时候, 必须决定对间接拷贝的对象是采取 浅拷贝 还是 深拷贝。 序列化深拷贝: 利用序列化来做深拷贝, 把对象写到流里的过程是序列化的过程, 这一过程称为“冷冻”或“腌咸菜”, 反序列化对象的过程叫做“解冻”或“回鲜”。 原型模式结构图 Prototype(抽象原型类): 它是声明克隆方法的接口, 是所有具体原型类的父类, 可以是抽象类也可以是接口, 甚至还可以是具体实现类; ConcretePrototype(具体原型类): 它实现在抽象原型类中声明的克隆方法, 在克隆方法中返回自己的一个克隆对象; Client(客户类): 让一个原型对象克隆原型对象自身从而创建一个新的对象, 在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。原型模式的核心在于如何实现克隆方法 原型模式简单演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?phpinterface Prototype&#123; //浅拷贝 public function shallowCopy(); //深拷贝 public function deepCopy();&#125;class ConcretePrototype implements Prototype&#123; private $_name; public function __construct($name) &#123; $this-&gt;_name = $name; &#125; public function setName($name) &#123; $this-&gt;_name = $name; &#125; public function getName() &#123; return $this-&gt;_name; &#125; //浅拷贝 public function shallowCopy() &#123; return clone $this; &#125; //深拷贝 public function deepCopy() &#123; $serialize_obj = serialize($this); $clone_obj = unserialize($serialize_obj); return $clone_obj; &#125;&#125;class Demo&#123; public $string;&#125;class UsePrototype&#123; public function shallow() &#123; $demo = new Demo(); $demo-&gt;string = \"susan\"; $object_shallow_first = new ConcretePrototype($demo); $object_shallow_second = $object_shallow_first-&gt;shallowCopy(); var_dump($object_shallow_first-&gt;getName()); echo '&lt;br/&gt;'; var_dump($object_shallow_second-&gt;getName()); echo '&lt;br/&gt;'; $demo-&gt;string = \"sacha\"; var_dump($object_shallow_first-&gt;getName()); echo '&lt;br/&gt;'; var_dump($object_shallow_second-&gt;getName()); echo '&lt;br/&gt;'; &#125; public function deep() &#123; $demo = new Demo(); $demo-&gt;string = \"Siri\"; $object_deep_first = new ConcretePrototype($demo); $object_deep_second = $object_deep_first-&gt;deepCopy(); var_dump($object_deep_first-&gt;getName()); echo '&lt;br/&gt;'; var_dump($object_deep_second-&gt;getName()); echo '&lt;br/&gt;'; $demo-&gt;string = \"Demo\"; var_dump($object_deep_first-&gt;getName()); echo '&lt;br/&gt;'; var_dump($object_deep_second-&gt;getName()); echo '&lt;br/&gt;'; &#125;&#125;$up = new UsePrototype;$up-&gt;shallow();echo '&lt;hr&gt;';$up-&gt;deep(); 原型管理器的引入和实现原型管理器(Prototype Manager)是将多个原型对象存储在一个集合中, 供客户端使用;它是一个专门负责克隆对象的工厂, 其中定义了一个集合用于存储原型对象, 如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。在原型管理器中针对抽象原型类进行编程, 以便扩展。其结构如下图： 下面通过模拟一个简单的公文管理器来介绍原型管理器的设计与实现： Sunny软件公司在日常办公中有许多公文需要创建、递交和审批，例如《可行性分析报告》、《立项建议书》、《软件需求规格说明书》、《项目进展报告》等， 为了提高工作效率，在OA系统中为各类公文均创建了模板，用户可以通过这些模板快速创建新的公文，这些公文模板需要统一进行管理，系统根据用户请求的不同生成不同的新公文。 我们使用带原型管理器的原型模式实现公文管理器的设计，其结构如下图： 原型模式总结 原型模式作为一种快速创建大量相同或相似对象的方式, 在软件开发中应用较为广泛, 很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的典型应用; 主要优点 当创建新的对象实例较为复杂时, 使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。 主要缺点 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。 适用场景(在以下情况下可以考虑使用原型模式) 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。 参考参考参考","categories":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/categories/OOP/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/tags/OOP/"}]},{"title":"OOP - Observer","slug":"2016-07-15-OOP-Observer","date":"2016-06-08T12:13:17.000Z","updated":"2018-01-16T10:44:31.000Z","comments":true,"path":"2016/06/08/2016-07-15-OOP-Observer/","link":"","permalink":"http://blog.renyimin.com/2016/06/08/2016-07-15-OOP-Observer/","excerpt":"","text":"前言 在日常交通中, 当红灯亮起, 来往的汽车将停止; 而绿灯亮起, 汽车可以继续前行。在这个过程中, 交通信号灯是汽车的观察目标, 而汽车是观察者; 随着交通信号灯的变化, 汽车的行为也将随之而变化, 一盏交通信号灯可以指挥多辆汽车; 在软件系统中, 有些对象之间也存在类似交通信号灯和汽车之间的关系, 一个对象的状态或行为的变化, 将导致其他对象的状态或行为也发生改变, 它们之间将产生联动。 为了更好地描述对象之间存在的这种一对多(包括一对一)的联动, 观察者模式应运而生, 它定义了对象之间一种一对多的依赖关系, 让一个对象的改变能够影响其他对象。 多人联机对战游戏的设计引出观察者模式 Sunny软件公司欲开发一款多人联机对战游戏(类似魔兽世界、星际争霸等游戏), 在该游戏中, 多个玩家可以加入同一战队组成联盟, 当战队中某一成员受到敌人攻击时将给所有其他盟友发送通知, 盟友收到通知后将作出响应。 Sunny软件公司开发人员需要提供一个设计方案来实现战队成员之间的联动。Sunny软件公司开发人员通过对系统功能需求进行分析, 发现在该系统中战队成员之间的联动过程可以简单描述为：联盟成员受到攻击–&gt;发送通知给盟友–&gt;盟友作出响应。 如果按照上述思路来设计系统, 由于联盟成员在受到攻击时需要通知他的每一个盟友, 因此每个联盟成员都需要持有其他所有盟友的信息, 这将导致系统开销较大; 因此Sunny公司开发人员决定引入一个新的角色 —— 战队控制中心 ——来负责维护和管理每个战队所有成员的信息; 当一个联盟成员受到攻击时, 将向相应的战队控制中心发送求助信息, 战队控制中心再逐一通知每个盟友盟友再作出响应。 如下图: 在图中, 受攻击的联盟成员将与战队控制中心产生联动, 战队控制中心还将与其他盟友产生联动。 如何实现对象之间的联动? 如何让一个对象的状态或行为改变时, 依赖于它的对象能够得到通知并进行相应的处理？本篇所介绍的观察者模式将为对象之间的联动提供一个优秀的解决方案, 下面就让我们正式进入观察者模式的学习。 观察者模式 观察者模式是使用频率最高的设计模式之一, 它用于建立一种对象与对象之间的依赖关系, 一个对象发生改变时将自动通知其他对象, 其他对象将相应作出反应。 观察者模式(Observer Pattern)定义： 对象之间的一种一对多依赖关系, 使得每当一个对象状态发生改变时, 其相关依赖对象皆得到通知并被自动更新。 观察者模式的别名包括发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式, 源-监听器(Source/Listener)模式 或 从属者(Dependents)模式。 观察者模式是一种对象行为型模式。 观察者模式描述了如何建立对象与对象之间的依赖关系, 以及如何构造满足这种需求的系统。 123观察者模式包含`观察目标` 和 `观察者` 两类对象, 一个目标可以有任意数目的与之相依赖的观察者, 一旦观察目标的状态发生改变, 所有的观察者都将得到通知。作为对这个通知的响应, **每个观察者都将监视观察目标的状态**以使其状态与目标状态同步, 这种交互也称为发布-订阅(Publish-Subscribe)。观察目标是通知的发布者, 它发出通知时并不需要知道谁是它的观察者, 可以有任意数目的观察者订阅它并接收通知。 观察者模式结构中通常包括观察目标和观察者两个继承层次结构，其结构如下图所示： 在观察者模式结构图中包含如下几个角色: Subject(目标): 目标又称为主题, 它是指被观察的对象。 在目标中定义了一个观察者集合, 一个目标可以接受任意数量的观察者来观察目标自己, 目标提供一系列方法来增加和删除观察者对象, 同时它定义了通知方法 notify()。目标类可以是接口，也可以是抽象类或具体类。 ConcreteSubject(具体目标): 具体目标是目标类的子类; 通常它包含有经常发生改变的数据, 当它的状态发生改变时, 向它的各个观察者发出通知; Observer(观察者): 观察者将对观察目标的改变做出反应, 观察者一般定义为接口, 该接口声明了更新数据的方法 update(), 因此又称为抽象观察者。 ConcreteObserver(具体观察者): 在具体观察者中维护一个指向具体目标对象的引用, 它存储了本观察者的有关状态, 这些状态需要和具体目标的状态保持一致; 它实现了在抽象观察者Observer中定义的update()方法, 通常在实现时, 可以调用具体目标类的 attach() 方法将自己添加到目标类的集合中或通过 detach() 方法将自己从目标类的集合中删除。 下面通过代码来进行分析 先看被观察的目标 12345678910111213141516171819202122232425262728293031323334353637383940414243interface Subject&#123; //注册方法, 用于向观察者集合中增加一个观察者 public function attach(Observer $observer); //注销方法, 用于在观察者集合中删除一个观察者 public function detach(Observer $observer); //通知所有注册过的观察者对象 public function notify();&#125;class ConcreteSubject&#123; // 定义一个观察者集合,用于存放所有观察者对象 private $observers = []; //注册方法, 用于向观察者集合中增加一个观察者 public function attach(Observer $observer) &#123; return array_push($this-&gt;observers, $observer); &#125; //注销方法, 用于在观察者集合中删除一个观察者 public function detach(Observer $observer) &#123; $index = array_search($observer, $this-&gt;observers); if ($index === FALSE || ! array_key_exists($index, $this-&gt;observers)) &#123; return FALSE; &#125; unset($this-&gt;observers[$index]); return TRUE; &#125; //通知所有观察者 public function notify() &#123; if (!is_array($this-&gt;observers)) return false; foreach ($this-&gt;observers as $observer) $observer-&gt;update(); return true; &#125;&#125; 观察者 1234567891011121314151617181920//抽象观察者角色interface Observer &#123; // 更新方法 public function update();&#125;class ConcreteObserver implements Observer &#123; //观察者的名称 private $name; public function __construct($name) &#123; $this-&gt;name = $name; &#125; //更新方法 public function update() &#123; echo 'Observer ', $this-&gt;name, ' has notified.&lt;br /&gt;'; &#125;&#125; 客户端操作 1234567891011121314151617//实例化一个'观察目标'$subject = new ConcreteSubject();//实例化一个观察者$observer1 = new ConcreteObserver('lant01');//'观察目标'添加第一个观察者$subject-&gt;attach($observer1);//'观察目标' 通知 已经观察了目标自己的观察者$subject-&gt;notify();echo '添加第二个观察者后, 再次通知: &lt;br/&gt;';$observer2 = new ConcreteObserver('lant02');$subject-&gt;attach($observer2);$subject-&gt;notify();echo '删除第一个观察者后, 再次通知: &lt;br/&gt;';$subject-&gt;detach($observer1);$subject-&gt;notify(); 结果: 123456Observer lant01 has notified.添加第二个观察者后, 再次通知:Observer lant01 has notified.Observer lant02 has notified.删除第一个观察者后, 再次通知:Observer lant02 has notified. 复杂情况 – 违反”开放-封闭原则” 在有些更加复杂的情况下, 具体观察者类 ConcreteObserver 的 update() 方法在执行时需要使用到 具体目标类ConcreteSubject中的状态(属性) 因此在 ConcreteObserver 与 ConcreteSubject 之间有时候还存在关联或依赖关系, 在 ConcreteObserver 中定义一个 ConcreteSubject 实例, 通过该实例获取存储在 ConcreteSubject 中的状态。 如果ConcreteObserver的update()方法不需要使用到ConcreteSubject中的状态属性，则可以对观察者模式的标准结构进行简化, 在具体观察者ConcreteObserver和具体目标ConcreteSubject之间无须维持对象引用。 如果观察者和观察目标在具体层具有关联关系, 系统的扩展性将受到一定的影响, 增加新的具体目标类有时候需要修改原有观察者的代码, 在一定程度上违反了开闭原则, 但是如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响。 多人对战游戏的解决方案注意此时不太是简单的观察者模式(不是简单由观察者 对 观察目标), 因为每个玩家既可以发布求救请求, 又可以去救援别人(此时队员对应了战队中心之后, 战队中心又对应了队员)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;?php//战队控制中心interface TeamControlCenter&#123; //盟友加入战队 public function setPlayers(Observer $observer); //盟友退出战队 public function removePlayers(Observer $observer); //通知战队其他成员 public function notify($observerName);&#125;class ConcreteTeamControlCenter implements TeamControlCenter&#123; // 用于存放本战队所有成员 private $players = []; // 战队名称 private $teamName; public function __construct($teamName) &#123; $this-&gt;teamName = $teamName; &#125; //注册方法, 用于向观察者集合中增加一个观察者 public function setPlayers(Observer $player) &#123; if (array_push($this-&gt;players, $player)) echo $player-&gt;getPlayerName() . ' 成功加入 ' . $this-&gt;teamName . '战队!' , '&lt;br/&gt;'; &#125; //注销方法, 用于在观察者集合中删除一个观察者 public function removePlayers(Observer $player) &#123; $index = array_search($player, $this-&gt;players); if ($index === FALSE || ! array_key_exists($index, $this-&gt;players)) &#123; return FALSE; &#125; unset($this-&gt;players[$index]); echo $player-&gt;getPlayerName() . ' 成功退出 ' . $this-&gt;teamName . '战队!' , '&lt;br/&gt;'; &#125; //通知所有观察者 public function notify($playerName) &#123; if (!is_array($this-&gt;players)) return false; foreach ($this-&gt;players as $player) &#123; if ($player-&gt;getPlayerName() != $playerName) $player-&gt;helpOther(); &#125; &#125;&#125;//抽象观察者角色interface Observer&#123; // 接收队友求救 public function helpOther(); // 被攻击,发出求救 public function beAttacked(TeamControlCenter $concreteTeamControlCenter); // 获取名字 public function getPlayerName();&#125;//每个玩家都是观察者class Player implements Observer&#123; //玩家(观察者)的名称 private $playerName; public function __construct($playerName) &#123; $this-&gt;playerName = $playerName; &#125; public function getPlayerName() &#123; return $this-&gt;playerName; &#125; //遭受攻击, 发求救 public function beAttacked(TeamControlCenter $concreteTeamControlCenter) &#123; echo '我是 ' . $this-&gt;playerName, ', 我被攻击了&lt;br /&gt;'; // 被攻击的话, 要通知战队中心, 让战队中心通知其他队友 $concreteTeamControlCenter-&gt;notify($this-&gt;playerName); &#125; //支援盟友 public function helpOther() &#123; echo '撑住!!!' . $this-&gt;playerName, ' 来救你了&lt;br /&gt;'; &#125;&#125;//创建战队控制中心$langya_team = new ConcreteTeamControlCenter('狼牙');//创建玩家$player1 = new Player('金刚狼');$player2 = new Player('死侍');//玩家加入一个战队$langya_team-&gt;setPlayers($player1);$langya_team-&gt;setPlayers($player2);$player1-&gt;beAttacked($langya_team); 参考参考参考","categories":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/categories/OOP/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/tags/OOP/"}]},{"title":"OOP - Abstract  Factory","slug":"2016-06-08-OOP-Factory","date":"2016-06-08T12:13:17.000Z","updated":"2018-01-16T05:34:44.000Z","comments":true,"path":"2016/06/08/2016-06-08-OOP-Factory/","link":"","permalink":"http://blog.renyimin.com/2016/06/08/2016-06-08-OOP-Factory/","excerpt":"","text":"前言工厂方法模式通过引入工厂等级结构, 解决了简单工厂模式中工厂类职责太重的问题;但由于工厂方法模式中的每个工厂只生产一类产品, 可能会导致系统中存在大量的工厂类, 势必会增加系统的开销;此时, 我们可以考虑将一些相关的产品组成一个 “产品族”, 由同一个工厂来统一生产, 这就是我们本文将要学习的抽象工厂模式的基本思想。 抽象工厂未完待续 参考参考","categories":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/categories/OOP/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/tags/OOP/"}]},{"title":"OOP - Factory Method","slug":"2016-06-05-OOP-Factory","date":"2016-06-05T11:12:21.000Z","updated":"2018-01-16T05:31:07.000Z","comments":true,"path":"2016/06/05/2016-06-05-OOP-Factory/","link":"","permalink":"http://blog.renyimin.com/2016/06/05/2016-06-05-OOP-Factory/","excerpt":"","text":"前言 之前已经了解到: 简单工厂模式虽然降低了一定的耦合度, 但仍然存在一个严重问题: 当系统中需要引入新产品时, 由于静态工厂方法是通过所传入参数的不同来创建不同的产品, 所以必定还要修改工厂类的源代码, 又将违背“开闭原则”。 如何实现增加新产品而不影响已有代码？工厂方法模式应运而生。 日志记录器的设计Sunny软件公司欲开发一个系统运行日志记录器(Logger), 该记录器可以通过多种途径保存系统的运行日志, 如通过文件记录或数据库记录, 用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时, Sunny公司的开发人员发现需要对日志记录器进行一些初始化工作, 初始化参数的设置过程较为复杂, 而且某些参数的设置有严格的先后次序, 否则可能会发生记录失败。如何封装记录器的初始化过程并保证多种记录器切换的灵活性是Sunny公司开发人员面临的一个难题。 Sunny公司的开发人员通过对该需求进行分析，发现该日志记录器有两个设计要点: 需要封装日志记录器的初始化过程, 这些初始化工作较为复杂, 例如需要初始化其他相关的类, 还有可能需要读取配置文件(例如连接数据库或创建文件), 导致代码较长, 如果将它们都写在构造函数中, 会导致构造函数庞大, 不利于代码的修改和维护; 用户可能需要更换日志记录方式, 在客户端代码中需要提供一种灵活的方式来选择日志记录器, 尽量在不修改源代码的基础上更换或者增加日志记录方式。 简单工厂模式的设计 Sunny公司开发人员最初使用简单工厂模式对日志记录器进行了设计，初始结构如下图所示: 在图中, LoggerFactory充当创建日志记录器的工厂, 提供了工厂方法 createLogger() 用于创建日志记录器, Logger是抽象日志记录器接口, 其子类为具体日志记录器。其中, 工厂类LoggerFactory代码片段如下所示: 123456789101112131415161718192021222324252627//为了突出设计重点, 代码进行了简化, 省略了具体日志记录器类的初始化代码。//日志记录器工厂 class LoggerFactory &#123; //静态工厂方法 public static function createLogger($type) &#123; if($type == 'db')) &#123; //连接数据库, 代码省略 //... //创建数据库日志记录器对象 $logger = new DatabaseLogger(); //初始化数据库日志记录器，代码省略 //... return logger; &#125; else if ($type == 'file') &#123; //创建日志文件 //... //创建文件日志记录器对象 Logger logger = new FileLogger(); //初始化文件日志记录器，代码省略 //... return logger; &#125; else &#123; return null; &#125; &#125; &#125; 正如之前学习的简单工厂模式, 存在问题: 工厂类过于庞大，包含了大量的if…else…代码，导致维护和测试难度增大; 系统扩展不灵活，如果增加新类型的日志记录器，必须修改静态工厂方法的业务逻辑，违反了“开闭原则”。 如何解决这两个问题, 这就是本文所介绍的 工厂方法模式 的动机之一。 工厂方法 在简单工厂模式中只提供一个工厂类, 该工厂类处于对产品类进行实例化的中心位置, 它需要知道每一个产品对象的创建细节, 并决定何时实例化哪一个产品类。 简单工厂模式最大的缺点是: 当有新产品要加入到系统中时, 必须修改工厂类, 需要在其中加入必要的业务逻辑, 这违背了“开闭原则”。 此外, 在简单工厂模式中, 所有的产品都由同一个工厂创建, 工厂类职责较重, 业务逻辑较为复杂, 具体产品与工厂类之间的耦合度高, 严重影响了系统的灵活性和扩展性, 而工厂方法模式则可以很好地解决这一问题! 在工厂方法模式中, 我们不再提供一个统一的工厂类来创建所有的产品对象, 而是针对不同的产品提供不同的工厂, 系统提供一个与产品等级结构对应的工厂等级结构, 工厂方法模式定义如下: 1234工厂方法模式(Factory Method Pattern): 定义一个用于创建对象的接口, 让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern), 又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。 工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。工厂方法模式结构如下图所示： 在工厂方法模式结构图中包含如下几个角色: Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。 ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。 Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。 ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 与简单工厂模式相比, 工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类，其典型代码如下所示： 123interface Factory &#123; public Product factoryMethod(); &#125; 在抽象工厂中声明了工厂方法, 具体产品对象的创建由其子类负责, 客户端针对抽象工厂编程, 可在运行时再指定具体工厂类, 具体工厂类实现了工厂方法, 不同的具体工厂可以创建不同的具体产品，其典型代码如下所示： 12345678class ConcreteFactory implements Factory &#123; public function factoryMethod() &#123; // 在实际使用时，具体工厂类在实现工厂方法时, 除了创建具体产品对象之外， // 还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。 return new ConcreteProduct(); &#125; &#125; 在客户端代码中，只需关心工厂类即可，**不同的具体工厂可以创建不同的产品**，典型的客户端类代码片段如下所示： 1234Factory factory; factory = new ConcreteFactory(); //可通过配置文件来实现 (通过配置来决定你要具体使用哪个具体的工厂类) Product product; product = factory-&gt;factoryMethod(); 可以通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。 工厂方法模式中的工厂方法能否为静态方法？为什么？ 貌似不太可以, 因为静态方法是类的, 不是对象的! 完整实现参考 http://blog.csdn.net/lovelion/article/details/9307137 隐藏工厂方法是参考 http://blog.csdn.net/lovelion/article/details/9307561 工厂方法模式是简单工厂模式的延伸, 它继承了简单工厂模式的优点, 同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一, 是很多开源框架和API类库的核心模式。 主要优点 在工厂方法模式中，具体的工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的具体工厂类是哪个，无须关心创建细节，甚至无须知道具体产品类的类名; 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类; 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 主要缺点 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要运行，会给系统带来一些额外的开销; 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到反射等技术，增加了系统的实现难度。 参考参考参考","categories":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/categories/OOP/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/tags/OOP/"}]},{"title":"OOP - Simple Factory","slug":"2016-06-04-OOP-Factory","date":"2016-06-04T13:11:30.000Z","updated":"2018-01-16T05:31:11.000Z","comments":true,"path":"2016/06/04/2016-06-04-OOP-Factory/","link":"","permalink":"http://blog.renyimin.com/2016/06/04/2016-06-04-OOP-Factory/","excerpt":"","text":"工厂模式是最常用的一类创建型设计模式, 通常所说的工厂模式是指工厂方法模式, 它也是使用频率最高的工厂模式。简单工厂模式是工厂方法模式的”小弟”, 它不属于 GoF23种设计模式, 但在软件开发中应用也较为频繁, 通常将它作为学习其他工厂模式的入门。此外，工厂方法模式还有一位”大哥” —— 抽象工厂模式。这三种工厂模式各具特色, 难度也逐个加大, 在软件开发中它们都得到了广泛的应用, 成为面向对象软件中常用的创建对象的工具。 前言 假设公司开发的CRM系统可以显示饼状图的效果, 原始设计方案如下图: 123456789101112131415161718192021222324class Client&#123; public $chartObject = null; public function __construct($type) &#123; switch ($chartType) &#123; case 'pie' : $this-&gt;chartObject = new PieChart(); break; case 'bar' : $this-&gt;chartObject = new BarChart(); break; default: //TODO break; &#125; &#125; public function show() &#123; $this-&gt;chartObject-&gt;display(); &#125;&#125; 客户端代码通过调用 ‘Client类’ 的构造函数来创建图表对象，根据参数 ‘type’ 可以得到不同类型的图表，然后再调用show()方法来显示相应的图表。 传统设计存在问题不难看出，Client类是一个 “巨大的” 类, 在该类的设计中存在如下几个问题: Client类中包含很多 “if…else…” / “switch…case…”代码块，整个类的代码相当冗长, 阅读难度、维护难度和测试难度也越大, 而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断; Client类的职责过重, 它将各种图表对象的创建和使用集中在一个类中实现, 违反了“单一职责原则”, 不利于类的重用和维护; 当需要增加新类型的图表时，必须修改Client类的源代码，违反了’开闭原则’; 客户端只能通过new关键字来直接创建图像对象, 图像类与客户端Client类耦合度较高 (比如一旦类的名字发生变更, 你也必须修改Client代码的源代码); 客户端在创建Chart对象之前可能还需要进行大量初始化设置, 例如设置柱状图的颜色、高度等, 如果在Client类的构造函数中没有提供一个默认设置, 那就只能由客户端来完成初始设置，这些代码在每次创建图像对象时都会出现, 导致代码的重复。 面对一个如此巨大、职责如此重，且与客户端代码耦合度非常高的类，我们应该怎么办？接下来介绍的 简单工厂模式 将在 一定程度上 解决上述问题。 简单工厂模式 为了将图像对象的创建和使用分离, 使用简单工厂模式对图表库进行重构, 重构后的结构如下图所示： 在图中, Chart接口充当抽象产品类, 其子类PieChart和BarChart充当具体产品类, ChartFactory充当工厂类。 现在, 我们使用工厂类的 静态工厂方法 来创建产品对象, 如果需要更换产品, 虽然也需要更改Client源码, 但是只需修改传递给静态工厂方法中的参数即可, 例如将柱状图改为饼状图, 只需将代码 $chartObject = ChartFactory::getChart(&quot;bar&quot;); 改为：$chartObject = ChartFactory::getChart(&quot;pie&quot;); 改进 现在你会发现: 在创建具体图像对象时, 每更换一个图像对象, 都需要修改客户端代码中静态工厂方法的参数(虽然修改都很小), 这对于客户端而言, 还是违反了“开闭原则”; 有没有一种方法能够在不修改客户端代码的前提下更换具体产品对象呢？答案是肯定的，下面将介绍一种常用的实现方式: 可以将静态工厂方法的参数放到配置文件中, 在配置文件中配置即可, 这样客户端代码如下所示：由$chartObject = ChartFactory::getChart(&quot;bar&quot;);改为：$type = Config::get('chartType'); $chartObject = ChartFactory::getChart(\"pie\"); 简单工厂模式总结 简单工厂模式提供了专门的工厂类用于创建对象, 将对象的创建和对象的使用分离开, 它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用; 主要优点 工厂类包含必要的判断逻辑, 可以决定在什么时候创建哪一个产品类的实例, 客户端可以免除直接创建产品对象的职责, 而仅仅“消费”产品, 简单工厂模式实现了对象创建和使用的分离; 客户端无须知道所创建的具体产品类的类名，只需要知道创建具体产品类所需要对应的参数即可, 对于一些复杂的类名, 通过简单工厂模式可以在一定程度减少使用者的记忆量; 通过引入配置文件, 可以在不修改任何客户端代码的情况下更换和增加新的具体产品类, 在一定程度上提高了系统的灵活性, 做到了 一定程度的”开放-封闭原则”, 下面会看到其实工厂类部分还是违反的。 主要缺点 由于工厂类集中了所有产品的创建逻辑, 职责过重, 一旦不能正常工作, 整个系统都要受到影响; 使用简单工厂模式势, 势必会增加系统中类的个数(引入了新的工厂类), 增加了系统的复杂度和理解难度; 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑, 在产品类型较多时, 有可能造成工厂逻辑过于复杂, 不利于系统的扩展和维护。(此处还是违反“开放-封闭原则”) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 适用场景, 在以下情况下可以考虑使用简单工厂模式: 工厂类负责创建的对象比较少, 由于创建的对象较少, 不会造成工厂方法中的业务逻辑太过复杂。 客户端只知道传入工厂类的参数, 对于如何创建对象并不关心。 总之, 仍未完全做到 “开放-封闭原则” 参考参考","categories":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/categories/OOP/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/tags/OOP/"}]},{"title":"OOP - 为什么要引入工厂类?","slug":"2016-06-03-OOP-Why-Factory","date":"2016-06-03T05:10:39.000Z","updated":"2018-01-16T05:31:16.000Z","comments":true,"path":"2016/06/03/2016-06-03-OOP-Why-Factory/","link":"","permalink":"http://blog.renyimin.com/2016/06/03/2016-06-03-OOP-Why-Factory/","excerpt":"","text":"前言工厂模式(包括简单工厂模式、工厂方法模式 和 抽象工厂模式 )到底有什么用? 很多时候通过反射机制就可以很灵活地创建对象, 为毛还要工厂？ 首先要知道, 与一个对象相关的职责通常有三类: 对象本身所具有的职责 创建对象的职责 使用对象的职责 对象本身的职责比较容易理解, 就是对象自身所具有的一些数据和行为, 可通过一些公开的方法来实现它的职责。 接下来将简单讨论一下对象的创建职责 和 使用职责 对象的 创建职责 和 使用职责 通常有以下几种创建对象的方式： 使用new关键字直接创建对象; 通过反射机制创建对象; 通过clone()方法创建对象； 通过工厂类创建对象; 在客户端代码中直接使用new关键字是最简单的一种创建对象的方式，但是它的灵活性较差，下面通过一个简单的示例来加以说明 假设公司开发的CRM系统可以显示饼状图的效果, 原始设计方案如下图: 1234567891011121314151617181920212223242526272829303132&lt;?php class PieChart &#123; public function display() &#123; echo 'piechart', '&lt;br/&gt;'; &#125; &#125; class BarChart &#123; public function display() &#123; echo 'barchart', '&lt;br/&gt;'; &#125; &#125; //Client class Client &#123; public $chartObject = null; public function __construct() &#123; $this-&gt;chartObject = new PieChart(); &#125; public function show() &#123; $this-&gt;chartObject-&gt;display(); &#125; &#125; 在’client’类的构造函数中创建了’PieChart’类型的对象，并在’show’方法中调用了’chartObject’对象的’display()’方法, 这段代码看上去并没有什么问题; 下面我们来分析一下’Client’和’PieChart’之间的关系: ‘Client’类负责创建了一个’PieChart’类的对象, 并使用其方法’display()’来完成相应的业务处理; 也就是说’Client’即负责对象的创建, 又负责对象的使用, 创建对象和使用对象的职责耦合在一起; 同时, 这样的设计会导致一个很严重的问题: 如果在 ‘Client’ 中希望能够使用另一个种类型的图像方案, 比如使用柱状图’BarChart’类的对象，那就必须修改’Client’类的源代码, 违反了”开闭原则”。 如何解决? 引出工厂类最常用的一种解决方法是将 ‘chartObject’ 对象的创建职责从 ‘Client’ 类中移除, 在 ‘Client’ 类之外创建对象, 那么谁来负责创建 ‘chartObject’ 对象呢?答案是：工厂类; 通过引入工厂类, 客户类就不会再涉及对象的创建(只是对对象进行使用), 而创建对象的工厂类自然也只是负责创建对象(也不会涉及对象的使用)。引入工厂类 ChartFactory 之后的结构如下图所示: 工厂类的引入将降低维护工作量： 如果图像类的构造函数发生变更, 或者需要添加或移除不同的图像类，你只要去维护 ChartFactory 的代码, 可能就不会影响到’Client’的代码; 而且如果 Chart 抽象接口发生改变, 例如添加、移除方法或改变方法名, 只需要修改 Client, 不会给 ChartFactory 带来任何影响; 在所有的工厂模式中, 我们都强调一点: 两个类A和B之间的关系应该仅仅是 A创建B 或是 A使用B, 而不能两种关系都有。将对象的创建和使用分离, 也使得系统更加符合 ‘单一职责原则’, 有利于对功能的复用和系统的维护; 此外, 将对象的创建和使用分离还有一个好处: 防止用来实例化一个类的代码在多个类中到处都是, 可以将有关创建的代码搬移到一个工厂类中。因为有时候我们创建一个对象不只是简单调用其构造函数, 还需要设置一些参数, 可能还需要配置环境,如果将这些代码散落在每一个创建对象的客户类中, 势必会出现代码重复、创建蔓延的问题, 而这些客户类其实无须承担对象的创建工作,它们只需使用已创建好的对象就可以了。此时, 可以引入工厂类来封装对象的创建逻辑和客户代码的实例化/配置选项。 参考","categories":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/categories/OOP/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/tags/OOP/"}]},{"title":"OOP - Singleton-02","slug":"2016-05-27-OOP-Singleton","date":"2016-05-27T12:07:13.000Z","updated":"2018-01-16T06:15:33.000Z","comments":true,"path":"2016/05/27/2016-05-27-OOP-Singleton/","link":"","permalink":"http://blog.renyimin.com/2016/05/27/2016-05-27-OOP-Singleton/","excerpt":"","text":"前言之前已经对单例模式有了比较简单的认识接下来通过一些资料在系统了解一下单例模式; 单例模式动机 对于一个软件系统的某些类而言, 我们无须创建多个实例。 举个大家都熟知的例子 —— Windows任务管理器, 当你在Windows的”任务栏”的右键弹出菜单上多次点击”启动任务管理器”。通常情况下，无论我们启动任务管理多少次，Windows系统始终只能弹出一个任务管理器窗口，也就是说在一个Windows系统中，任务管理器存在唯一性。为什么要这样设计呢？我们可以从以下两个方面来分析：其一，如果能弹出多个窗口，且这些窗口的内容完全一致，全部是重复对象，这势必会浪费系统资源，任务管理器需要获取系统运行时的诸多信息，这些信息的获取需要消耗一定的系统资源，包括CPU资源及内存资源等，浪费是可耻的，而且根本没有必要显示多个内容完全相同的窗口;其二，如果弹出的多个窗口内容不一致，问题就更加严重了，这意味着在某一瞬间系统资源使用情况和进程、服务等信息存在多个状态，例如任务管理器窗口A显示“CPU使用率”为10%，窗口B显示“CPU使用率”为15%，到底哪个才是真实的呢？这纯属”调戏”用户，给用户带来误解，更不可取。由此可见，确保Windows任务管理器在系统中有且仅有一个非常重要。 回到实际开发中, 我们也经常遇到类似的情况, 为了节约系统资源, 有时需要确保系统中某个类只有唯一一个实例, 当这个唯一实例创建成功之后, 我们无法再创建一个同类型的其他对象, 所有的操作都只能基于这个唯一实例。 为了确保对象的唯一性, 我们可以通过单例模式来实现, 这就是单例模式的动机所在。 参考一个负载均衡器的例子 Sunny软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高系统的整体处理能力，缩短响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键。 Sunny公司开发人员通过分析和权衡，决定使用单例模式来设计该负载均衡器, 将负载均衡器LoadBalancer设计为单例类, 其中包含一个存储服务器信息的集合serverList, 每次在serverList中随机选择一台服务器来响应客户端的请求,实现代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpclass LoadBalancer&#123; private static $instance = null; private $serverList = array(); private function __construct() &#123; &#125; private function __clone() &#123; &#125; public static function getInstance() &#123; if (null === self::$instance) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; /** * 增加一台服务器 */ public function addServer($server) &#123; $this-&gt;serverList[] = $server; &#125; /** * 减少一台宕机的服务器 */ public function removeServer($key) &#123; unset($this-&gt;serverList[$key]); &#125; /** * 随机获取一台服务器 */ public function getServer() &#123; $random = mt_rand(0, count($this-&gt;serverList)-1); return $this-&gt;serverList[$random]; &#125;&#125;echo '&lt;pre/&gt;';$loadBalancer1 = LoadBalancer::getInstance();$loadBalancer2 = LoadBalancer::getInstance();var_dump($loadBalancer1 === $loadBalancer2);$loadBalancer1-&gt;addServer(\"Server 1\");$loadBalancer1-&gt;addServer(\"Server 2\");$loadBalancer2-&gt;addServer(\"Server 3\");$loadBalancer2-&gt;addServer(\"Server 4\");//模拟客户端请求的分发for ($i=0; $i&lt;10; $i++) &#123; $server = $loadBalancer1-&gt;getServer(); var_dump(\"分发请求至服务器： \" . $server);&#125; 结果: 1234567891011bool(true)string(36) \"分发请求至服务器： Server 1\"string(36) \"分发请求至服务器： Server 3\"string(36) \"分发请求至服务器： Server 4\"string(36) \"分发请求至服务器： Server 3\"string(36) \"分发请求至服务器： Server 3\"string(36) \"分发请求至服务器： Server 3\"string(36) \"分发请求至服务器： Server 3\"string(36) \"分发请求至服务器： Server 3\"string(36) \"分发请求至服务器： Server 1\"string(36) \"分发请求至服务器： Server 4\" 虽然创建了四个LoadBalancer对象，但是它们实际上是同一个对象，因此，通过使用单例模式可以确保LoadBalancer对象的唯一性。 饿汉式单例与懒汉式单例的讨论涉及到多线程未完待续… 参考参考参考","categories":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/categories/OOP/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/tags/OOP/"}]},{"title":"OOP - Singleton-01","slug":"2016-05-26-OOP-Singleton","date":"2016-05-26T10:21:28.000Z","updated":"2018-01-16T06:15:39.000Z","comments":true,"path":"2016/05/26/2016-05-26-OOP-Singleton/","link":"","permalink":"http://blog.renyimin.com/2016/05/26/2016-05-26-OOP-Singleton/","excerpt":"","text":"常见场景举例 框架底层的 数据库模型层 就可以使用单例 ThinkPHP3.2中, 虽然 数据库模型层 使用了单例模式, 但并非传统意义上所谓 三公一私 的单例: 1234567891011121314TP3.2创建数据库模型实例的过程大概为: Think\\Model -&gt; Think\\Db -&gt; Think\\Db\\Driver\\Mysql -&gt; Think\\Db\\DriverD()/M() 方法都可以调用 Think\\Model 这个模型类虽然 Think\\Model 层并未做到单例, 即 new Model(...) 实例出的对象为非单例, 但其通过调用下层 Think\\Db 的 getInstance(), 然后简单结合一个 数据库对象池$_db(注册树模式) 来保证底层各不同数据库对象的单例性; Think\\Db 的 getInstance() 通过 数据库连接池$instance 保证了下层 Think\\Db\\Driver\\Mysql 数据库连接实例的单例性而 Think\\Db 其内部与底层沟通的方法全是static型, 用户在顶层控制器中直接new也没意义只有在顶层控制器直接 new `Think\\Db\\Driver\\Mysql` 你会获得不同的数据库连接实例, 但一般也不会直接new底层!最下层 Think\\Db\\Driver 为抽象层 所以实现单例未必需要严格按照传统的规则来, 有很多变体都可以保证实现单例; 日志类TP3中的Log类比较简单, 作为基础类, 直接各方法为静态, 很简单就做到了要想使用, 就必然是单例, 基本上你new也没什么用!…未完待续 项目的配置类…未完待续 优点 提供了对唯一实例的受控访问 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能缺点 PHP语言是一种解释型的脚本语言, 这种运行机制使得每个PHP页面被解释执行后, 所有的相关资源都会被回收。 在PHP中, 所有的变量无论是全局变量还是类的静态成员, 都是页面级的, 每次页面被执行时, 都会重新建立新的对象, 所以PHP单例模式貌似只是针对单次页面级请求时出现多个应用场景并需要共享同一对象资源时是有意义的; 几个基本注意事项 通常我们都是遵循正常的”三私一公”来写单例, 但是可以看到如下代码会因为序列化,反序列化而导致单例出问题 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass Singleton&#123; private static $instance = null; private function __construct() &#123; &#125; private function __clone() &#123; &#125; public static function getInstance() &#123; if (null === self::$instance) self::$instance = new self(); return self::$instance; &#125;&#125;echo &apos;&lt;pre/&gt;&apos;;$test_1 = Singleton::getInstance();$test_2 = Singleton::getInstance();var_dump($test_1); //实例1var_dump($test_2); //实例1var_dump($test_1 === $test_2); // trueecho &apos;unserialize, serialize:---------------------------&lt;br/&gt;&apos;;$test_1 = unserialize(serialize($test_1));var_dump($test_1); //实例2var_dump(Singleton::getInstance()); //实例1var_dump( Singleton::getInstance() === $test_1); //falseecho &apos;unserialize, serialize:---------------------------&lt;br/&gt;&apos;;$test_3 = Singleton::getInstance();var_dump($test_3); //实例1$test_3 = unserialize(serialize($test_3));var_dump($test_3); //实例3var_dump(Singleton::getInstance()); //实例1var_dump( Singleton::getInstance() === $test_3); //false 鸟哥博文其实并不能完全解决, 看下面例子: 虽然每次反序列化后的所有实例都一致, 但是一旦碰到再次反序列化, 还是会出问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpclass Singleton&#123; private static $instance = null; private function __construct() &#123; &#125; private function __clone() &#123; &#125; public function __wakeup() &#123; self::$instance = $this; &#125; public static function getInstance() &#123; if (null === self::$instance) self::$instance = new self(); return self::$instance; &#125; public function __destruct() &#123; &#125;&#125;echo '&lt;pre/&gt;';$test_1 = Singleton::getInstance(); $test_2 = Singleton::getInstance(); var_dump($test_1); //实例1var_dump($test_2); //实例1var_dump($test_1 === $test_2); //trueecho 'unserialize, serialize:---------------------------&lt;br/&gt;';$test_1 = unserialize(serialize($test_1));var_dump($test_1); //实例2var_dump(Singleton::getInstance()); //实例2var_dump( Singleton::getInstance() === $test_1); //trueecho 'unserialize, serialize:---------------------------&lt;br/&gt;';$test_3 = Singleton::getInstance();var_dump($test_3); //实例2$test_3 = unserialize(serialize($test_3));var_dump($test_3); //实例3var_dump(Singleton::getInstance()); //实例3var_dump( Singleton::getInstance() === $test_3); //true 可以看到还是出现了多个不同的实例!!! 博文中有个评论比较有意思, 可以看一下: 另外, 单例模式出现继承关系时, 需要注意PHP的 self 和 static 关键字的区别 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpclass Singleton&#123; protected static $instance = null; protected function __construct() &#123; &#125; protected function __clone() &#123; &#125; protected function __wakeup() &#123; static::$instance = $this; &#125; public static function getInstance() &#123; if (null === static::$instance) static::$instance = new static(); return static::$instance; &#125;&#125;echo &apos;&lt;pre/&gt;&apos;;$test_1 = Singleton::getInstance();$test_2 = Singleton::getInstance();var_dump($test_1);var_dump($test_2);var_dump($test_1 === $test_2);class Log extends Singleton&#123; // 注意: 每个继承单例的子类, 必须要做清空, 否则所有的实例都是上面的实例结果 protected static $instance = null; public function write() &#123; echo &apos;success write something&apos;; &#125;&#125;class Model extends Singleton&#123; // 注意: 每个继承单例的子类, 必须要做清空, 否则所有的实例都是上面的实例结果 protected static $instance = null; public function select() &#123; echo &apos;success select something&apos;; &#125;&#125;$log_1 = Log::getInstance();$log_2 = Log::getInstance();var_dump($log_1);var_dump($log_2);var_dump($log_1 === $log_2);$model_1 = Model::getInstance();$model_2 = Model::getInstance();var_dump($model_1);var_dump($model_2);var_dump($model_1 === $model_2);var_dump($model_1 === $test_2); // false","categories":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/categories/OOP/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/tags/OOP/"}]},{"title":"OOD-S.O.L.I.D","slug":"2016-05-23-OOP-SOLID","date":"2016-05-23T10:21:21.000Z","updated":"2018-01-15T02:56:29.000Z","comments":true,"path":"2016/05/23/2016-05-23-OOP-SOLID/","link":"","permalink":"http://blog.renyimin.com/2016/05/23/2016-05-23-OOP-SOLID/","excerpt":"","text":"The Single Responsibility Principle（单一职责原则 SRP）高内聚, 低耦合 单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。 单一职责原则定义为: 一个类或者模块应该有且只有一个被改变的原因。 如果一个类承担的职责过多, 就等于把这些职责 耦合 在一起了。 一个职责的变化可能会影响其他的职责, 这种耦合会导致脆弱的设计, 当发生变化时, 设计会遭受到意想不到的破坏。 而如果想要避免这种现象的发生, 就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性。 单一职责原则告诉我们: 一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即,将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则也可考虑将它们封装在同一类中。 遵循单一职责原的优点有: 可以降低类的复杂度, 一个类只负责一项职责, 其逻辑肯定要比负责多项职责简单的多; 提高类的可读性, 提高系统的可维护性; 变更引起的风险降低, 变更是必然的, 如果单一职责原则遵守的好, 当修改一个功能时, 可以显著降低对其他功能的影响; 需要说明的一点是单一职责原则不只是面向对象编程思想所特有的, 只要是模块化的程序设计, 都适用单一职责原则; 参考: http://blog.csdn.net/lovelion/article/details/7536542 The Open/Closed Principle（开放封闭原则OCP）对抽象编程, 而不对具体编程 开放-封闭原则: 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 任何软件都需要面临一个很重要的问题, 即, 它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。 有必要用例子来简单说明一下, 假设公司开发的CRM系统可以显示各种类型的图表, 如 饼状图 和 柱状图 等, 为了支持多种图表显示方式, 原始设计方案如下图: 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpclass PieChart&#123; public function display() &#123; echo 'piechart', '&lt;br/&gt;'; &#125;&#125;class BarChart&#123; public function display() &#123; echo 'barchart', '&lt;br/&gt;'; &#125;&#125;class ChartDisplay&#123; public $chartObject = null; public function __construct() &#123; //TODO &#125; public function display($chartType) &#123; switch ($chartType) &#123; case 'pie' : $piechart = new PieChart(); $piechart-&gt;display(); break; case 'bar' : $barchart = new BarChart(); $barchart-&gt;display(); break; default: //TODO break; &#125; &#125;&#125; 问题: 现在如果需要增加一个图表类, 如折线图LineChart, 则需要修改ChartDisplay类的display()方法的源代码, 增加新的判断逻辑, 违反了开闭原则!! 现对该系统进行重构, 使之符合开闭原则 我们引入了抽象图表类AbstractChart, 并且让ChartDisplay针对抽象图表类进行编程(依赖抽象), 在ChartDisplay的display()方法中调用chart对象的display()方法显示图表。 如果需要增加一种新的图表, 如折线图LineChart, 只需要将LineChart也作为AbstractChart的子类, 在客户端向ChartDisplay中注入一个LineChart对象即可, 无须修改现有类库的源代码。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpabstract class AbstractChart&#123; protected function display() &#123; &#125;&#125;class PieChart extends AbstractChart&#123; public function display() &#123; echo 'piechart', '&lt;br/&gt;'; &#125;&#125;class BarChart extends AbstractChart&#123; public function display() &#123; echo 'barchart', '&lt;br/&gt;'; &#125;&#125;class ChartDisplay&#123; public function __construct() &#123; //TODO &#125; public function display(AbstractChart $chart) &#123; $chart-&gt;display(); &#125;&#125;$cd = new ChartDisplay();$cd-&gt;display(new PieChart());$cd-&gt;display(new BarChart()); 参考: http://blog.csdn.net/lovelion/article/details/7537584 The Liskov Substitution Principle（里氏替换原则LSP） 所有引用基类（父类）的地方必须能透明地使用其子类对象。 子类可以实现父类的抽象方法, 但是不能覆盖父类的非抽象方法, 也就是子类可以扩展父类的功能, 但是不能改变父类原有的功能; 当子类覆盖或实现父类的方法时, 方法的前置条件(即方法的形参)要比父类方法的输入参数更宽松。(PHP是弱类型语言) 当子类的方法实现父类的抽象方法时, 方法的后置条件(即方法的返回值)要比父类更严格。(PHP是弱类型语言)参考: http://blog.csdn.net/lovelion/article/details/7540445 貌似主要就是说, 如果依赖的类可能日后会有扩展的话, 你最好设计一个抽象父类或接口, 子类继承、实现父类; 里氏代换原则是实现开闭原则的重要方式之一, 由于使用基类对象的地方都可以使用子类对象, 因此在程序中尽量使用基类类型来对对象进行定义, 而在运行时再确定其子类类型, 用子类对象来替换父类对象。 The Interface Segregation Principle（接口分离原则ISP）该原则比较好理解 不要定义过于臃肿的接口, 接口中不要有很多不相关的逻辑方法(否则一定也违背单一职责原则); 过于臃肿的接口可能会强迫用户去实现接口内部用户并不需要的方法。换句话说, 使用 多个专门的接口 比使用 一个臃肿的总接口 要好很多; 如果你在类中实现了你不需要使用的接口方法, 估计也是重写为空方法, 这其实已经违背了接口分离原则。 也就是说，一个接口或者类应该拥有尽可能少的行为, 就是少到恰好能完成它自身的职责, 这也是保证 “软件系统模块的粒度尽可能少, 以达到高度可重用的目的”; 接口包含太多的方法会降低其可用性，像这种包含了无用方法的”胖接口”会增加类之间的耦合。 如果一个类想实现该接口,那么它需要实现所有的方法,尽管有些对它来说可能完全没用，所以这样做会在系统中引入不必要的复杂度, 降低代码的可维护性或鲁棒性。 接口分离原则确保实现的接口有它们共同的职责, 它们是明确的, 易理解的, 可复用的. The Dependency Inversion Principle（依赖反转原则DIP）要针对接口编程, 而不是针对实现编程 如果说开闭原则是面向对象设计的目标的话, 那么依赖倒转原则就是面向对象设计的主要实现机制之一, 它是系统抽象化的具体实现; 上层不用去定义自己要依赖哪个具体的类, 而是定义自己依赖哪个 抽象; 然后让底层代码根据上层的要求, 去实现相应的 抽象; 这样就变成了底层对上层的依赖, 底层代码需要去 实现 上层代码定义的抽象; 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。 在实现依赖倒转原则时, 我们需要针对抽象层编程，将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和 接口注入。 构造注入是指通过构造函数来传入具体类的对象 设值注入是指通过Setter方法来传入具体类的对象 而接口注入是指通过在接口中声明的业务方法来传入具体类的对象这些方法在定义时使用的是抽象类型, 在运行时再传入具体类型的对象, 由子类对象来覆盖父类对象。 有必要用例子来简单说明一下 由于CustomerDAO针对具体数据转换类编程, 因此在增加新的数据转换类或者更换数据转换类时都不得不修改CustomerDAO的源代码。 我们可以通过引入抽象数据转换类解决该问题，在引入抽象数据转换类DataConvertor之后，CustomerDAO针对抽象类DataConvertor编程，符合依赖倒转原则。 根据里氏代换原则，程序运行时，具体的数据转换类对象 将替换DataConvertor类型的对象，程序不会出现任何问题。更换具体数据转换类时无须修改源代码，只需要说明你需要哪个具体的类(可以在配置文件中配置)。 如果需要增加新的具体数据转换类，只要将新增数据转换类作为DataConvertor的子类即可，原有代码无须做任何修改，满足开闭原则。 重构后的结构如图2所示： 在上述重构过程中, 我们使用了 开闭原则、里氏代换原则 和 依赖倒转原则 , 在大多数情况下, 这三个设计原则会同时出现, 开闭原则是目标, 里氏代换原则是基础, 依赖倒转原则是手段, 它们相辅相成, 相互补充, 目标一致, 只是分析问题时所站角度不同而已。参考: http://blog.csdn.net/lovelion/article/details/7562783 小结开闭原则是目标, 里氏代换原则 和 依赖倒转原则 都是为了实现开闭原则! 怪不得举的例子都那么相似~~","categories":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/categories/OOP/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://blog.renyimin.com/tags/OOP/"}]}]}