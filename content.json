{"meta":{"title":"Lant's Blog","subtitle":null,"description":null,"author":"Lant","url":"http://blog.renyimin.com"},"pages":[{"title":"分类","date":"2017-09-17T02:40:28.000Z","updated":"2017-09-18T09:08:09.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.renyimin.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-09-17T02:40:21.000Z","updated":"2017-09-18T09:08:03.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.renyimin.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Django URL反向解析","slug":"2017-11-13-Django-04","date":"2017-11-13T14:30:27.000Z","updated":"2017-12-15T08:24:14.000Z","comments":true,"path":"2017/11/13/2017-11-13-Django-04/","link":"","permalink":"http://blog.renyimin.com/2017/11/13/2017-11-13-Django-04/","excerpt":"","text":"错误处理 流程 基本配置 路由系统 视图view 模板 Model 中间件 Form认证系统CSRF分页CookieSeesion缓存序列化信号admin","categories":[{"name":"Django","slug":"Django","permalink":"http://blog.renyimin.com/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://blog.renyimin.com/tags/Django/"}]},{"title":"Django URL反向解析","slug":"2017-11-13-Django-03","date":"2017-11-13T14:30:25.000Z","updated":"2017-12-18T02:41:00.000Z","comments":true,"path":"2017/11/13/2017-11-13-Django-03/","link":"","permalink":"http://blog.renyimin.com/2017/11/13/2017-11-13-Django-03/","excerpt":"","text":"在使用Django项目时, 在视图view, 模板template….等地方都会要求获得URL的最终形式, 此时就需要注意, 不要硬编码这些URL(费力、不可扩展且容易产生错误); 在Django中, 要做URL反查, 首先要对你的URL模式进行命名: 也就是在URLConf的urlpatternslist使用url()的关键字参数name对你的URL模式进行命名; Django在项目的不同层级, 提供了不同的工具用于URL反查: 在模板中: 使用url模板标签; 在Python代码中: 使用 django.core.urlresolvers.reverse() 函数; 在更高层的与处理Django模型实例相关的代码中: 使用 get_absolute_url() 方法; URL模式的命名 URL模式的名称所用的字符串可以包含任何你喜欢的字符, 并不仅限于合法的Python名称; 随着应用的增多, URL模式的名称容易冲突, 你不同的应用中可能都会出现 url(r&#39;detail/$&#39;, views.detail, name=&#39;detail&#39;), 中detail这个命名, 这样就出现URL模式同名的问题, 因为Django无法知道使用detail到底想获得哪个URL; 当然, 在URL名称中加上一个前缀, 比如应用的名称, 将减少冲突的可能, 比如 detail 可以改为 polls-detail, 但是这显然不是最好的方法是, 建议使用命名空间; URL 命名空间 URL命名空间允许你反查到唯一的命名URL模式, 即使不同的应用使用相同的URL名称; 使用URL命名空间的话, 就需要在根URLConf中使用include引入每个应用的URLConf文件; 一个URL命名空间有两个部分: 应用命名空间 app_name 和 实例命名空间 namespace; 实例命名空间 namespace 实例命名空间是通过include()的namespace关键字参数来设定; 实例命名空间其实是应用命名空间的下级, 所以理论上, 同一应用下的不同实例由于具有相同的应用命名空间, 则不同应用应该可以使用相同的实例命名空间; 但事实上, 实例命名空间在你所有项目中都需要是唯一的; 如果实例命名空间的命名有冲突, 则会报错: WARNINGS: ?: (urls.W005) URL namespace &#39;test1_index&#39; isn&#39;t unique. You may not be able to reverse all URLs in this namespace 实例命名空间可以和应用命名空间名称一样, 这样的话, 如果你使用应用命名空间获取URL的话, 会走根URLConf中这个默认的URL规则; 使用实例命名空间反查URL的时候, 会直接在根URLConf中找到namespace相等的唯一URL规则, 然后再和应用的views中的URL模式名name进行匹配; 例子: 应用命名空间 app_name 应用命名空间是通过include()的app_name关键字参数来设定; 不管是在模板中获取URL还是在Python中获取URL, 如果使用的是 应用命名空间app_name:URL模式名 则会先在根URLConf中选中app_name相等的那些URL规则, 然后查看是否有默认的URL(即, namespace=app_name的), 否则就找到这些URL规则的最后一条规则, 然后再和应用的views中的URL模式名name进行匹配; 注意, 使用reverse()获取URL的时候, 可以通过current_app来设置应用当前的namespace: reverse(&#39;app1:index&#39;, current_app=&#39;third&#39;); 例子 创建两个应用 test, test1 (注意完事在INSTALLED_APPS中配置好应用的名字) 根URLConf: 1234567891011121314from django.conf.urls import include, urlurlpatterns = [ url(r'^test/1/', include('test.urls', namespace='test_index', app_name='test')), url(r'^test/2/', include('test.urls', namespace='test_redirect', app_name='test')), url(r'^test1/3/', include('test1.urls', namespace='test1_index', app_name='test1')), url(r'^test1/4/', include('test1.urls', namespace='test1_detail', app_name='test1')), url(r'^test1/5/', include('test1.urls', namespace='test1_redirect', app_name='test1')), url(r'^test/6/', include('test.urls', namespace='test', app_name='test')), url(r'^test/7/', include('test.urls', namespace='test_detail', app_name='test')), url(r'^test1/8/', include('test1.urls', namespace='test1', app_name='test1')),] 设置每个应用的URLConf文件如下: test/urls.py 12345678from django.conf.urls import urlfrom . import viewsurlpatterns = [ url(r'index/$', views.index, name='index'), url(r'detail/$', views.detail, name='detail'), url(r'redirect/$', views.redirect, name='redirect'),] test1/urls.py 12345678from django.conf.urls import urlfrom . import viewsurlpatterns = [ url(r'index/$', views.index, name='index'), url(r'detail/$', views.detail, name='detail'), url(r'redirect/$', views.redirect, name='redirect'),] 每个应用的views如下: test/views.py 12345678910111213from django.shortcuts import renderfrom django.core.urlresolvers import reversefrom django.http import HttpResponseRedirectdef index(request): return render(request, 'test/index.html')def detail(request): return render(request, 'test/detail.html')def redirect(request): return HttpResponseRedirect(reverse('test_index:index')) test1/views.py 123456789101112from django.shortcuts import renderfrom django.core.urlresolvers import reversefrom django.http import HttpResponseRedirectdef index(request): return render(request, 'test1/index.html')def detail(request): return render(request, 'test1/detail.html')def redirect(request): return HttpResponseRedirect(reverse('test1_index:index')) 其他文件….. 结果: 12345678910- `&lt;a href=&quot;&#123;% url &apos;test_detail:index&apos; %&#125;&quot;&gt;test_detail:index&lt;/a&gt;` 会跳转到 `test/7/` -- `index`- `reverse(&apos;test_index:index&apos;)` 会跳转到 `test/1/` -- `index`- `&lt;a href=&quot;&#123;% url &apos;test1_detail:index&apos; %&#125;&quot;&gt;test1_detail:index&lt;/a&gt;` 会跳转到 `test1/4/` -- `index`- `reverse(&apos;test1_index:index&apos;)` 会跳转到 `test1/3/` -- `index` - `&lt;a href=&quot;&#123;% url &apos;test:index&apos; %&#125;&quot;&gt;test:index&lt;/a&gt;` 跳转到原来的 (这里暂时有点问题, 为什么会跳回原处呢? 不应该和下面一样么)- `reverse(&apos;test:index&apos;)` 会跳转到 `test/6/` -- `index`- `&lt;a href=&quot;&#123;% url &apos;test:index&apos; %&#125;&quot;&gt;test:index&lt;/a&gt;` 跳转到原来的 (这里暂时有点问题, 为什么会跳回原处呢? 不应该和下面一样么)- `reverse(&apos;test:index&apos;)` 会跳转到 `test/8/` -- `index`","categories":[{"name":"Django","slug":"Django","permalink":"http://blog.renyimin.com/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://blog.renyimin.com/tags/Django/"}]},{"title":"Django URL路由","slug":"2017-11-13-Django-02","date":"2017-11-13T13:11:25.000Z","updated":"2017-12-15T01:42:42.000Z","comments":true,"path":"2017/11/13/2017-11-13-Django-02/","link":"","permalink":"http://blog.renyimin.com/2017/11/13/2017-11-13-Django-02/","excerpt":"","text":"Django决定要使用的 根URLconf模块, 通常是通过settings.py文件中的ROOT_URLCONF设置的; URLconf不检查使用了哪种请求方法, 换句话讲, 所有的请求方法–即, 对同一个URL的无论是POST请求、GET请求、或HEAD请求方法等等 —— 都将路由到相同的函数; 每个捕获的参数都作为一个普通的Python字符串传递给视图, 无论正则表达式使用的是什么匹配方式; urlpatterns 中的每个正则表达式在第一次访问它们时被编译, 这使得系统相当快; urlpatterns 变量的语法: urlpatterns 应该是一个url()实例类型的Python列表; URL模式捕获 位置参数 及 嵌套位置参数 URL模式捕获 关键字参数 可以使用命名的正则表达式组来捕获URL中的值并以关键字参数传递给视图; 在Python正则表达式中, 命名正则表达式组的语法是(?P&lt;name&gt;pattern), 其中name是组的名称, pattern 是要匹配的模式; 例子: 代码: 12345678910from django.conf.urls import url from . import viewsurlpatterns = [ url(r'^articles/2003/$', views.special_case_2003), url(r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$', views.year_archive), url(r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/$', views.month_archive), url(r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/(?P&lt;day&gt;[0-9]&#123;2&#125;)/$', views.article_detail),] 捕获的值是作为关键字参数, 而不是位置参数, 传递给视图函数的 : 12/articles/2005/03/ 请求将调用views.month_archive(request, year=&apos;2005&apos;, month=&apos;03&apos;)函数，而不是views.month_archive(request, &apos;2005&apos;, &apos;03&apos;)。/articles/2003/03/03/ 请求将调用函数views.article_detail(request, year=&apos;2003&apos;, month=&apos;03&apos;, day=&apos;03&apos;)。 在实际应用中, 这意味你的URLconf会更加明晰且不容易产生参数顺序问题的错误; 传递额外的 关键字参数 给 视图函数 URLconfs 具有一个钩子, 让你传递一个Python字典作为额外的参数传递给视图函数: django.conf.urls.url() 函数可以接收一个可选的第三个参数, 它是一个字典, 表示想要传递给视图函数的额外关键字参数; 例如： 123456from django.conf.urls import urlfrom . import viewsurlpatterns = [ url(r'^blog/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$', views.year_archive, &#123;'foo': 'bar'&#125;),] 在这个例子中，对于/blog/2005/请求, Django 将调用 views.year_archive(request, year=&#39;2005&#39;, foo=&#39;bar&#39;); 处理 命名关键字参数 和 额外参数 的冲突 URL模式捕获的命名关键字参数(?P&lt;name&gt;pattern) 和 在字典中传递的 额外参数 有可能具有相同的名称, 当这种情况发生时, 将使用字典中的参数而不是URL中捕获的参数; 传递额外的 关键字参数 给 include()include的应用的URLconf中所有的路由都会默认获取到这里的额外选项 类似地, 你可以传递额外的选项给include() 当你传递额外的选项给include() 时, 被包含的URLconf的每一行将被传递这些额外的选项; 例如, 下面两个URLconf设置功能上完全相同： 设置一 123456789101112131415# main.pyfrom django.conf.urls import include, urlurlpatterns = [ url(r'^blog/', include('inner'), &#123;'blogid': 3&#125;),]# inner.pyfrom django.conf.urls import urlfrom mysite import viewsurlpatterns = [ url(r'^archive/$', views.archive), url(r'^about/$', views.about),] 设置二 123456789101112131415# main.pyfrom django.conf.urls import include, urlfrom mysite import viewsurlpatterns = [ url(r'^blog/', include('inner')),]# inner.pyfrom django.conf.urls import urlurlpatterns = [ url(r'^archive/$', views.archive, &#123;'blogid': 3&#125;), url(r'^about/$', views.about, &#123;'blogid': 3&#125;),] 注意: 额外的选项将永远传递给被包含的URLconf中的每一行, 无论该行的视图实际上是否认为这些选项是合法的; 由于这个原因, 该技术只有当你确定被包含的URLconf中的每个视图都接收你传递给它们的额外的选项时才有价值; 包含其它的URLconfs 你项目的根URLconfs可以包含项目中应用的URLconf模块; 例子: 12345678from django.conf.urls import include, urlurlpatterns = [ # ... snip ... url(r&apos;^community/&apos;, include(&apos;django_website.aggregator.urls&apos;)), url(r&apos;^contact/&apos;, include(&apos;django_website.contact.urls&apos;)), # ... snip ...] 注意: 正则表达式没有包含$(字符串结束匹配符), 但是包含一个末尾的斜杠。每当Django 遇到include()(django.conf.urls.include())时, 它会去掉URL中匹配的部分,并将剩下的字符串发送给包含的URLconf做进一步处理; 另外一种包含其它URL模式的方式是使用一个url()实例的列表 例如, 请看下面的URLconf: 123456789101112131415from django.conf.urls import include, urlfrom apps.main import views as main_viewsfrom credit import views as credit_viewsextra_patterns = [ url(r&apos;^reports/(?P&lt;id&gt;[0-9]+)/$&apos;, credit_views.report), url(r&apos;^charge/$&apos;, credit_views.charge),]urlpatterns = [ url(r&apos;^$&apos;, main_views.homepage), url(r&apos;^help/&apos;, include(&apos;apps.help.urls&apos;)), url(r&apos;^credit/&apos;, include(extra_patterns)),] 在这个例子中, /credit/reports/ URL将被 credit.views.report() 这个Django 视图处理; 这可以用于移除URL配置中重复的部分, 例如 考虑这个URLconf： 123456789from django.conf.urls import urlfrom . import viewsurlpatterns = [ url(r&apos;^(?P&lt;page_slug&gt;[\\w-]+)-(?P&lt;page_id&gt;\\w+)/history/$&apos;, views.history), url(r&apos;^(?P&lt;page_slug&gt;[\\w-]+)-(?P&lt;page_id&gt;\\w+)/edit/$&apos;, views.edit), url(r&apos;^(?P&lt;page_slug&gt;[\\w-]+)-(?P&lt;page_id&gt;\\w+)/discuss/$&apos;, views.discuss), url(r&apos;^(?P&lt;page_slug&gt;[\\w-]+)-(?P&lt;page_id&gt;\\w+)/permissions/$&apos;, views.permissions),] 我们可以改进它，通过只声明共同的路径前缀一次并将后面的部分分组： 1234567891011from django.conf.urls import include, urlfrom . import viewsurlpatterns = [ url(r&apos;^(?P&lt;page_slug&gt;[\\w-]+)-(?P&lt;page_id&gt;\\w+)/&apos;, include([ url(r&apos;^history/$&apos;, views.history), url(r&apos;^edit/$&apos;, views.edit), url(r&apos;^discuss/$&apos;, views.discuss), url(r&apos;^permissions/$&apos;, views.permissions), ])),] 被包含的URLconf会收到来自父URLconf捕获的任何参数 指定视图参数的默认值 有一个方便的小技巧是指定视图参数的默认值, 下面是一个URLconf 和视图的示例: 1234567891011121314# URLconf from django.conf.urls import url from . import views urlpatterns = [ url(r'^blog/$', views.page), url(r'^blog/page(?P&lt;num&gt;[0-9]+)/$', views.page), ] # View (in blog/views.py) def page(request, num=\"1\"): # Output the appropriate page of blog entries, according to num. ... 在上面的例子中, 两个URL模式指向同一个视图views.page – 但是第一个模式不会从URL中捕获任何值。 如果第一个模式匹配, page()函数将使用num参数的默认值”1”; 如果第二个模式匹配, page() 将使用正则表达式捕获的num值;","categories":[{"name":"Django","slug":"Django","permalink":"http://blog.renyimin.com/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://blog.renyimin.com/tags/Django/"}]},{"title":"01 - Django入门","slug":"2017-11-10-Django-01","date":"2017-11-10T11:05:00.000Z","updated":"2017-12-14T03:09:08.000Z","comments":true,"path":"2017/11/10/2017-11-10-Django-01/","link":"","permalink":"http://blog.renyimin.com/2017/11/10/2017-11-10-Django-01/","excerpt":"","text":"Python也有很多web框架, 常用的如: Django, Tornado, Flask, Bottle, Pylons 等; Django版本的选择 选择一款 LTS 版本 各版本发布列表 各版本对应python版本的支持情况 通过上述了解, 此处采用Django1.11.7版本: Django的安装本机是Mac系统 直接官网下载源码包 tar.gz包下载 解压, 到包中执行 python setup.py install github拉取代码 git clone -b stable/1.11.x https://github.com/django/django.git 到包中执行 python setup.py install 直接 pip install Django==1.11.7 安装; 注意可能因你安装Python版本的不同, 可能使用 pip 或 pip3 本机在学习阶段, 安装了 Anaconda3(将自己的python3写到了环境变量里), 所以可以直接使用pip 如下则安装成功: 1234&gt;&gt;&gt; import django&gt;&gt;&gt; print(django.get_version())1.11.7&gt;&gt;&gt; 构建项目及应用 先看一下Django常用基本命令 django-admin.py startproject 项目名 : 新建项目 (PyCharm professional版可以在创建Django项目时直接执行命令生成目录结构) python manage.py : 查看命令列表 python manage.py startapp appname : 新建 app python manage.py runserver ip:port : 启动服务器，默认ip和端口为http://127.0.0.1:8000/ python manage.py makemigrations : 显示并记录所有数据的改动 python manage.py migrate : 将改动更新到数据库 python manage.py sqlmigrate 你的应用名 0001 : 查看迁移文件对用的sql语句 python manage.py createsuperuser : 为Django自带简版admin后台系统创建超级管理员账号 python manage.py dbshell (数据库命令行) Django自带的开发服务器 Django包含一个可用于测试的轻量级Web服务器 python manage.py runserver 参考: http://python.usyiyi.cn/documents/django_182/topics/install.html 如果您使用MySQL, 则需要使用DB API driver 参考: http://python.usyiyi.cn/documents/django_182/topics/install.html, http://python.usyiyi.cn/documents/django_182/ref/databases.html#mysql-db-api-drivers 这里我们可以选择安装 mysqlclient, 但貌似安装过程错误不好解决 所以选择同一个作者开发的PyMysql: pip install pymysql 主目录下配置: 12import pymysqlpymysql.install_as_MySQLdb() Git拉取Django代码后的问题","categories":[{"name":"Django","slug":"Django","permalink":"http://blog.renyimin.com/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://blog.renyimin.com/tags/Django/"}]},{"title":"04.与调度器之间通信--系统调用","slug":"2017-05-16-Iterator-generator-yield-04","date":"2017-05-16T14:15:00.000Z","updated":"2017-11-15T03:02:20.000Z","comments":true,"path":"2017/05/16/2017-05-16-Iterator-generator-yield-04/","link":"","permalink":"http://blog.renyimin.com/2017/05/16/2017-05-16-Iterator-generator-yield-04/","excerpt":"","text":"调度器现在已经正常运行了, 下一个问题是：任务和调度器之间的通信 ; 任务和调度器之间的通信: 我们将使用与 进程和操作系统之间会话 所使用的方式来通信: 系统调用 ; 使用 系统调用 这种通信方式的理由是: 操作系统与进程相比, 两者是处在不同的权限级别上, 操作系统为了执行特权级别的操作(如杀死另一个进程), 就不得不以某种方式把控制传回给内核, 这样内核就可以执行所说的操作了;(再说一遍, 这种行为在内部是通过使用中断指令来实现的, 过去使用的是通用的int指令, 如今使用的是更特殊并且更快速的syscall/sysenter指令) 而接下来我们的任务调度系统就要使用这种设计:不是简单地把调度器传递给任务(这样就允许它做它想做的任何事), 我们将通过给yield表达式传递信息来与系统调用通信, 这儿yield既是中断,也是传递信息给调度器(和从调度器传递出信息)的方法; 代码: 任务类: 和之前没什么变化 12345678910111213141516171819202122232425262728293031323334&lt;?phpclass Task &#123; protected $taskId; protected $coroutine; protected $sendValue = null; protected $beforeFirstYield = true; public function __construct($taskId, Generator $coroutine) &#123; $this-&gt;taskId = $taskId; $this-&gt;coroutine = $coroutine; &#125; public function getTaskId() &#123; return $this-&gt;taskId; &#125; public function setSendValue($sendValue) &#123; $this-&gt;sendValue = $sendValue; &#125; public function run() &#123; if ($this-&gt;beforeFirstYield) &#123; $this-&gt;beforeFirstYield = false; return $this-&gt;coroutine-&gt;current(); &#125; else &#123; $this-&gt;coroutine-&gt;send($this-&gt;sendValue); $this-&gt;sendValue = null; &#125; &#125; public function isFinished() &#123; return !$this-&gt;coroutine-&gt;valid(); &#125;&#125; 系统调用:系统调用是操作系统提供给程序设计人员的一种服务,程序设计人员在编写程序时,可以利用系统调用来请求操作系统的服务 12345678910111213&lt;?phpclass SystemCall &#123; protected $callback; public function __construct(callable $callback) &#123; $this-&gt;callback = $callback; &#125; public function __invoke(Task $task, Scheduler $scheduler) &#123; $callback = $this-&gt;callback; return $callback($task, $scheduler); &#125;&#125; 调度器: run方法相比之前做了一些修改 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpclass Scheduler &#123; protected $taskId = 0; //protected $taskMap = []; // taskId =&gt; task protected $taskQueue; public function __construct() &#123; $this-&gt;taskQueue = new SplQueue(); &#125; public function newTask(Generator $coroutine) &#123; $taskId = ++$this-&gt;taskId; $task = new Task($taskId, $coroutine); //$this-&gt;taskMap[$taskId] = $task; $this-&gt;schedule($task); return $taskId; &#125; public function schedule(Task $task) &#123; $this-&gt;taskQueue-&gt;enqueue($task); &#125; public function run() &#123; while (!$this-&gt;taskQueue-&gt;isEmpty()) &#123; $task = $this-&gt;taskQueue-&gt;dequeue(); $retval = $task-&gt;run(); //如果yield返回的是个系统调用(每个任务第一次的yield返回的就是个系统调用) if ($retval instanceof SystemCall) &#123; echo 123 . PHP_EOL; $retval($task, $this); continue; &#125; if ($task-&gt;isFinished()) &#123; //unset($this-&gt;taskMap[$task-&gt;getTaskId()]); &#125; else &#123; $this-&gt;schedule($task); &#125; &#125; &#125;&#125; 测试: 12345678910111213141516171819202122232425262728&lt;?phprequire_once \"task.php\";require_once \"scheduler.php\";require_once \"systemCall.php\";function getTaskId() &#123; return new SystemCall(function(Task $task, Scheduler $scheduler) &#123; $task-&gt;setSendValue($task-&gt;getTaskId());//这里主要是在任务运行一开始进行的系统调用中设置任务的id, 并将任务继续压栈 (总共就干两件事), $scheduler-&gt;schedule($task); &#125;);&#125;//系统功能调用是操作系统提供给程序设计人员的一种服务。程序设计人员在编写程序时，可以利用系统调用来请求操作系统的服务//用户程序只在用户态下运行，有时需要访问`系统核心功能`，这时就需要通过系统调用接口来使用 `系统调用`function task($max) &#123; $tid = (yield getTaskId()); // &lt;-- here's the syscall! for ($i = 1; $i &lt;= $max; ++$i) &#123; echo \"This is task $tid iteration $i.\\n\"; yield; &#125;&#125;$scheduler = new Scheduler;//添加两个任务到队列中$scheduler-&gt;newTask(task(10));$scheduler-&gt;newTask(task(5));//运行调度器$scheduler-&gt;run(); 结果和之前的简单任务调度一样; 123456789101112131415161718renyimin$ php index1.php 123 // 可以看到, 总共运行了两次系统调用(每个任务在一开始都是各自运行一次自己的系统调用)123This is task 1 iteration 1. This is task 2 iteration 1.This is task 1 iteration 2.This is task 2 iteration 2.This is task 1 iteration 3.This is task 2 iteration 3.This is task 1 iteration 4.This is task 2 iteration 4.This is task 1 iteration 5.This is task 2 iteration 5.This is task 1 iteration 6.This is task 1 iteration 7.This is task 1 iteration 8.This is task 1 iteration 9.This is task 1 iteration 10. 参考: http://www.laruence.com/2015/05/28/3038.html","categories":[{"name":"PHP高级","slug":"PHP高级","permalink":"http://blog.renyimin.com/categories/PHP高级/"},{"name":"Coroutine","slug":"PHP高级/Coroutine","permalink":"http://blog.renyimin.com/categories/PHP高级/Coroutine/"}],"tags":[{"name":"PHP高级","slug":"PHP高级","permalink":"http://blog.renyimin.com/tags/PHP高级/"},{"name":"Coroutine","slug":"Coroutine","permalink":"http://blog.renyimin.com/tags/Coroutine/"}]},{"title":"03.PHP - 如何使用协程来实施任务调度","slug":"2017-05-16-Iterator-generator-yield-03","date":"2017-05-16T11:25:00.000Z","updated":"2017-11-29T19:00:42.000Z","comments":true,"path":"2017/05/16/2017-05-16-Iterator-generator-yield-03/","link":"","permalink":"http://blog.renyimin.com/2017/05/16/2017-05-16-Iterator-generator-yield-03/","excerpt":"","text":"从之前的知识可以了解到, 其实(迭代器)生成器 也只不过是一个函数, 不同的是这个函数的返回值是依次返回, 而不是只返回一个单独的值; (也就是说, 生成器使你更方便的实现了迭代器) ; 生成器为可中断的函数, 在它里面的 yield 构成了中断点 ; 再看一个简单的 迭代生成器 进行双向传输信息的 例子 : 1234567891011121314&lt;?phpfunction gen() &#123; $ret = (yield 'yield1'); var_dump($ret); $ret = (yield 'yield2'); var_dump($ret);&#125; $gen = gen();var_dump($gen-&gt;current()); // string(6) \"yield1\"var_dump($gen-&gt;send('ret1')); // string(4) \"ret1\" (the first var_dump in gen) // string(6) \"yield2\" (the var_dump of the -&gt;send() return value)var_dump($gen-&gt;send('ret2')); // string(4) \"ret2\" (again from within gen) // NULL (the return value of -&gt;send()) 那么什么是协程(Coroutine)？ 协程, 又称微线程, 纤程, 英文名Coroutine 和多线程相比, 协程的优势?（1）最大的优势就是协程极高的执行效率, 因为子程序切换不是线程切换, 而是由程序自身控制, 因此, 没有线程切换的开销; 所以, 和多线程比, 当应用的线程数量越多, 换成协程的话, 性能优势就越明显; （2）第二大优势就是不需要多线程的锁机制, 因为只有一个线程, 也不存在同时写变量冲突, 在协程中控制共享资源不加锁, 只需要判断状态就好了, 所以执行效率比多线程高很多; 协程是在应用程序的层面进行切换, 而不是线程级的切换, 所以切换带来的开销很小; 多进程+协程因为协程是一个线程执行, 那怎么利用多核CPU呢?最简单的方法是多进程+协程, 既充分利用多核, 又充分发挥协程的高效率, 可获得极高的性能。 协程（coroutine）跟具有操作系统概念的线程不一样, 实际上协程就是类函数一样的程序组件, 你可以在一个线程里面轻松创建数十万个协程,就像数十万次函数调用一样。只不过函数只有一个调用入口起始点, 返回之后就结束了, 而协程入口既可以是起始点, 又可以从上一个返回点继续执行, 也就是说协程之间可以通过 yield 方式转移执行权, 对称（symmetric）、平级地调用对方, 而不是像函数那样上下级调用关系;当然协程也可以模拟函数那样实现上下级调用关系, 这就叫非对称协程（asymmetric coroutines）; 注意： yield表达式两边的括号在PHP7以前不是可选的, 也就是说在PHP5.5和PHP5.6中圆括号是必须的 ; …. 协程特点: 为应用层实现多任务提供了工具; 协程不允许多任务同时执行，要执行其它协程，必须使用关键字yield主动放弃cpu控制权; 协程需要自己写任务管理器，以及任务调度器； 减轻了OS处理零散任务和轻量级任务的负 使用协程实现多任务协作，我们要解决的问题是你想并发地运行多任务(或者”程序”), 不过我们都知道CPU在一个时刻只能运行一个任务(不考虑多核的情况), 因此处理器需要在不同的任务之间进行切换,而且总是让每个任务运行 一小会儿 ; 多任务协作 这个术语中的”协作”很好的说明了如何进行这种切换的: 首先, 我们是通过调度器来调度每个任务运行的, 它而所谓协作就是要求当前正在运行的任务自动把控制传回给调度器, 这样就调度器就可以调度其他任务来运行了 ; 现在你应当明白 协程 和 任务调度 之间的关系: yield指令提供了任务中断自身的一种方法, 然后把控制交回给任务调度器, 因此协程可以运行多个任务; 更进一步, yield还可以用来在任务和调度器之间进行通信 ; 可以这么理解 :调度器在调度任务的时候, 是通过模拟一个队列, 然后将使用调度器创建任务(其实就是将多个任务压栈), 之后由于每个任务执行一次就会执行出栈, 并且就任务会通过yield中断当前任务并将控制权交给调度器, 调度器就可以通过这样就实现了轮询的方式执行多个任务 ; 小疑问: 12345678&lt;?phpfunction gen() &#123; yield 'foo'; yield 'bar';&#125;$gen = gen();var_dump($gen-&gt;send('something')); // 鸟哥博客相关讨论小结: // 在send之前, 如果没有显示地调用current, 那么当$gen迭代器被创建的时候一个rewind()方法已经被隐式调用 // 所以实际上发生的应该类似: 123456789&lt;?phpfunction gen() &#123; yield 'foo'; yield 'bar';&#125;$gen = gen();var_dump($gen-&gt;rewind()); //不过可惜的是, rewind的执行将虽然会导致第一个yield被执行, 但是却会忽略他的返回值.var_dump($gen-&gt;send('something')); // 真正当我们调用yield的时候, 我们得到的是第二个yield的值! 导致第一个yield的值被忽略. 先看一个简单的任务调度程序: 通过模拟cpu轮询来调度两个 循环打印的任务 任务类: 主要作用是在其内部将一个用轻量级的包装的协程函数手动进行迭代 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpclass Task &#123; protected $taskId; protected $coroutine; protected $sendValue = null; //在此处暂时还没有用 //通过添加 firstYieldTag 我们可以保证第一处 yield 的值能被正确返回, 因为之前我们已经了解到: //对生成器生成的迭代器进行手动迭代的话, 如果在send之前, 没有显示地调用current, 那么当迭代器被创建的时候一个rewind会默认执行, 但是不会有返回; //所以针对第一处yield, 要想看到返回值, 我们需要手动调用current protected $firstYieldTag = true; public function __construct($taskId, Generator $coroutine) &#123; $this-&gt;taskId = $taskId; $this-&gt;coroutine = $coroutine; &#125; public function getTaskId() &#123; return $this-&gt;taskId; &#125; // 使用setSendValue()方法, 你可以指定哪些值将被发送到下次的恢复(现在暂时不会用到, 在之后会用到) public function setSendValue($sendValue) &#123; $this-&gt;sendValue = $sendValue; &#125; //其实就是在这个run方法中做的手动迭代 public function run() &#123; if ($this-&gt;firstYieldTag) &#123; $this-&gt;firstYieldTag = false; // 第一次调用之后就进行标识 $this-&gt;coroutine-&gt;current(); &#125; else &#123; $this-&gt;coroutine-&gt;send($this-&gt;sendValue); $this-&gt;sendValue = null; &#125; &#125; public function isFinished() &#123; return !$this-&gt;coroutine-&gt;valid(); &#125;&#125; 调度器类: 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpclass Scheduler &#123; protected $taskId = 0; //protected $taskMap = []; // taskId =&gt; task protected $taskQueue; //调度器初始化其实就是简单创建了一个队列 public function __construct() &#123; $this-&gt;taskQueue = new SplQueue(); &#125; public function newTask(Generator $coroutine) &#123; $taskId = ++$this-&gt;taskId;//简单通过递增的方法来设置 任务的唯一标识 任务id $task = new Task($taskId, $coroutine);//通过 任务id 和 迭代器的生成器 来创建任务 //将创建好的任务和任务id对应起来 存入数组 //$this-&gt;taskMap[$taskId] = $task; $this-&gt;schedule($task); return $taskId; &#125; //添加任务到队列 public function schedule(Task $task) &#123; $this-&gt;taskQueue-&gt;enqueue($task); &#125; //运行调度器, 这里是模拟cpu并发 轮询执行任务的关键 (通过不断地将任务出栈和压栈) public function run() &#123; //如果任务队列不为空 while (!$this-&gt;taskQueue-&gt;isEmpty()) &#123; //将任务弹出队列 准备运行任务 $currentTask = $this-&gt;taskQueue-&gt;dequeue(); //然后运行任务 (其实每个任务就是 迭代器生成器 生成的 迭代器) //这里run其实就是对队列中的任务进行了 '一次' 迭代 $currentTask-&gt;run(); // 如果弹出队列的任务(迭代器)如果运行结束(即 迭代器对象循环结束), 则从任务数组中删除任务 if ($currentTask-&gt;isFinished()) &#123; //unset($this-&gt;taskMap[$task-&gt;getTaskId()]); &#125; else &#123; //如果任务没有运行结束则继续将任务压入队列 $this-&gt;schedule($currentTask); &#125; &#125; &#125;&#125; 测试: 1234567891011121314151617181920212223242526&lt;?phprequire_once \"task.php\";require_once \"scheduler.php\"; //第一个任务(一个`迭代器生成器`):function task1() &#123; for ($i = 1; $i &lt;= 10; ++$i) &#123; echo \"This is task 1 iteration $i.\\n\"; yield; &#125;&#125;//第二个任务(一个`迭代器生成器`):function task2() &#123; for ($i = 1; $i &lt;= 5; ++$i) &#123; echo \"This is task 2 iteration $i.\\n\"; yield; &#125;&#125; $scheduler = new Scheduler;//创建两个任务到调度器的队列中$scheduler-&gt;newTask(task1());$scheduler-&gt;newTask(task2());//运行调度器$scheduler-&gt;run(); 结果: 果然是两个任务交替执行各自的循环 12345678910111213141516renyimin$ php index.phpThis is task 1 iteration 1.This is task 2 iteration 1.This is task 1 iteration 2.This is task 2 iteration 2.This is task 1 iteration 3.This is task 2 iteration 3.This is task 1 iteration 4.This is task 2 iteration 4.This is task 1 iteration 5.This is task 2 iteration 5.This is task 1 iteration 6.This is task 1 iteration 7.This is task 1 iteration 8.This is task 1 iteration 9.This is task 1 iteration 10. 参考: http://www.laruence.com/2015/05/28/3038.html","categories":[{"name":"PHP高级","slug":"PHP高级","permalink":"http://blog.renyimin.com/categories/PHP高级/"},{"name":"Coroutine","slug":"PHP高级/Coroutine","permalink":"http://blog.renyimin.com/categories/PHP高级/Coroutine/"}],"tags":[{"name":"PHP高级","slug":"PHP高级","permalink":"http://blog.renyimin.com/tags/PHP高级/"},{"name":"Coroutine","slug":"Coroutine","permalink":"http://blog.renyimin.com/tags/Coroutine/"}]},{"title":"02.PHP - Generator (迭代)生成器","slug":"2017-05-13-Iterator-generator-yield-02","date":"2017-05-13T04:15:00.000Z","updated":"2017-11-29T18:56:50.000Z","comments":true,"path":"2017/05/13/2017-05-13-Iterator-generator-yield-02/","link":"","permalink":"http://blog.renyimin.com/2017/05/13/2017-05-13-Iterator-generator-yield-02/","excerpt":"","text":"Generator (迭代)生成器 之所以叫 迭代生成器, 是因为这个生成器(就是一个包含yield关键字的函数)生成的东西是个迭代器对象;( 参考PHP: 生成器类的结构, 会发现生成器这个类也确实实现了迭代器接口); 生成器函数 的核心是 yield 关键字 它最简单的调用形式看起来像 return 的用法, 但普通 return 会返回值并终止函数的执行; 而 yield 会返回一个值给循环调用此生成器的代码, 并且只是暂停 生成器函数的运行; 暂停当前过程，意味着将处理权转交由上一级继续进行，直至上一级再次调用被暂停的 生成器函数，则生成器函数会从上一次暂停的位置继续执行; 当然, yield 更重要的特性是除了可以返回一个值以外, 还能够接收一个值 参考PHP: 生成器类的结构, 可以看到 Generator 类除了实现 Iterator 接口中的必要方法以外, 还有一个 send 方法, 这个方法就是向 yield 语句处传递一个值, 同时从 yield 语句处继续执行, 直至再次遇到 yield 后控制权回到外部 ; 当然, 此时是先返回yield处的值, 然后再将接收到的外部值作用于另一个表达式(可能直接打印或者赋值给另一个变量); 测试代码: 12345678910111213141516171819202122232425262728&lt;?phpfunction printer()&#123; $i = 0; while (true) &#123; echo 123 . \"\\n\"; //同时进行接收和发送 （先返回 yield 后面的值, 然后才将 接收到的值 作用于 printf函数） printf(\"receive: %s\\n\", (yield ++$i)); echo 456 . \"\\n\"; &#125;&#125;$printer = printer();printf(\"%d\\n\", $printer-&gt;current()); //123 //1 碰到yield则中断, 将$i发出, 并将控制权交给外部的调度器var_dump($printer-&gt;send('hello')); //receive: hello 调度器再次调度,继续开始 //456 //123 //int(2) 碰到yield则中断, 将$i发出, 并将控制权交给外部的调度器printf(\"%d\\n\", $printer-&gt;current()); //yield发出的当前值果然是2var_dump($printer-&gt;send('world')); //receive: world 调度器再次调度,继续开始 //456 //123 //int(3)碰到yield则中断, 将$i发出, 并将控制权交给外部的调度器printf(\"%d\\n\", $printer-&gt;current());//yield发出的当前值果然是3 这儿yield没有作为一个语句来使用, 而是用作一个表达式, 这样, 这个yield表达式 能被演化成一个值, 这个值就是调用者传递给send()方法的值; 到这里, 我们看到 yield 可以在其位置同时进行 接收 和 返回 (双向传递), 当然, 这是实现 协程 的根本; 补充 ： 另外, 我们可以使用生成器来重新实现 range() 函数, 标准的 range() 函数需要在内存中生成一个数组包含每一个在它范围内的值，然后返回该数组, 结果就是会产生多个很大的数组。 比如, 调用 range(0, 1000000) 将导致内存占用超过 100 MB ; 做为一种替代方法, 我们可以实现一个 xrange() 生成器, 只需要足够的内存来创建 Iterator 对象并在内部跟踪生成器的当前状态，这样只需要不到1K字节的内存; 例子: 即使你打印100W个键值对, 也不一次性将这些简直对放入变量中导致内存爆掉 12345678910&lt;?phpfunction xrange($start, $limit, $step = 1) &#123; for ($i = $start; $i &lt;= $limit; $i += $step) &#123; yield $i + 1 =&gt; $i; &#125;&#125;foreach (xrange(0, 10000000000, 2) as $key =&gt; $value) &#123; printf(\"%d =&gt; %d\" . PHP_EOL, $key, $value);&#125; 参考: https://www.insp.top/article/php-knowledge-completion-generator-and-the-realization-of-coroutine","categories":[{"name":"PHP高级","slug":"PHP高级","permalink":"http://blog.renyimin.com/categories/PHP高级/"},{"name":"Coroutine","slug":"PHP高级/Coroutine","permalink":"http://blog.renyimin.com/categories/PHP高级/Coroutine/"}],"tags":[{"name":"PHP高级","slug":"PHP高级","permalink":"http://blog.renyimin.com/tags/PHP高级/"},{"name":"Coroutine","slug":"Coroutine","permalink":"http://blog.renyimin.com/tags/Coroutine/"}]},{"title":"01.PHP - Iterator (迭代器) 接口简介","slug":"2017-05-13-Iterator-generator-yield-01","date":"2017-05-13T03:05:00.000Z","updated":"2017-11-15T02:38:25.000Z","comments":true,"path":"2017/05/13/2017-05-13-Iterator-generator-yield-01/","link":"","permalink":"http://blog.renyimin.com/2017/05/13/2017-05-13-Iterator-generator-yield-01/","excerpt":"","text":"迭代: 可以理解为是指反复执行一个过程, 每执行一次叫做一次迭代; 在php中我们经常做迭代, 如下: 12345678910&lt;?php$mapping = ['red' =&gt; '#FF0000','green' =&gt; '#00FF00','blue' =&gt; '##0000FF'];foreach ($mapping as $key =&gt; $value) &#123;printf(\"key: %d - value: %s \\n\", $key, $value);&#125; 上述代码通过foreach对数组遍历并迭代输出其内容, 在foreach内部, 每次迭代都会将当前的元素的值赋给$value并将数组的指针移动指向下一个元素为下一次迭代做准备,从而实现顺序遍历;像这样能够让外部的迭代自己内部数据的接口就是迭代器接口;对应的那个被迭代的对象(这里是数组), 其实就是迭代器对象; PHP中提供的迭代器接口和类 PHP提供了统一的迭代器接口预定义接口中; SPL标准库中也提供了多种迭代器类; 简单实现一个迭代器 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass Xrange implements Iterator&#123; protected $start; protected $limit; protected $step; protected $i; public function __construct($start, $limit, $step = 0) &#123; $this-&gt;start = $start; $this-&gt;limit = $limit; $this-&gt;step = $step; &#125; public function rewind() &#123; $this-&gt;i = $this-&gt;start; &#125; public function next() &#123; $this-&gt;i += $this-&gt;step; &#125; public function current() &#123; return $this-&gt;i; &#125; public function key() &#123; return $this-&gt;i; &#125; public function valid() &#123; return $this-&gt;i &lt;= $this-&gt;limit; &#125;&#125;foreach (new Xrange(0, 10, 2) as $key =&gt; $value) &#123; printf(\"%d %d\" . PHP_EOL, $key, $value);&#125; 1234567$ php Iterator.php 0 02 24 46 68 810 10 补充: 可以将一个普通对象变成一个可被遍历的对象, 场景: 如一个StudentsContact对象, 这个对象是用于处理学生联系方式的, 通过 addStudent 方法注册学生, 通过 getAllStudent 获取全部注册的学生联系方式数组(比如获取一页学生联系方式列表), 我们以往是通过 StudentsContact::getAllStudent() 获取一个数组然后遍历该数组, 但是现在有了迭代器, 只要这个类继承这个接口, 就可以直接遍历该对象获取学生数组, 并且可以在获取之前在类的内部就对输出的数据做好处理工作; PHP的迭代器可以让你利用 面向对象 实现常见的数据结构, 例如列表, 堆栈, 队列与图 ; (有助于你使用纯面向对象的思想来设计你的程序)特别说明一下 对对象的遍历, 一般人觉得所谓的遍历对象*就是对一个对象里的属性或者方法一个一个的取出来, 然后做输出或者处理; 实际上, 这里的迭代器对对象的遍历并不是这个意思, 可能这句话本身的描述有问题, 比如, 可以使用迭代器模拟一个字符串对象的迭代器类, 让PHP可以对这个字符串对象进行遍历; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phpclass String implements Iterator&#123; private $string; public function __construct($string) &#123; $this-&gt;string = $this-&gt;strToArray($string); &#125; private function strToArray($string, $l = 0) &#123; //if ($l &gt; 0) &#123; //$ret = array(); //$len = mb_strlen($string, \"UTF-8\"); //for ($i = 0; $i &lt; $len; $i += $l) &#123; //$ret[] = mb_substr($string, $i, $l, \"UTF-8\"); //&#125; //return $ret; //&#125; return preg_split(\"//u\", $string, -1, PREG_SPLIT_NO_EMPTY); &#125; public function current() &#123; return current($this-&gt;string); &#125; public function next() &#123; return next($this-&gt;string); &#125; public function key() &#123; return key($this-&gt;string); &#125; public function valid() &#123; if (key($this-&gt;string) === null) &#123; return false; &#125; else &#123; return true; &#125; &#125; public function rewind() &#123; reset($this-&gt;string); &#125;&#125;$string = new String('这个是什么213jdjlf');foreach ($string as $k =&gt; $v) &#123; echo \"&#123;$k&#125; =&gt; &#123;$v&#125;\" . \"&lt;br/&gt;\";&#125;结果:0 =&gt; 这1 =&gt; 个2 =&gt; 是3 =&gt; 什4 =&gt; 么5 =&gt; 26 =&gt; 17 =&gt; 38 =&gt; j9 =&gt; d10 =&gt; j11 =&gt; l12 =&gt; f","categories":[{"name":"PHP高级","slug":"PHP高级","permalink":"http://blog.renyimin.com/categories/PHP高级/"},{"name":"Coroutine","slug":"PHP高级/Coroutine","permalink":"http://blog.renyimin.com/categories/PHP高级/Coroutine/"}],"tags":[{"name":"PHP高级","slug":"PHP高级","permalink":"http://blog.renyimin.com/tags/PHP高级/"},{"name":"Coroutine","slug":"Coroutine","permalink":"http://blog.renyimin.com/tags/Coroutine/"}]},{"title":"05 - 分布式","slug":"2017-04-17-distributed-05","date":"2017-04-13T12:03:09.000Z","updated":"2017-12-07T13:07:56.000Z","comments":true,"path":"2017/04/13/2017-04-17-distributed-05/","link":"","permalink":"http://blog.renyimin.com/2017/04/13/2017-04-17-distributed-05/","excerpt":"","text":"","categories":[{"name":"分布式","slug":"分布式","permalink":"http://blog.renyimin.com/categories/分布式/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://blog.renyimin.com/tags/分布式/"}]},{"title":"02 - 分布式锁","slug":"2017-04-13-distributed-02","date":"2017-04-13T12:03:09.000Z","updated":"2017-12-07T13:07:00.000Z","comments":true,"path":"2017/04/13/2017-04-13-distributed-02/","link":"","permalink":"http://blog.renyimin.com/2017/04/13/2017-04-13-distributed-02/","excerpt":"","text":"分布式锁","categories":[{"name":"分布式","slug":"分布式","permalink":"http://blog.renyimin.com/categories/分布式/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://blog.renyimin.com/tags/分布式/"}]},{"title":"01 - 分布式","slug":"2017-04-13-distributed-01","date":"2017-04-13T05:20:31.000Z","updated":"2017-12-07T13:07:12.000Z","comments":true,"path":"2017/04/13/2017-04-13-distributed-01/","link":"","permalink":"http://blog.renyimin.com/2017/04/13/2017-04-13-distributed-01/","excerpt":"","text":"数据一致性问题","categories":[{"name":"分布式","slug":"分布式","permalink":"http://blog.renyimin.com/categories/分布式/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://blog.renyimin.com/tags/分布式/"}]},{"title":"07.小结 \"Jsonp\" 对比 \"CORS简单/非简单请求\"","slug":"2016-09-21-sameoriginpolicy-07","date":"2016-09-21T13:20:16.000Z","updated":"2017-10-28T02:30:36.000Z","comments":true,"path":"2016/09/21/2016-09-21-sameoriginpolicy-07/","link":"","permalink":"http://blog.renyimin.com/2016/09/21/2016-09-21-sameoriginpolicy-07/","excerpt":"","text":"Jsonp 对比 CORS简单/非简单请求都可以方便实现跨域; Jsonp简单适用, 老式浏览器全部支持, 服务器端改动很小; 但是JSONP只能发GET请求; JSONP跨域发送Cookie的话, 只用设置好cookie的domain属性为顶级域名即可 ; CORS简单请求服务端需要设置一些允许选项; 发送请求为 GET, POST, HEAD ; 跨域发送cookie的话, 不仅需要设置cookie的domain属性, 服务端和客户端都要对Credentials header属性进行设置;跨域发送cookie的话, 服务端 Access-Control-Allow-Origin 不能设置为 * , 否则会提示 :123Failed to load http://test.test.com/index.php?sex=renyimin&amp;age=100: The value of the 'Access-Control-Allow-Origin' header in the response must not be the wildcard '*' when the request's credentials mode is 'include'. Origin 'http://www.test.com' is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute. CORS非简单请求服务端需要设置一些允许选项; 发送其他请求 (PUT) .. 可以设置自定义header头 cookie方面和 CORS简单请求一样","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"06.Ajax请求不能发送 之 \"CORS方案 -- (not-so-simple request)\"","slug":"2016-09-18-sameoriginpolicy-06","date":"2016-09-18T12:10:16.000Z","updated":"2017-10-27T10:15:27.000Z","comments":true,"path":"2016/09/18/2016-09-18-sameoriginpolicy-06/","link":"","permalink":"http://blog.renyimin.com/2016/09/18/2016-09-18-sameoriginpolicy-06/","excerpt":"","text":"预检请求 preflight 说明1.非简单请求是那种对服务器有特殊要求的请求, 比如请求方法是 PUT 或 DELETE, 或者 Content-Type 字段的类型是 application/json ; 2.非简单请求的CORS请求, 会在正式通信之前, 增加一次HTTP查询请求, 称为 &quot;预检&quot;请求(preflight) ; 浏览器先询问服务器, 当前网页所在的域名是否在服务器的许可名单之中, 以及可以使用哪些HTTP动词和头信息字段; 只有得到肯定答复, 浏览器才会发出正式的XMLHttpRequest请求, 否则就报错 ; 3.非简单请求会导致原先的一次请求变成两次, 第一次请求是 预检请求 ; 4.”预检”请求用的请求方法是 OPTIONS，表示这个请求是用来询问的，头信息里面关键字段是Origin，表示请求来自哪个源 ; 非简单请求的例子1.www.test.com/index.php 本例子使用 PUT 来进行ajax请求, 满足 非简单请求 的条件 ; 另外, 本例还自定义了请求时的 header 首部字段, 也满足 非简单请求 的条件 ; 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" &gt; $(document).ready(function()&#123; $(\"#btn\").click(function() &#123; //序列化name/value var data = $(\"form\").serializeArray(); $.ajax(&#123; //这里用PUT, 则为 `非简单` 请求 type: 'PUT', url: 'http://test.test.com/index.php', dataType: 'json', data: data, //或者如果你自定义了一些请求时的 header 首部字段, 那么请求就也是 复杂请求 headers: &#123;\"custom-header-field\" : \"test\"&#125;, success: function (result) &#123; console.log(result); &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=\"form\"&gt; &lt;input type=\"text\" name=\"sex\"&gt; &lt;input type=\"text\" name=\"age\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"button\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.test.test.com/index.php 12345678910&lt;?php//服务器允许的 Originheader(\"Access-Control-Allow-Origin: http://www.test.com\");//服务器允许的 methodsheader(\"Access-Control-Allow-Methods: PUT, GET, POST\");//服务器允许设置的头部字段header(\"Access-Control-Allow-Headers: custom-header-field\");$arguments = file_get_contents('php://input');echo json_encode(['arguments' =&gt; $arguments]); 3.注意: 像上面例子的复杂跨域请求 必须: 首先和简单请求一样, 服务器端的 Access-Control-Allow-Origin 是必须设置的, 不然首先就跨不了域; 必须: 其次, 是使用了 get, post, head 之外方法的 复杂请求, 那么就必须在服务端有对应的 Access-Control-Allow-Method, 否则: 可选: 如果你自定义了 自定义首部字段 的 复杂请求, 那么也要在服务端有对应的 Access-Control-Allow-Headers, 否则: 4.另外需要关注的是: 如果你设置了自定义的首部字段, 那么即使你的请求类型是get, post, head, 自然也是复杂请求, 此时的HTTP请求方法显示的仍然如下: Request Method:OPTIONS 分析预检请求1.上面www.test.com/index.php代码进行ajax请求的时候, HTTP请求的方法是PUT, 所以浏览器会发现, 这是一个非简单请求, 就自动发出一个”预检”请求, 要求服务器确认可以这样请求 ; 2.所以请求应该是包括预检请求和真正的请求两个请求的: 3.下面是这个”预检”请求的HTTP头信息 和 回应信息: 4.可以看到, “预检”请求用的请求方法是OPTIONS, 表示这个请求是用来询问的, 头信息里面, 关键字段是Origin, 表示请求来自哪个源; 除了Origin字段，”预检”请求的头信息包括两个特殊字段:(1)Access-Control-Request-Method ：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT ;(2)Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段, 上例是X-Custom-Header ; 分析预检响应1.从下面预检请求的截图中，可以看到预检请求的回应中, 服务器收到”预检”请求以后, 检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后，确认允许跨源请求，就可以做出回应 ; 并且预检请求部分是不会真的发送数据的: 2.上面的HTTP回应中，关键的是 Access-Control-Allow-Origin 字段，表示 http://www.test.com 可以请求数据, 该字段也可以设为星号，表示同意任意跨源请求 ; 123Access-Control-Allow-Origin: http://www.test.com或者Access-Control-Allow-Origin: * 3.如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段 ; 这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest 对象的 onerror 回调函数捕获; 控制台会打印出如下的报错信息 ; 4.服务器还可能回应的其他CORS相关字段如下: 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 测试代码cors请求是否允许包含cookie?(和CORS简单请求是一样的要求) www.test.com/index.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpsetcookie('address', json_encode(['city' =&gt; 'yuncheng', 'town' =&gt; 'xiaoliang']), 0, '/', '.test.com');?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" &gt; $(document).ready(function()&#123; $.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); $(\"#btn\").click(function() &#123; //序列化name/value var data = $(\"form\").serializeArray(); $.ajax(&#123; //这里用PUT, 则为 `非简单` 请求 type: 'PUT', url: 'http://test.test.com/index.php', dataType: 'json', data: data, //或者如果你自定义了一些请求时的 header 首部字段, 那么请求就也是 复杂请求 headers: &#123;\"custom-header-field\" : \"test\"&#125;, success: function (result) &#123; console.log(result); &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=\"form\"&gt; &lt;input type=\"text\" name=\"sex\"&gt; &lt;input type=\"text\" name=\"age\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"button\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; test.test.com 12345678910111213&lt;?php//服务器允许的 Origin (如果要发送cookie的话复杂请求也不能为*)header(\"Access-Control-Allow-Origin: http://www.test.com\");//服务器允许的 methodsheader(\"Access-Control-Allow-Methods: PUT, GET, POST\");//服务器允许设置的头部字段header(\"Access-Control-Allow-Headers: custom-header-field\");//要跨子域发cookie, 这个自然不能少header(\"Access-Control-Allow-Credentials: true\");$arguments = file_get_contents('php://input');$address = $_COOKIE['address'];echo json_encode(['arguments' =&gt; $arguments, 'cookie' =&gt; $address]); 参考 CORS","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"05.Ajax请求不能发送 之 \"CORS方案 -- (simple request)\"","slug":"2016-09-18-sameoriginpolicy-05","date":"2016-09-18T04:45:07.000Z","updated":"2017-10-27T10:03:24.000Z","comments":true,"path":"2016/09/18/2016-09-18-sameoriginpolicy-05/","link":"","permalink":"http://blog.renyimin.com/2016/09/18/2016-09-18-sameoriginpolicy-05/","excerpt":"","text":"CORS说明1.CORS是一个W3C标准, 全称是 “跨域资源共享 “(Cross-origin resource sharing), 通俗说就是我们所熟知的跨域请求 ; 众所周知，在以前，跨域可以采用 代理、JSONP 等方式，而在Modern浏览器面前，这些终将成为过去式，因为有了CORS ; CORS在最初接触的时候只大概了解到，通过服务器端设置Access-Control-Allow-Origin响应头，即可使指定来源像访问同源接口一样访问跨域接口，但其实CORS的规范定义远不止这些 ; 2.它允许浏览器向跨源服务器发出XMLHttpRequest请求, 也就是克服了AJAX只能同源使用的限制 ; 3.CORS需要浏览器和服务器同时支持 (目前, 所有浏览器都支持该功能, IE浏览器不能低于IE10) ; 4.整个CORS通信过程都是浏览器自动完成, 不需要用户参与 ; 对于开发者来说, CORS通信与同源的AJAX通信没有差别, 代码完全一样, 浏览器一旦发现AJAX的请求是跨源的, 就会自动添加一些附加的头信息, 有时还会多出一次附加的请求, 但用户不会有感觉; 之所以CORS通信与同源的AJAX通信的代码没有差别, 是因为: 其实实现CORS通信的关键是服务器, 只要服务器实现了CORS接口，就可以跨源通信 CORS的两类请求1.浏览器将CORS请求分成两类: 简单请求(simple request) 和 非简单请求(not-so-simple request) 2.以下情况会被归类为 非简单请求 : 请求以 GET, HEAD 或者 POST 以外的方法发起请求 ; 虽然使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型, 比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求 ; 使用自定义请求头（比如添加诸如 X-PINGOTHER） 简单请求代码案例1.客户端代码 www.test.com/index.html : 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; &gt; $(document).ready(function()&#123; $(&quot;#btn&quot;).click(function(k) &#123; var data = $(&quot;form&quot;).serializeArray();//序列化name/value $.ajax(&#123; type: &apos;GET&apos;, //这里用GET url: &apos;http://test.test.com/index.php&apos;, dataType: &apos;json&apos;, //类型 data: data, success: function (result) &#123;//返回的json数据 console.log(result); //回调输出 &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.服务端代码test.test.com/index.php : 123&lt;?phpheader(\"Access-Control-Allow-Origin: http://www.test.com\");echo json_encode(['name' =&gt; 'lant', 'age' =&gt; 100]); 基本流程分析1.对于简单请求，浏览器直接发出CORS请求, 具体来说, 就是在头信息之中, 自动增加一个Origin字段 ; 浏览器发现这次跨源AJAX请求是简单请求, 就自动在头信息之中, 添加一个Origin字段: 上面的头信息中, Origin字段 用来说明本次请求来自哪个源(协议 + 域名 + 端口), 服务器根据这个值, 决定是否同意这次请求 ; 2.如果Origin源不在服务器的许可范围内 服务器仍然会返回一个正常的HTTP回应, 不过浏览器会发现, 这个回应的头信息并没有包含 Access-Control-Allow-Origin 字段(详见下文), 就知道出错了, 从而抛出一个错误, 被XMLHttpRequest的onerror回调函数捕获; 注意, 这种错误无法通过状态码识别, 因为HTTP回应的状态码有可能是200 ; 3.当然, 如果Origin源在服务器设置的许可范围内 服务器的响应就会多出如下几个头信息字段(当然也不一定是所有都包含, 具体还得看服务器如何进行设置): 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 重点分析 :上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头:(1) Access-Control-Allow-Origin服务器要设置ajax请求可以跨域, 该字段是必须的, 它的值要么是请求时Origin字段的值，要么是一个，表示接受任意域名的请求;(2) Access-Control-Allow-Credentials该字段可选, 它的值是一个布尔值，表示是否允许发送Cookie, *默认情况下，Cookie不包括在CORS请求之中, 设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器;注意, 这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。(3) Access-Control-Expose-Headers该字段可选, CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma;如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定;上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 服务器端的具体设置 服务器在设置的时候, 其实就是通过header函数设置上面的三个选项! 比如之前的例子中, 如果服务器只是简单的为了实现跨域, 直接设置如下选项即可: 123&lt;?phpheader(\"Access-Control-Allow-Origin: http://www.test1.com\");echo json_encode(['name' =&gt; 'lant', 'age' =&gt; 100]); withCredentials 属性CORS请求默认不发送Cookie和HTTP认证信息 (Jsonp是会发送cookie信息的) 1.之前在介绍Access-Control-Allow-Credentials选项的时候提到, CORS请求默认不发送Cookie和HTTP认证信息; 如果要把Cookie发到服务器: 一方面要 服务器同意指定Access-Control-Allow-Credentials字段 : 123Access-Control-Allow-Credentials: true//php中设置如下:header(\"Access-Control-Allow-Credentials: true\"); 另一方面, 开发者必须在AJAX请求中打开 withCredentials 属性: 1234var xhr = new XMLHttpRequest();xhr.withCredentials = true;//jquery中设置withCredentials的代码如下:$.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); 2.需要以上两方面都做到才可以 否则，即使服务器同意发送Cookie，浏览器也不会发送 ; 但是, 如果省略 withCredentials 设置, 有的浏览器还是会一起发送Cookie, 这时, 可以显式关闭 withCredentials ;1xhr.withCredentials = false; 3.需要注意的是: 如果要发送Cookie, Access-Control-Allow-Origin 就不能设为星号*, 必须指定明确的、与请求网页一致的域名 ; 同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传, 其他域名的Cookie并不会上传, 且(跨源)原网页代码中的document.cookie也无法读取服务器域名下的Cookie ; 测试代码1.域1中的代码(www.test.com/index.php)：123456789101112131415161718192021222324252627282930313233343536373839&lt;?php//Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传, 其他域名的Cookie并不会上传, 且(跨源)原网页代码中的document.cookie也无法读取服务器域名下的Cookiesetcookie('address', json_encode(['city' =&gt; 'yuncheng', 'town' =&gt; 'xiaoliang']), 0, '/', '.test.com');?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" &gt; $(document).ready(function()&#123; //要在跨域请求服务器时在cors请求中包含cookie, 需要开启withCredentials属性 $.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); $(\"#btn\").click(function(k) &#123; var data = $(\"form\").serializeArray();//序列化name/value $.ajax(&#123; type: 'GET', //这里用GET url: 'http://test.test.com/index.php', dataType: 'json', //类型 data: data, success: function (result) &#123;//返回的json数据 console.log(result); //回调输出 &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=\"form\"&gt; &lt;input type=\"text\" name=\"sex\"&gt; &lt;input type=\"text\" name=\"age\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"button\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.域2中的代码(test.test.comindex.php):123456&lt;?phpheader(\"Access-Control-Allow-Origin: http://www.test.com\");//服务器允许前端在跨域cors请求时包含cookieheader(\"Access-Control-Allow-Credentials: true\");$address = $_COOKIE['address'];echo json_encode(['name' =&gt; 'lant', 'age' =&gt; 100, 'address' =&gt; $address]); 3.效果: 4.两个注意点 如果域1中在html中设置了 withCredentials 为 true : 1$.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); 那么在对应的ajax请求的域2中必须设置 1header(\"Access-Control-Allow-Credentials: true\"); 否则, 报错如下: 如果两边都不设置 withCredentials 属性的话, 也就是默认请求不带cookie, 那么即使请求方域1中设置了domain属性为 .test.com 的cookie值, 服务方(test.test.com)中也获取不到cookie, 因为域1默认请求就没有带cookie ; 参考 阮一峰参考 阮一峰 CORS","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"04. Ajax请求不能发送 之 \"JSONP方案\"","slug":"2016-09-17-sameoriginpolicy-04","date":"2016-09-17T11:27:31.000Z","updated":"2017-10-27T09:32:16.000Z","comments":true,"path":"2016/09/17/2016-09-17-sameoriginpolicy-04/","link":"","permalink":"http://blog.renyimin.com/2016/09/17/2016-09-17-sameoriginpolicy-04/","excerpt":"","text":"JSONP1.JSONP是服务器与客户端 跨源通信 的常用方法, 最大特点就是简单适用, 老式浏览器全部支持, 服务器端改造非常小 ; 2.但是，JSONP只能发GET请求 ; 3.注意: JSONP跨子域发送Cookie的话, 只用设置好cookie的domain属性为顶级域名即可 ; ajax使用jsonp跨域的时候是可以轻松像上面这样带上cookie给所跨的域 ; 而下一篇介绍的ajax使用cors方案跨域的话, 除了设置了cookie的 document.domain 为两个地址的顶级域名, 却也不能带上cookie, 还需要注意 前端和服务端的 withCredentials 头字段 ; jsonp跨域请求案例www.test.com/index.html123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; &gt; $(document).ready(function()&#123; //注意, 此时jsonp是会带上cookie的(当然, 如果你不设置cookie的domain, test.test.com自然获取不到www.test.com域的cookie) document.cookie = &quot;name=value; domain=test.com&quot;; $(&quot;#btn&quot;).click(function() &#123; var data = $(&quot;form&quot;).serializeArray();//序列化name/value $.ajax(&#123; type: &apos;GET&apos;, //这里用GET url: &apos;http://test.test.com/index.php&apos;, dataType: &apos;jsonp&apos;, //类型 data: data, jsonp: &apos;callback&apos;, //jsonp回调参数，必需 async: false, success: function (result) &#123;//返回的json数据 console.log(result); //回调输出 &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; test.test.com/index.php1234567891011&lt;?php//jsonp回调参数，必需$callback = isset($_GET['callback']) ? trim($_GET['callback']) : '';$sex = isset($_GET['sex']) ? trim($_GET['sex']) : '';$age = isset($_GET['age']) ? trim($_GET['age']) : '';$data = [\"sex\" =&gt; $sex, \"age\" =&gt; $age];$res = json_encode($data); //json 数据// 不能用returnecho $callback . '(' . $res . ')'; //返回格式，必需 参考","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"03.同源策略的限制 之 \"Ajax请求不能发送\"","slug":"2016-09-16-sameoriginpolicy-03","date":"2016-09-16T05:04:17.000Z","updated":"2017-10-27T09:33:06.000Z","comments":true,"path":"2016/09/16/2016-09-16-sameoriginpolicy-03/","link":"","permalink":"http://blog.renyimin.com/2016/09/16/2016-09-16-sameoriginpolicy-03/","excerpt":"","text":"同源策略的限制 - Ajax请求不能发送 同源政策规定, AJAX请求只能发给同源的网址, 否则就报错 ; 除了架设服务器代理(浏览器请求同源服务器，再由后者请求外部服务), 有三种方法规避这个限制 : JSONP CORS WebSocket 参考","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"02.同源策略的限制 之 \"Cookie无法读取\"","slug":"2016-09-15-sameoriginpolicy-02","date":"2016-09-15T13:10:13.000Z","updated":"2017-10-27T09:18:13.000Z","comments":true,"path":"2016/09/15/2016-09-15-sameoriginpolicy-02/","link":"","permalink":"http://blog.renyimin.com/2016/09/15/2016-09-15-sameoriginpolicy-02/","excerpt":"","text":"回顾之前学习同源策略基础知识的时候, 了解了同源策略的 三种行为 限制: Cookie、LocalStorage 和 IndexDB 无法读取 DOM 无法获得 AJAX 请求不能发送 不过这里需要注意一点: “同源策略”的限制, 并没有限制住CSRF攻击“同源策略的限制”并不会导致 B站点中嵌入的 A站点超链接去读取A站点用户的cookie;假如你当前已经登录了邮箱，或bbs，同时你又访问了另外一个站点，假设这就是一个钓鱼网站; 这个网站上面可能因为某个图片吸引你，你去点击一下，此时可能就会触发一个js的点击事件，去构造一个bbs发帖的请求，去往你的bbs站点发帖，由于当前你的浏览器状态已经是登陆状态，所以session登陆cookie信息都会跟正常的请求一样，纯天然的利用当前的登陆状态，让用户在不知情的情况下，帮你发帖或干其他事情; (这也就是我们通常所说的CSRF攻击, CSRF攻击的主要目的是让用户在不知情的情况下攻击自己已登录的一个系统，类似于钓鱼); 同源策略的限制之”Cookie无法读取” 本篇构造跨域的场景来模拟”Cookie无法读取”的限制, 方法主要有: B站&lt;a href=&quot;A&quot;&gt;test&lt;/a&gt;超链接无法读取B站点的cookie; (而csrf所讨论的是B站&lt;a href=&quot;A&quot;&gt;test&lt;/a&gt;超链接可以读取A站点自己的cookie) 不通过B站超链接, 而是直接打开另一个网页来访问A站点, 结果当然也是A站点读不到B站点的Cookie ; 暂时不会涉及到 Ajax请求所涉及的cookie传递问题, 这个问题属于同源策略的第三种限制 AJAX请求不能发送; 例子 : A网页是 http://www.test.com/index.html，B网页是 http://test.test.com/index.html : A: www.test.com/index.html (此处是使用js来设置cookie进行测试; 当然, 用服务端代码php测试也是OK的) 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; document.cookie=&quot;name=value;&quot;;&lt;/script&gt;&lt;/html&gt; B: test.test.com/index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; console.log(document.cookie);&lt;/script&gt;&lt;/html&gt; // 可以看到, 同顶级域名也不能跨子域名获取cookie //同理, 直接在http://www.test.com/index.html中超链接点击到http://test.test.com/index.html也是获取不到cookie的 ; 合理规避Cookie无法读取的限制 虽然同源导致的这些限制是必要, 但是有些情况下, 其实我们是需要 合理 规避Cookie无法读取的限制的 ; 比如: 如果两个网页的顶级域名相同, 只是二级域名不同的话, 浏览器其实是允许你通过设置 document.domain 来共享 Cookie 的; 例子: A网页是 http://www.test.com/index.html，B网页是 http://test.test.com/index.html, 那么只要设置相同的 document.domain，两个网页就可以共享Cookie : A: www.test.com/index.html (此处是使用js来设置cookie进行测试; 当然, 用php代码也是OK的) 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; document.cookie=&quot;name=value; domain=test.com&quot;;&lt;/script&gt;&lt;/html&gt; B: test.test.com/index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; console.log(document.cookie);&lt;/script&gt;&lt;/html&gt; 注意:这种方法只适用于 Cookie 和 iframe 窗口(DOM无法获取); 而 LocalStorage 和 IndexDB 无法通过这种方法来规避同源政策，而要使用之后会介绍的PostMessage API ; 参考 阮一峰","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"01.浏览器的同源策略(Same origin policy)","slug":"2016-09-15-sameoriginpolicy-01","date":"2016-09-15T11:21:54.000Z","updated":"2017-10-27T08:57:30.000Z","comments":true,"path":"2016/09/15/2016-09-15-sameoriginpolicy-01/","link":"","permalink":"http://blog.renyimin.com/2016/09/15/2016-09-15-sameoriginpolicy-01/","excerpt":"","text":"同源策略1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策； 最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”，所谓 “同源” 指的是 “三个相同” ： 1.协议相同http://blog.renyimin.com 和 https://blog.renyimin.com 就不是同一个源 ； 2.域名完全相同http://blog.renyimin.com/test/index.php 和 http://blog.renyimin.com/welcome/index.html 就是同一个源; 但是 http://www.renyimin.com/test/index.php 和 http://blog.renyimin.com/test/index.php 就不是同一个源 ；请注意：localhost和127.0.0.1虽然都指向本机, 但也不是同一个源 ; 3.端口相同http://www.renyimin.com:8080/test/index.php 和 http://www.renyimin.com:80/test/index.php 就不是同一个源 ; 再举例来说，http://www.example.com/dir/page.html 这个网址，协议是 http://，域名是 www.example.com，端口是80（默认端口可以省略），它的同源情况如下： 1234567http://www.example.com/dir2/other.html：同源http://example.com/dir/other.html：不同源（域名不同）http://v2.www.example.com/dir/other.html：不同源（域名不同）http://www.example.com:81/dir/other.html：不同源（端口不同） 同源策略目的1.为了保证用户信息的安全，防止恶意的网站窃取数据;比如:用户登录一家银行网站后，又去浏览其他站点, 如果没有同源策略限制, 其他站点就也能读取银行网站的 Cookie, 会发生什么？ 如果 Cookie 包含用户银行的私密信息，这些信息就会泄漏给第三方站点, 当然, cookie中包含的敏感信息通常经过加密，很难将其反向破解, 但这并不意味着绝对安全; 不去获取cookie中的信息, 而是直接偷取Cookie去骗取银行网站的信任; 2.由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了 ; 同源策略的限制随着互联网的发展, “同源政策”越来越严格, 目前, 如果非同源, 共有三种行为受到限制: Cookie、LocalStorage 和 IndexDB 无法读取 DOM 无法获得 AJAX 请求不能发送 (可能我平时更过关注到的是1，3这两点限制) 不过这里需要注意一点: “同源策略”的限制, 并没有限制住CSRF攻击“同源策略的限制”并不会导致 B站点中嵌入的 A站点超链接去读取A站点用户的cookie;假如你当前已经登录了邮箱，或bbs，同时你又访问了另外一个站点，假设这就是一个钓鱼网站; 这个网站上面可能因为某个图片吸引你，你去点击一下，此时可能就会触发一个js的点击事件，去构造一个bbs发帖的请求，去往你的bbs站点发帖，由于当前你的浏览器状态已经是登陆状态，所以session登陆cookie信息都会跟正常的请求一样，纯天然的利用当前的登陆状态，让用户在不知情的情况下，帮你发帖或干其他事情; (这也就是我们通常所说的CSRF攻击, CSRF攻击的主要目的是让用户在不知情的情况下攻击自己已登录的一个系统，类似于钓鱼); 最后, 虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响, 接下来将详细介绍如何在需要的时候合理地去规避”同源政策”的限制 ; 参考 阮一峰","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"02 - 并发写问题","slug":"2016-08-10-concurrency-02","date":"2016-08-10T14:19:27.000Z","updated":"2017-12-12T09:03:22.000Z","comments":true,"path":"2016/08/10/2016-08-10-concurrency-02/","link":"","permalink":"http://blog.renyimin.com/2016/08/10/2016-08-10-concurrency-02/","excerpt":"","text":"初级并发写的问题保证并发写的数据安全问题MySQL锁并发测试抢购超卖问题 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?phpnamespace App\\Http\\Controllers\\Test;use App\\Http\\Models\\Test\\Goods;use Illuminate\\Http\\Request;use App\\Http\\Requests;use App\\Http\\Controllers\\Controller;use Illuminate\\Support\\Facades\\DB;/** * 主要做一些高并发测试 * Class ConcurrencyController * @package App\\Http\\Controllers */class ConcurrencyController extends Controller&#123; /* DROP TABLE IF EXISTS `goods`; CREATE TABLE `goods` ( `id` int(10) NOT NULL AUTO_INCREMENT, `goods_name` varchar(100) NOT NULL, `num` int(100) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO `goods` VALUES (1, 'iphone 6 plus', 10); */ /** * mysql模拟并发写(修改)数据 * Jmeter模拟调用10次 */ public function analogueConcurrencyByMySql() &#123; $good = Goods::select('num')-&gt;find(1); if ($good['num']&gt;0) &#123; //增加代复杂度,不然超卖不好模拟出来 usleep(500000); $res = Goods::where(['id' =&gt; 1])-&gt;decrement('num', 1);//-&gt;update(['num' =&gt; $good['num']-1]); &#125; &#125; /** * 乐观锁测试 */ public function mysqlOptimisticLock() &#123; $good = Goods::select('num')-&gt;find(1); if ($good['num']&gt;0) &#123; //增加代复杂度,不然超卖不好模拟出来 usleep(500000); Goods::where(['id' =&gt; 1])-&gt;where('num', '&gt;', '0')-&gt;decrement('num', 1);//-&gt;update(['num' =&gt; $good['num']-1]); &#125; &#125; /** * 悲观锁测试(没有事务, 测试失败) */ public function mysqlPessimisticLock1() &#123; $good = Goods::select('num')-&gt;lockForUpdate()-&gt;find(1); if ($good['num']&gt;0) &#123; //增加代复杂度,不然超卖不好模拟出来 usleep(500000); Goods::where(['id' =&gt; 1])-&gt;decrement('num', 1);//-&gt;update(['num' =&gt; $good['num']-1]); &#125; &#125; /** * 悲观锁测试(有事务, 测试成功) */ public function mysqlPessimisticLock2() &#123; try&#123; DB::beginTransaction(); $good = Goods::select('num')-&gt;lockForUpdate()-&gt;find(1); if ($good['num']&gt;0) &#123; //增加代复杂度,不然超卖不好模拟出来 usleep(500000); Goods::where(['id' =&gt; 1])-&gt;decrement('num', 1);//-&gt;update(['num' =&gt; $good['num']-1]); &#125; DB::commit(); &#125; catch(\\Exception $e) &#123; DB::rollback(); &#125; &#125;&#125; 悲观锁必须配合事务使用 Jmeter压测文件 Redis锁的利用 Redis的事务涉及到的WATCH Redis原子锁 memcached锁https://github.com/Yurunsoft/YurunLock 场景 如: 并发减少库存如何保证不超卖利用Redis锁 如:","categories":[{"name":"高并发","slug":"高并发","permalink":"http://blog.renyimin.com/categories/高并发/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://blog.renyimin.com/tags/高并发/"}]},{"title":"01 - 并发读问题","slug":"2016-08-10-concurrency-01","date":"2016-08-10T11:16:54.000Z","updated":"2017-12-12T02:29:20.000Z","comments":true,"path":"2016/08/10/2016-08-10-concurrency-01/","link":"","permalink":"http://blog.renyimin.com/2016/08/10/2016-08-10-concurrency-01/","excerpt":"","text":"初级并发读的问题如何尽可能承载更高的并发访问量","categories":[{"name":"高并发","slug":"高并发","permalink":"http://blog.renyimin.com/categories/高并发/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://blog.renyimin.com/tags/高并发/"}]},{"title":"MySQL锁 - 02","slug":"2016-08-09-mysql_locks-02","date":"2016-08-09T13:30:12.000Z","updated":"2017-12-13T01:52:54.000Z","comments":true,"path":"2016/08/09/2016-08-09-mysql_locks-02/","link":"","permalink":"http://blog.renyimin.com/2016/08/09/2016-08-09-mysql_locks-02/","excerpt":"","text":"乐观锁(Optimistic Lock) 在提交数据更新之前, 每个事务才会检查在该事务读取数据后, 有没有其他事务又修改了该数据, 如果其他事务有更新的话, 那么当前正在提交的事务会进行回滚; 很显然, 这可以解决 丢失更新 的问题, 因为在这个事务中, 操作语句可能类似下面: 乐观锁的底层机制 (https://www.cnblogs.com/zhiqian-ali/p/6200874.html) 其底层机制是这样：在数据库内部update同一行的时候是不允许并发的，即数据库每次执行一条update语句时会获取被update行的写锁，直到这一行被成功更新后才释放; 乐观锁优点: 乐观锁通常来说根本没有真正的锁, 是依靠程序实现, 不会存在死锁等问题; 可以不放在事务内; 锁冲突少的时候用乐观锁比较有优势, 锁冲突大的时候用悲观锁; 悲观锁(Pessimistic Lock) 悲观锁的特点是先获取锁, 再进行业务操作, 即悲观的认为获取锁是非常有可能失败的, 因此要先确保获取锁成功再进行业务操作; 通常所说的一锁二查三更新即指的是使用悲观锁; 通常来讲在数据库上的悲观锁需要数据库本身提供支持, 即通过常用的select … for update操作来实现悲观锁, 当数据库执行select for update时会获取被select中的数据行的行锁, 因此其他并发执行的select for update如果试图选中同一行则会发生排斥(需要等待行锁被释放), 因此达到锁的效果; for update 仅适用于InnoDB; for update 必须在事务块(BEGIN/COMMIT)中才能生效; 在进行事务操作时, 通过for update语句, MySQL会对查询结果集中每行数据都添加排他锁, 其他并行事务对该记录的查询, 更新, 删除操作都会被阻塞, 排他锁包含行锁、表锁。 for update 必须注意点: 这里需要注意的一点是, 不同的数据库对 select for update 的实现和支持都是有所区别的, 例如oracle支持 select for update no wait, 表示如果拿不到锁立刻报错, 而不是等待; 而mysql就没有 no wait 这个选项; 另外mysql还有个问题是 select for update 语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题, 因此如果在mysql中用悲观锁务必要确定走了索引, 而不是全表扫描; 貌似乐观锁和悲观锁都是为了解决高并发下, 事务中的锁所没有解决的 丢失更新 问题? 并发测试","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/tags/MySQL/"}]},{"title":"MySQL锁 - 03","slug":"2016-08-09-mysql_mvcc-03","date":"2016-08-09T13:07:12.000Z","updated":"2017-12-13T01:52:54.000Z","comments":true,"path":"2016/08/09/2016-08-09-mysql_mvcc-03/","link":"","permalink":"http://blog.renyimin.com/2016/08/09/2016-08-09-mysql_mvcc-03/","excerpt":"","text":"MVCC","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/tags/MySQL/"}]},{"title":"MySQL锁 - 01","slug":"2016-08-09-mysql_locks-01","date":"2016-08-09T11:16:54.000Z","updated":"2017-12-13T01:50:05.000Z","comments":true,"path":"2016/08/09/2016-08-09-mysql_locks-01/","link":"","permalink":"http://blog.renyimin.com/2016/08/09/2016-08-09-mysql_locks-01/","excerpt":"","text":"前言 之前已经学习了事务及事务在高并发下所面临的问题, 并且介绍了事务的隔离级别是如何解决这些问题的; 那这些问题已经通过事务解决了, 为什么还要学习锁的相关知识? 这是因为我们之前介绍的事务的隔离级别，其实它的核心就是锁; 而且我们学习了锁的概念之后, 还能在高并发的时候解决非事务下(不使用事务)或者事务的隔离级别也解决不了的 丢失更新 的问题 （乐观,悲观锁的使用） 所以我们也需要对锁有一定的认识; 常见锁相关的词 在学习锁相关知识之前, 先看一些关于锁的名词: 锁冲突(锁等待) 死锁 两段锁 (https://www.cnblogs.com/rainwang/p/4429211.html) 表级锁(MYISAM, INNODB引擎) 意向锁(意向共享锁, 意向排他锁) 行级锁(记录锁) (INNODB引擎) 页级锁(BDB引擎) 共享锁(S锁)(读锁) 排他锁(X锁)(写锁) 乐观锁 悲观锁 记录锁 间隙锁 next-key锁 自动锁 显示锁 (DML锁和DDL锁：http://www.hollischuang.com/archives/909) 锁冲突线程1将A上锁后, 线程2又对A上锁, 锁不能共存否则会出现锁冲突; (共享锁和共享锁可以共存, 共享锁和排它锁不能共存, 排它锁和排他锁也不可以共存) 死锁 死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候; 比如: 线程1锁住了A, 然后尝试对B进行加锁, 于此同时线程2已经锁住了B, 接着尝试对A进行加锁, 这时死锁就发生了, 线程1永远得不到B, 线程2也永远得不到A, 并且它们永远也不会知道发生了这样的事情; 为了得到彼此的对象(A和B), 它们将永远阻塞下去, 这种情况就是一个死锁; 有多种方法可以避免死锁, 这里只介绍常见的三种: 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表, 可以大大降低死锁机会; 在同一个事务中, 尽可能做到一次锁定所需要的所有资源, 减少死锁产生概率; 对于非常容易产生死锁的业务部分, 可以尝试使用升级锁定颗粒度, 通过表级锁定来减少死锁产生的概率; 表级锁 表级锁是MySQL中锁定粒度最大的一种锁, 表示对当前操作的整张表加锁, 它实现简单, 资源消耗较少, 被大部分MySQL引擎支持, 最常使用的MYISAM与INNODB引擎都支持表级锁定, 但INNODB默认采用的是行级锁, 表级锁定分为表共享读锁(共享锁)与表独占写锁(排他锁); (意向锁就属于表锁) 特点: 加锁快(开销小) 锁定粒度大(出现锁冲突(即:锁等待)的概率最高, 并发度最低) MYISAM引擎默认就是表级锁 (另外, 由于MYISAM引擎不支持事务, 每次操作执行完后会立即提交, 也就是每次操作只加一个锁, 其他操作只用等待就行; 而在InnoDB中, 锁是逐步获得的, 就造成了死锁的可能) 页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁, 表级锁加锁速度快,但冲突多,行级锁冲突少,但加锁速度慢, 所以取了折衷的页级, 一次锁定相邻的一组记录; (BDB支持页级锁) 特点: 加锁时间和开销界于表锁和行锁之间 锁定粒度界于表锁和行锁之间, 并发度一般 BDB引擎使用的就是页级锁, 会出现死锁 行级锁 行级锁是Mysql中锁定粒度最细的一种锁, 只对当前操作的行进行加锁, 行级锁能大大减少数据库操作的冲突, 因为其加锁粒度最小, 但行级锁加锁的开销也最大。行级锁分为共享锁 和 排他锁; 特点: 加锁慢, 开销大 锁定粒度最小(发生锁冲突的概率最低, 并发度也最高) INNODB引擎使用行锁, 支持事务, 会出现死锁 Innodb中的行锁与表锁注意事项 前面提到过, Innodb引擎中既支持行锁也支持表锁, 那么什么时候会锁住整张表, 什么时候或只锁住一行? InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的; InnoDB这种行锁实现特点意味着: 只有通过索引条件检索数据, InnoDB才使用行级锁, 否则, InnoDB将使用表锁!(不过, 在实际应用中, 一般在做更改的时候, 都是使用主键进行筛选, 所以自然是行锁) 在实际应用中, 要特别注意InnoDB行锁的这一特性, 不然的话, 可能导致大量的锁冲突, 从而影响并发性能; 在不通过索引条件查询的时候,InnoDB 确实使用的是表锁,而不是行锁; 由于 MySQL 的行锁是针对索引加的锁, 而不是针对记录加的锁, 所以虽然是访问不同行的记录, 但是如果是使用相同的索引键, 是会出现锁冲突的, 应用设计的时候要注意这一点;(也就是Innodb引擎中, 写操作即使是操作不同的行, 也可能由于使用一样的索引而导致锁冲突) 当表有多个索引的时候, 不同的事务可以使用不同的索引锁定不同的行, 另外, 不论是使用主键索引、唯一索引或普通索引, InnoDB 都会使用行锁来对数据加锁; 即便在条件中使用了索引字段, 但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的, 如果 MySQL 认为全表扫效率更高, 比如对一些很小的表, 它就不会使用索引, 这种情况下 InnoDB 将使用表锁, 而不是行锁;因此, 在分析锁冲突时, 别忘了检查 SQL 的执行计划, 以确认是否真正使用了索引; 行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。 共享锁(Share Lock) 共享锁又称读锁, 是读取操作创建的锁。 其他事务可以并发读取数据, 但不能对数据进行修改(获取数据上的排他锁), 直到已释放所有共享锁; (也就是共享锁只可以和共享锁共存) 如果事务T对数据A加上共享锁后, 则其他事务只能对A再加共享锁, 不能加排他锁, 获准共享锁的事务只能读数据, 不能修改数据; 对于一般的select语句, InnoDB不会加任何锁, 当然, 也可以显示手动去自己加: SELECT ... LOCK IN SHARE MODE; 在查询语句后面增加LOCK IN SHARE MODE, Mysql会对查询结果中的每行都加共享锁, 当没有其他线程对查询结果集中的任何一行使用排他锁时, 可以成功申请共享锁, 否则会被阻塞; 其他线程也可以读取使用了共享锁的表, 而且这些线程读取的是同一个版本的数据; 排他锁(Xclusive Lock) 排他锁又称写锁, 如果事务T对数据A加上排他锁后, 则其他事务不能再对A加任任何类型的锁; 获准排他锁的事务既能读数据, 又能修改数据。 对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁(X), 当然, 也可以显示手动去自己加: SELECT ... FOR UPDATE; 在查询语句后面增加FOR UPDATE, Mysql会对查询结果中的每行都加排他锁, 当没有其他线程对查询结果集中的任何一行使用排他锁时, 可以成功申请排他锁, 否则会被阻塞; 意向锁 (不用干预) 意向锁是表级锁, 其设计目的主要是为了在一个事务中揭示下一行将要被请求锁的类型; InnoDB中的两个表锁: 意向共享锁(IS): 表示事务准备给数据行加入共享锁, 也就是说一个数据行加共享锁前必须先取得该表的IS锁; 意向排他锁(IX): 类似上面, 表示事务准备给数据行加入排他锁, 说明事务在一个数据行加排他锁前必须先取得该表的IX锁; 3.意向锁是InnoDB自动加的,不需要用户干预; 4.显示加共享锁或排他锁: 共享锁：SELECT ... LOCK IN SHARE MODE; 排他锁：SELECT ... FOR UPDATE; 共享锁和意向共享锁，排他锁与意向排他锁的区别 共享锁和排他锁: 系统在特定的条件下会自动添加共享锁或者排他锁, 也可以手动添加共享锁或者排他锁; 意向共享锁和意向排他锁都是系统自动添加和自动释放的, 整个过程无需人工干预; 共享锁和排他锁都是锁的行记录,意向共享锁和意向排他锁锁定的是表。 间隙锁 间隙锁是innodb中 行锁 的一种，但是这种锁锁住的却不止一行数据, 他锁住的是多行, 是一个数据范围; 通过生活中的一个小场景来认识间隙锁: a,b,c 三个人依次站成一排, 此时, 新来了一个d, 如何让新来的d不站在小红旁边? 其实只要将b和它前面的a之间的空隙封锁; 再将b和它后面的c之间的空隙封锁; 那么d就不能站到b的旁边了; 这里的a, b, c, d 如果对应到数据表中, 那就是就是一条条记录； 他们之间的空隙也就是间隙, 而封锁他们之间间隙的锁, 就叫做间隙锁; (http://www.jianshu.com/p/bf862c37c4c9) next-key锁 MYISAM 和 INNODB相比:MYISAM不会出现死锁(因为MYISAM没有事务)","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/tags/MySQL/"}]},{"title":"MySQL(INNODB引擎)事务","slug":"2016-08-07-mysql_transaction-01","date":"2016-08-07T13:01:07.000Z","updated":"2017-12-27T09:35:13.000Z","comments":true,"path":"2016/08/07/2016-08-07-mysql_transaction-01/","link":"","permalink":"http://blog.renyimin.com/2016/08/07/2016-08-07-mysql_transaction-01/","excerpt":"","text":"事务的概念 事务 可以理解为一个 独立的工作单元, 在这个 独立的工作单元 中有 一组操作; 放在事务中的多个操作, 要么全部执行成功, 要么全部执行失败, 这当然也是事务的目的; 还是通过最经典的银行应用来解释事务 假设Iron Man通过网上银行给Wolverine转账100元, 那么本次转账操作至少需要三个步骤: 123检查`Iron Man`余额`&gt;=100`元从`Iron Man`余额中`-100`元给`Wolverine`余额`+100`元 注意:上面的三个步骤的操作必须打包在一个事务中, 来作为一个 独立的工作单元 来执行, 在这个 独立工作单元(即事务) 中的这三个操作, 只要有任何一个操作失败, 则事务就整体就是失败的, 那就必须回滚所有的步骤; 假设第二步操作成功, 但是第三步操作失败, 那么整个事务也就应该是失败的, 那就必须将第二步的操作也回滚; 这就是事务最基本的特性, 保证数据的一致性。 但这只是理想情况下, 在真实的高并发场景下, 事务为了做到一致性, 需要做的事情其实还很多, 因为高并发会出现很多理想状态下所意想不到的问题。 事务的 ACID 特性一个运行良好的事务处理系统必须具备这些标准特性 Atomicity 原子性一个事务必须被视为一个不可分割的最小工作单元, 整个事务中的所有操作要么全部提交成功, 要么全部失败回滚;对于一个事务来说, 不能只成功执行其中的一部分操作, 这就是事务的原子性; Consistency 一致性事务的一致性会保证 数据库总是从一个一致性的状态 转换到 另一个一致性的状态;(比如在之前的转账例子中, 即使已经行完了第二步(从A用户余额中-100元), 但在开始执行第三步(给B用户余额+100元)时系统突然崩溃, 那么A用户的余额也不会损失100元, 因为事务最终没有提交, 所以事务中所做的修改也不会保存到数据库中; Isolation 隔离性通常来说, 一个事务所做的修改在最终提交以前, 对其他事务是不可见的; 比如在之前的转账例子中, 在执行完成第二步, 但是第三步还没开始的时候, 此时有另一个账户汇总的程序开始运行, 那么这个程序所拿到的A账户余额应该是没有被 -100 的余额才对 后面我们还会详细讨论事务隔离性的 隔离级别, 到时候就知道这里为什么说通常来说对其他事务是不可见的; (也就是还有特例, 比如最低隔离级别 READ UNCOMMITTED, 对其他事务的可见就造成了脏读问题的出现) Durability 持久性一旦事务被最终提交, 则在事务这个独立单元中的所有操作所做的修改将会 永久保存到数据库中;(这里所说的永久 ~你懂得就好~, 别太较真了, 你要是把硬盘烧掉, 哪儿来的永久可言…) 事务隔离级别事务的隔离级别 其实就是通过 锁机制 实现的; 高并发事务的问题在并发量比较大的时候, 很容易出现多个事务同时进行的情况。 假设有两个事务正在同时进行, 值得注意的是: 它们两者之间是互相不知道对方的存在的, 各自都对自身所处的环境过分乐观, 从而并没有对自己所操作的数据做一定的保护处理, 所以最终会导致一些问题的出现; 脏读读取的是非永久性的数据! mysql中一个事务读取了另一个并行事务未最终提交的写数据, 那这个读取就是脏读。(要知道, 另一个事务最终可能会因为内部其他子操作的失败, 而导致事务最终整体提交失败, 那么当前事务读取到的这个数据就是个非永久的数据(会被回滚), 也就是所谓的脏数据) 图示: 事务A在T4阶段读取库存为20, 这个库存其实就属于脏数据, 因为这个数据是事务B最终会撤销掉的数据即非永久性的数据, 所以如果事务A使用库存20进行后续的操作, 就会引发问题; 解决方案 - 事务的隔离性 当事务的隔离级别为 read commited 及 以上 隔离级别时, 可以让一个事务只能读取另一个事务已经提交的数据, 这样就可以避免了上面的脏读现象; 但是脏读问题解决后, 还是有问题存在的: 试想一下, 解决脏读之后, 一个事务确实是只能读取另一个事务已经提交的数据, 也就是每个事务读到的数据都是永久数据; 那问题在哪里?在同一个事务单元内, 虽然每次读取到的都是永久数据, 但是会出现, 两次读到的数据可能是不一样的; 不可重复读 上面在 脏读问题 的末尾, 已经介绍了不可重复读是怎么产生的!!! 解决方案 - 事务的隔离性 当事务的隔离级别为 repeatable read 或 以上 级别时, 一个事务内部对数据的多次查询都是相同的(无论该数据在中途是否被其他事务修改并最终提交过, 本事务都不理会), 这样就避免了不可重复读的问题; 但是该隔离级别依然解决不了幻读的问题!! 但是 不可重复读问题 解决后, 还是有问题存在的: 因为在一个事务内部, 如果直接忽略其他并行事务对当前数据所做的修改的话, 虽然确实可以解决事务内部不可重复读的问题。 但很显然这会造成另一个问题, 那就是 忽略并行事务的修改 而造成的 丢失更新; (注意: 这里是在 已解决不可重复读 情况下在事务内多次读取时进行的举例) 其实不管是 已解决不可重复读 情况下在事务内多次读取, 还是 没有解决不可重复读 情况下在事务内只读取一次, 丢失更新 都是存在的!! 丢失更新 上面在 不可重复读问题 的末尾, 已经介绍了 丢失更新 是怎么产生的!!! 解决方案 – 貌似无法通过隔离级别来进行解决 实际上, 上面介绍的情况只是一种常见的丢失更新的情况 通过 乐观锁 可以解决这个问题, 事务在进行更新余额操作的时候, SQL修改为 update table set kucun=1100 where id=xxx **** and kucun=1000****, 通过加上一个金额的判断, 这样的话, 如果更改之前数据没有修改则执行成功, 否则执行失败回滚; 当然, 你可以可以通过设置InnoDB的隔离级别为SERIALIZABLE, 不过在实际场景中很少使用该隔离级别; 幻读 (间隙锁) 幻读主要是查询记录的数量问题 在上图中, 事务A一开始查询没有数据, 但是插入记录失败, 提示主键冲突; 这种查询明明没有, 插入却提示已经存在的现象, 叫做幻读; 幻读和不可重复读类似, 即两次读取的结果不一致, 两者的不同点在于: 不可重复读针对数据的修改造成的读不一致; 而幻读针对数据的插入和删除造成的读不一致, 如同发生幻觉一样; 如何避免这个问题? 当事务的隔离级别为 SERIALIZABLE 时, 会通过间隙锁来防止幻读的出现, 即锁定特定数据的前后间隙让数据无法被插入; 事务的4种隔离级别事务的隔离性比较复杂, 在SQL标准中定义了四种隔离级别, 每一种级别都规定了在一个事务中所做的修改, 哪些在事务内和事务间是可见的, 哪些是不可见的, 较低的隔离级别通常可以执行更高的并发, 系统的开销也更低; 下面简单了解一下四种隔离级别 READ UNCOMMITTED (未提交读)出现 脏读 在READ UNCOMMITTED级别, 事务中的修改, 即使没有提交, 对其他事务也都是可见的; 也就是说事务可以读取未递交的数据, 这也就造成了脏读(Dirty Read)的出现; 这个级别会导致很多问题, 从性能上来说, READ UNCOMMITTED级别也不会比其他的级别好太多, 但却缺乏其他级别的很多好处, 所以在实际应用中一般很少使用; READ COMMITTED (提交读)解决 脏读 大多数数据库系统的默认隔离级别都是READ COMMIT(但MySQL不是); READ COMMIT满足前面提到的隔离性的简单定义: 一个事务开始时, 只能”看见”已经提交的事务所做的修改; 也就是说一个事务从开始直到事务提交之前, 所做的任何修改对其他事务都是不可见的; 这也就解决了脏读的问题!! 这个级别有时候也叫不可重复读(nonrepeatable read), 应为两次执行同样的查询, 可能会得到不一样的结果; REPEATABLE READ (可重复读)解决脏读, 解决 不可重复读, 依然无法解决 幻读 首先 REPEATABLE READ 比 READ COMMITTED 的隔离级别高, 也可以解决脏读的问题; 该级别保证了在同一个事务中多次读取同样的记录的结果是一致的; 但是理论上, 可重复读这个隔离级别还是无法解决另外一个幻读(Phantom Read)的问题; 所谓幻读, 指的是当某个事务在读取某个范围内的记录时, 另外一个事务又在该范围内插入了新的记录, 当之前的事务再次读取该范围的记录时, 会产生幻行(Phantom Row); InnoDB和XtraDB存储引擎通过多版本并发控制(MVCC)解决了幻读的问题 可重复读是MySQL的默认事务隔离级别; SERIALIZABLE(可串行化)SERIALIZABLE是最高的隔离级别, 他通过强制事务串行执行, 避免了前面说的幻读的问题;简单来说, SERIALIZABLE 会在读取的每一行数据上都加锁, 所以可能导致大量的超时和锁争用的问题, 实际应用中也很少用到这个隔离级别, 只有在非常需要保障数据一致性而且可以接受没有并发的情况下, 才考虑采用该级别; 小结当然, 上面描述的通过事务的隔离级别所解决的问题, 首先都需要放在事务中!","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/tags/MySQL/"}]},{"title":"BTree,B-Tree,B+Tree","slug":"2016-08-03-btree-03","date":"2016-08-02T11:11:12.000Z","updated":"2017-12-19T13:53:27.000Z","comments":true,"path":"2016/08/02/2016-08-03-btree-03/","link":"","permalink":"http://blog.renyimin.com/2016/08/02/2016-08-03-btree-03/","excerpt":"","text":"树的定义 树(Tree)是n(n&gt;=0)个结点的有限集, n=0时称为空树; 在任意一棵非空树中: 有且仅有一个特定的称为根(Root)的结点; 当n&gt;=1时, 其余结点可以分为m(m&gt;0)个互不相交的有限集T1,T2,T3,….Tm, 其中每一个集合本身又是一棵树,并且称为根的子树(SubTree); 如下图所示: 子树T1和子树T2就是根结点A的子树, 当然, D,G,H,I组成的树又是B为根节点的子树; E,J组成的树是以C为根结点的子树; 子树一定是互不相交的, 如下就不符合树的定义, 因为他们都有相交的子树: 常见概念 树的结点包含一个数据元素 和 若干指向其子树的分支; 结点拥有的子树数量称为结点的度(De-gree); (结点拥有的子树其实和结点拥有的子结点是一个意思) 度为0的结点称为叶结点(Leaf)或终端结点; 度不为0的结点称为非终端结点 或 分支结点; 除了根结点之外, 分支结点也称为内部结点; 树的度是树内各结点的度的最大值, 如下图, 因为这棵树结点的度的最大值是结点D的度, 为3, 所以树的度也为3: 结点间的关系 结点的子树的根称为该结点的孩子(Child), 相应的, 该结点称为孩子的双亲(Parent)(父母同体,只有一个, 所以称为双亲); 同一个双亲的孩子之间互称兄弟(Sibling); 结点的祖先是从根到该结点所经历分支上的所有结点, 所以对于H来说, D,B,A都是它的祖先; 反之, 以某结点为根的子树中的任一结点都称为该结点的子孙, B的子孙有D,G,H,I; 如下图: 树其他相关概念 结点的层次(Level)从根开始定义起, 根为第一层, 根的孩子为第二层; 若某结点在第l层, 则其子树的根就在第l+1层; 双亲为同一结点的结点互为兄弟, B,C是兄弟, E,F也是兄弟; 双亲在同一层的结点互为堂兄弟, D,E,F是堂兄弟, G,H,I,J也是; 树中结点的最大层次称为树的深度(Depth)或高度, 当前树的深度为4; 如下图: 如果将树中结点的各子树看成从左至右是有次序的, 不能互换的, 则称该树为有序树, 否则称为无序树; 对比线性表和树的结构, 有很大区别: 树的存储结构1.2.3. BTree (二叉搜索树)基础概念先看一个满二叉树: 1.结点: 指二叉树中一个个的点, 像上图中的 1，2，3，4，5，6，7 - 根结点: 根结点(root)比较好理解, 它是树的一个组成部分, 也叫树根, 所有非空的二叉树中, 都有且仅有一个根结点。它是同一棵树中除本身外所有结点的祖先, 没有父结点; - 叶子结点: 一棵树当中没有子结点(即度为0)的结点称为叶子结点, 简称&quot;叶子&quot;, 叶子是指度为0的结点, 又称为终端结点; 2.度: 指父结点下面有几个孩子结点, 如上图中: - 针对结点2, 它下面有两个孩子4、5，所以说结点2的度为2; - 针对结点4，他下面一个孩子都没有, 所以说结点4的度为0; 前序: 根结点第一个访问, 然后访问左、右孩子; 上图中, 1245367 这种序列就是前序序列 中序: 根结点第二个访问, 最先访问左孩子, 最后访问右孩子; 上图中, 4251637 这种序列就是中序序列 后序: 根结点最后访问, 开始先访问左、右孩子; 上图中, 4526731 这种序列就是后序序列 https://www.cnblogs.com/polly333/p/4740355.html 二叉树: 二叉树是树的特殊一种, 具有如下特点: 每个结点最多有两棵子树, 结点的度最大为2 所有非叶子结点至多拥有两个儿子 (Left和Right) 所有结点存储一个关键字 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.renyimin.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.renyimin.com/tags/数据结构/"}]},{"title":"《高性能mysql》 -- 第五章 创建高性能索引","slug":"2016-08-02-mysql_index-01","date":"2016-08-02T11:11:12.000Z","updated":"2017-12-26T01:49:39.000Z","comments":true,"path":"2016/08/02/2016-08-02-mysql_index-01/","link":"","permalink":"http://blog.renyimin.com/2016/08/02/2016-08-02-mysql_index-01/","excerpt":"","text":"相关笔记补充 如何确定一个查询有没有走索引, 走了哪些索引？ MySQL中自带命令行工具 explain 来查看一个sql语句是否了索引, 使用方式：explain select * from tb_test;; 结果字段 结果字段分析 id: 这是SELECT的查询序列号; select_type: select的类型, 可以有以下几种: 12345678SIMPLE：简单SELECT(不使用UNION或子查询等)PRIMARY：最外面的SELECTUNION：UNION中的第二个或后面的SELECT语句DEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询UNION RESULT：UNION的结果。SUBQUERY：子查询中的第一个SELECTDEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询DERIVED：导出表的SELECT(FROM子句的子查询) table: 显示这一行的数据是关于哪张表的 type: 这列很重要,显示了连接使用了哪种类别,有无使用索引, 是使用Explain命令分析性能瓶颈的关键项之一; 结果值从好到坏依次是: system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 一般来说，得保证查询至少达到range级别, 最好能达到ref, 否则就可能会出现性能问题;1234567891011system : 表仅有一行(=系统表)。这是 const 连接类型的一个特例。const : const 用于用常数值比较 PRIMARY KEY 时。当查询的表仅有一行时, 使用 System。eq_ref const 用于用常数值比较 PRIMARY KEY 时。当 查询的表仅有一行时,使用 System。ref : 连接不能基于关键字选择单个行,可能查找到多个符合条件的行。叫做 ref 是因为索引要跟某个参考值相比较。这个参考值或者是一个常数,或者是来自一个表里的多表查询的结果值。ref_or_null 如同 ref, 但是 MySQL 必须在初次查找的结果 里找出 null 条目,然后进行二次查找。index_merge 说明索引合并优化被使用了。unique_subquery: 在某些 IN 查询中使用此种类型,而不是常规的 ref:value IN (SELECT primary_key FROM single_table WHERE some_expr)index_subquery: 在某些IN查 询 中 使 用 此 种 类 型 , 与 unique_subquery 类似,但是查询的是非唯一性索引: value IN (SELECT key_column FROM single_table WHERE some_expr)range: 只检索给定范围的行,使用一个索引来选择 行。key 列显示使用了哪个索引。当使用=、 &lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN 或者 IN 操作符,用常量比较关键字列时,可 以使用 range。index: 全表扫描,只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序, 但是开销仍然非常大。all: 最坏的情况,从头到尾全表扫描。 possible_keys: 指出 MySQL 能在该表中使用哪些索引有助于查询。如果为空,说明没有可用的索引; key: MySQL 实际从 possible_key 选择使用的索引, 如果为 NULL, 则没有使用索引。 很少的情况下,MYSQL会选择优化不足的索引, 这种情况下,可以在 SELECT 语句中使用 USE INDEX (indexname)来强制使用一个索引或者用 IGNORE INDEX(indexname)来强制 MYSQL 忽略索引; key_len: 显示MySQL决定使用的键长度。如果键是NULL, 则长度为NULL。使用的索引的长度, 在不损失精确性的情况下, 长度越短越好; ref: 显示使用哪个列或常数, 与key一起从表中选择行; rows: 显示MySQL认为它执行查询时必须检查的行数; (查询逻辑扫描过的记录行数) Extra: 包含MySQL解决查询的详细信息，也是关键参考项之一; 123456789101112131415Distinct: 一旦MYSQL找到了与行相联合匹配的行,就不再搜索了Not exists: MYSQL 优化了LEFT JOIN, 一旦它找到了匹配LEFT JOIN标准的行,就不再搜索了Range checked for eachRecord（index map:#）没有找到理想的索引, 因此对于从前面表中来的每一个行组合, MYSQL检查使用哪个索引, 并用它来从表中返回行, 这是使用索引的最慢的连接之一Using filesort: 看到这个的时候, 查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候Using temporary: 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上Using where: 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index， 这就会发生，或者是查询有问题 其他一些Tip: 当type显示为 index 时, 并且Extra显示为 Using Index, 表明使用了覆盖索引; 额外参考:https://www.cnblogs.com/clphp/p/5403215.htmlhttp://www.cnblogs.com/chenshishuo/p/5030029.htmlhttps://www.cnblogs.com/xuan52rock/p/4551192.htmlhttp://blog.csdn.net/xluren/article/details/32746183https://tech.meituan.com/mysql-index.html","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/tags/MySQL/"}]},{"title":"04 - 授权码模式各阶段参数分析","slug":"2016-05-25-OAuth-04","date":"2016-05-25T12:10:12.000Z","updated":"2017-10-25T08:44:37.000Z","comments":true,"path":"2016/05/25/2016-05-25-OAuth-04/","link":"","permalink":"http://blog.renyimin.com/2016/05/25/2016-05-25-OAuth-04/","excerpt":"","text":"第一阶段: 第三方站点将导向授权页 第三方应用将用户导向授权页时, 传递的参数如下: response_type: 表示授权类型, 必选项, 此处由于采用的是授权码模式, 所以值固定为 “code” client_id/AppID: 表示客户端的ID, 必选项由于你可能会有多个站点需要对接OAuth授权服务器, 所以一般在授权服务平台登录之后, 是可以创建多个 应用 的 (不同的站点对接授权服务器中不同的应用);每个应用对应你的一个 第三方站点, 开放平台会为每个应用(第三方站点)生成相应的 AppID 和 AppSecret/AppKey, 主要用来验证应用的合法性; redirect_uri: 设定的重定向到第三方站点URI, 必选项 scope: 表示申请的权限范围, 可选项 state: 表示客户端的当前状态, 可以指定任意值, 认证服务器会原封不动地返回这个值 下面是各开放平台的参数对比: 新浪 QQ 微信 GitHub 蚂蚁金服 简单测试: redirect_uri在OAuth服务器中为第三方站点创建 应用 的时候, 设定的回调地址, 无论在认证服务器, 还是在第三方站点, 都会对其进行校验, 以防篡改; 新浪授权传递错误 redirect_uri 简书qq授权传递错误 redirect_uri state第三方站点会对state做校验给了一个新的弹框用来进行授权, 但是如果恶意用户复制出弹框中的url, 之后再修改state并刷新页面, 授权后发现: 从上面各平台也可以看到, 返回参数相对比较简单; 返回的code是和授权页登录的用户身份相关的; (后面的access_token也是通过code和用户身份关联起来的) 第二阶段: 通过Authorization Code获取Access Token 如果第三方站点的用户在第一阶段的授权页中选择对第三方站点授权, 那么就第三方站点就会收到授权服务器的Authorization Code, 进而进入本阶段;(每个用户在授权后, 第三方站点都需要到授权服务器上为用户获取一个access_token, 这个access_token就是以后第三方站点从授权服务器上获取用户信息的凭证了, 一般在获取到access_token令牌之后, 可以存储到session中) 本阶段, 我们在自己的第三方站点中就可以使用第一阶段的Authorization Code获取Access Token: 微信 qq 基本上入参就像QQ互联那样大概有5个 (需要对每个参数进行了解); 本阶段的返回参数比较有讲究, 一般为如下三个 access_token 授权令牌access_token一般在获取到之后, 第三方站点可以将其 保存到用户的session中 , 第三方站点之后要获取用户在授权服务器上的资源的时候, 就需要带上当前session中用户的access_token去获取; expires_in 该access token的有效期,单位为秒 (微信公众平台access_token有效期为2小时, qq互联平台为3个月 可以作为参考)设置access_token有效期也是为了定期修改access_token, 以提高安全性;(并且微信对获取access_token这个基础API是有限制的，每天最多请求2000次, 因为有效期为2小时, 每天2000次也足够了;) refresh_token 授权自动续期时使用 (微信公众平台refresh_token有效期为30天, qq互联平台具体不详, 可以作为参考) (可选)权限自动续期问题 注意微信公众平台: 1.若access_token已超时，那么进行refresh_token会获取一个新的access_token，新的超时时间, 并且一旦使用refresh_token来刷新access_token的话, refresh_token的过期时间也会更新(自动延期) ; 2.若access_token未超时，那么进行refresh_token不会改变access_token，但超时时间会刷新，相当于续期access_token ; 这里说的超时时间刷新, 指的自然是第三方站点和授权服务器上的超时时间都要更新了(只不过你如果只是做对接的话, 授权服务器这部分人家已经开发好了, 如果你是授权服务器也是自己开发的话, 那你就需要注意这里了) 其实第三方站点在受到授权服务器分配给当前用户的access_token之后, 假设说授权服务器返回access_token的过期时间为7200s(2小时), 那么第三方站点将access_token保存到用户session中, 并设置过期时间为6600s(中间可以有个10分钟的服务器时间差); 如果第三方站点在使用access_token为用户获取授权服务器中的资源时, 发现session中的access_token并没有过期, 那么请求后就需要为access_token续期(第三方站点和授权服务器上都要做续期) 如果第三方站点在使用access_token为用户获取授权服务器中的资源时, 发现session中的access_token过期, 则就需要使用refresh_token调用生成access_token的api接口重新生成access_token来进行续期； qq: 这样下来, 基本上第三方站点只有在大于refresh_token的过期时间都没有调用过授权服务器的话, 才需要用户重新登录; 第三阶段(比较简单): 第三方站点通过access_token获取授权平台资源服务器上的用户资源 获取access_token后，进行接口调用，有以下前提： access_token有效且未超时； 微信用户已授权给第三方应用帐号相应接口作用域(scope);也就是在授权服务器上还会使用access_token去检测对应的scope权限是否正确; 许多开放平台在申请完access_token令牌之后, 都提供了对应接口来获取用户相关信息QQ互联提供了相应的接口, 使用Access Token来获取用户的OpenID;新浪开放平台提供了相应的接口来获取access_token对应的用户信息;而微信公众平台: 在获取access_token的时候, 会同时返回openid表示微信用户在本公众号中的唯一标识;","categories":[{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/categories/后端架构/"},{"name":"OAuth2.0","slug":"后端架构/OAuth2-0","permalink":"http://blog.renyimin.com/categories/后端架构/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"},{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/tags/后端架构/"}]},{"title":"03 - OAuth2.0的CSRF攻击","slug":"2016-05-24-OAuth-03","date":"2016-05-24T11:27:36.000Z","updated":"2017-10-25T08:01:49.000Z","comments":true,"path":"2016/05/24/2016-05-24-OAuth-03/","link":"","permalink":"http://blog.renyimin.com/2016/05/24/2016-05-24-OAuth-03/","excerpt":"","text":"假设有如下几个角色:受害者 lant ;攻击者 rymuscle ;第三方Web应用 liangren网 (它允许用户将其在 sandiruiqi网 的账号 和 liangren网 的账号进行绑定) ;OAuth2服务提供平台 sandiruiqi网 ; 攻击流程 攻击者rymuscle 登录 liangren网 并且选择使用自己的 sandiruiqi网 账号登录 ; liangren网 将 攻击者rymuscle 重定向到 sandiruiqi网 的授权页(这时可能需要 攻击者rymuscle 登录过sandiruiqi网), sandiruiqi网 的授权页向 攻击者rymuscle 显示 “是否授权liangren网访问” ; 攻击者rymuscle 在点击”同意授权”之后, 截获 sandiruiqi网 服务器返回的含有 Authorization Code 参数的HTTP响应 ; 然后 攻击者rymuscle 精心构造一个Web页面, 它会触发 liangren网 向 sandiruiqi网 发起令牌申请的请求, 而这个请求中的Authorization Code参数正是上一步 攻击者rymuscle 截获到的code ; 攻击者rymuscle 将这个Web页面放到互联网上, 等待或者诱骗受害者来访问 ; 假设正好一个受害者 lant 访问了 攻击者rymuscle 准备的这个Web页面后, 令牌申请流程在 受害者lant 的浏览器里被顺利触发, laingren网 从 sandiruiqi网 那里获取到access_token, 但是这个token以及通过它进一步获取到的用户信息却都是攻击者 攻击者rymuscle 的 ; 也就是最终 liangren网 将 攻击者rymuscle 的 sandiruiqi 账号同 lant 的 liangren网 账号关联了起来 从此以后, lant只要没有察觉到自己最初被悄悄使用了 攻击者rymuscle 的sandiruiqi网 账号登录, 那么他在 liangren网 上的所有资料, 都可以被 攻击者rymuscle 所看到, 并且 攻击者rymuscle 可能在 lant 的账号中做一些非法操作; 整体时序图分析 先看标准oauth时序图 下面是从网上copy的一张图, 从整体上来看, 这次攻击的时序图类似下图: 可以看到, 攻击的关键点在于:OAuth2的认证流程是分为好几步来完成的, 在标准oauth图的第3步, 第三方应用在收到一个GET请求时, 除了能知道当前用户的cookie, 以及URL中的Authorization Code之外, 难以分辨出这个请求到底是用户本人的意愿, 还是攻击者利用用户的身份伪造出来的请求; 于是乎, 攻击者就能使用移花接木的手段, 提前准备一个含有自己的Authorization Code的请求, 并让受害者的浏览器来接着完成后续的令牌申请流程 ; 难点(涉及到了非state参数防御): 尽管这个攻击既巧妙又隐蔽, 但是要成功进行这样的CSRF攻击也是比较困难的 : 整个攻击必须在短时间内完成, 因为OAuth2提供者颁发的Authorization Code有效期很短, OAuth2官方推荐的时间是不大于10分钟, 而一旦Authorization Code过期那么后续的攻击也就不能进行下去了; 一个Authorization Code只能被使用一次, 如果OAuth2提供者收到重复的Authorization Code, 它会拒绝当前的令牌申请请求, 不止如此, 根据OAuth2官方推荐, 它还可以把和这个已经使用过的Authorization Code相关联的access_token全部撤销掉, 进一步降低安全风险; 其实貌似只要做到Authorization Code只能被使用一次, 就可以防止csrf在此处的攻击了, 因为 rymuscle 在攻击的时候, 一旦获得 Authorization Code, 第三方站点服务器就会使用 Authorization Code 去申请access_token, 然后只要标记 Authorization Code 为已经使用, 那么 受害者lant 即使点击 攻击者rymuscle 构造好的链接也没用, 因为连接中的 Authorization Code 已经被标记为使用过了; 所以不一定非要使用下面的state参数来进行防御比如微信公众平台的OAuth授权: state参数就是可选的新浪开放平台的OAuth授权, state参数也是可选的当然, 他们不一定做的是和此处一样的防御方案, 但明显不依赖于state参数来解决问题; state参数防御: 要防止这样的攻击其实很容易, 作为第三方应用的开发者, 只需在OAuth认证过程中加入 state 参数, 并验证它的参数值即可; 在将用户重定向到OAuth2的Authorization Endpoint去的时候, 为用户生成一个随机的字符串, 并作为state参数加入到URL中 ; 在收到OAuth2服务提供者返回的Authorization Code请求的时候, 验证接收到的state参数值, 如果是正确合法的请求, 那么此时接受到的参数值应该和上一步提到的为该用户生成的state参数值完全一致, 否则就是异常请求; 但需要注意 state参数 需要具备下面几个特性: 不可预测性: 足够的随机, 使得攻击者难以猜到正确的参数值 ;如果你每次生成的state都被放在一起, 比如一个库/缓存中存在很多state;那么问题就是攻击者还是可以拿着自己的code再加上一个state, 来构造一个链接欺骗用户来点击;(假设state正好就在你的库/缓存中); 重点是关联性: state参数值可以和当前用户会话(user session)相互关联的所以应该让state和具体的用户关联起来, 虽然用户还没有登录, 但是也可以让state放到session中 ;然后攻击者要猜测出来一个state的话, 即便是已经生成过了, 但是也得正好攻击的是这个用户; 唯一性: 每个用户每次请求生成的state参数值都是唯一的 ; 时效性: state参数一旦被使用则立即失效 ; 参考 蚂蚁金服开放平台: 其实可以结合以上各种方法一起来进行防御! 参考 移花接木参考 state参数漏洞参考 阮一峰","categories":[{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/categories/后端架构/"},{"name":"OAuth2.0","slug":"后端架构/OAuth2-0","permalink":"http://blog.renyimin.com/categories/后端架构/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"},{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/tags/后端架构/"}]},{"title":"02 - 授权码模式","slug":"2016-05-22-OAuth-02","date":"2016-05-22T12:27:36.000Z","updated":"2017-10-25T08:33:40.000Z","comments":true,"path":"2016/05/22/2016-05-22-OAuth-02/","link":"","permalink":"http://blog.renyimin.com/2016/05/22/2016-05-22-OAuth-02/","excerpt":"","text":"授权码模式运行过程 运行图 运行过程分析1.向用户取得授权许可对应图中的第1、2、3步; 2.申请访问令牌access_token令牌的申请对应图中的第4、5步; 3.使用令牌获取用户数据开放平台在申请完access_token令牌之后, 都提供了对应接口来获取用户相关信息, 比如:QQ互联: 提供了相应的接口, 使用Access Token来获取用户的OpenID;新浪开放平台: 提供了相应的接口来获取access_token对应的用户信息;而微信公众平台: 在获取access_token的时候, 会同时返回openid表示微信用户在本公众号中的唯一标识; 这一过程中涉及了不少敏感参数和数据, 例如client_secret相当于是第三方应用自己的密码, access_token某种程度上来讲就是用户的session id, 由于这些参数以及数据极其特殊, 我们当然得确保它们的安全性, HTTPS加密传输以及安全存储是必不可少的防护手段, 不过仅仅做到这些是远远不够的, 因为其实在这个流程里存在一个弱点， 容易被攻击者利用进行CSRF攻击, 下一篇笔记将会详细分析 ;","categories":[{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/categories/后端架构/"},{"name":"OAuth2.0","slug":"后端架构/OAuth2-0","permalink":"http://blog.renyimin.com/categories/后端架构/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"},{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/tags/后端架构/"}]},{"title":"01 - OAuth(Open Authorization)开放式授权协议","slug":"2016-05-19-OAuth-01","date":"2016-05-19T03:05:00.000Z","updated":"2017-10-27T02:19:29.000Z","comments":true,"path":"2016/05/19/2016-05-19-OAuth-01/","link":"","permalink":"http://blog.renyimin.com/2016/05/19/2016-05-19-OAuth-01/","excerpt":"","text":"OAuth是一个关于授权(authorization)的开放网络标准, 目前的版本是2.0版 OAuth之前的传统”授权”比较 简单, 直接, 暴力, 一般是直接提供自己资源服务器的账号和密码给第三方站点, 要知道这种做的法弊端太多: 12345678910111.如果用户在每个第三方站点都这样做, 那将会存在严重安全隐患:很多第三方网站为了后续的服务, 会保存用户资源服务器的账号和密码, 这样很不安全, 因为难免有些第三方平台会由于自己的安全问题而导致用户的账号和密码泄露, 从而导致用户大量信息泄露 ;2.用户无法设定第三方站点的权利范围:第三方网站拥有了获取用户某个资源服务器的账号和密码后, 就拥有了资源服务器上的所有的资料, 用户没法限制第三方站点获取资源服务器上资源的权利范围和有效期 ;3.用户想收回第三方站点的权利不太方便:用户只有修改密码, 才能收回赋予第三方网站的权力, 否则第三方网站将会永久拥有用户资源服务器上资源的权利，但是这样做, 又会使得其他所有获得用户授权的第三方应用程序全部失效 ;或者, 一些良心第三方可以设置 用户账号 和 资源服务器账号的绑定和解绑, 但不一定所有第三方都会给你做, 如果不做解绑的话, 你还真就只有前一种方法能够收回权利 ; 而OAuth的授权不会让 第三方站点 触及到用户在 资源服务器 上的帐号信息(如用户名与密码), 即第三方站点无需使用用户资源服务器上的账号与密码, 就可以获得该用户在 资源服务器 上的资源, 因此 OAuth 是安全的 ; OAuth2.0协议定义了用于获得授权的”四种主要授权类型”1.授权码(Authorization code)模式 授权码模式是功能最完整、流程最严密的授权模式(标准的Server授权模式, 非常适合Server端的Web应用); 它的特点是: 通过客户端的后台服务器, 与&quot;服务提供商&quot;的认证服务器进行互动; 运行流程图解 123456用户打开客户端以后，客户端要求用户给予授权。用户同意给予客户端授权。客户端使用上一步获得的授权，向认证服务器申请令牌。认证服务器对客户端进行认证以后，确认无误，同意发放令牌。客户端使用令牌，向资源服务器申请获取资源。资源服务器确认令牌无误，同意向客户端开放资源 场景: 比如公司需要对接 QQ, 微博, 微信(网页授权) 等登录授权; 或者公司达到可以做自己对外的开放平台; 当然, 公司如果要做对外开放平台, 可能不止使用这一种模式: 像微信网页授权使用的就是`授权码模式`； 但是微信的基础功能接口和开发者服务器交互的时候, 就使用到了`客户端模式`； 而微信服务器涉及到和开发者服务器进行消息交互的时候, 还使用了类似`JWT`的签名校验来保证数据传输的安全; 2.隐式授权模式(Implicit Grant) 也叫简化模式, 该模式不通过第三方应用程序的服务器, 而是直接在浏览器中向认证服务器申请令牌, 跳过了”授权码”这个步骤, 因此得名; 它的特点是: 所有步骤在浏览器中完成, 令牌对访问者是可见的; 流程图: 场景: 3.密码模式(Resource Owner Password Credentials) 用户向客户端提供自己的用户名和密码, 客户端使用这些信息，向”服务商提供商”索要授权 ; 这种模式要求用户提供用户名和密码来交换访问令牌access_token ; 它的特点是:客户端仍然是以单个用户的名义向”服务提供商”进行认证;在这种模式中, 用户必须把自己的密码给客户端, 但是客户端不得储存密码, 这通常用在 用户对客户端高度信任的情况下, 比如客户端也是系统的一部分; 流程图: 下图也可参考: 场景:比如当third party application、authorization server、resource owner都是自己公司内的系统, Resource owner对third party application足够信任，所以我们就能采取这种模式来实现;就像: 公司如果有多套内部后台系统, 开发人员和公司管理员可能就要准备多套账号, 比较麻烦, 为了解决这个问题, 可以做一个账号中心系统, 用户在登录各个系统后台的时候, 会先跳转到用户中心进行登录, 一旦登录成功之后, 就会给用户分发一个access_token, 用来在各个系统间作为登录认证 (这也实现了SSO单点登录);(参考: http://www.cnblogs.com/richieyang/p/4918819.html) 4.客户端模式(Client Credentials) 客户端模式指客户端以客户端自己的名义, 而不是以单个用户的名义，向”服务提供商”进行认证;严格地说, 客户端模式并不属于OAuth框架所要解决的问题; 流程图: 服务器 不提供像用户数据这样的重要资源，仅仅是一些开放的功能性API;例如微信公众平台, Google Storage或Amazon S3 等开放平台提供的基础服务接口; 场景:1.你自己实现了一套基础服务的Api(都是些基础功能接口, 并不涉及用户数据这种重要资源), 提供给内部其他系统通过认证的方式来调用;2.公司如果实力强悍的话, 也可以将公司开发的基础服务Api公开出来 供外部其他第三方站点服务器 来调用, 比如: 微信公众平台的开放接口其实就是使用这种方式(但微信的网页授权采用的就是授权码模式): 客户端模式(Client Credentials) 和 用户密码模式 有时候比较容易混淆1.客户端模式: 如果客户端以自己的身份向服务提供商进行认证, 那需要授权中心给各个应用(不管是内部系统还是第三方站点服务器)分配对应的AppID和AppSecret, 然后第三方应用使用这两个信息来向”认证服务器”申请access_token, 这种场景下, 认证服务器一般提供的接口都是功能性的基础服务接口;2.用户密码模式: 如果客户端以单个用户身份向服务提供商进行认证, 只要用户账号密码能通过认证服务器, 认证服务器就会发放access_token, 当然这种场景需要的是几方角色都属于本公司内部; 当然这里所聊的是授权相关的知识, 并没有涉及数据传输的加密及签名校验, 但其实像微信公众平台这样开放平台, 除了基础服务接口供给开发者服务器调用时不需要做数据传输的加密和签名校验; 当微信服务器和开发者服务器涉及到用户消息数据的收发时, 会推荐对数据进行加密和签名校验; 参考: http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html参考: http://www.cnblogs.com/richieyang/p/4918819.html参考: http://www.dannysite.com/blog/176/","categories":[{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/categories/后端架构/"},{"name":"OAuth2.0","slug":"后端架构/OAuth2-0","permalink":"http://blog.renyimin.com/categories/后端架构/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"},{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/tags/后端架构/"}]}]}