{"meta":{"title":"Lant's Blog","subtitle":null,"description":null,"author":"Lant","url":"http://blog.renyimin.com"},"pages":[{"title":"分类","date":"2017-09-17T02:40:28.000Z","updated":"2017-09-18T09:08:09.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.renyimin.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-09-17T02:40:21.000Z","updated":"2017-09-18T09:08:03.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.renyimin.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Laravel-install-01","slug":"Laravel-install-01","date":"2016-04-15T08:34:13.000Z","updated":"2017-09-19T04:52:28.000Z","comments":true,"path":"2016/04/15/Laravel-install-01/","link":"","permalink":"http://blog.renyimin.com/2016/04/15/Laravel-install-01/","excerpt":"","text":"通过Composer下载安装可以在终端中通过Composer的==create-project==命令来创建一个新的Laravel项目:123composer create-project laravel/laravel [项目目录名] [项目版本号] --prefer-dist如果不写laravel下载下来后放置项目的目录名, 则默认为laravel; 1234567比如要下载Laravel的LTS版本(目前是Laravel5.1), 操作如下:composer create-project laravel/laravel vip 5.1.33 --prefer-dist或者composer create-project laravel/laravel vip 5.1.* --prefer-dist 应用Key的设置如果你是通过Composer或者Laravel安装器安装的话, 该key的值已经通过key:generate命令生成好了; (通常, 该字符串应该是32位长, 该key被配置在.env环境文件中(APP_KEY), 如果你还没有将.env.example文件重命名为.env, 现在立即这样做;如果应用key没有被设置, 用户sessions和其它加密数据将会有安全隐患!) 如果你不是通过composer安装的laravel, 生成key的方式如下:1先创建一个.env文件 12345然后生成应用key:bogon:laravel renyimin$ php artisan key:generateApplication key [7a7rsPOdMubimWYQRddpxEiTRuoQMScE] set successfully.bogon:laravel renyimin$ 你如果是使用Composer安装的话, 可以看到: image.png image.png nginx的设置:1$uri $uri/ /index.php?$query_string image.png 1项目根目录配置到: 项目目录的 public 目录下; 安装成功: image.png","categories":[{"name":"PHP框架","slug":"PHP框架","permalink":"http://blog.renyimin.com/categories/PHP框架/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.renyimin.com/tags/Laravel/"}]},{"title":"Authuorization Code CSRF","slug":"OAuth-auth-code-CSRF","date":"2016-03-20T14:03:21.000Z","updated":"2017-09-20T06:25:11.000Z","comments":true,"path":"2016/03/20/OAuth-auth-code-CSRF/","link":"","permalink":"http://blog.renyimin.com/2016/03/20/OAuth-auth-code-CSRF/","excerpt":"","text":"针对OAuth2的CSRF攻击让我们来看一个针对OAuth2的CSRF攻击的例子: 假设有用户 张三, 和 攻击者 李四, 还有一个第三方Web应用 Third Web, 它集成了第三方社交账号登录并且允许用户将社交账号和Lant中的账号进行绑定, 此外还有一个OAuth2服务提供平台 `` ; 攻击流程 攻击者李四登录Third Web网站并且选择绑定自己的GitHub账号; Third Web网站将李四重定向到Github, 由于他之前已经登录过Github, 所以Github直接向他显示 “是否授权Tonr访问” 的页面; 李四在点击”同意授权”之后, 截获Github服务器返回的含有Authorization Code参数的HTTP响应; 李四精心构造一个Web页面, 它会触发Third Web网站向Github发起令牌申请的请求, 而这个请求中的Authorization Code参数正是上一步截获到的code; 李四将这个Web页面放到互联网上, 等待或者诱骗受害者张三来访问; 张三之前登录了Third Web网站, 只是没有把自己的账号和其他社交账号绑定起来; 在张三访问了李四准备的这个Web页面后, 令牌申请流程在张三的浏览器里被顺利触发, Third Web网站从Github那里获取到access_token, 但是这个token以及通过它进一步获取到的用户信息却都是攻击者李四的; Third Web网站将李四的Github账号同张三的Third Web账号关联绑定起来, 从此以后, 李四就可以用自己的Github账号通过OAuth登录到张三在Tonr网站中的账号, 堂而皇之的冒充张三的身份执行各种操作; 这一切发生得太快, 可能你还没看清楚李四怎么就登录到张三的账号里去了, 下面让我们从几个不同的角度来看看这当中发生了什么？ 下面从不同角色的视角来分析这个漏洞受害者张三(Resource Owner)视角受害者张三访问了一个Web页面, 然后, 就没有然后了, 他在Third Web网站上的账号就和攻击者李四在GitHub上的账号绑定到了一起, 伪造的请求是经过精心构造的, 令牌申请这一过程在张三的浏览器里是非常隐蔽的被触发的, 换句话讲就是, 他根本不知道这背后发生了什么; Third Web网站(Client)视角从 Third Web 网站来看, 它收到的所有请求看上去都是正常的, 比如客户端在申请令牌的时候, 它收到了一个HTTP请求, 其代表着当前用户张三在 GitHub 网站上已经做了”同意授权”操作, 其内容如下:1GET /bindingCallback?code=AUTHORIZATION_CODE 不过需要注意的是, URL里的code不是当前受害者张三的Authorization Code, 而是攻击者李四的; 当 Third Web 收到这样的请求时, 它以为张三已经同意授权(但实际上这个请求是李四伪造的), 于是就发起后续的令牌申请请求, 用收到的Authorization Code向在 GitHub 换取access_token, 只不过最后拿到的是攻击者李四的 access_token; 最后, Third Web 网站把攻击者李四的access_token和当前受害者张三在 Third Web 网站上的账号进行关联绑定; GitHub网站(OAuth2服务提供者)视角GitHub网站也是一脸茫然的样子, 因为在它看来, 自己收到的授权请求以及后续的令牌申请请求都是正常的, 或者说它无法得知接收到的这些请求之间的关联关系, 而且也无法区别出这些请求到底是来自张三本人, 还是由李四伪造出来的; 因此只要自己收到的参数是正确有效的, 那就提供正常的认证服务, 仅此而已; 攻击者李四视角李四伪造了一个用户授权成功的请求, 并且将其中的Authorization Code参数替换成了自己提前获取到的code, 这样, 当受害者张三的浏览器被欺骗从而发起令牌申请请求时, 实际上是在用张三在 Third Web 网站上的账号和李四在 GitHub 网站上的账号做绑定; 攻击完成后, 李四在 Third Web 网站上可以通过自己在 GitHub 网站的账号进行登录, 而且登录进入的是张三在 Third Web 网站上的账号, 而张三通过自己在 Third Web 网站上的账号登录进去之后, 看到的是李四在 GitHub 网站上的部分账户信息; 上帝视角从整体上来看,这次攻击的时序图应该是下面这个样子的 image.png 分析漏洞回顾图1 图1 分析漏洞的本质这个问题的关键点在于, OAuth2的认证流程是分为好几步来完成的, 在的图1中的第4步, 第三方应用在收到一个GET请求时, 除了能知道当前用户的cookie, 以及URL中的Authorization Code之外, 难以分辨出这个请求到底是用户本人的意愿, 还是攻击者利用用户的身份伪造出来的请求; 于是乎, 攻击者就能使用移花接木的手段, 提前准备一个含有自己的Authorization Code的请求, 并让受害者的浏览器来接着完成后续的令牌申请流程; 漏洞被攻击者使用还需要具备的前提条件尽管这个攻击既巧妙又隐蔽, 但是要成功进行这样的CSRF攻击也是需要满足一定前提条件的: 首先, 在攻击过程中, 受害者张三在 Third Web 网站上的用户会话(User Session)必须是有效的, 也就是说, 张三在受到攻击前已经登录了 Third Web 网站; 其次, 整个攻击必须在短时间内完成, 因为OAuth2提供者颁发的Authorization Code有效期很短, OAuth2官方推荐的时间是不大于10分钟, 而一旦Authorization Code过期那么后续的攻击也就不能进行下去了; 最后, 一个Authorization Code只能被使用一次, 如果OAuth2提供者收到重复的Authorization Code, 它会拒绝当前的令牌申请请求, 不止如此, 根据OAuth2官方推荐, 它还可以把和这个已经使用过的Authorization Code相关联的access_token全部撤销掉, 进一步降低安全风险; 防御办法要防止这样的攻击其实很容易, 作为第三方应用的开发者, 只需在OAuth认证过程中加入state参数, 并验证它的参数值即可; 具体细节如下: 在将用户重定向到OAuth2的Authorization Endpoint去的时候, 为用户生成一个随机的字符串, 并作为state参数加入到URL中; 在收到OAuth2服务提供者返回的Authorization Code请求的时候, 验证接收到的state参数值, 如果是正确合法的请求, 那么此时接受到的参数值应该和上一步提到的为该用户生成的state参数值完全一致, 否则就是异常请求; state参数值需要具备下面几个特性:1234567不可预测性: 足够的随机, 使得攻击者难以猜到正确的参数值;关联性: state参数值和当前用户会话(user session) 是相互关联的;唯一性: 每个用户, 甚至每次请求生成的state参数值都是唯一的;时效性: state参数一旦被使用则立即失效; 摘自 参考 state参数漏洞","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"Authuorization Code","slug":"OAuth-authorization-code","date":"2016-03-19T12:27:36.000Z","updated":"2017-09-21T14:42:12.000Z","comments":true,"path":"2016/03/19/OAuth-authorization-code/","link":"","permalink":"http://blog.renyimin.com/2016/03/19/OAuth-authorization-code/","excerpt":"","text":"授权码模式简介授权码模式(authorization code)是功能最完整、流程最严密的授权模式, 它的特点就是通过 客户端的后台服务器 与 &quot;服务提供商&quot;的认证服务器 进行互动 ; 授权码模式运行过程运行图 authorization_code 运行步骤1.用户(RO)通过浏览器(UA)在客户端(Client)中触发操作(比方说新浪微博登录/QQ登录), Client之后将用户导向认证服务器的授权页面; weixin qq 2.假设用户在授权页面给予客户端授权(authorization grant), 认证服务器会生成一个授权码code, 并带着这个code重新导向客户端配置并传递的 redirect_url ; 3.客户端的回调接口收到授权码, 然后在客户端的服务器中使用授权码去直接向认证服务器申请令牌 ; 4.认证服务器对客户端进行认证以后, 确认无误, 同意发放令牌(access_token) ; 5.客户端使用令牌，向资源服务器申请获取资源 ; 6.资源服务器确认令牌无误, 同意向客户端开放资源 ; 重新分阶段这里, 我们又把OAuth2的整个认证过程大致分为三个阶段(分几个阶段, 几部步骤都是次要的, 重要的是能够理解整个过程): 第一阶段主要是向用户取得授权许可对应图中的第1、2、3步; 第二阶段主要是申请访问令牌(access_token)对应图中的第4、5步; 第三阶段就是使用access_token获取用户数据这一过程中涉及了不少敏感参数和数据, 例如client_secret相当于是第三方应用自己的密码, access_token某种程度上来讲就是用户的session id, 由于这些参数以及数据极其特殊, 我们当然得确保它们的安全性, HTTPS加密传输以及安全存储是必不可少的防护手段, 不过仅仅做到这些是远远不够的, 因为其实在这个流程里存在一个弱点， 容易被攻击者利用进行CSRF攻击, 稍后讲解 ;","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"Intro to OAuth","slug":"OAuth","date":"2016-03-19T03:05:00.000Z","updated":"2017-09-21T14:51:10.000Z","comments":true,"path":"2016/03/19/OAuth/","link":"","permalink":"http://blog.renyimin.com/2016/03/19/OAuth/","excerpt":"","text":"什么是OAuth开放式授权 Open Authorization 1.OAuth是一个关于授权(authorization)的开放网络标准, 在全世界得到广泛应用, 目前的版本是2.0版; 2.与以往的授权方式不同之处是, OAuth的授权 不会使第三方触及到用户的帐号信息(如用户名与密码) , 即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权, 因此 OAuth 是安全的, OAuth 是 Open Authorization(开放授权) 的简写; OAuth协议版本1.0版本: 2007.12有过安全漏洞, 比较复杂不易用 2.0版本: 2010年初OAuth的应用场景各个站点随处可见的QQ,微信,微博登录比如你要做一个站点, 常规做法就需要建立一套用户注册登录体系, 而网民很反感, 因为他们可能有很多站点的用户名密码, 不太想再多一个账号了, 但大家几乎都有 QQ , 微信, 人人, 豆瓣 等互联网大佬的帐号; 那我们为何不用 QQ 帐号登录后, 授权给本网站呢？可行, 不过先要确定好相互之间(网站和QQ之间)认证的规范, 这个规范有很多, 也可以自己写, 但业界比较通用 OAuth ; 有些站点干脆就是需要使用其他站点的用户资料比如, 用户想在 “云冲印”网站上冲印自己Google账户上的照片, 首先”云冲印”网站得读取到用户储存在Google上的照片, 那么用户就需要授予”云冲印”网站自己Google账户的部分权限; (至少也得给予云冲印网站能够读取用户Google账户中照片的权限吧) 传统授权的弊端传统所谓的”授权”做法, 最简单 直接 暴力 的就是用户直接将自己的Google账号和密码提供给”云冲印”网站, 这样后者就可以读取用户的照片了; 但这种做法有以下几个严重缺点: 哪怕有一个Client有隐患第三方网站, 为了后续的服务, 会保存用户的 Google/QQ/新浪微博/微信 账号和密码, 这样很不安全, 如果第三方网站都这样做的话, 难免有些第三方平台会由于自己的安全问题而导致用户 Google/QQ/新浪微博/微信 账户和密码的泄露, 这样将导致所有被密码保护的用户大量信息泄露 ; 用户无法设定Client的权利范围第三方网站拥有了获取用户 Google/QQ/新浪微博/微信 所有资料的权力, 用户没法限制 第三方网站 获得授权的范围和有效期 ; 用户想收回Client权利不太方便用户只有修改密码, 才能收回赋予 第三方网站 的权力, 否则 第三方网站 将会永久拥有用户 Google/QQ/新浪微博/微信 上的权利, 但是这样做, 会使得其他所有获得用户授权的第三方应用程序全部失效； 或者, 一些良心第三方可以设置 用户账号 和 Google/QQ/新浪微博/微信 账号的绑定和解绑, 但不一定所有第三方都会给你做, 如果不做解绑的话, 你还真只有前一种方法能够收回权利; OAuth应运而生名词定义在详细讲解OAuth 2.0之前, 需要了解几个专用名词: Third-party application第三方应用程序, 本文中又称”客户端”, 即上一节例子中的”云冲印” ; (之前愚蠢的我,一直给网站接入的 如 “QQ, 人人, 微信 等登录api” 叫第三方, 所以后来就和这里的”第三方”有点混淆了, 这里的第三方其实是针对”提供授权服务”的一方来说的, 之前说的第三方是针对你正在操作的网站来说的) Owner资源所有者, 用户自己 ; Authorization server认证服务器, 即服务提供商专门用来处理认证的服务器 ; (如QQ, google, 人人, 微信等都有自己的认证服务器) Resource server资源服务器, 即服务提供商存放用户生成的资源的服务器 (当然, 它与认证服务器, 可以是同一台服务器,也可以是不同的服务器) User Agent用户代理, 本文中就是指浏览器 ; OAuth 2.0的运行流程运行流程图 OAuth 2.0的运行流程图 运行流程图解123456（A）用户打开客户端以后，客户端要求用户给予授权。（B）用户同意给予客户端授权。（C）客户端使用上一步获得的授权，向认证服务器申请令牌。（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。（E）客户端使用令牌，向资源服务器申请获取资源。（F）资源服务器确认令牌无误，同意向客户端开放资源 不难看出来, 上面六个步骤之中, B是关键, 即用户怎样才能给于客户端授权; 有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源; 引出客户端的授权模式客户端必须得到用户的授权(authorization grant), 才能获得令牌(access token), OAuth 2.0定义了四种授权方式: 授权码模式（authorization code)简化模式（implicit）密码模式（resource owner password credentials）客户端模式（client credentials）参考: 阮一峰","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"PHP的Closure学习整理","slug":"clusore-introduction","date":"2016-03-10T06:30:15.000Z","updated":"2017-09-19T04:55:10.000Z","comments":true,"path":"2016/03/10/clusore-introduction/","link":"","permalink":"http://blog.renyimin.com/2016/03/10/clusore-introduction/","excerpt":"","text":"主要是对网上现存的一些资料做了一些简单地整理, 一方面让自己对基础知识加深印象, 一方面便于日后自己随时回顾! JavaScript中的闭包在了解PHP的闭包之前, 我们可以先简单了解一下JavaScript的闭包是怎样的? Js的作用域1.要理解闭包，首先必须理解Javascript的 变量作用域 ; 2.变量的作用域无非就是两种: 全局变量 和 局部变量 ; Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量:js12345var n=999;function f1()&#123; alert(n);&#125;f1(); // 999 另一方面, 在函数外部自然无法读取函数内的局部变量:js1234function f1()&#123; var n=999; //这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！&#125;alert(n); // error 如何从外部读取局部变量？出于种种原因, 我们有时候需要得到函数内的局部变量, 但是, 前面已经说过了, 正常情况下，这是办不到的, 只有通过变通方法才能实现; 于是, 我们可以在函数的内部, 再定义一个函数:js123456function f1()&#123; var n = 999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中, 函数f2就被包括在函数f1内部, 这时, f1内部的所有局部变量, 对f2都是可见的;但是反过来就不行, f2内部的局部变量, 对f1就是不可见的; 这就是Javascript语言特有的”链式作用域”结构(chain scope), 子对象会一级一级地向上寻找所有父对象的变量; 所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！js123456789101112131415161718192021function f1(a)&#123; var n = &apos;局部变量&apos;; function f2(c)&#123; console.log(n); console.log(a); console.log(c); &#125; return f2;&#125;var result = f1(&apos;传递给函数的参数,也成了一个局部值&apos;);result(&apos;传递给闭包的参数1&apos;);console.log(&apos;&apos;);result(&apos;传递给闭包的参数2&apos;);//结果: 局部变量 //可以看到我们就从外部取到了函数内部的局部变量传递给函数的参数,也成了一个局部值传递给闭包的参数1局部变量 //可以看到我们就从外部取到了函数内部的局部变量传递给函数的参数,也成了一个局部值传递给闭包的参数2 闭包的概念上一节代码中的f2函数, 就是闭包; 各种专业文献上对 “闭包”（closure）定义非常抽象，很难看懂; 我的理解是，闭包就是能够读取其他函数内部变量的函数; 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量, 因此可以把闭包简单理解成 “定义在一个函数内部的函数” ; 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁; 闭包的用途1.闭包可以用在许多地方, 它的最大用处有两个:12一个是前面提到的可以读取函数内部的变量; 另一个就是让这些变量的值始终保持在内存中; 2.怎么来理解上面的话呢？ 之前的代码中, result 这个变量其实就是闭包函数f2, 它一共运行了两次; 而函数f1中的局部变量一直保存在内存中, 并没有在f1调用后被自动清除; 原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后被垃圾回收机制（garbage collection）回收; 使用闭包的注意点1.由于闭包会使得函数中的变量都被保存在内存中, 内存消耗很大, 所以不能滥用闭包, 否则会造成网页的性能问题, 在IE中可能导致内存泄露, 解决方法是, 在退出函数之前, 将不使用的局部变量全部删除; 2.闭包会在父函数外部改变父函数内部变量的值; 所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method）, 把内部变量当作它的私有属性（private value）, 这时一定要小心, 不要随便改变父函数内部变量的值; js12345678910var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); // The Window js1234567891011var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); // My Object 以上参考阮一峰的博客, 阮一峰大哥真的写的很好了, 本人这里只是过一遍, 然后稍微简化了一点点, 修改了一点列子, 便于自己理解; PHP的闭包1.PHP的闭包 和 匿名函数 是在PHP5.3.0中引入, 这两个特性非常有用, 每个PHP开发者都应该掌握; 2.闭包是指在创建时, 封装周围状态的函数, 即便闭包所在的环境不存在了, 闭包中封装的状态依然存在, 这个概念如果你看了之前的JavaScript相关闭包的概念, 应该理解起来不是太难; 3.匿名函数是没有名称的的函数, 匿名函数可以赋值给变量, 还能像其他任何PHP变量那样传递, 不过匿名函数仍是函数, 因此可以调用, 还可以传入参数, 匿名函数特别适合作为函数或方法的回调; 4.理论上讲, 闭包和匿名函数是不同的概念, 不过, PHP将其视为相同的概念, 所以一般在PHP中说闭包就是匿名函数, 说匿名函数也是指闭包; 5.PHP闭包和匿名函数使用的句法虽然和普通函数相同, 但是需要注意的是, 闭包和匿名函数其实是伪装成函数的对象, 如果审查PHP闭包或匿名函数, 会发现阀门是Closure类的实例; 闭包和字符串或证书一样, 也是一等值类型 ; 创建闭包12345678&lt;?php$closure = function ($name) &#123; return sprintf('Hello %s', $name);&#125;;var_dump($closure); //object(Closure)#1 (1) &#123; [\"parameter\"]=&gt; array(1) &#123; [\"$name\"]=&gt; string(10) \"\" &#125; &#125;echo '&lt;br/&gt;';echo $closure('Josh'); //Hello Josh 闭包对象的创建就这么简单; 12建议: 之所以能调用$closure变量, 是因为这个变量的值是一个闭包, 而且闭包对象实现了__invoke()魔术方法;只要变量名后面有(), PHP就会查找并调用__invoke()方法; 通常情况下, 我们会把PHP的闭包对象当做函数和方法的回调来使用; 很多PHP的函数都会用到回调函数, 例如 array_map()和preg_replace_callback();这是使用PHP匿名函数的绝佳时机! 记住, 闭包和其他值一样, 可以作为参数出传入其他PHP函数; PHP中闭包的 附加状态1.之前我们说的 array_map()和preg_replace_callback() 对闭包的使用, 主要是把匿名函数当做回调来使用;下面我们讨论的是如何为PHP闭包附加并封装状态; 2.JavaScript开发者可能对PHP的闭包感到奇怪, 因为通过之前对JavaScript中闭包的了解, 它的闭包会自动封装应用的状态; 而PHP的闭包不会像真正的JS闭包那样自动封装应用的状态;在PHP中, 我们必须手动调用闭包对象的 use关键字 , 或者闭包对象的 bindTo()方法 来把状态附加到PHP闭包上; use关键字使用use关键字附加闭包状态比较常见, 我们先看这种方式; 使用use关键字把变量附加到闭包上时, 附加的变量会记住附加时赋给它的值:1234567891011&lt;?phpfunction enclosePerson($name)&#123; return function ($doCommand) use ($name) &#123; return sprintf('%s, %s', $name, $doCommand); &#125;;&#125;$clay = enclosePerson('Clay');echo $clay('get me sweet tea!'); 在例子中, 具名函数enclosePerson()有个名为$name参数, 这个函数返回一个闭包对象, 而且这个闭包对象封装了$name参数;即便返回的闭包对象已经跳出了enclosePerson()函数的作用域, 闭包对象也会记住$name参数的值, 因为$name变量仍在闭包中; 1使用use关键字可以把多个参数传入闭包, 此时要像php函数或方法的参数一样, 使用都好分割多个参数; Closure对象的bindTo()方法1.别忘了, php闭包是个对象(Closure对象), 与任何其他PHP对象类似, 每个闭包都可以使用$this关键字获取闭包的内部状态; 虽然闭包对象的默认状态没什么用, 只不过是有一个__invoke魔术方法和bindTo()方法而已; 但是bindTo()方法为闭包增加了一些有趣的潜力, 我们可以使用这个方法把closure对象内部的状态绑定到其他对象上; 2.bindTo()方法的第二个参数很重要, 其作用是指定绑定闭包的那个对象所属的PHP类; 因此, 闭包可以访问绑定闭包的对象中受保护和似有的成员变量; 3.其实如果经常看一些php框架源码, 你会发现, PHP框架经常使用bindTo()方法把 路由URL所映射的匿名回调函数 绑定到 应用对象上, 这么做可以在这个匿名函数中使用$this关键字引用重要的应用对象:12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass App&#123; protected $routes = []; protected $responseStatus = '200 OK'; protected $responseContentType = 'text/html'; protected $responseBody = 'Hello world'; public function addRoute($routePath, $routeCallback) &#123; $this-&gt;routes[$routePath] = $routeCallback-&gt;bindTo($this, __CLASS__); &#125; public function dispatch($currentPath) &#123; foreach($this-&gt;routes as $routePath =&gt; $callBack) &#123; if ($routePath === $currentPath) &#123; $callBack(); &#125; &#125; header('HTTP/1.1 ' . $this-&gt;responseStatus); header('Content-type: ' . $this-&gt;responseContentType); header('Content-length: ' . mb_strlen($this-&gt;responseBody)); echo $this-&gt;responseBody; &#125;&#125;$app = new App();$app-&gt;addRoute('/user/getName', function() &#123; $this-&gt;responseContentType = 'application/json;charset=utf8'; $this-&gt;responseBody = '&#123;\"name\": \"renyimin\"&#125;';&#125;);$app-&gt;dispatch('/user/getName');//结果返回: &#123;\"name\": \"renyimin\"&#125; 上面例子其实就是通过在App应用类中, 使用匿名函数的bindTo()方法将匿名函数绑定到了App对象上, 所以你就可以在绑定路由与其匿名函数的时候, 在匿名函数中来通过$this来调用App对象中的一些受保护的属性, 从而设定本路由的返回信息; 《Modern PHP》","categories":[{"name":"PHP New Features","slug":"PHP-New-Features","permalink":"http://blog.renyimin.com/categories/PHP-New-Features/"},{"name":"PHP","slug":"PHP-New-Features/PHP","permalink":"http://blog.renyimin.com/categories/PHP-New-Features/PHP/"}],"tags":[{"name":"Closure(闭包)","slug":"Closure-闭包","permalink":"http://blog.renyimin.com/tags/Closure-闭包/"}]}]}