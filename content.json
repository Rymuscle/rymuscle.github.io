{"meta":{"title":"Lant's Blog","subtitle":null,"description":null,"author":"Lant","url":"http://blog.renyimin.com"},"pages":[{"title":"标签","date":"2017-09-17T02:40:21.000Z","updated":"2017-09-18T09:08:03.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.renyimin.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-09-17T02:40:28.000Z","updated":"2017-09-18T09:08:09.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.renyimin.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"04.PHP - 系统调用","slug":"2017-05-16-Iterator-generator-yield-04","date":"2017-05-16T14:15:00.000Z","updated":"2017-11-14T02:50:38.000Z","comments":true,"path":"2017/05/16/2017-05-16-Iterator-generator-yield-04/","link":"","permalink":"http://blog.renyimin.com/2017/05/16/2017-05-16-Iterator-generator-yield-04/","excerpt":"","text":"既然调度器已经运行了, 那么我们来看下一个问题：任务和调度器之间的通信 ; 任务和调度器之间的通信: 我们将使用与 进程和操作系统会话 相同的方式来通信: 系统调用 ; 使用 系统调用 这种通信方式的理由是: 操作系统与进程相比, 两者是处在不同的权限级别上, 操作系统为了执行特权级别的操作(如杀死另一个进程), 就不得不以某种方式把控制传回给内核, 这样内核就可以执行所说的操作了;(再说一遍, 这种行为在内部是通过使用中断指令来实现的, 过去使用的是通用的int指令, 如今使用的是更特殊并且更快速的syscall/sysenter指令) 而接下来我们的任务调度系统就要使用这种设计:不是简单地把调度器传递给任务(这样就允许它做它想做的任何事), 我们将通过给yield表达式传递信息来与系统调用通信, 这儿yield既是中断,也是传递信息给调度器(和从调度器传递出信息)的方法; 代码: 任务类: 和之前没什么变化 123456789101112131415161718192021222324252627282930313233343536&lt;?phpclass Task &#123; protected $taskId; protected $coroutine; protected $sendValue = null; protected $beforeFirstYield = true; public function __construct($taskId, Generator $coroutine) &#123; $this-&gt;taskId = $taskId; $this-&gt;coroutine = $coroutine; &#125; public function getTaskId() &#123; return $this-&gt;taskId; &#125; public function setSendValue($sendValue) &#123; $this-&gt;sendValue = $sendValue; &#125; public function run() &#123; //每个任务在第一次被调度时, 会进行一次系统调用, 之后的调度才是任务中的循环 if ($this-&gt;beforeFirstYield) &#123; $this-&gt;beforeFirstYield = false; return $this-&gt;coroutine-&gt;current(); &#125; else &#123; $retval = $this-&gt;coroutine-&gt;send($this-&gt;sendValue); $this-&gt;sendValue = null; return $retval; &#125; &#125; public function isFinished() &#123; return !$this-&gt;coroutine-&gt;valid(); &#125;&#125; 系统调用:系统调用是操作系统提供给程序设计人员的一种服务,程序设计人员在编写程序时,可以利用系统调用来请求操作系统的服务 12345678910111213&lt;?phpclass SystemCall &#123; protected $callback; public function __construct(callable $callback) &#123; $this-&gt;callback = $callback; &#125; public function __invoke(Task $task, Scheduler $scheduler) &#123; $callback = $this-&gt;callback; return $callback($task, $scheduler); &#125;&#125; 调度器: run方法相比之前做了一些修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass Scheduler &#123; protected $taskId = 0;// protected $taskMap = []; // taskId =&gt; task protected $taskQueue; public function __construct() &#123; $this-&gt;taskQueue = new SplQueue(); &#125; public function newTask(Generator $coroutine) &#123; $taskId = ++$this-&gt;taskId; $task = new Task($taskId, $coroutine);// $this-&gt;taskMap[$taskId] = $task; $this-&gt;schedule($task); return $taskId; &#125; public function schedule(Task $task) &#123; $this-&gt;taskQueue-&gt;enqueue($task); &#125; public function run() &#123; //如果任务队列不为空 while (!$this-&gt;taskQueue-&gt;isEmpty()) &#123; $task = $this-&gt;taskQueue-&gt;dequeue(); $retval = $task-&gt;run(); //如果是`系统调用`(任务的第一行就是进行系统调用, 之后才是循环) if ($retval instanceof SystemCall) &#123; echo 123 . PHP_EOL; $retval($task, $this); continue; &#125; if ($task-&gt;isFinished()) &#123; //unset($this-&gt;taskMap[$task-&gt;getTaskId()]); &#125; else &#123; $this-&gt;schedule($task); &#125; &#125; &#125;&#125; 测试: 123456789101112131415161718192021222324252627282930&lt;?phprequire_once \"task.php\";require_once \"scheduler.php\";require_once \"systemCall.php\";function getTaskId() &#123; return new SystemCall(function(Task $task, Scheduler $scheduler) &#123; $task-&gt;setSendValue($task-&gt;getTaskId());//这里主要是在任务运行一开始进行的系统调用中设置任务的id (总共就两个任务), 其实在scheduler的run循环中,通过$task-&gt;run()中的send被传递给了任务中的 `$tid = (yield getTaskId());` $scheduler-&gt;schedule($task); &#125;);&#125;//系统功能调用是操作系统提供给程序设计人员的一种服务。程序设计人员在编写程序时，可以利用系统调用来请求操作系统的服务//本任务中的`系统调用`作用: 调度器创建的任务id, 会在系统调用中通过任务对象获取到, 并将其再次回传给任务中, 并且继续任务后续的调用时使用function task($max) &#123; //用户程序只在用户态下运行，有时需要访问`系统核心功能`，这时就需要通过系统调用接口来使用 `系统调用` $tid = (yield getTaskId()); // &lt;-- here's the syscall! for ($i = 1; $i &lt;= $max; ++$i) &#123; echo \"This is task $tid iteration $i.\\n\"; yield; &#125;&#125;$scheduler = new Scheduler;//添加两个任务到队列中$scheduler-&gt;newTask(task(10));$scheduler-&gt;newTask(task(5));//运行调度器$scheduler-&gt;run(); 结果和之前的简单任务调度一样; 123456789101112131415161718renyimin$ php index1.php 123 // 可以看到, 总共运行了两次系统调用(每个任务各自运行一次)123This is task 1 iteration 1. This is task 2 iteration 1.This is task 1 iteration 2.This is task 2 iteration 2.This is task 1 iteration 3.This is task 2 iteration 3.This is task 1 iteration 4.This is task 2 iteration 4.This is task 1 iteration 5.This is task 2 iteration 5.This is task 1 iteration 6.This is task 1 iteration 7.This is task 1 iteration 8.This is task 1 iteration 9.This is task 1 iteration 10. 参考: http://www.laruence.com/2015/05/28/3038.html","categories":[{"name":"Coroutine","slug":"Coroutine","permalink":"http://blog.renyimin.com/categories/Coroutine/"}],"tags":[{"name":"Coroutine","slug":"Coroutine","permalink":"http://blog.renyimin.com/tags/Coroutine/"}]},{"title":"03.PHP - 如何使用协程来实施任务调度","slug":"2017-05-16-Iterator-generator-yield-03","date":"2017-05-16T11:25:00.000Z","updated":"2017-11-14T02:14:40.000Z","comments":true,"path":"2017/05/16/2017-05-16-Iterator-generator-yield-03/","link":"","permalink":"http://blog.renyimin.com/2017/05/16/2017-05-16-Iterator-generator-yield-03/","excerpt":"","text":"(迭代器)生成器也是一个函数,不同的是这个函数的返回值是依次返回,而不是只返回一个单独的值; 或者, 换句话说, 生成器使你能更方便的实现了迭代器接口; 生成器为可中断的函数 要从生成器认识协程, 理解它内部是如何工作是非常重要的: 生成器是一种可中断的函数, 在它里面的yield构成了中断点; 为什么叫 迭代生成器, 因为它返回了一个 迭代器, 而这个迭代器实现了Iterator接口; 之前我们也了解到: 协程 的支持是在 迭代生成器 的基础上, 增加了可以回送数据给生成器的功能(调用者发送数据给被调用的生成器函数), 这就把生成器到调用者的单向通信转变为两者之间的双向通信; 123456789101112131415&lt;?phpfunction gen() &#123; $ret = (yield 'yield1'); var_dump($ret); $ret = (yield 'yield2'); var_dump($ret);&#125; $gen = gen();var_dump($gen-&gt;current()); // string(6) \"yield1\"var_dump($gen-&gt;send('ret1')); // string(4) \"ret1\" (the first var_dump in gen) // string(6) \"yield2\" (the var_dump of the -&gt;send() return value)var_dump($gen-&gt;send('ret2')); // string(4) \"ret2\" (again from within gen) // NULL (the return value of -&gt;send())?&gt; 注意： 第一点,yield表达式两边的括号在PHP7以前不是可选的, 也就是说在PHP5.5和PHP5.6中圆括号是必须的. 第二点,你可能已经注意到调用current()之前没有调用rewind().这是因为生成迭代对象的时候已经隐含地执行了rewind操作. 使用协程实现多任务协作，我们要解决的问题是你想并发地运行多任务(或者”程序”), 不过我们都知道CPU在一个时刻只能运行一个任务(不考虑多核的情况), 因此处理器需要在不同的任务之间进行切换,而且总是让每个任务运行 一小会儿; 多任务协作 这个术语中的”协作”很好的说明了如何进行这种切换的: 首先, 我们是通过调度器来调度每个任务运行的, 它而所谓协作就是要求当前正在运行的任务自动把控制传回给调度器, 这样就调度器就可以调度其他任务来运行了; 现在你应当明白 协程 和 任务调度 之间的关系: yield指令提供了任务中断自身的一种方法, 然后把控制交回给任务调度器, 因此协程可以运行多个其他任务; 更进一步来说, yield还可以用来在任务和调度器之间进行通信; 可以这么理解: 调度器在调度任务的时候, 是通过模拟一个队列, 然后将任务压栈, 之后每个任务执行一次就中断, 然后只要任务没有执行完毕, 就执行出栈再次压栈, 通过这样就实现了轮询的方式进行调度; 这里的重点是每个任务执行一次就中断, 这就是每个任务中 yield 的作用; 小疑问: 1234567891011121314151617&lt;?phpfunction gen() &#123; yield 'foo'; yield 'bar';&#125;$gen = gen();var_dump($gen-&gt;rewind());var_dump($gen-&gt;send('something'));// 鸟哥博客相关讨论小结:// 在send之前, 如果没有显示地调用current, 那么当$gen迭代器被创建的时候一个rewind()方法已经被隐式调用// 所以实际上发生的应该类似://$gen-&gt;rewind(); //不过可惜的是, rewind的执行将虽然会导致第一个yield被执行, 但是却忽略了他的返回值.//var_dump($gen-&gt;send('something')); // 真正当我们调用yield的时候, 我们得到的是第二个yield的值! 导致第一个yield的值被忽略. //string(3) \"bar\" 先看一个简单的任务调度程序: 通过模拟cpu轮询来调度两个 循环打印的任务 任务类: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php// 为了实现我们的多任务调度, 首先实现\"任务\" — 一个用轻量级的包装的协程函数:// 一个任务就是用任务ID标记的一个协程(函数).class Task &#123; protected $taskId; protected $coroutine; protected $sendValue = null; //通过添加 beforeFirstYieldcondition 我们可以确定第一个yield的值能被正确返回 //因为之前我们已经了解到: 在send之前, 如果没有显示地调用current, 那么当迭代器被创建的时候一个rewind会默认执行, 但是不会有返回 protected $beforeFirstYield = true; public function __construct($taskId, Generator $coroutine) &#123; $this-&gt;taskId = $taskId; $this-&gt;coroutine = $coroutine; &#125; public function getTaskId() &#123; return $this-&gt;taskId; &#125; // 使用setSendValue()方法, 你可以指定哪些值将被发送到下次的恢复(在之后你会了解到我们需要这个) //public function setSendValue($sendValue) &#123; //$this-&gt;sendValue = $sendValue; //&#125; //其实就是在这个run方法中做的手动迭代 public function run() &#123; if ($this-&gt;beforeFirstYield) &#123; $this-&gt;beforeFirstYield = false; $this-&gt;coroutine-&gt;current(); &#125; else &#123; $retval = $this-&gt;coroutine-&gt;send($this-&gt;sendValue); $this-&gt;sendValue = null; $retval; &#125; &#125; public function isFinished() &#123; return !$this-&gt;coroutine-&gt;valid(); &#125;&#125; 调度器类: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpclass Scheduler &#123; protected $taskId = 0;// protected $taskMap = []; // taskId =&gt; task protected $taskQueue; //调度器初始化其实就是简单创建了一个队列 public function __construct() &#123; $this-&gt;taskQueue = new SplQueue(); &#125; public function newTask(Generator $coroutine) &#123; $taskId = ++$this-&gt;taskId;//简单通过递增的方法来设置 任务的唯一标识 任务id $task = new Task($taskId, $coroutine);//通过 任务id 和 迭代器的生成器 来创建任务 //将创建好的任务和任务id对应起来 存入数组// $this-&gt;taskMap[$taskId] = $task; $this-&gt;schedule($task); return $taskId; &#125; //添加任务到队列 public function schedule(Task $task) &#123; $this-&gt;taskQueue-&gt;enqueue($task); &#125; //运行调度器, 这里是模拟cpu并发 轮询执行任务的关键 public function run() &#123; //如果任务队列不为空 while (!$this-&gt;taskQueue-&gt;isEmpty()) &#123; //将任务弹出队列 准备运行任务 $task = $this-&gt;taskQueue-&gt;dequeue(); //然后运行任务 (其实每个任务就是 迭代器生成器 生成的 迭代器) //这里run其实就是运行了 \"一次\" 迭代器, 进行了 \"一次\" 迭代 $task-&gt;run(); // 弹出队列的任务(迭代器)如果运行结束(即 迭代器对象循环结束) // 则从任务数组中删除任务 if ($task-&gt;isFinished()) &#123; //unset($this-&gt;taskMap[$task-&gt;getTaskId()]); &#125; else &#123; //如果任务没有运行结束则继续将任务放入队列 $this-&gt;schedule($task); &#125; &#125; &#125;&#125;?&gt; 测试: 123456789101112131415161718192021222324252627&lt;?phprequire_once \"task.php\";require_once \"scheduler.php\"; // **如代码, 一个任务就是用任务ID标记的一个协程(函数)** //第一个任务(一个`迭代器生成器`生成了迭代器, 然后再外部循环自己内部的任务):function task1() &#123; for ($i = 1; $i &lt;= 10; ++$i) &#123; echo \"This is task 1 iteration $i.\\n\"; yield; &#125;&#125;//第二个任务(一个`迭代器生成器`生成了迭代器, 然后再外部循环自己内部的任务):function task2() &#123; for ($i = 1; $i &lt;= 5; ++$i) &#123; echo \"This is task 2 iteration $i.\\n\"; yield; &#125;&#125;$scheduler = new Scheduler;//添加两个任务到队列中$scheduler-&gt;newTask(task1());$scheduler-&gt;newTask(task2());//运行调度器$scheduler-&gt;run(); 结果: 果然是两个任务交替执行各自的循环 12345678910111213141516renyimin$ php index.phpThis is task 1 iteration 1.This is task 2 iteration 1.This is task 1 iteration 2.This is task 2 iteration 2.This is task 1 iteration 3.This is task 2 iteration 3.This is task 1 iteration 4.This is task 2 iteration 4.This is task 1 iteration 5.This is task 2 iteration 5.This is task 1 iteration 6.This is task 1 iteration 7.This is task 1 iteration 8.This is task 1 iteration 9.This is task 1 iteration 10. 参考: http://www.laruence.com/2015/05/28/3038.html","categories":[{"name":"Coroutine","slug":"Coroutine","permalink":"http://blog.renyimin.com/categories/Coroutine/"}],"tags":[{"name":"Coroutine","slug":"Coroutine","permalink":"http://blog.renyimin.com/tags/Coroutine/"}]},{"title":"02.PHP - Generator (迭代)生成器","slug":"2017-05-13-Iterator-generator-yield-02","date":"2017-05-13T04:15:00.000Z","updated":"2017-11-13T10:26:33.000Z","comments":true,"path":"2017/05/13/2017-05-13-Iterator-generator-yield-02/","link":"","permalink":"http://blog.renyimin.com/2017/05/13/2017-05-13-Iterator-generator-yield-02/","excerpt":"","text":"Generator (迭代)生成器 之所以叫 迭代生成器, 是因为生成的对象是个迭代器对象, 可以参考PHP: 生成器类的结构, 实现了迭代器;1234567891011&lt;?phpfunction xrange($start, $end, $step = 1) &#123; for ($i = $start; $i &lt;= $end; $i += $step) &#123; yield $i; &#125;&#125;$range = xrange(1, 1000000);var_dump($range); // object(Generator)#1var_dump($range instanceof Iterator); // bool(true) 生成器函数的核心是 yield 关键字 它最简单的调用形式看起来像 return 的用法, 但普通 return 会返回值并终止函数的执行;而 yield 会返回一个值给循环调用此生成器的代码, 并且只是暂停执行生成器的函数的运行;暂停当前过程，意味着将处理权转交由上一级继续进行，直至上一级再次调用被暂停的执行生成器的函数，则执行生成器的函数会从上一次暂停的位置继续执行; 当然, yield 更重要的特性是除了可以返回一个值以外,还能够接收一个值 参考PHP: 生成器类的结构, 可以看到 Generator 类除了实现 Iterator 接口中的必要方法以外, 还有一个 send 方法, 这个方法就是向 yield 语句处传递一个值, 同时从 yield 语句处继续执行, 直至再次遇到 yield 后控制权回到外部 ; 测试代码: 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php/** * Created by PhpStorm. * User: renyimin * Date: 2017/5/13 * Time: 下午12:24 */function printer()&#123; $i = 0; while (true) &#123; echo 123 . \"\\n\"; //同时进行接收和发送 printf(\"receive: %s\\n\", (yield ++$i)); echo 456 . \"\\n\"; &#125;&#125;$printer = printer();//foreach($printer as $k =&gt; $v) &#123;// var_dump(1);//&#125;//为了使程序不会无限执行,下面手动调用current, send方法来让生成器生成的迭代器对象往下走printf(\"%d\\n\", $printer-&gt;current()); //123 //1 碰到yield则中断,将控制权交给外部的调度器$printer-&gt;send('hello'); //receive: hello 调度器再次调度,继续开始 //456 //123 碰到yield再次中断,将控制权交给外部的调度器printf(\"%d\\n\", $printer-&gt;current()); //2 又碰到yield再次中断,将控制权交给外部的调度器$printer-&gt;send('world'); //receive: world 调度器再次调度,继续开始 //456 //123 碰到yield再次中断,将控制权交给外部的调度器printf(\"%d\\n\", $printer-&gt;current()); //3 又碰到yield再次中断,将控制权交给外部的调度器 这儿yield没有作为一个语句来使用, 而是用作一个表达式, 即它能被演化成一个值. 这个值就是调用者传递给send()方法的值; 到这里, 我们看到 yield 可以在其位置同时进行 接收 和 返回 ( 双向传递 ), 当然, 这是实现 协程 的根本; 补充 ： 生成器允许你在 foreach 代码块中写代码来迭代一组数据而不需要在内存中创建一个数组, 那会使你的内存达到上限，或者会占据可观的处理时间。相反，你可以写一个生成器函数，就像一个普通的自定义函数一样, 和普通函数只返回一次不同的是, 生成器可以根据需要 yield 多次，以便生成需要迭代的值; 一个简单的例子就是使用生成器来重新实现 range() 函数, 标准的 range() 函数需要在内存中生成一个数组包含每一个在它范围内的值，然后返回该数组, 结果就是会产生多个很大的数组。 比如, 调用 range(0, 1000000) 将导致内存占用超过 100 MB ; 做为一种替代方法, 我们可以实现一个 xrange() 生成器, 只需要足够的内存来创建 Iterator 对象并在内部跟踪生成器的当前状态，这样只需要不到1K字节的内存; 例子: 即使你打印100W个键值对, 也不一次性将这些简直对放入变量中导致内存爆掉 12345678910111213141516&lt;?php/** * Created by PhpStorm. * User: renyimin * Date: 2017/5/13 * Time: 下午12:50 */function xrange($start, $limit, $step = 1) &#123; for ($i = $start; $i &lt;= $limit; $i += $step) &#123; yield $i + 1 =&gt; $i; &#125;&#125;foreach (xrange(0, 10000000000, 2) as $key =&gt; $value) &#123; printf(\"%d =&gt; %d\" . PHP_EOL, $key, $value);&#125; 参考: https://www.insp.top/article/php-knowledge-completion-generator-and-the-realization-of-coroutine","categories":[{"name":"Coroutine","slug":"Coroutine","permalink":"http://blog.renyimin.com/categories/Coroutine/"}],"tags":[{"name":"Coroutine","slug":"Coroutine","permalink":"http://blog.renyimin.com/tags/Coroutine/"}]},{"title":"01.PHP - Iterator (迭代器) 接口简介","slug":"2017-05-13-Iterator-generator-yield-01","date":"2017-05-13T03:05:00.000Z","updated":"2017-11-13T10:26:24.000Z","comments":true,"path":"2017/05/13/2017-05-13-Iterator-generator-yield-01/","link":"","permalink":"http://blog.renyimin.com/2017/05/13/2017-05-13-Iterator-generator-yield-01/","excerpt":"","text":"迭代: 可以理解为是指反复执行一个过程, 每执行一次叫做一次迭代; 在php中我们经常做迭代, 如下: 12345678910&lt;?php$mapping = ['red' =&gt; '#FF0000','green' =&gt; '#00FF00','blue' =&gt; '##0000FF'];foreach ($mapping as $key =&gt; $value) &#123;printf(\"key: %d - value: %s \\n\", $key, $value);&#125; 上述代码通过foreach对数组遍历并迭代输出其内容, 在foreach内部, 每次迭代都会将当前的元素的值赋给$value并将数组的指针移动指向下一个元素为下一次迭代做准备,从而实现顺序遍历;像这样能够让外部的迭代自己内部数据的接口就是迭代器接口;对应的那个被迭代的对象(这里是数组), 其实就是迭代器对象; PHP中提供的迭代器接口和类 PHP提供了统一的迭代器接口预定义接口中; SPL标准库中也提供了多种迭代器类; 简单实现一个迭代器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php/** * Created by PhpStorm. * User: renyimin * Date: 2017/5/13 * Time: 下午11:25 */class Xrange implements Iterator&#123; protected $start; protected $limit; protected $step; protected $i; public function __construct($start, $limit, $step = 0) &#123; $this-&gt;start = $start; $this-&gt;limit = $limit; $this-&gt;step = $step; &#125; public function rewind() &#123; $this-&gt;i = $this-&gt;start; &#125; public function next() &#123; $this-&gt;i += $this-&gt;step; &#125; public function current() &#123; return $this-&gt;i; &#125; public function key() &#123; return $this-&gt;i; &#125; public function valid() &#123; return $this-&gt;i &lt;= $this-&gt;limit; &#125;&#125;foreach (new Xrange(0, 10, 2) as $key =&gt; $value) &#123; printf(\"%d %d\" . PHP_EOL, $key, $value);&#125; 1234567$ php Iterator.php 0 02 24 46 68 810 10 补充: 可以将一个普通对象变成一个可被遍历的对象, 场景: 如一个StudentsContact对象, 这个对象是用于处理学生联系方式的, 通过 addStudent 方法注册学生, 通过 getAllStudent 获取全部注册的学生联系方式数组(比如获取一页学生联系方式列表), 我们以往是通过 StudentsContact::getAllStudent() 获取一个数组然后遍历该数组, 但是现在有了迭代器, 只要这个类继承这个接口, 就可以直接遍历该对象获取学生数组, 并且可以在获取之前在类的内部就对输出的数据做好处理工作; PHP的迭代器可以让你利用 面向对象 实现常见的数据结构, 例如列表, 堆栈, 队列与图 ; (有助于你使用纯面向对象的思想来设计你的程序)特别说明一下 对对象的遍历, 一般人觉得所谓的遍历对象*就是对一个对象里的属性或者方法一个一个的取出来, 然后做输出或者处理; 实际上, 这里的迭代器对对象的遍历并不是这个意思, 可能这句话本身的描述有问题, 比如, 可以使用迭代器模拟一个字符串对象的迭代器类, 让PHP可以对这个字符串对象进行遍历; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?phpclass String implements Iterator&#123; private $string; public function __construct($string) &#123; $this-&gt;string = $this-&gt;strToArray($string); &#125; /** * @param $string * @param int $l * @return array */ private function strToArray($string, $l = 0) &#123; //if ($l &gt; 0) &#123; //$ret = array(); //$len = mb_strlen($string, \"UTF-8\"); //for ($i = 0; $i &lt; $len; $i += $l) &#123; //$ret[] = mb_substr($string, $i, $l, \"UTF-8\"); //&#125; //return $ret; //&#125; return preg_split(\"//u\", $string, -1, PREG_SPLIT_NO_EMPTY); &#125; public function current() &#123; return current($this-&gt;string); &#125; public function next() &#123; return next($this-&gt;string); &#125; public function key() &#123; return key($this-&gt;string); &#125; public function valid() &#123; if (key($this-&gt;string) === null) &#123; return false; &#125; else &#123; return true; &#125; &#125; public function rewind() &#123; reset($this-&gt;string); &#125;&#125;$string = new String('这个是什么213jdjlf');foreach ($string as $k =&gt; $v) &#123; echo \"&#123;$k&#125; =&gt; &#123;$v&#125;\" . \"&lt;br/&gt;\";&#125;结果:0 =&gt; 这1 =&gt; 个2 =&gt; 是3 =&gt; 什4 =&gt; 么5 =&gt; 26 =&gt; 17 =&gt; 38 =&gt; j9 =&gt; d10 =&gt; j11 =&gt; l12 =&gt; f","categories":[{"name":"Coroutine","slug":"Coroutine","permalink":"http://blog.renyimin.com/categories/Coroutine/"}],"tags":[{"name":"Coroutine","slug":"Coroutine","permalink":"http://blog.renyimin.com/tags/Coroutine/"}]},{"title":"07.小结 \"Jsonp\" 对比 \"CORS简单/非简单请求\"","slug":"2016-09-21-sameoriginpolicy-07","date":"2016-09-21T13:20:16.000Z","updated":"2017-10-28T02:30:36.000Z","comments":true,"path":"2016/09/21/2016-09-21-sameoriginpolicy-07/","link":"","permalink":"http://blog.renyimin.com/2016/09/21/2016-09-21-sameoriginpolicy-07/","excerpt":"","text":"Jsonp 对比 CORS简单/非简单请求都可以方便实现跨域; Jsonp简单适用, 老式浏览器全部支持, 服务器端改动很小; 但是JSONP只能发GET请求; JSONP跨域发送Cookie的话, 只用设置好cookie的domain属性为顶级域名即可 ; CORS简单请求服务端需要设置一些允许选项; 发送请求为 GET, POST, HEAD ; 跨域发送cookie的话, 不仅需要设置cookie的domain属性, 服务端和客户端都要对Credentials header属性进行设置;跨域发送cookie的话, 服务端 Access-Control-Allow-Origin 不能设置为 * , 否则会提示 :123Failed to load http://test.test.com/index.php?sex=renyimin&amp;age=100: The value of the 'Access-Control-Allow-Origin' header in the response must not be the wildcard '*' when the request's credentials mode is 'include'. Origin 'http://www.test.com' is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute. CORS非简单请求服务端需要设置一些允许选项; 发送其他请求 (PUT) .. 可以设置自定义header头 cookie方面和 CORS简单请求一样","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"06.Ajax请求不能发送 之 \"CORS方案 -- (not-so-simple request)\"","slug":"2016-09-18-sameoriginpolicy-06","date":"2016-09-18T12:10:16.000Z","updated":"2017-10-27T10:15:27.000Z","comments":true,"path":"2016/09/18/2016-09-18-sameoriginpolicy-06/","link":"","permalink":"http://blog.renyimin.com/2016/09/18/2016-09-18-sameoriginpolicy-06/","excerpt":"","text":"预检请求 preflight 说明1.非简单请求是那种对服务器有特殊要求的请求, 比如请求方法是 PUT 或 DELETE, 或者 Content-Type 字段的类型是 application/json ; 2.非简单请求的CORS请求, 会在正式通信之前, 增加一次HTTP查询请求, 称为 &quot;预检&quot;请求(preflight) ; 浏览器先询问服务器, 当前网页所在的域名是否在服务器的许可名单之中, 以及可以使用哪些HTTP动词和头信息字段; 只有得到肯定答复, 浏览器才会发出正式的XMLHttpRequest请求, 否则就报错 ; 3.非简单请求会导致原先的一次请求变成两次, 第一次请求是 预检请求 ; 4.”预检”请求用的请求方法是 OPTIONS，表示这个请求是用来询问的，头信息里面关键字段是Origin，表示请求来自哪个源 ; 非简单请求的例子1.www.test.com/index.php 本例子使用 PUT 来进行ajax请求, 满足 非简单请求 的条件 ; 另外, 本例还自定义了请求时的 header 首部字段, 也满足 非简单请求 的条件 ; 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" &gt; $(document).ready(function()&#123; $(\"#btn\").click(function() &#123; //序列化name/value var data = $(\"form\").serializeArray(); $.ajax(&#123; //这里用PUT, 则为 `非简单` 请求 type: 'PUT', url: 'http://test.test.com/index.php', dataType: 'json', data: data, //或者如果你自定义了一些请求时的 header 首部字段, 那么请求就也是 复杂请求 headers: &#123;\"custom-header-field\" : \"test\"&#125;, success: function (result) &#123; console.log(result); &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=\"form\"&gt; &lt;input type=\"text\" name=\"sex\"&gt; &lt;input type=\"text\" name=\"age\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"button\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.test.test.com/index.php 12345678910&lt;?php//服务器允许的 Originheader(\"Access-Control-Allow-Origin: http://www.test.com\");//服务器允许的 methodsheader(\"Access-Control-Allow-Methods: PUT, GET, POST\");//服务器允许设置的头部字段header(\"Access-Control-Allow-Headers: custom-header-field\");$arguments = file_get_contents('php://input');echo json_encode(['arguments' =&gt; $arguments]); 3.注意: 像上面例子的复杂跨域请求 必须: 首先和简单请求一样, 服务器端的 Access-Control-Allow-Origin 是必须设置的, 不然首先就跨不了域; 必须: 其次, 是使用了 get, post, head 之外方法的 复杂请求, 那么就必须在服务端有对应的 Access-Control-Allow-Method, 否则: 可选: 如果你自定义了 自定义首部字段 的 复杂请求, 那么也要在服务端有对应的 Access-Control-Allow-Headers, 否则: 4.另外需要关注的是: 如果你设置了自定义的首部字段, 那么即使你的请求类型是get, post, head, 自然也是复杂请求, 此时的HTTP请求方法显示的仍然如下: Request Method:OPTIONS 分析预检请求1.上面www.test.com/index.php代码进行ajax请求的时候, HTTP请求的方法是PUT, 所以浏览器会发现, 这是一个非简单请求, 就自动发出一个”预检”请求, 要求服务器确认可以这样请求 ; 2.所以请求应该是包括预检请求和真正的请求两个请求的: 3.下面是这个”预检”请求的HTTP头信息 和 回应信息: 4.可以看到, “预检”请求用的请求方法是OPTIONS, 表示这个请求是用来询问的, 头信息里面, 关键字段是Origin, 表示请求来自哪个源; 除了Origin字段，”预检”请求的头信息包括两个特殊字段:(1)Access-Control-Request-Method ：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT ;(2)Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段, 上例是X-Custom-Header ; 分析预检响应1.从下面预检请求的截图中，可以看到预检请求的回应中, 服务器收到”预检”请求以后, 检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后，确认允许跨源请求，就可以做出回应 ; 并且预检请求部分是不会真的发送数据的: 2.上面的HTTP回应中，关键的是 Access-Control-Allow-Origin 字段，表示 http://www.test.com 可以请求数据, 该字段也可以设为星号，表示同意任意跨源请求 ; 123Access-Control-Allow-Origin: http://www.test.com或者Access-Control-Allow-Origin: * 3.如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段 ; 这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest 对象的 onerror 回调函数捕获; 控制台会打印出如下的报错信息 ; 4.服务器还可能回应的其他CORS相关字段如下: 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 测试代码cors请求是否允许包含cookie?(和CORS简单请求是一样的要求) www.test.com/index.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpsetcookie('address', json_encode(['city' =&gt; 'yuncheng', 'town' =&gt; 'xiaoliang']), 0, '/', '.test.com');?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" &gt; $(document).ready(function()&#123; $.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); $(\"#btn\").click(function() &#123; //序列化name/value var data = $(\"form\").serializeArray(); $.ajax(&#123; //这里用PUT, 则为 `非简单` 请求 type: 'PUT', url: 'http://test.test.com/index.php', dataType: 'json', data: data, //或者如果你自定义了一些请求时的 header 首部字段, 那么请求就也是 复杂请求 headers: &#123;\"custom-header-field\" : \"test\"&#125;, success: function (result) &#123; console.log(result); &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=\"form\"&gt; &lt;input type=\"text\" name=\"sex\"&gt; &lt;input type=\"text\" name=\"age\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"button\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; test.test.com 12345678910111213&lt;?php//服务器允许的 Origin (如果要发送cookie的话复杂请求也不能为*)header(\"Access-Control-Allow-Origin: http://www.test.com\");//服务器允许的 methodsheader(\"Access-Control-Allow-Methods: PUT, GET, POST\");//服务器允许设置的头部字段header(\"Access-Control-Allow-Headers: custom-header-field\");//要跨子域发cookie, 这个自然不能少header(\"Access-Control-Allow-Credentials: true\");$arguments = file_get_contents('php://input');$address = $_COOKIE['address'];echo json_encode(['arguments' =&gt; $arguments, 'cookie' =&gt; $address]); 参考 CORS","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"05.Ajax请求不能发送 之 \"CORS方案 -- (simple request)\"","slug":"2016-09-18-sameoriginpolicy-05","date":"2016-09-18T04:45:07.000Z","updated":"2017-10-27T10:03:24.000Z","comments":true,"path":"2016/09/18/2016-09-18-sameoriginpolicy-05/","link":"","permalink":"http://blog.renyimin.com/2016/09/18/2016-09-18-sameoriginpolicy-05/","excerpt":"","text":"CORS说明1.CORS是一个W3C标准, 全称是 “跨域资源共享 “(Cross-origin resource sharing), 通俗说就是我们所熟知的跨域请求 ; 众所周知，在以前，跨域可以采用 代理、JSONP 等方式，而在Modern浏览器面前，这些终将成为过去式，因为有了CORS ; CORS在最初接触的时候只大概了解到，通过服务器端设置Access-Control-Allow-Origin响应头，即可使指定来源像访问同源接口一样访问跨域接口，但其实CORS的规范定义远不止这些 ; 2.它允许浏览器向跨源服务器发出XMLHttpRequest请求, 也就是克服了AJAX只能同源使用的限制 ; 3.CORS需要浏览器和服务器同时支持 (目前, 所有浏览器都支持该功能, IE浏览器不能低于IE10) ; 4.整个CORS通信过程都是浏览器自动完成, 不需要用户参与 ; 对于开发者来说, CORS通信与同源的AJAX通信没有差别, 代码完全一样, 浏览器一旦发现AJAX的请求是跨源的, 就会自动添加一些附加的头信息, 有时还会多出一次附加的请求, 但用户不会有感觉; 之所以CORS通信与同源的AJAX通信的代码没有差别, 是因为: 其实实现CORS通信的关键是服务器, 只要服务器实现了CORS接口，就可以跨源通信 CORS的两类请求1.浏览器将CORS请求分成两类: 简单请求(simple request) 和 非简单请求(not-so-simple request) 2.以下情况会被归类为 非简单请求 : 请求以 GET, HEAD 或者 POST 以外的方法发起请求 ; 虽然使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型, 比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求 ; 使用自定义请求头（比如添加诸如 X-PINGOTHER） 简单请求代码案例1.客户端代码 www.test.com/index.html : 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; &gt; $(document).ready(function()&#123; $(&quot;#btn&quot;).click(function(k) &#123; var data = $(&quot;form&quot;).serializeArray();//序列化name/value $.ajax(&#123; type: &apos;GET&apos;, //这里用GET url: &apos;http://test.test.com/index.php&apos;, dataType: &apos;json&apos;, //类型 data: data, success: function (result) &#123;//返回的json数据 console.log(result); //回调输出 &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.服务端代码test.test.com/index.php : 123&lt;?phpheader(\"Access-Control-Allow-Origin: http://www.test.com\");echo json_encode(['name' =&gt; 'lant', 'age' =&gt; 100]); 基本流程分析1.对于简单请求，浏览器直接发出CORS请求, 具体来说, 就是在头信息之中, 自动增加一个Origin字段 ; 浏览器发现这次跨源AJAX请求是简单请求, 就自动在头信息之中, 添加一个Origin字段: 上面的头信息中, Origin字段 用来说明本次请求来自哪个源(协议 + 域名 + 端口), 服务器根据这个值, 决定是否同意这次请求 ; 2.如果Origin源不在服务器的许可范围内 服务器仍然会返回一个正常的HTTP回应, 不过浏览器会发现, 这个回应的头信息并没有包含 Access-Control-Allow-Origin 字段(详见下文), 就知道出错了, 从而抛出一个错误, 被XMLHttpRequest的onerror回调函数捕获; 注意, 这种错误无法通过状态码识别, 因为HTTP回应的状态码有可能是200 ; 3.当然, 如果Origin源在服务器设置的许可范围内 服务器的响应就会多出如下几个头信息字段(当然也不一定是所有都包含, 具体还得看服务器如何进行设置): 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 重点分析 :上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头:(1) Access-Control-Allow-Origin服务器要设置ajax请求可以跨域, 该字段是必须的, 它的值要么是请求时Origin字段的值，要么是一个，表示接受任意域名的请求;(2) Access-Control-Allow-Credentials该字段可选, 它的值是一个布尔值，表示是否允许发送Cookie, *默认情况下，Cookie不包括在CORS请求之中, 设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器;注意, 这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。(3) Access-Control-Expose-Headers该字段可选, CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma;如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定;上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 服务器端的具体设置 服务器在设置的时候, 其实就是通过header函数设置上面的三个选项! 比如之前的例子中, 如果服务器只是简单的为了实现跨域, 直接设置如下选项即可: 123&lt;?phpheader(\"Access-Control-Allow-Origin: http://www.test1.com\");echo json_encode(['name' =&gt; 'lant', 'age' =&gt; 100]); withCredentials 属性CORS请求默认不发送Cookie和HTTP认证信息 (Jsonp是会发送cookie信息的) 1.之前在介绍Access-Control-Allow-Credentials选项的时候提到, CORS请求默认不发送Cookie和HTTP认证信息; 如果要把Cookie发到服务器: 一方面要 服务器同意指定Access-Control-Allow-Credentials字段 : 123Access-Control-Allow-Credentials: true//php中设置如下:header(\"Access-Control-Allow-Credentials: true\"); 另一方面, 开发者必须在AJAX请求中打开 withCredentials 属性: 1234var xhr = new XMLHttpRequest();xhr.withCredentials = true;//jquery中设置withCredentials的代码如下:$.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); 2.需要以上两方面都做到才可以 否则，即使服务器同意发送Cookie，浏览器也不会发送 ; 但是, 如果省略 withCredentials 设置, 有的浏览器还是会一起发送Cookie, 这时, 可以显式关闭 withCredentials ;1xhr.withCredentials = false; 3.需要注意的是: 如果要发送Cookie, Access-Control-Allow-Origin 就不能设为星号*, 必须指定明确的、与请求网页一致的域名 ; 同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传, 其他域名的Cookie并不会上传, 且(跨源)原网页代码中的document.cookie也无法读取服务器域名下的Cookie ; 测试代码1.域1中的代码(www.test.com/index.php)：123456789101112131415161718192021222324252627282930313233343536373839&lt;?php//Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传, 其他域名的Cookie并不会上传, 且(跨源)原网页代码中的document.cookie也无法读取服务器域名下的Cookiesetcookie('address', json_encode(['city' =&gt; 'yuncheng', 'town' =&gt; 'xiaoliang']), 0, '/', '.test.com');?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" &gt; $(document).ready(function()&#123; //要在跨域请求服务器时在cors请求中包含cookie, 需要开启withCredentials属性 $.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); $(\"#btn\").click(function(k) &#123; var data = $(\"form\").serializeArray();//序列化name/value $.ajax(&#123; type: 'GET', //这里用GET url: 'http://test.test.com/index.php', dataType: 'json', //类型 data: data, success: function (result) &#123;//返回的json数据 console.log(result); //回调输出 &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=\"form\"&gt; &lt;input type=\"text\" name=\"sex\"&gt; &lt;input type=\"text\" name=\"age\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"button\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.域2中的代码(test.test.comindex.php):123456&lt;?phpheader(\"Access-Control-Allow-Origin: http://www.test.com\");//服务器允许前端在跨域cors请求时包含cookieheader(\"Access-Control-Allow-Credentials: true\");$address = $_COOKIE['address'];echo json_encode(['name' =&gt; 'lant', 'age' =&gt; 100, 'address' =&gt; $address]); 3.效果: 4.两个注意点 如果域1中在html中设置了 withCredentials 为 true : 1$.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); 那么在对应的ajax请求的域2中必须设置 1header(\"Access-Control-Allow-Credentials: true\"); 否则, 报错如下: 如果两边都不设置 withCredentials 属性的话, 也就是默认请求不带cookie, 那么即使请求方域1中设置了domain属性为 .test.com 的cookie值, 服务方(test.test.com)中也获取不到cookie, 因为域1默认请求就没有带cookie ; 参考 阮一峰参考 阮一峰 CORS","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"04. Ajax请求不能发送 之 \"JSONP方案\"","slug":"2016-09-17-sameoriginpolicy-04","date":"2016-09-17T11:27:31.000Z","updated":"2017-10-27T09:32:16.000Z","comments":true,"path":"2016/09/17/2016-09-17-sameoriginpolicy-04/","link":"","permalink":"http://blog.renyimin.com/2016/09/17/2016-09-17-sameoriginpolicy-04/","excerpt":"","text":"JSONP1.JSONP是服务器与客户端 跨源通信 的常用方法, 最大特点就是简单适用, 老式浏览器全部支持, 服务器端改造非常小 ; 2.但是，JSONP只能发GET请求 ; 3.注意: JSONP跨子域发送Cookie的话, 只用设置好cookie的domain属性为顶级域名即可 ; ajax使用jsonp跨域的时候是可以轻松像上面这样带上cookie给所跨的域 ; 而下一篇介绍的ajax使用cors方案跨域的话, 除了设置了cookie的 document.domain 为两个地址的顶级域名, 却也不能带上cookie, 还需要注意 前端和服务端的 withCredentials 头字段 ; jsonp跨域请求案例www.test.com/index.html123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; &gt; $(document).ready(function()&#123; //注意, 此时jsonp是会带上cookie的(当然, 如果你不设置cookie的domain, test.test.com自然获取不到www.test.com域的cookie) document.cookie = &quot;name=value; domain=test.com&quot;; $(&quot;#btn&quot;).click(function() &#123; var data = $(&quot;form&quot;).serializeArray();//序列化name/value $.ajax(&#123; type: &apos;GET&apos;, //这里用GET url: &apos;http://test.test.com/index.php&apos;, dataType: &apos;jsonp&apos;, //类型 data: data, jsonp: &apos;callback&apos;, //jsonp回调参数，必需 async: false, success: function (result) &#123;//返回的json数据 console.log(result); //回调输出 &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; test.test.com/index.php1234567891011&lt;?php//jsonp回调参数，必需$callback = isset($_GET['callback']) ? trim($_GET['callback']) : '';$sex = isset($_GET['sex']) ? trim($_GET['sex']) : '';$age = isset($_GET['age']) ? trim($_GET['age']) : '';$data = [\"sex\" =&gt; $sex, \"age\" =&gt; $age];$res = json_encode($data); //json 数据// 不能用returnecho $callback . '(' . $res . ')'; //返回格式，必需 参考","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"03.同源策略的限制 之 \"Ajax请求不能发送\"","slug":"2016-09-16-sameoriginpolicy-03","date":"2016-09-16T05:04:17.000Z","updated":"2017-10-27T09:33:06.000Z","comments":true,"path":"2016/09/16/2016-09-16-sameoriginpolicy-03/","link":"","permalink":"http://blog.renyimin.com/2016/09/16/2016-09-16-sameoriginpolicy-03/","excerpt":"","text":"同源策略的限制 - Ajax请求不能发送 同源政策规定, AJAX请求只能发给同源的网址, 否则就报错 ; 除了架设服务器代理(浏览器请求同源服务器，再由后者请求外部服务), 有三种方法规避这个限制 : JSONP CORS WebSocket 参考","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"02.同源策略的限制 之 \"Cookie无法读取\"","slug":"2016-09-15-sameoriginpolicy-02","date":"2016-09-15T13:10:13.000Z","updated":"2017-10-27T09:18:13.000Z","comments":true,"path":"2016/09/15/2016-09-15-sameoriginpolicy-02/","link":"","permalink":"http://blog.renyimin.com/2016/09/15/2016-09-15-sameoriginpolicy-02/","excerpt":"","text":"回顾之前学习同源策略基础知识的时候, 了解了同源策略的 三种行为 限制: Cookie、LocalStorage 和 IndexDB 无法读取 DOM 无法获得 AJAX 请求不能发送 不过这里需要注意一点: “同源策略”的限制, 并没有限制住CSRF攻击“同源策略的限制”并不会导致 B站点中嵌入的 A站点超链接去读取A站点用户的cookie;假如你当前已经登录了邮箱，或bbs，同时你又访问了另外一个站点，假设这就是一个钓鱼网站; 这个网站上面可能因为某个图片吸引你，你去点击一下，此时可能就会触发一个js的点击事件，去构造一个bbs发帖的请求，去往你的bbs站点发帖，由于当前你的浏览器状态已经是登陆状态，所以session登陆cookie信息都会跟正常的请求一样，纯天然的利用当前的登陆状态，让用户在不知情的情况下，帮你发帖或干其他事情; (这也就是我们通常所说的CSRF攻击, CSRF攻击的主要目的是让用户在不知情的情况下攻击自己已登录的一个系统，类似于钓鱼); 同源策略的限制之”Cookie无法读取” 本篇构造跨域的场景来模拟”Cookie无法读取”的限制, 方法主要有: B站&lt;a href=&quot;A&quot;&gt;test&lt;/a&gt;超链接无法读取B站点的cookie; (而csrf所讨论的是B站&lt;a href=&quot;A&quot;&gt;test&lt;/a&gt;超链接可以读取A站点自己的cookie) 不通过B站超链接, 而是直接打开另一个网页来访问A站点, 结果当然也是A站点读不到B站点的Cookie ; 暂时不会涉及到 Ajax请求所涉及的cookie传递问题, 这个问题属于同源策略的第三种限制 AJAX请求不能发送; 例子 : A网页是 http://www.test.com/index.html，B网页是 http://test.test.com/index.html : A: www.test.com/index.html (此处是使用js来设置cookie进行测试; 当然, 用服务端代码php测试也是OK的) 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; document.cookie=&quot;name=value;&quot;;&lt;/script&gt;&lt;/html&gt; B: test.test.com/index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; console.log(document.cookie);&lt;/script&gt;&lt;/html&gt; // 可以看到, 同顶级域名也不能跨子域名获取cookie //同理, 直接在http://www.test.com/index.html中超链接点击到http://test.test.com/index.html也是获取不到cookie的 ; 合理规避Cookie无法读取的限制 虽然同源导致的这些限制是必要, 但是有些情况下, 其实我们是需要 合理 规避Cookie无法读取的限制的 ; 比如: 如果两个网页的顶级域名相同, 只是二级域名不同的话, 浏览器其实是允许你通过设置 document.domain 来共享 Cookie 的; 例子: A网页是 http://www.test.com/index.html，B网页是 http://test.test.com/index.html, 那么只要设置相同的 document.domain，两个网页就可以共享Cookie : A: www.test.com/index.html (此处是使用js来设置cookie进行测试; 当然, 用php代码也是OK的) 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; document.cookie=&quot;name=value; domain=test.com&quot;;&lt;/script&gt;&lt;/html&gt; B: test.test.com/index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; console.log(document.cookie);&lt;/script&gt;&lt;/html&gt; 注意:这种方法只适用于 Cookie 和 iframe 窗口(DOM无法获取); 而 LocalStorage 和 IndexDB 无法通过这种方法来规避同源政策，而要使用之后会介绍的PostMessage API ; 参考 阮一峰","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"01.浏览器的同源策略(Same origin policy)","slug":"2016-09-15-sameoriginpolicy-01","date":"2016-09-15T11:21:54.000Z","updated":"2017-10-27T08:57:30.000Z","comments":true,"path":"2016/09/15/2016-09-15-sameoriginpolicy-01/","link":"","permalink":"http://blog.renyimin.com/2016/09/15/2016-09-15-sameoriginpolicy-01/","excerpt":"","text":"同源策略1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策； 最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”，所谓 “同源” 指的是 “三个相同” ： 1.协议相同http://blog.renyimin.com 和 https://blog.renyimin.com 就不是同一个源 ； 2.域名完全相同http://blog.renyimin.com/test/index.php 和 http://blog.renyimin.com/welcome/index.html 就是同一个源; 但是 http://www.renyimin.com/test/index.php 和 http://blog.renyimin.com/test/index.php 就不是同一个源 ；请注意：localhost和127.0.0.1虽然都指向本机, 但也不是同一个源 ; 3.端口相同http://www.renyimin.com:8080/test/index.php 和 http://www.renyimin.com:80/test/index.php 就不是同一个源 ; 再举例来说，http://www.example.com/dir/page.html 这个网址，协议是 http://，域名是 www.example.com，端口是80（默认端口可以省略），它的同源情况如下： 1234567http://www.example.com/dir2/other.html：同源http://example.com/dir/other.html：不同源（域名不同）http://v2.www.example.com/dir/other.html：不同源（域名不同）http://www.example.com:81/dir/other.html：不同源（端口不同） 同源策略目的1.为了保证用户信息的安全，防止恶意的网站窃取数据;比如:用户登录一家银行网站后，又去浏览其他站点, 如果没有同源策略限制, 其他站点就也能读取银行网站的 Cookie, 会发生什么？ 如果 Cookie 包含用户银行的私密信息，这些信息就会泄漏给第三方站点, 当然, cookie中包含的敏感信息通常经过加密，很难将其反向破解, 但这并不意味着绝对安全; 不去获取cookie中的信息, 而是直接偷取Cookie去骗取银行网站的信任; 2.由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了 ; 同源策略的限制随着互联网的发展, “同源政策”越来越严格, 目前, 如果非同源, 共有三种行为受到限制: Cookie、LocalStorage 和 IndexDB 无法读取 DOM 无法获得 AJAX 请求不能发送 (可能我平时更过关注到的是1，3这两点限制) 不过这里需要注意一点: “同源策略”的限制, 并没有限制住CSRF攻击“同源策略的限制”并不会导致 B站点中嵌入的 A站点超链接去读取A站点用户的cookie;假如你当前已经登录了邮箱，或bbs，同时你又访问了另外一个站点，假设这就是一个钓鱼网站; 这个网站上面可能因为某个图片吸引你，你去点击一下，此时可能就会触发一个js的点击事件，去构造一个bbs发帖的请求，去往你的bbs站点发帖，由于当前你的浏览器状态已经是登陆状态，所以session登陆cookie信息都会跟正常的请求一样，纯天然的利用当前的登陆状态，让用户在不知情的情况下，帮你发帖或干其他事情; (这也就是我们通常所说的CSRF攻击, CSRF攻击的主要目的是让用户在不知情的情况下攻击自己已登录的一个系统，类似于钓鱼); 最后, 虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响, 接下来将详细介绍如何在需要的时候合理地去规避”同源政策”的限制 ; 参考 阮一峰","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"04 - 授权码模式各阶段参数分析","slug":"2016-05-25-OAuth-04","date":"2016-05-25T12:10:12.000Z","updated":"2017-10-25T08:44:37.000Z","comments":true,"path":"2016/05/25/2016-05-25-OAuth-04/","link":"","permalink":"http://blog.renyimin.com/2016/05/25/2016-05-25-OAuth-04/","excerpt":"","text":"第一阶段: 第三方站点将导向授权页 第三方应用将用户导向授权页时, 传递的参数如下: response_type: 表示授权类型, 必选项, 此处由于采用的是授权码模式, 所以值固定为 “code” client_id/AppID: 表示客户端的ID, 必选项由于你可能会有多个站点需要对接OAuth授权服务器, 所以一般在授权服务平台登录之后, 是可以创建多个 应用 的 (不同的站点对接授权服务器中不同的应用);每个应用对应你的一个 第三方站点, 开放平台会为每个应用(第三方站点)生成相应的 AppID 和 AppSecret/AppKey, 主要用来验证应用的合法性; redirect_uri: 设定的重定向到第三方站点URI, 必选项 scope: 表示申请的权限范围, 可选项 state: 表示客户端的当前状态, 可以指定任意值, 认证服务器会原封不动地返回这个值 下面是各开放平台的参数对比: 新浪 QQ 微信 GitHub 蚂蚁金服 简单测试: redirect_uri在OAuth服务器中为第三方站点创建 应用 的时候, 设定的回调地址, 无论在认证服务器, 还是在第三方站点, 都会对其进行校验, 以防篡改; 新浪授权传递错误 redirect_uri 简书qq授权传递错误 redirect_uri state第三方站点会对state做校验给了一个新的弹框用来进行授权, 但是如果恶意用户复制出弹框中的url, 之后再修改state并刷新页面, 授权后发现: 从上面各平台也可以看到, 返回参数相对比较简单; 返回的code是和授权页登录的用户身份相关的; (后面的access_token也是通过code和用户身份关联起来的) 第二阶段: 通过Authorization Code获取Access Token 如果第三方站点的用户在第一阶段的授权页中选择对第三方站点授权, 那么就第三方站点就会收到授权服务器的Authorization Code, 进而进入本阶段;(每个用户在授权后, 第三方站点都需要到授权服务器上为用户获取一个access_token, 这个access_token就是以后第三方站点从授权服务器上获取用户信息的凭证了, 一般在获取到access_token令牌之后, 可以存储到session中) 本阶段, 我们在自己的第三方站点中就可以使用第一阶段的Authorization Code获取Access Token: 微信 qq 基本上入参就像QQ互联那样大概有5个 (需要对每个参数进行了解); 本阶段的返回参数比较有讲究, 一般为如下三个 access_token 授权令牌access_token一般在获取到之后, 第三方站点可以将其 保存到用户的session中 , 第三方站点之后要获取用户在授权服务器上的资源的时候, 就需要带上当前session中用户的access_token去获取; expires_in 该access token的有效期,单位为秒 (微信公众平台access_token有效期为2小时, qq互联平台为3个月 可以作为参考)设置access_token有效期也是为了定期修改access_token, 以提高安全性;(并且微信对获取access_token这个基础API是有限制的，每天最多请求2000次, 因为有效期为2小时, 每天2000次也足够了;) refresh_token 授权自动续期时使用 (微信公众平台refresh_token有效期为30天, qq互联平台具体不详, 可以作为参考) (可选)权限自动续期问题 注意微信公众平台: 1.若access_token已超时，那么进行refresh_token会获取一个新的access_token，新的超时时间, 并且一旦使用refresh_token来刷新access_token的话, refresh_token的过期时间也会更新(自动延期) ; 2.若access_token未超时，那么进行refresh_token不会改变access_token，但超时时间会刷新，相当于续期access_token ; 这里说的超时时间刷新, 指的自然是第三方站点和授权服务器上的超时时间都要更新了(只不过你如果只是做对接的话, 授权服务器这部分人家已经开发好了, 如果你是授权服务器也是自己开发的话, 那你就需要注意这里了) 其实第三方站点在受到授权服务器分配给当前用户的access_token之后, 假设说授权服务器返回access_token的过期时间为7200s(2小时), 那么第三方站点将access_token保存到用户session中, 并设置过期时间为6600s(中间可以有个10分钟的服务器时间差); 如果第三方站点在使用access_token为用户获取授权服务器中的资源时, 发现session中的access_token并没有过期, 那么请求后就需要为access_token续期(第三方站点和授权服务器上都要做续期) 如果第三方站点在使用access_token为用户获取授权服务器中的资源时, 发现session中的access_token过期, 则就需要使用refresh_token调用生成access_token的api接口重新生成access_token来进行续期； qq: 这样下来, 基本上第三方站点只有在大于refresh_token的过期时间都没有调用过授权服务器的话, 才需要用户重新登录; 第三阶段(比较简单): 第三方站点通过access_token获取授权平台资源服务器上的用户资源 获取access_token后，进行接口调用，有以下前提： access_token有效且未超时； 微信用户已授权给第三方应用帐号相应接口作用域(scope);也就是在授权服务器上还会使用access_token去检测对应的scope权限是否正确; 许多开放平台在申请完access_token令牌之后, 都提供了对应接口来获取用户相关信息QQ互联提供了相应的接口, 使用Access Token来获取用户的OpenID;新浪开放平台提供了相应的接口来获取access_token对应的用户信息;而微信公众平台: 在获取access_token的时候, 会同时返回openid表示微信用户在本公众号中的唯一标识;","categories":[{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/categories/后端架构/"},{"name":"OAuth2.0","slug":"后端架构/OAuth2-0","permalink":"http://blog.renyimin.com/categories/后端架构/OAuth2-0/"}],"tags":[{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/tags/后端架构/"},{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"03 - OAuth2.0的CSRF攻击","slug":"2016-05-24-OAuth-03","date":"2016-05-24T11:27:36.000Z","updated":"2017-10-25T08:01:49.000Z","comments":true,"path":"2016/05/24/2016-05-24-OAuth-03/","link":"","permalink":"http://blog.renyimin.com/2016/05/24/2016-05-24-OAuth-03/","excerpt":"","text":"假设有如下几个角色:受害者 lant ;攻击者 rymuscle ;第三方Web应用 liangren网 (它允许用户将其在 sandiruiqi网 的账号 和 liangren网 的账号进行绑定) ;OAuth2服务提供平台 sandiruiqi网 ; 攻击流程 攻击者rymuscle 登录 liangren网 并且选择使用自己的 sandiruiqi网 账号登录 ; liangren网 将 攻击者rymuscle 重定向到 sandiruiqi网 的授权页(这时可能需要 攻击者rymuscle 登录过sandiruiqi网), sandiruiqi网 的授权页向 攻击者rymuscle 显示 “是否授权liangren网访问” ; 攻击者rymuscle 在点击”同意授权”之后, 截获 sandiruiqi网 服务器返回的含有 Authorization Code 参数的HTTP响应 ; 然后 攻击者rymuscle 精心构造一个Web页面, 它会触发 liangren网 向 sandiruiqi网 发起令牌申请的请求, 而这个请求中的Authorization Code参数正是上一步 攻击者rymuscle 截获到的code ; 攻击者rymuscle 将这个Web页面放到互联网上, 等待或者诱骗受害者来访问 ; 假设正好一个受害者 lant 访问了 攻击者rymuscle 准备的这个Web页面后, 令牌申请流程在 受害者lant 的浏览器里被顺利触发, laingren网 从 sandiruiqi网 那里获取到access_token, 但是这个token以及通过它进一步获取到的用户信息却都是攻击者 攻击者rymuscle 的 ; 也就是最终 liangren网 将 攻击者rymuscle 的 sandiruiqi 账号同 lant 的 liangren网 账号关联了起来 从此以后, lant只要没有察觉到自己最初被悄悄使用了 攻击者rymuscle 的sandiruiqi网 账号登录, 那么他在 liangren网 上的所有资料, 都可以被 攻击者rymuscle 所看到, 并且 攻击者rymuscle 可能在 lant 的账号中做一些非法操作; 整体时序图分析 先看标准oauth时序图 下面是从网上copy的一张图, 从整体上来看, 这次攻击的时序图类似下图: 可以看到, 攻击的关键点在于:OAuth2的认证流程是分为好几步来完成的, 在标准oauth图的第3步, 第三方应用在收到一个GET请求时, 除了能知道当前用户的cookie, 以及URL中的Authorization Code之外, 难以分辨出这个请求到底是用户本人的意愿, 还是攻击者利用用户的身份伪造出来的请求; 于是乎, 攻击者就能使用移花接木的手段, 提前准备一个含有自己的Authorization Code的请求, 并让受害者的浏览器来接着完成后续的令牌申请流程 ; 难点(涉及到了非state参数防御): 尽管这个攻击既巧妙又隐蔽, 但是要成功进行这样的CSRF攻击也是比较困难的 : 整个攻击必须在短时间内完成, 因为OAuth2提供者颁发的Authorization Code有效期很短, OAuth2官方推荐的时间是不大于10分钟, 而一旦Authorization Code过期那么后续的攻击也就不能进行下去了; 一个Authorization Code只能被使用一次, 如果OAuth2提供者收到重复的Authorization Code, 它会拒绝当前的令牌申请请求, 不止如此, 根据OAuth2官方推荐, 它还可以把和这个已经使用过的Authorization Code相关联的access_token全部撤销掉, 进一步降低安全风险; 其实貌似只要做到Authorization Code只能被使用一次, 就可以防止csrf在此处的攻击了, 因为 rymuscle 在攻击的时候, 一旦获得 Authorization Code, 第三方站点服务器就会使用 Authorization Code 去申请access_token, 然后只要标记 Authorization Code 为已经使用, 那么 受害者lant 即使点击 攻击者rymuscle 构造好的链接也没用, 因为连接中的 Authorization Code 已经被标记为使用过了; 所以不一定非要使用下面的state参数来进行防御比如微信公众平台的OAuth授权: state参数就是可选的新浪开放平台的OAuth授权, state参数也是可选的当然, 他们不一定做的是和此处一样的防御方案, 但明显不依赖于state参数来解决问题; state参数防御: 要防止这样的攻击其实很容易, 作为第三方应用的开发者, 只需在OAuth认证过程中加入 state 参数, 并验证它的参数值即可; 在将用户重定向到OAuth2的Authorization Endpoint去的时候, 为用户生成一个随机的字符串, 并作为state参数加入到URL中 ; 在收到OAuth2服务提供者返回的Authorization Code请求的时候, 验证接收到的state参数值, 如果是正确合法的请求, 那么此时接受到的参数值应该和上一步提到的为该用户生成的state参数值完全一致, 否则就是异常请求; 但需要注意 state参数 需要具备下面几个特性: 不可预测性: 足够的随机, 使得攻击者难以猜到正确的参数值 ;如果你每次生成的state都被放在一起, 比如一个库/缓存中存在很多state;那么问题就是攻击者还是可以拿着自己的code再加上一个state, 来构造一个链接欺骗用户来点击;(假设state正好就在你的库/缓存中); 重点是关联性: state参数值可以和当前用户会话(user session)相互关联的所以应该让state和具体的用户关联起来, 虽然用户还没有登录, 但是也可以让state放到session中 ;然后攻击者要猜测出来一个state的话, 即便是已经生成过了, 但是也得正好攻击的是这个用户; 唯一性: 每个用户每次请求生成的state参数值都是唯一的 ; 时效性: state参数一旦被使用则立即失效 ; 参考 蚂蚁金服开放平台: 其实可以结合以上各种方法一起来进行防御! 参考 移花接木参考 state参数漏洞参考 阮一峰","categories":[{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/categories/后端架构/"},{"name":"OAuth2.0","slug":"后端架构/OAuth2-0","permalink":"http://blog.renyimin.com/categories/后端架构/OAuth2-0/"}],"tags":[{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/tags/后端架构/"},{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"02 - 授权码模式","slug":"2016-05-22-OAuth-02","date":"2016-05-22T12:27:36.000Z","updated":"2017-10-25T08:33:40.000Z","comments":true,"path":"2016/05/22/2016-05-22-OAuth-02/","link":"","permalink":"http://blog.renyimin.com/2016/05/22/2016-05-22-OAuth-02/","excerpt":"","text":"授权码模式运行过程 运行图 运行过程分析1.向用户取得授权许可对应图中的第1、2、3步; 2.申请访问令牌access_token令牌的申请对应图中的第4、5步; 3.使用令牌获取用户数据开放平台在申请完access_token令牌之后, 都提供了对应接口来获取用户相关信息, 比如:QQ互联: 提供了相应的接口, 使用Access Token来获取用户的OpenID;新浪开放平台: 提供了相应的接口来获取access_token对应的用户信息;而微信公众平台: 在获取access_token的时候, 会同时返回openid表示微信用户在本公众号中的唯一标识; 这一过程中涉及了不少敏感参数和数据, 例如client_secret相当于是第三方应用自己的密码, access_token某种程度上来讲就是用户的session id, 由于这些参数以及数据极其特殊, 我们当然得确保它们的安全性, HTTPS加密传输以及安全存储是必不可少的防护手段, 不过仅仅做到这些是远远不够的, 因为其实在这个流程里存在一个弱点， 容易被攻击者利用进行CSRF攻击, 下一篇笔记将会详细分析 ;","categories":[{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/categories/后端架构/"},{"name":"OAuth2.0","slug":"后端架构/OAuth2-0","permalink":"http://blog.renyimin.com/categories/后端架构/OAuth2-0/"}],"tags":[{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/tags/后端架构/"},{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"01 - OAuth(Open Authorization)开放式授权协议","slug":"2016-05-19-OAuth-01","date":"2016-05-19T03:05:00.000Z","updated":"2017-10-27T02:19:29.000Z","comments":true,"path":"2016/05/19/2016-05-19-OAuth-01/","link":"","permalink":"http://blog.renyimin.com/2016/05/19/2016-05-19-OAuth-01/","excerpt":"","text":"OAuth是一个关于授权(authorization)的开放网络标准, 目前的版本是2.0版 OAuth之前的传统”授权”比较 简单, 直接, 暴力, 一般是直接提供自己资源服务器的账号和密码给第三方站点, 要知道这种做的法弊端太多: 12345678910111.如果用户在每个第三方站点都这样做, 那将会存在严重安全隐患:很多第三方网站为了后续的服务, 会保存用户资源服务器的账号和密码, 这样很不安全, 因为难免有些第三方平台会由于自己的安全问题而导致用户的账号和密码泄露, 从而导致用户大量信息泄露 ;2.用户无法设定第三方站点的权利范围:第三方网站拥有了获取用户某个资源服务器的账号和密码后, 就拥有了资源服务器上的所有的资料, 用户没法限制第三方站点获取资源服务器上资源的权利范围和有效期 ;3.用户想收回第三方站点的权利不太方便:用户只有修改密码, 才能收回赋予第三方网站的权力, 否则第三方网站将会永久拥有用户资源服务器上资源的权利，但是这样做, 又会使得其他所有获得用户授权的第三方应用程序全部失效 ;或者, 一些良心第三方可以设置 用户账号 和 资源服务器账号的绑定和解绑, 但不一定所有第三方都会给你做, 如果不做解绑的话, 你还真就只有前一种方法能够收回权利 ; 而OAuth的授权不会让 第三方站点 触及到用户在 资源服务器 上的帐号信息(如用户名与密码), 即第三方站点无需使用用户资源服务器上的账号与密码, 就可以获得该用户在 资源服务器 上的资源, 因此 OAuth 是安全的 ; OAuth2.0协议定义了用于获得授权的”四种主要授权类型”1.授权码(Authorization code)模式 授权码模式是功能最完整、流程最严密的授权模式(标准的Server授权模式, 非常适合Server端的Web应用); 它的特点是: 通过客户端的后台服务器, 与&quot;服务提供商&quot;的认证服务器进行互动; 运行流程图解 123456用户打开客户端以后，客户端要求用户给予授权。用户同意给予客户端授权。客户端使用上一步获得的授权，向认证服务器申请令牌。认证服务器对客户端进行认证以后，确认无误，同意发放令牌。客户端使用令牌，向资源服务器申请获取资源。资源服务器确认令牌无误，同意向客户端开放资源 场景: 比如公司需要对接 QQ, 微博, 微信(网页授权) 等登录授权; 或者公司达到可以做自己对外的开放平台; 当然, 公司如果要做对外开放平台, 可能不止使用这一种模式: 像微信网页授权使用的就是`授权码模式`； 但是微信的基础功能接口和开发者服务器交互的时候, 就使用到了`客户端模式`； 而微信服务器涉及到和开发者服务器进行消息交互的时候, 还使用了类似`JWT`的签名校验来保证数据传输的安全; 2.隐式授权模式(Implicit Grant) 也叫简化模式, 该模式不通过第三方应用程序的服务器, 而是直接在浏览器中向认证服务器申请令牌, 跳过了”授权码”这个步骤, 因此得名; 它的特点是: 所有步骤在浏览器中完成, 令牌对访问者是可见的; 流程图: 场景: 3.密码模式(Resource Owner Password Credentials) 用户向客户端提供自己的用户名和密码, 客户端使用这些信息，向”服务商提供商”索要授权 ; 这种模式要求用户提供用户名和密码来交换访问令牌access_token ; 它的特点是:客户端仍然是以单个用户的名义向”服务提供商”进行认证;在这种模式中, 用户必须把自己的密码给客户端, 但是客户端不得储存密码, 这通常用在 用户对客户端高度信任的情况下, 比如客户端也是系统的一部分; 流程图: 下图也可参考: 场景:比如当third party application、authorization server、resource owner都是自己公司内的系统, Resource owner对third party application足够信任，所以我们就能采取这种模式来实现;就像: 公司如果有多套内部后台系统, 开发人员和公司管理员可能就要准备多套账号, 比较麻烦, 为了解决这个问题, 可以做一个账号中心系统, 用户在登录各个系统后台的时候, 会先跳转到用户中心进行登录, 一旦登录成功之后, 就会给用户分发一个access_token, 用来在各个系统间作为登录认证 (这也实现了SSO单点登录);(参考: http://www.cnblogs.com/richieyang/p/4918819.html) 4.客户端模式(Client Credentials) 客户端模式指客户端以客户端自己的名义, 而不是以单个用户的名义，向”服务提供商”进行认证;严格地说, 客户端模式并不属于OAuth框架所要解决的问题; 流程图: 服务器 不提供像用户数据这样的重要资源，仅仅是一些开放的功能性API;例如微信公众平台, Google Storage或Amazon S3 等开放平台提供的基础服务接口; 场景:1.你自己实现了一套基础服务的Api(都是些基础功能接口, 并不涉及用户数据这种重要资源), 提供给内部其他系统通过认证的方式来调用;2.公司如果实力强悍的话, 也可以将公司开发的基础服务Api公开出来 供外部其他第三方站点服务器 来调用, 比如: 微信公众平台的开放接口其实就是使用这种方式(但微信的网页授权采用的就是授权码模式): 客户端模式(Client Credentials) 和 用户密码模式 有时候比较容易混淆1.客户端模式: 如果客户端以自己的身份向服务提供商进行认证, 那需要授权中心给各个应用(不管是内部系统还是第三方站点服务器)分配对应的AppID和AppSecret, 然后第三方应用使用这两个信息来向”认证服务器”申请access_token, 这种场景下, 认证服务器一般提供的接口都是功能性的基础服务接口;2.用户密码模式: 如果客户端以单个用户身份向服务提供商进行认证, 只要用户账号密码能通过认证服务器, 认证服务器就会发放access_token, 当然这种场景需要的是几方角色都属于本公司内部; 当然这里所聊的是授权相关的知识, 并没有涉及数据传输的加密及签名校验, 但其实像微信公众平台这样开放平台, 除了基础服务接口供给开发者服务器调用时不需要做数据传输的加密和签名校验; 当微信服务器和开发者服务器涉及到用户消息数据的收发时, 会推荐对数据进行加密和签名校验; 参考: http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html参考: http://www.cnblogs.com/richieyang/p/4918819.html参考: http://www.dannysite.com/blog/176/","categories":[{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/categories/后端架构/"},{"name":"OAuth2.0","slug":"后端架构/OAuth2-0","permalink":"http://blog.renyimin.com/categories/后端架构/OAuth2-0/"}],"tags":[{"name":"后端架构","slug":"后端架构","permalink":"http://blog.renyimin.com/tags/后端架构/"},{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]}]}