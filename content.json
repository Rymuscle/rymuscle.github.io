{"meta":{"title":"Lant's Blog","subtitle":null,"description":null,"author":"Lant","url":"http://blog.renyimin.com"},"pages":[{"title":"分类","date":"2017-09-17T02:40:28.000Z","updated":"2017-09-18T09:08:09.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.renyimin.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-09-17T02:40:21.000Z","updated":"2017-09-18T09:08:03.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.renyimin.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Laravel-install-01","slug":"Laravel-install-01","date":"2016-04-15T08:34:13.000Z","updated":"2017-09-18T09:01:20.000Z","comments":true,"path":"2016/04/15/Laravel-install-01/","link":"","permalink":"http://blog.renyimin.com/2016/04/15/Laravel-install-01/","excerpt":"","text":"通过Composer下载安装可以在终端中通过Composer的==create-project==命令来创建一个新的Laravel项目:123composer create-project laravel/laravel [项目目录名] [项目版本号] --prefer-dist如果不写laravel下载下来后放置项目的目录名, 则默认为laravel; 1234567比如要下载Laravel的LTS版本(目前是Laravel5.1), 操作如下:composer create-project laravel/laravel vip 5.1.33 --prefer-dist或者composer create-project laravel/laravel vip 5.1.* --prefer-dist 应用Key的设置如果你是通过Composer或者Laravel安装器安装的话, 该key的值已经通过key:generate命令生成好了; (通常, 该字符串应该是32位长, 该key被配置在.env环境文件中(APP_KEY), 如果你还没有将.env.example文件重命名为.env, 现在立即这样做;如果应用key没有被设置, 用户sessions和其它加密数据将会有安全隐患!) 如果你不是通过composer安装的laravel, 生成key的方式如下:1先创建一个.env文件 12345然后生成应用key:bogon:laravel renyimin$ php artisan key:generateApplication key [7a7rsPOdMubimWYQRddpxEiTRuoQMScE] set successfully.bogon:laravel renyimin$ 你如果是使用Composer安装的话, 可以看到: image.png image.png nginx的设置:1$uri $uri/ /index.php?$query_string image.png 1项目根目录配置到: 项目目录的 public 目录下; 安装成功: image.png","categories":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.renyimin.com/categories/Laravel/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.renyimin.com/tags/Laravel/"}]},{"title":"PHP的Closure学习整理","slug":"clusore-introduction","date":"2016-03-10T06:30:15.000Z","updated":"2017-09-19T01:40:45.000Z","comments":true,"path":"2016/03/10/clusore-introduction/","link":"","permalink":"http://blog.renyimin.com/2016/03/10/clusore-introduction/","excerpt":"","text":"主要是对网上现存的一些资料做了一些简单地整理, 一方面让自己对基础知识加深印象, 一方面便于日后自己随时回顾! JavaScript中的闭包在了解PHP的闭包之前, 我们可以先简单了解一下JavaScript的闭包是怎样的? Js的作用域1.要理解闭包，首先必须理解Javascript的 变量作用域 ; 2.变量的作用域无非就是两种: 全局变量 和 局部变量 ; Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量:js12345var n=999;function f1()&#123; alert(n);&#125;f1(); // 999 另一方面, 在函数外部自然无法读取函数内的局部变量:js1234function f1()&#123; var n=999; //这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！&#125;alert(n); // error 如何从外部读取局部变量？出于种种原因, 我们有时候需要得到函数内的局部变量, 但是, 前面已经说过了, 正常情况下，这是办不到的, 只有通过变通方法才能实现; 于是, 我们可以在函数的内部, 再定义一个函数:js123456function f1()&#123; var n = 999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中, 函数f2就被包括在函数f1内部, 这时, f1内部的所有局部变量, 对f2都是可见的;但是反过来就不行, f2内部的局部变量, 对f1就是不可见的; 这就是Javascript语言特有的”链式作用域”结构(chain scope), 子对象会一级一级地向上寻找所有父对象的变量; 所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！js123456789101112131415161718192021function f1(a)&#123; var n = &apos;局部变量&apos;; function f2(c)&#123; console.log(n); console.log(a); console.log(c); &#125; return f2;&#125;var result = f1(&apos;传递给函数的参数,也成了一个局部值&apos;);result(&apos;传递给闭包的参数1&apos;);console.log(&apos;&apos;);result(&apos;传递给闭包的参数2&apos;);//结果: 局部变量 //可以看到我们就从外部取到了函数内部的局部变量传递给函数的参数,也成了一个局部值传递给闭包的参数1局部变量 //可以看到我们就从外部取到了函数内部的局部变量传递给函数的参数,也成了一个局部值传递给闭包的参数2 闭包的概念上一节代码中的f2函数, 就是闭包; 各种专业文献上对 “闭包”（closure）定义非常抽象，很难看懂; 我的理解是，闭包就是能够读取其他函数内部变量的函数; 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量, 因此可以把闭包简单理解成 “定义在一个函数内部的函数” ; 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁; 闭包的用途1.闭包可以用在许多地方, 它的最大用处有两个:12一个是前面提到的可以读取函数内部的变量; 另一个就是让这些变量的值始终保持在内存中; 2.怎么来理解上面的话呢？ 之前的代码中, result 这个变量其实就是闭包函数f2, 它一共运行了两次; 而函数f1中的局部变量一直保存在内存中, 并没有在f1调用后被自动清除; 原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后被垃圾回收机制（garbage collection）回收; 使用闭包的注意点1.由于闭包会使得函数中的变量都被保存在内存中, 内存消耗很大, 所以不能滥用闭包, 否则会造成网页的性能问题, 在IE中可能导致内存泄露, 解决方法是, 在退出函数之前, 将不使用的局部变量全部删除; 2.闭包会在父函数外部改变父函数内部变量的值; 所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method）, 把内部变量当作它的私有属性（private value）, 这时一定要小心, 不要随便改变父函数内部变量的值; js12345678910var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); // The Window js1234567891011var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); // My Object 以上参考阮一峰的博客, 阮一峰大哥真的写的很好了, 本人这里只是过一遍, 然后稍微简化了一点点, 修改了一点列子, 便于自己理解; PHP的闭包1.PHP的闭包 和 匿名函数 是在PHP5.3.0中引入, 这两个特性非常有用, 每个PHP开发者都应该掌握; 2.闭包是指在创建时, 封装周围状态的函数, 即便闭包所在的环境不存在了, 闭包中封装的状态依然存在, 这个概念如果你看了之前的JavaScript相关闭包的概念, 应该理解起来不是太难; 3.匿名函数是没有名称的的函数, 匿名函数可以赋值给变量, 还能像其他任何PHP变量那样传递, 不过匿名函数仍是函数, 因此可以调用, 还可以传入参数, 匿名函数特别适合作为函数或方法的回调; 4.理论上讲, 闭包和匿名函数是不同的概念, 不过, PHP将其视为相同的概念, 所以一般在PHP中说闭包就是匿名函数, 说匿名函数也是指闭包; 5.PHP闭包和匿名函数使用的句法虽然和普通函数相同, 但是需要注意的是, 闭包和匿名函数其实是伪装成函数的对象, 如果审查PHP闭包或匿名函数, 会发现阀门是Closure类的实例; 闭包和字符串或证书一样, 也是一等值类型 ; 创建闭包12345678&lt;?php$closure = function ($name) &#123; return sprintf('Hello %s', $name);&#125;;var_dump($closure); //object(Closure)#1 (1) &#123; [\"parameter\"]=&gt; array(1) &#123; [\"$name\"]=&gt; string(10) \"\" &#125; &#125;echo '&lt;br/&gt;';echo $closure('Josh'); //Hello Josh 闭包对象的创建就这么简单; 12建议: 之所以能调用$closure变量, 是因为这个变量的值是一个闭包, 而且闭包对象实现了__invoke()魔术方法;只要变量名后面有(), PHP就会查找并调用__invoke()方法; 通常情况下, 我们会把PHP的闭包对象当做函数和方法的回调来使用; 很多PHP的函数都会用到回调函数, 例如 array_map()和preg_replace_callback();这是使用PHP匿名函数的绝佳时机! 记住, 闭包和其他值一样, 可以作为参数出传入其他PHP函数; PHP中闭包的 附加状态1.之前我们说的 array_map()和preg_replace_callback() 对闭包的使用, 主要是把匿名函数当做回调来使用;下面我们讨论的是如何为PHP闭包附加并封装状态; 2.JavaScript开发者可能对PHP的闭包感到奇怪, 因为通过之前对JavaScript中闭包的了解, 它的闭包会自动封装应用的状态; 而PHP的闭包不会像真正的JS闭包那样自动封装应用的状态;在PHP中, 我们必须手动调用闭包对象的 use关键字 , 或者闭包对象的 bindTo()方法 来把状态附加到PHP闭包上; use关键字使用use关键字附加闭包状态比较常见, 我们先看这种方式; 使用use关键字把变量附加到闭包上时, 附加的变量会记住附加时赋给它的值:1234567891011&lt;?phpfunction enclosePerson($name)&#123; return function ($doCommand) use ($name) &#123; return sprintf('%s, %s', $name, $doCommand); &#125;;&#125;$clay = enclosePerson('Clay');echo $clay('get me sweet tea!'); 在例子中, 具名函数enclosePerson()有个名为$name参数, 这个函数返回一个闭包对象, 而且这个闭包对象封装了$name参数;即便返回的闭包对象已经跳出了enclosePerson()函数的作用域, 闭包对象也会记住$name参数的值, 因为$name变量仍在闭包中; 1使用use关键字可以把多个参数传入闭包, 此时要像php函数或方法的参数一样, 使用都好分割多个参数; Closure对象的bindTo()方法1.别忘了, php闭包是个对象(Closure对象), 与任何其他PHP对象类似, 每个闭包都可以使用$this关键字获取闭包的内部状态; 虽然闭包对象的默认状态没什么用, 只不过是有一个__invoke魔术方法和bindTo()方法而已; 但是bindTo()方法为闭包增加了一些有趣的潜力, 我们可以使用这个方法把closure对象内部的状态绑定到其他对象上; 2.bindTo()方法的第二个参数很重要, 其作用是指定绑定闭包的那个对象所属的PHP类; 因此, 闭包可以访问绑定闭包的对象中受保护和似有的成员变量; 3.其实如果经常看一些php框架源码, 你会发现, PHP框架经常使用bindTo()方法把 路由URL所映射的匿名回调函数 绑定到 应用对象上, 这么做可以在这个匿名函数中使用$this关键字引用重要的应用对象:12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass App&#123; protected $routes = []; protected $responseStatus = '200 OK'; protected $responseContentType = 'text/html'; protected $responseBody = 'Hello world'; public function addRoute($routePath, $routeCallback) &#123; $this-&gt;routes[$routePath] = $routeCallback-&gt;bindTo($this, __CLASS__); &#125; public function dispatch($currentPath) &#123; foreach($this-&gt;routes as $routePath =&gt; $callBack) &#123; if ($routePath === $currentPath) &#123; $callBack(); &#125; &#125; header('HTTP/1.1 ' . $this-&gt;responseStatus); header('Content-type: ' . $this-&gt;responseContentType); header('Content-length: ' . mb_strlen($this-&gt;responseBody)); echo $this-&gt;responseBody; &#125;&#125;$app = new App();$app-&gt;addRoute('/user/getName', function() &#123; $this-&gt;responseContentType = 'application/json;charset=utf8'; $this-&gt;responseBody = '&#123;\"name\": \"renyimin\"&#125;';&#125;);$app-&gt;dispatch('/user/getName');//结果返回: &#123;\"name\": \"renyimin\"&#125; 上面例子其实就是通过在App应用类中, 使用匿名函数的bindTo()方法将匿名函数绑定到了App对象上, 所以你就可以在绑定路由与其匿名函数的时候, 在匿名函数中来通过$this来调用App对象中的一些受保护的属性, 从而设定本路由的返回信息; 《Modern PHP》","categories":[{"name":"Closure(闭包)","slug":"Closure-闭包","permalink":"http://blog.renyimin.com/categories/Closure-闭包/"}],"tags":[{"name":"Closure(闭包)","slug":"Closure-闭包","permalink":"http://blog.renyimin.com/tags/Closure-闭包/"}]},{"title":"welcome","slug":"welcome","date":"2016-03-10T03:30:17.000Z","updated":"2017-09-18T08:55:32.000Z","comments":false,"path":"2016/03/10/welcome/","link":"","permalink":"http://blog.renyimin.com/2016/03/10/welcome/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2016-03-10T02:10:13.000Z","updated":"2017-09-18T08:35:53.000Z","comments":true,"path":"2016/03/10/hello-world/","link":"","permalink":"http://blog.renyimin.com/2016/03/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}