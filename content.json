{"meta":{"title":"Lant's Blog","subtitle":null,"description":null,"author":"Lant","url":"http://blog.renyimin.com"},"pages":[{"title":"分类","date":"2017-09-17T02:40:28.000Z","updated":"2017-09-18T09:08:09.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.renyimin.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-09-17T02:40:21.000Z","updated":"2017-09-18T09:08:03.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.renyimin.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Laravel-install-01","slug":"Laravel-install-01","date":"2016-04-15T08:34:13.000Z","updated":"2017-09-19T04:52:28.000Z","comments":true,"path":"2016/04/15/Laravel-install-01/","link":"","permalink":"http://blog.renyimin.com/2016/04/15/Laravel-install-01/","excerpt":"","text":"通过Composer下载安装可以在终端中通过Composer的==create-project==命令来创建一个新的Laravel项目:123composer create-project laravel/laravel [项目目录名] [项目版本号] --prefer-dist如果不写laravel下载下来后放置项目的目录名, 则默认为laravel; 1234567比如要下载Laravel的LTS版本(目前是Laravel5.1), 操作如下:composer create-project laravel/laravel vip 5.1.33 --prefer-dist或者composer create-project laravel/laravel vip 5.1.* --prefer-dist 应用Key的设置如果你是通过Composer或者Laravel安装器安装的话, 该key的值已经通过key:generate命令生成好了; (通常, 该字符串应该是32位长, 该key被配置在.env环境文件中(APP_KEY), 如果你还没有将.env.example文件重命名为.env, 现在立即这样做;如果应用key没有被设置, 用户sessions和其它加密数据将会有安全隐患!) 如果你不是通过composer安装的laravel, 生成key的方式如下:1先创建一个.env文件 12345然后生成应用key:bogon:laravel renyimin$ php artisan key:generateApplication key [7a7rsPOdMubimWYQRddpxEiTRuoQMScE] set successfully.bogon:laravel renyimin$ 你如果是使用Composer安装的话, 可以看到: image.png image.png nginx的设置:1$uri $uri/ /index.php?$query_string image.png 1项目根目录配置到: 项目目录的 public 目录下; 安装成功: image.png","categories":[{"name":"PHP框架","slug":"PHP框架","permalink":"http://blog.renyimin.com/categories/PHP框架/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.renyimin.com/tags/Laravel/"}]},{"title":"Client Credentials Grant.","slug":"OAuth-Client-Credentials-Grant","date":"2016-03-24T13:07:01.000Z","updated":"2017-09-22T03:51:35.000Z","comments":true,"path":"2016/03/24/OAuth-Client-Credentials-Grant/","link":"","permalink":"http://blog.renyimin.com/2016/03/24/OAuth-Client-Credentials-Grant/","excerpt":"","text":"客户端模式（Client Credentials Grant）指客户端以自己的名义, 而不是以用户的名义, 向”服务提供商”进行认证; 严格地说, 客户端模式并不属于OAuth框架所要解决的问题; 在这种模式中, 用户直接向客户端注册, 客户端以自己的名义要求”服务提供商”提供服务, 其实不存在授权问题; 步骤如下1.客户端向认证服务器进行身份认证, 并要求一个访问令牌 ;2.认证服务器确认无误后, 向客户端提供访问令牌 ;","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"Password Credentials Grant","slug":"OAuth-Password-Credentials-Grant","date":"2016-03-23T04:45:07.000Z","updated":"2017-09-22T04:39:36.000Z","comments":true,"path":"2016/03/23/OAuth-Password-Credentials-Grant/","link":"","permalink":"http://blog.renyimin.com/2016/03/23/OAuth-Password-Credentials-Grant/","excerpt":"","text":"密码模式(Resource Owner Password Credentials Grant)用户向客户端提供自己的用户名和密码,客户端使用这些信息, 向”服务商提供商”索要授权; 在这种模式中, 用户必须把自己的密码给客户端, 但是客户端不得储存密码 ; 这通常用在用户对客户端高度信任的情况下, 比如客户端是操作系统的一部分, 或者由一个著名公司出品; 而认证服务器只有在其他授权模式无法执行的情况下, 才能考虑使用这种模式;","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"OAuth-implicit-grant","slug":"OAuth-Implicit-grant","date":"2016-03-22T12:11:19.000Z","updated":"2017-09-22T04:27:07.000Z","comments":true,"path":"2016/03/22/OAuth-Implicit-grant/","link":"","permalink":"http://blog.renyimin.com/2016/03/22/OAuth-Implicit-grant/","excerpt":"","text":"简化模式/隐式授权(implicit grant type)不通过第三方应用程序的服务器, 直接在浏览器中向认证服务器申请令牌, 跳过了”授权码”这个步骤, 因此得名; 所有步骤在浏览器中完成, 令牌对访问者是可见的, 且客户端不需要认证; 步骤如下1.客户端将用户导向认证服务器 ; 2.用户决定是否给于客户端授权 ; 3.假设用户给予授权, 认证服务器将用户导向客户端指定的”重定向URI”, 并在URI的Hash部分包含了访问令牌 ; 4.浏览器向资源服务器发出请求, 其中不包括上一步收到的Hash值 ; 5.资源服务器返回一个网页, 其中包含的代码可以获取Hash值中的令牌 ; 6.浏览器执行上一步获得的脚本, 提取出令牌 ; 7.浏览器将令牌发给客户端 ;","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"03-授权码模式分析","slug":"OAuth-authorization-code03","date":"2016-03-22T11:11:10.000Z","updated":"2017-09-22T07:55:11.000Z","comments":true,"path":"2016/03/22/OAuth-authorization-code03/","link":"","permalink":"http://blog.renyimin.com/2016/03/22/OAuth-authorization-code03/","excerpt":"","text":"各步骤的参数研究客户端将用户导向授权页应该传递的参数12345response_type: 表示授权类型, 必选项, 此处由于采用的是授权码模式, 所以值固定为 \"code\"client_id: 表示客户端的ID, 必选项redirect_uri: 表示重定向URI, 可选项scope: 表示申请的权限范围, 可选项state: 表示客户端的当前状态, 可以指定任意值, 认证服务器会原封不动地返回这个值 新浪 QQ 微信 GitHub 小结各平台对比来看, 如果你要自己设计一个OAuth认证服务器的话, 你的授权码模式下, 授权页API的参数应该至少有如下: response_type表示授权类型, 必选项, 此处由于采用的是授权码模式, 所以值固定为 “code”你的认证服务器可能还有其他的OAuth授权模式, 所以需要此参数来加以区分 client_id表示客户端的ID, 必选项客户端在你的Oauth服务器注册时生成的client_id redirect_uri表示重定向URI, 必选项客户端在你的OAuth服务器注册时设定的回调地址, 一般客户端自己的服务器中会首先校验一下可以在认证服务端做redirect_uri校验, 以防篡改, 很多认证服务器在做校验的时候, 都是简单校验顶级域名是否正确即可(其实这样即可) 简书新浪授权传递错误 redirect_uri 简书qq授权传递错误 redirect_uri scope表示申请的权限范围, 必选项前提是你已经在认证服务方申请了开放哪些权限, 然后可以使用这个参数来在授权页中罗列出来(不建议罗列太多, 用户会有顾虑) state一个不可估量的随机字符串, 它用于防止跨站点请求伪造攻击, 认证服务器会原封不动地返回这个值 知乎的state首先知乎作为第三方网站, 对自己生成的也是对state做了校验给了一个新的弹框用来进行授权, 但是如果用户复制出弹框中的url, 之后再修改state并刷新页面, 授权后发现: 简书的state简书也对自己生成的state做校验了, 如果你改动授权页中的state, 你会发现登录失败并跳到登录页 认证服务器返回state原样返回之前客户端生成并传递过来的state code为了防止code被篡改:123可以设置有时效性, 比如QQ的code会在十分钟后过期, 这样即使攻击者给受害者的链接中是自己的code, 让受害者在十分钟内就点击的难度也会增大其实最好是code一旦申请过token_access之后, 认证服务器就应该立马做上标记, 以便不能被二次使用","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"02-针对OAuth2的CSRF攻击","slug":"OAuth-authorization-code02","date":"2016-03-20T14:03:21.000Z","updated":"2017-09-22T10:17:16.000Z","comments":true,"path":"2016/03/20/OAuth-authorization-code02/","link":"","permalink":"http://blog.renyimin.com/2016/03/20/OAuth-authorization-code02/","excerpt":"","text":"针对OAuth2的CSRF攻击例子针对OAuth2的CSRF攻击的例子, 假设有如下几个角色:1.受害者 张三 ;2.攻击者 李四 ;3.还有一个第三方Web应用 Tonr网站, 它集成了第三方社交账号登录并且允许用户将社交账号和 Tonr网站 中的账号进行绑定 ;4.此外还有一个OAuth2服务提供平台 Sparklr网站 ; 攻击流程1.攻击者李四登录Tonr网站 并且选择绑定自己的Sparklr网站账号; 2.Tonr网站 将李四重定向到Sparklr网站, 由于他之前已经登录过Sparklr网站, 所以Sparklr网站直接向他显示 “是否授权Tonr网站访问” 的页面; 3.李四在点击”同意授权”之后, 截获Sparklr网站服务器返回的含有Authorization Code参数的HTTP响应; 4.李四精心构造一个Web页面, 它会触发Tonr网站 向Sparklr网站发起令牌申请的请求, 而这个请求中的Authorization Code参数正是上一步截获到的code; 5.李四将这个Web页面放到互联网上, 等待或者诱骗受害者张三来访问; 6.(张三之前登录了Tonr网站 , 只是没有把自己的账号和其他社交账号绑定起来) 在 张三 访问了 李四 准备的这个Web页面后, 令牌申请流程在 张三 的浏览器里被顺利触发, Tonr网站 从Sparklr网站那里获取到access_token, 但是这个token以及通过它进一步获取到的用户信息却都是攻击者李四的; 7.Tonr网站 将 李四 的 Sparklr网站 账号同 张三 的 Tonr网站 账号关联绑定起来, 从此以后, 李四就可以用自己的Sparklr网站账号通过OAuth登录到 张三 在 Tonr网站 中的账号, 堂而皇之的冒充张三的身份执行各种操作; 这一切发生得太快, 可能你还没看清楚李四怎么就登录到张三的账号里去了, 下面让我们从几个不同的角度来看看这当中发生了什么？ 下面从不同角色的视角来分析这个漏洞受害者张三(Resource Owner)视角受害者 张三 访问了一个Web页面, 然后, 就没有然后了, 他在Tonr网站 上的账号就和攻击者李四在Sparklr网站上的账号绑定到了一起, 伪造的请求是经过精心构造的, 令牌申请这一过程在受害者张三的浏览器里是非常隐蔽的被触发的, 换句话讲就是, 他根本不知道这背后发生了什么; Tonr网站 (Client)视角从 Tonr网站 来看, 它收到的所有请求看上去都是正常的, 比如客户端在申请令牌的时候, 它收到了一个HTTP请求, 其代表着当前用户张三在 Sparklr网站 上已经做了”同意授权”操作, 其内容可能会如下:1GET /bindingCallback?code=AUTHORIZATION_CODE 不过需要注意的是, URL里的code不是当前受害者张三的Authorization Code, 而是攻击者李四的; 当 Tonr网站 收到这样的请求时, 它以为张三已经同意授权(但实际上这个请求是李四伪造的), 于是就发起后续的令牌申请请求, 用收到的Authorization Code向在 Sparklr网站 换取access_token, 只不过最后拿到的是攻击者李四的 access_token; 最后, Tonr网站 把攻击者李四的access_token和当前受害者张三在 Tonr网站 上的账号进行关联绑定; Sparklr网站 (OAuth2服务提供者)视角Sparklr网站 也是一脸茫然的样子, 因为在它看来, 自己收到的授权请求以及后续的令牌申请请求都是正常的, 或者说它无法得知接收到的这些请求之间的关联关系, 而且也无法区别出这些请求到底是来自张三本人, 还是由李四伪造出来的; 因此只要自己收到的参数是正确有效的, 那就提供正常的认证服务, 仅此而已; 攻击者李四视角李四伪造了一个用户授权成功的请求, 并且将其中的Authorization Code参数替换成了自己提前获取到的code, 这样, 当受害者 张三 的浏览器被欺骗从而发起令牌申请求时, 实际上是在 和 李四在 Sparklr网站 上的账号做绑定; 攻击完成后, 李四 在 Tonr网站 上可以通过自己在 Sparklr网站 的账号进行登录, 而且登录进入的是 张三 在 Tonr网站 上的账号, 而 张三 通过自己在 Tonr网站 上的账号登录进去之后, 看到的是 李四 在 Sparklr网站 上的部分账户信息; 上帝视角从整体上来看,这次攻击的时序图应该是下面这个样子的 分析漏洞回顾图1 分析漏洞的本质这个问题的关键点在于, OAuth2的认证流程是分为好几步来完成的, 在的图1中的第4步, 第三方应用在收到一个GET请求时, 除了能知道当前用户的cookie, 以及URL中的Authorization Code之外, 难以分辨出这个请求到底是用户本人的意愿, 还是攻击者利用用户的身份伪造出来的请求; 于是乎, 攻击者就能使用移花接木的手段, 提前准备一个含有自己的Authorization Code的请求, 并让受害者的浏览器来接着完成后续的令牌申请流程; 漏洞被攻击者使用还需要具备的前提条件尽管这个攻击既巧妙又隐蔽, 但是要成功进行这样的CSRF攻击也是需要满足一定前提条件的: 首先, 在攻击过程中, 受害者 张三 在 Tonr网站 上的用户会话(User Session)必须是有效的, 也就是说, 张三在受到攻击前已经登录了 Tonr网站 ; ？？？？ 其次, 整个攻击必须在短时间内完成, 因为OAuth2提供者颁发的Authorization Code有效期很短, OAuth2官方推荐的时间是不大于10分钟, 而一旦Authorization Code过期那么后续的攻击也就不能进行下去了; 最后, 一个Authorization Code只能被使用一次, 如果OAuth2提供者收到重复的Authorization Code, 它会拒绝当前的令牌申请请求, 不止如此, 根据OAuth2官方推荐, 它还可以把和这个已经使用过的Authorization Code相关联的access_token全部撤销掉, 进一步降低安全风险; 防御办法要防止这样的攻击其实很容易, 作为第三方应用的开发者, 只需在OAuth认证过程中加入state参数, 并验证它的参数值即可; 具体细节如下: 在将用户重定向到OAuth2的Authorization Endpoint去的时候, 为用户生成一个随机的字符串, 并作为state参数加入到URL中; 在收到OAuth2服务提供者返回的Authorization Code请求的时候, 验证接收到的state参数值, 如果是正确合法的请求, 那么此时接受到的参数值应该和上一步提到的为该用户生成的state参数值完全一致, 否则就是异常请求; state参数值需要具备下面几个特性:1.不可预测性: 足够的随机, 使得攻击者难以猜到正确的参数值 ;如果你每次生成的state都被放在一起, 比如一个库/缓存中存在很多state;那么问题就是攻击者还是可以拿着自己的code在加上一个state, 来构造一个链接欺骗用户来点击;假设state正好就在你的库/缓存中;所以应该让state和具体的用户关联起来, 虽然用户还没有登录, 但是也可以让state放到session中 ;然后攻击者要猜测出来一个state的话, 即便是已经生成过了, 但是也得正好攻击的是这个用户; 2.关联性: state参数值可以和当前用户会话(user session)相互关联的 ;比如简书, 每次你点击QQ登录之后, 会跳转到授权页面(url中带了简书服务器生成的state)此时你还会发现简书的cookie中总会多出一个_maleskine_session, 并且值是很长的一大串类似hash加密传, 可以猜测这个值就是state; 3.唯一性: 每个用户, 甚至每次请求生成的state参数值都是唯一的 ; 4.时效性: state参数一旦被使用则立即失效 ;``` 摘自 马伟 移花接木参考 state参数漏洞","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"01-授权码模式简介","slug":"OAuth-authorization-code01","date":"2016-03-19T12:27:36.000Z","updated":"2017-09-22T07:44:25.000Z","comments":true,"path":"2016/03/19/OAuth-authorization-code01/","link":"","permalink":"http://blog.renyimin.com/2016/03/19/OAuth-authorization-code01/","excerpt":"","text":"授权码模式简介授权码模式(authorization code)是功能最完整、流程最严密的授权模式, 它的特点就是通过 客户端的后台服务器 与 &quot;服务提供商&quot;的认证服务器 进行互动 ; 授权码模式运行过程运行图 运行步骤1.用户(RO)通过浏览器(UA)在客户端(Client)中触发操作(比方说新浪微博登录/QQ登录), Client之后将用户导向认证服务器的授权页面： 2.假设用户在授权页面给予客户端授权(authorization grant), 认证服务器会生成一个授权码code, 并带着这个code重新导向客户端配置并传递的 redirect_url ; 3.客户端的回调接口收到授权码, 然后在客户端的服务器中使用授权码去直接向认证服务器申请令牌 ; 4.认证服务器对客户端进行认证以后, 确认无误, 同意发放令牌(access_token) ; 5.客户端使用令牌，向资源服务器申请获取资源 ; 6.资源服务器确认令牌无误, 同意向客户端开放资源 ; 授权码模式图中的三个阶段这里, 我们又把OAuth2的整个认证过程大致分为三个阶段(分几个阶段, 几部步骤都是次要的, 重要的是能够理解整个过程): 向用户取得授权许可对应图中的第1、2、3步; 申请访问令牌access_token令牌的申请对应图中的第4、5步; 使用令牌获取用户数据这一过程中涉及了不少敏感参数和数据, 例如client_secret相当于是第三方应用自己的密码, access_token某种程度上来讲就是用户的session id, 由于这些参数以及数据极其特殊, 我们当然得确保它们的安全性, HTTPS加密传输以及安全存储是必不可少的防护手段, 不过仅仅做到这些是远远不够的, 因为其实在这个流程里存在一个弱点， 容易被攻击者利用进行CSRF攻击, 稍后讲解 ;","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"01-OAuth简介","slug":"OAuth","date":"2016-03-19T03:05:00.000Z","updated":"2017-09-22T07:53:30.000Z","comments":true,"path":"2016/03/19/OAuth/","link":"","permalink":"http://blog.renyimin.com/2016/03/19/OAuth/","excerpt":"","text":"什么是OAuth开放式授权 Open Authorization 1.OAuth是一个关于授权(authorization)的开放网络标准, 在全世界得到广泛应用, 目前的版本是2.0版; 2.与以往的授权方式不同之处是, OAuth的授权 不会使第三方触及到用户的帐号信息(如用户名与密码) , 即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权, 因此 OAuth 是安全的, OAuth 是 Open Authorization(开放授权) 的简写; OAuth协议版本1.0版本: 2007.12有过安全漏洞, 比较复杂不易用 2.0版本: 2010年初OAuth的应用场景各个站点随处可见的 QQ,微信,微博 登录比如你要做一个站点, 常规做法就需要建立一套用户注册登录体系, 而网民很反感, 因为他们可能有很多站点的用户名密码, 不太想再多一个账号了, 但大家几乎都有 QQ , 微信, 人人, 豆瓣 等互联网大佬的帐号; 那我们为何不用 QQ 帐号登录后, 授权给本网站呢？可行, 不过先要确定好相互之间(网站和QQ之间)认证的规范, 这个规范有很多, 也可以自己写, 但业界比较通用 OAuth ; 有些站点干脆就是需要使用其他站点的用户资料比如, 用户想在 “云冲印”网站上冲印自己Google账户上的照片, 首先”云冲印”网站得读取到用户储存在Google上的照片, 那么用户就需要授予”云冲印”网站自己Google账户的部分权限; (至少也得给予云冲印网站能够读取用户Google账户中照片的权限吧) 传统授权的弊端传统所谓的”授权”做法, 最简单 直接 暴力 的就是用户直接将自己的Google账号和密码提供给”云冲印”网站, 这样后者就可以读取用户的照片了; 但这种做法有以下几个严重缺点: 哪怕有一个Client有隐患第三方网站, 为了后续的服务, 会保存用户的 Google/QQ/新浪微博/微信 账号和密码, 这样很不安全, 如果第三方网站都这样做的话, 难免有些第三方平台会由于自己的安全问题而导致用户 Google/QQ/新浪微博/微信 账户和密码的泄露, 这样将导致所有被密码保护的用户大量信息泄露 ; 用户无法设定Client的权利范围第三方网站拥有了获取用户 Google/QQ/新浪微博/微信 所有资料的权力, 用户没法限制 第三方网站 获得授权的范围和有效期 ; 用户想收回Client权利不太方便用户只有修改密码, 才能收回赋予 第三方网站 的权力, 否则 第三方网站 将会永久拥有用户 Google/QQ/新浪微博/微信 上的权利, 但是这样做, 会使得其他所有获得用户授权的第三方应用程序全部失效； 或者, 一些良心第三方可以设置 用户账号 和 Google/QQ/新浪微博/微信 账号的绑定和解绑, 但不一定所有第三方都会给你做, 如果不做解绑的话, 你还真只有前一种方法能够收回权利; OAuth应运而生名词定义在详细讲解OAuth 2.0之前, 需要了解几个专用名词: Third-party application第三方应用程序, 本文中又称”客户端”, 即上一节例子中的”云冲印” ; (之前愚蠢的我,一直给网站接入的 如 “QQ, 人人, 微信 等登录api” 叫第三方, 所以后来就和这里的”第三方”有点混淆了, 这里的第三方其实是针对”提供授权服务”的一方来说的, 之前说的第三方是针对你正在操作的网站来说的) Owner资源所有者, 用户自己 ; Authorization server认证服务器, 即服务提供商专门用来处理认证的服务器 ; (如QQ, google, 人人, 微信等都有自己的认证服务器) Resource server资源服务器, 即服务提供商存放用户生成的资源的服务器 (当然, 它与认证服务器, 可以是同一台服务器,也可以是不同的服务器) User Agent用户代理, 本文中就是指浏览器 ; OAuth 2.0的运行流程运行流程图 OAuth 2.0的运行流程图 运行流程图解123456（A）用户打开客户端以后，客户端要求用户给予授权。（B）用户同意给予客户端授权。（C）客户端使用上一步获得的授权，向认证服务器申请令牌。（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。（E）客户端使用令牌，向资源服务器申请获取资源。（F）资源服务器确认令牌无误，同意向客户端开放资源 不难看出来, 上面六个步骤之中, B是关键, 即用户怎样才能给于客户端授权; 有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源; 引出客户端的授权模式客户端必须得到用户的授权(authorization grant), 才能获得令牌(access token), OAuth 2.0定义了四种授权方式: 授权码模式（authorization code)简化模式（implicit）密码模式（resource owner password credentials）客户端模式（client credentials）参考: 阮一峰","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"PHP的Closure学习整理","slug":"clusore-introduction","date":"2016-03-10T06:30:15.000Z","updated":"2017-09-19T04:55:10.000Z","comments":true,"path":"2016/03/10/clusore-introduction/","link":"","permalink":"http://blog.renyimin.com/2016/03/10/clusore-introduction/","excerpt":"","text":"主要是对网上现存的一些资料做了一些简单地整理, 一方面让自己对基础知识加深印象, 一方面便于日后自己随时回顾! JavaScript中的闭包在了解PHP的闭包之前, 我们可以先简单了解一下JavaScript的闭包是怎样的? Js的作用域1.要理解闭包，首先必须理解Javascript的 变量作用域 ; 2.变量的作用域无非就是两种: 全局变量 和 局部变量 ; Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量:js12345var n=999;function f1()&#123; alert(n);&#125;f1(); // 999 另一方面, 在函数外部自然无法读取函数内的局部变量:js1234function f1()&#123; var n=999; //这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！&#125;alert(n); // error 如何从外部读取局部变量？出于种种原因, 我们有时候需要得到函数内的局部变量, 但是, 前面已经说过了, 正常情况下，这是办不到的, 只有通过变通方法才能实现; 于是, 我们可以在函数的内部, 再定义一个函数:js123456function f1()&#123; var n = 999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中, 函数f2就被包括在函数f1内部, 这时, f1内部的所有局部变量, 对f2都是可见的;但是反过来就不行, f2内部的局部变量, 对f1就是不可见的; 这就是Javascript语言特有的”链式作用域”结构(chain scope), 子对象会一级一级地向上寻找所有父对象的变量; 所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！js123456789101112131415161718192021function f1(a)&#123; var n = &apos;局部变量&apos;; function f2(c)&#123; console.log(n); console.log(a); console.log(c); &#125; return f2;&#125;var result = f1(&apos;传递给函数的参数,也成了一个局部值&apos;);result(&apos;传递给闭包的参数1&apos;);console.log(&apos;&apos;);result(&apos;传递给闭包的参数2&apos;);//结果: 局部变量 //可以看到我们就从外部取到了函数内部的局部变量传递给函数的参数,也成了一个局部值传递给闭包的参数1局部变量 //可以看到我们就从外部取到了函数内部的局部变量传递给函数的参数,也成了一个局部值传递给闭包的参数2 闭包的概念上一节代码中的f2函数, 就是闭包; 各种专业文献上对 “闭包”（closure）定义非常抽象，很难看懂; 我的理解是，闭包就是能够读取其他函数内部变量的函数; 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量, 因此可以把闭包简单理解成 “定义在一个函数内部的函数” ; 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁; 闭包的用途1.闭包可以用在许多地方, 它的最大用处有两个:12一个是前面提到的可以读取函数内部的变量; 另一个就是让这些变量的值始终保持在内存中; 2.怎么来理解上面的话呢？ 之前的代码中, result 这个变量其实就是闭包函数f2, 它一共运行了两次; 而函数f1中的局部变量一直保存在内存中, 并没有在f1调用后被自动清除; 原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后被垃圾回收机制（garbage collection）回收; 使用闭包的注意点1.由于闭包会使得函数中的变量都被保存在内存中, 内存消耗很大, 所以不能滥用闭包, 否则会造成网页的性能问题, 在IE中可能导致内存泄露, 解决方法是, 在退出函数之前, 将不使用的局部变量全部删除; 2.闭包会在父函数外部改变父函数内部变量的值; 所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method）, 把内部变量当作它的私有属性（private value）, 这时一定要小心, 不要随便改变父函数内部变量的值; js12345678910var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); // The Window js1234567891011var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); // My Object 以上参考阮一峰的博客, 阮一峰大哥真的写的很好了, 本人这里只是过一遍, 然后稍微简化了一点点, 修改了一点列子, 便于自己理解; PHP的闭包1.PHP的闭包 和 匿名函数 是在PHP5.3.0中引入, 这两个特性非常有用, 每个PHP开发者都应该掌握; 2.闭包是指在创建时, 封装周围状态的函数, 即便闭包所在的环境不存在了, 闭包中封装的状态依然存在, 这个概念如果你看了之前的JavaScript相关闭包的概念, 应该理解起来不是太难; 3.匿名函数是没有名称的的函数, 匿名函数可以赋值给变量, 还能像其他任何PHP变量那样传递, 不过匿名函数仍是函数, 因此可以调用, 还可以传入参数, 匿名函数特别适合作为函数或方法的回调; 4.理论上讲, 闭包和匿名函数是不同的概念, 不过, PHP将其视为相同的概念, 所以一般在PHP中说闭包就是匿名函数, 说匿名函数也是指闭包; 5.PHP闭包和匿名函数使用的句法虽然和普通函数相同, 但是需要注意的是, 闭包和匿名函数其实是伪装成函数的对象, 如果审查PHP闭包或匿名函数, 会发现阀门是Closure类的实例; 闭包和字符串或证书一样, 也是一等值类型 ; 创建闭包12345678&lt;?php$closure = function ($name) &#123; return sprintf('Hello %s', $name);&#125;;var_dump($closure); //object(Closure)#1 (1) &#123; [\"parameter\"]=&gt; array(1) &#123; [\"$name\"]=&gt; string(10) \"\" &#125; &#125;echo '&lt;br/&gt;';echo $closure('Josh'); //Hello Josh 闭包对象的创建就这么简单; 12建议: 之所以能调用$closure变量, 是因为这个变量的值是一个闭包, 而且闭包对象实现了__invoke()魔术方法;只要变量名后面有(), PHP就会查找并调用__invoke()方法; 通常情况下, 我们会把PHP的闭包对象当做函数和方法的回调来使用; 很多PHP的函数都会用到回调函数, 例如 array_map()和preg_replace_callback();这是使用PHP匿名函数的绝佳时机! 记住, 闭包和其他值一样, 可以作为参数出传入其他PHP函数; PHP中闭包的 附加状态1.之前我们说的 array_map()和preg_replace_callback() 对闭包的使用, 主要是把匿名函数当做回调来使用;下面我们讨论的是如何为PHP闭包附加并封装状态; 2.JavaScript开发者可能对PHP的闭包感到奇怪, 因为通过之前对JavaScript中闭包的了解, 它的闭包会自动封装应用的状态; 而PHP的闭包不会像真正的JS闭包那样自动封装应用的状态;在PHP中, 我们必须手动调用闭包对象的 use关键字 , 或者闭包对象的 bindTo()方法 来把状态附加到PHP闭包上; use关键字使用use关键字附加闭包状态比较常见, 我们先看这种方式; 使用use关键字把变量附加到闭包上时, 附加的变量会记住附加时赋给它的值:1234567891011&lt;?phpfunction enclosePerson($name)&#123; return function ($doCommand) use ($name) &#123; return sprintf('%s, %s', $name, $doCommand); &#125;;&#125;$clay = enclosePerson('Clay');echo $clay('get me sweet tea!'); 在例子中, 具名函数enclosePerson()有个名为$name参数, 这个函数返回一个闭包对象, 而且这个闭包对象封装了$name参数;即便返回的闭包对象已经跳出了enclosePerson()函数的作用域, 闭包对象也会记住$name参数的值, 因为$name变量仍在闭包中; 1使用use关键字可以把多个参数传入闭包, 此时要像php函数或方法的参数一样, 使用都好分割多个参数; Closure对象的bindTo()方法1.别忘了, php闭包是个对象(Closure对象), 与任何其他PHP对象类似, 每个闭包都可以使用$this关键字获取闭包的内部状态; 虽然闭包对象的默认状态没什么用, 只不过是有一个__invoke魔术方法和bindTo()方法而已; 但是bindTo()方法为闭包增加了一些有趣的潜力, 我们可以使用这个方法把closure对象内部的状态绑定到其他对象上; 2.bindTo()方法的第二个参数很重要, 其作用是指定绑定闭包的那个对象所属的PHP类; 因此, 闭包可以访问绑定闭包的对象中受保护和似有的成员变量; 3.其实如果经常看一些php框架源码, 你会发现, PHP框架经常使用bindTo()方法把 路由URL所映射的匿名回调函数 绑定到 应用对象上, 这么做可以在这个匿名函数中使用$this关键字引用重要的应用对象:12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass App&#123; protected $routes = []; protected $responseStatus = '200 OK'; protected $responseContentType = 'text/html'; protected $responseBody = 'Hello world'; public function addRoute($routePath, $routeCallback) &#123; $this-&gt;routes[$routePath] = $routeCallback-&gt;bindTo($this, __CLASS__); &#125; public function dispatch($currentPath) &#123; foreach($this-&gt;routes as $routePath =&gt; $callBack) &#123; if ($routePath === $currentPath) &#123; $callBack(); &#125; &#125; header('HTTP/1.1 ' . $this-&gt;responseStatus); header('Content-type: ' . $this-&gt;responseContentType); header('Content-length: ' . mb_strlen($this-&gt;responseBody)); echo $this-&gt;responseBody; &#125;&#125;$app = new App();$app-&gt;addRoute('/user/getName', function() &#123; $this-&gt;responseContentType = 'application/json;charset=utf8'; $this-&gt;responseBody = '&#123;\"name\": \"renyimin\"&#125;';&#125;);$app-&gt;dispatch('/user/getName');//结果返回: &#123;\"name\": \"renyimin\"&#125; 上面例子其实就是通过在App应用类中, 使用匿名函数的bindTo()方法将匿名函数绑定到了App对象上, 所以你就可以在绑定路由与其匿名函数的时候, 在匿名函数中来通过$this来调用App对象中的一些受保护的属性, 从而设定本路由的返回信息; 《Modern PHP》","categories":[{"name":"PHP New Features","slug":"PHP-New-Features","permalink":"http://blog.renyimin.com/categories/PHP-New-Features/"},{"name":"PHP","slug":"PHP-New-Features/PHP","permalink":"http://blog.renyimin.com/categories/PHP-New-Features/PHP/"}],"tags":[{"name":"Closure(闭包)","slug":"Closure-闭包","permalink":"http://blog.renyimin.com/tags/Closure-闭包/"}]},{"title":"CORS方案02 (not-so-simple request)","slug":"sameoriginpolicy05-ajax-disabled-cors-not-simple","date":"2015-09-20T12:10:16.000Z","updated":"2017-09-29T05:43:48.000Z","comments":true,"path":"2015/09/20/sameoriginpolicy05-ajax-disabled-cors-not-simple/","link":"","permalink":"http://blog.renyimin.com/2015/09/20/sameoriginpolicy05-ajax-disabled-cors-not-simple/","excerpt":"","text":"非简单请求预检请求 preflight 说明 非简单请求是那种对服务器有特殊要求的请求, 比如请求方法是 PUT 或 DELETE, 或者 Content-Type 字段的类型是 application/json ; 非简单请求的CORS请求, 会在正式通信之前, 增加一次HTTP查询请求, 称为 &quot;预检&quot;请求(preflight) ; 浏览器先询问服务器, 当前网页所在的域名是否在服务器的许可名单之中, 以及可以使用哪些HTTP动词和头信息字段; 只有得到肯定答复, 浏览器才会发出正式的XMLHttpRequest请求, 否则就报错 ; 非简单请求会导致原先的一次请求变成两次, 第一次请求是 预检请求 ; “预检”请求用的请求方法是 OPTIONS，表示这个请求是用来询问的，头信息里面，关键字段是Origin，表示请求来自哪个源 ; 即使你的请求方法是 GET, POST 或者 HEAD(只是请求时自定义了一些header首部字段), 你的这个跨域请求也是 非简单请求，此时请求头显示的 ； 非简单请求的例子 www.test.com/index.php 本例子使用 PUT 来进行ajax请求, 满足 非简单请求 的条件 ; 另外, 本例还自定义了请求时的 header 首部字段, 也满足 非简单请求 的条件 ; 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" &gt; $(document).ready(function()&#123; $(\"#btn\").click(function() &#123; //序列化name/value var data = $(\"form\").serializeArray(); $.ajax(&#123; //这里用PUT, 则为复杂请求 type: 'PUT', url: 'http://test.test.com/index.php', dataType: 'json', data: data, //或者如果你自定义了一些请求时的 header 首部字段, 那么请求就也是 复杂请求 headers: &#123;\"custom-header-field\" : \"test\"&#125;, success: function (result) &#123; console.log(result); &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=\"form\"&gt; &lt;input type=\"text\" name=\"sex\"&gt; &lt;input type=\"text\" name=\"age\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"button\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; test.test.com/index.php 12345678910&lt;?php//服务器允许的 Originheader(\"Access-Control-Allow-Origin: http://www.test.com\");//服务器允许的 methodsheader(\"Access-Control-Allow-Methods: PUT, GET, POST\");//服务器允许设置的头部字段header(\"Access-Control-Allow-Headers: custom-header-field\");$arguments = file_get_contents('php://input');echo json_encode(['arguments' =&gt; $arguments]); 注意: 像上面例子的复杂跨域请求 必须: 首先和简单请求一样, 服务器端的 Access-Control-Allow-Origin 是必须设置的, 不然首先就跨不了域; 必须: 其次, 是使用了 get, post, head 之外方法的 复杂请求, 那么就必须在服务端有对应的 Access-Control-Allow-Method, 否则: 可选: 如果你自定义了 自定义首部字段 的 复杂请求, 那么也要在服务端有对应的 Access-Control-Allow-Headers, 否则: 另外需要关注的是: 如果你设置了自定义的首部字段, 那么即使你的请求类型是get, post, head, 自然也是复杂请求, 此时的HTTP请求方法显示的仍然如下: 1Request Method:OPTIONS 分析预检请求 上面www.test.com/index.php代码进行ajax请求的时候, HTTP请求的方法是PUT, 所以浏览器会发现, 这是一个非简单请求, 就自动发出一个”预检”请求, 要求服务器确认可以这样请求 ; 所以请求应该是包括预检请求和真正的请求两个请求的: 下面是这个”预检”请求的HTTP头信息 和 回应信息: 可以看到, “预检”请求用的请求方法是OPTIONS, 表示这个请求是用来询问的, 头信息里面, 关键字段是Origin, 表示请求来自哪个源;除了Origin字段，”预检”请求的头信息包括两个特殊字段:(1)Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT ;(2)Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段, 上例是X-Custom-Header ; 预检响应 从下面预检请求的截图中，可以看到预检请求的回应中, 服务器收到”预检”请求以后, 检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后，确认允许跨源请求，就可以做出回应 ; 并且预检请求部分是不会真的发送数据的: 上面的HTTP回应中，关键的是 Access-Control-Allow-Origin 字段，表示 http://www.test.com 可以请求数据, 该字段也可以设为星号，表示同意任意跨源请求 ; 123Access-Control-Allow-Origin: http://www.test.com或者Access-Control-Allow-Origin: * 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段 ; 这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest 对象的 onerror 回调函数捕获; 控制台会打印出如下的报错信息 ; 服务器回应的其他CORS相关字段如下: 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 Method PUT is not allowed by Access-Control-Allow-Methods in preflight response. 浏览器的正常请求和回应 一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段 ; 服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段 ; 下面是”预检”请求之后，浏览器的正常CORS请求: 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的; 下面是服务器正常的回应: 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中, Access-Control-Allow-Origin 字段是每次回应都必定包含的 ; WebSocket 参考 CORS","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"CORS方案01 (simple request)","slug":"sameoriginpolicy04-ajax-disabled-cors-simple","date":"2015-09-19T04:45:07.000Z","updated":"2017-09-29T05:43:58.000Z","comments":true,"path":"2015/09/19/sameoriginpolicy04-ajax-disabled-cors-simple/","link":"","permalink":"http://blog.renyimin.com/2015/09/19/sameoriginpolicy04-ajax-disabled-cors-simple/","excerpt":"","text":"CORS说明 CORS是一个W3C标准, 全称是 “跨域资源共享 “(Cross-origin resource sharing), 通俗说就是我们所熟知的跨域请求 ; 12众所周知，在以前，跨域可以采用 `代理`、`JSONP` 等方式，而在Modern浏览器面前，这些终将成为过去式，因为有了CORS ;CORS在最初接触的时候只大概了解到，通过服务器端设置Access-Control-Allow-Origin响应头，即可使指定来源像访问同源接口一样访问跨域接口，但其实CORS的规范定义远不止这些 ; 它允许 浏览器 向 跨源服务器 发出XMLHttpRequest请求, 从而克服了AJAX只能同源使用的限制 ; CORS需要浏览器和服务器同时支持 (目前, 所有浏览器都支持该功能, IE浏览器不能低于IE10) ; 整个CORS通信过程都是浏览器自动完成, 不需要用户参与 ; 对于开发者来说, CORS通信与同源的AJAX通信没有差别, 代码完全一样, 浏览器一旦发现AJAX的请求是跨源的, 就会自动添加一些附加的头信息, 有时还会多出一次附加的请求, 但用户不会有感觉; 因此，其实实现CORS通信的关键是服务器, 只要服务器实现了CORS接口，就可以跨源通信 CORS的两类请求 浏览器将CORS请求分成两类: 简单请求(simple request) 和 非简单请求(not-so-simple request) 以下为非简单请求的情况 : 12345请求以 GET, HEAD 或者 POST 以外的方法发起请求 ;或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型, 比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求 ;使用自定义请求头（比如添加诸如 X-PINGOTHER） 简单请求先看代码案例 客户端代码 www.test.com/index.html : 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; &gt; $(document).ready(function()&#123; $(&quot;#btn&quot;).click(function(k) &#123; var data = $(&quot;form&quot;).serializeArray();//序列化name/value $.ajax(&#123; type: &apos;GET&apos;, //这里用GET url: &apos;http://test.test.com/index.php&apos;, dataType: &apos;json&apos;, //类型 data: data, success: function (result) &#123;//返回的json数据 console.log(result); //回调输出 &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 服务端代码test.test.com/index.php : 123&lt;?phpheader(\"Access-Control-Allow-Origin: http://www.test.com\");echo json_encode(['name' =&gt; 'lant', 'age' =&gt; 100]); 基本流程分析浏览器直接发出CORS请求对于简单请求，浏览器直接发出CORS请求, 具体来说, 就是在头信息之中, 自动增加一个Origin字段 ; 浏览器识别出跨域AJAX简单请求浏览器发现这次跨源AJAX请求是简单请求, 就自动在头信息之中, 添加一个Origin字段: 上面的头信息中, Origin字段 用来说明本次请求来自哪个源(协议 + 域名 + 端口), 服务器根据这个值, 决定是否同意这次请求 ; 浏览器添加的Origin源不在服务器设置的许可范围如果Origin源, 不在许可范围内, 服务器让然会返回一个正常的HTTP回应, 不过浏览器会发现, 这个回应的头信息并没有包含 Access-Control-Allow-Origin 字段(详见下文), 就知道出错了, 从而抛出一个错误, 被XMLHttpRequest的onerror回调函数捕获; 注意, 这种错误无法通过状态码识别, 因为HTTP回应的状态码有可能是200 ; 浏览器添加的Origin源在服务器设置的许可范围内 当然, 如果 Origin源在服务器设置的许可范围内 , 服务器返回的响应, 就会多出如下个头信息字段(当然也不一定是所有都包含, 具体还得看服务器如何进行设置) : 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 重点分析:上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头:(1) Access-Control-Allow-Origin服务器要设置ajax请求可以跨域, 该字段是必须的, 它的值要么是请求时Origin字段的值，要么是一个，表示接受任意域名的请求;(2) Access-Control-Allow-Credentials该字段可选, 它的值是一个布尔值，表示是否允许发送Cookie, *默认情况下，Cookie不包括在CORS请求之中, 设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器;注意, 这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。(3) Access-Control-Expose-Headers该字段可选, CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 服务器端的具体设置 服务器在设置的时候, 其实就是通过header函数设置上面的三个选项! 比如之前的例子中, 如果服务器只是简单的为了实现跨域, 直接设置如下选项即可: 123&lt;?phpheader(\"Access-Control-Allow-Origin: http://www.test1.com\");echo json_encode(['name' =&gt; 'lant', 'age' =&gt; 100]); withCredentials 属性CORS请求默认不发送Cookie和HTTP认证信息 之前在介绍Access-Control-Allow-Credentials选项的时候提到, CORS请求默认不发送Cookie和HTTP认证信息; 如果要把Cookie发到服务器: 一方面要 服务器同意指定Access-Control-Allow-Credentials字段 : 123Access-Control-Allow-Credentials: true//php中设置如下:header(\"Access-Control-Allow-Credentials: true\"); 另一方面, 开发者必须在AJAX请求中打开 withCredentials 属性: 1234var xhr = new XMLHttpRequest();xhr.withCredentials = true;//jquery中设置withCredentials的代码如下:$.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); 需要以上两方面都做到才可以 否则，即使服务器同意发送Cookie，浏览器也不会发送, 或者，服务器要求设置Cookie，浏览器也不会处理 ; 但是, 如果省略 withCredentials 设置, 有的浏览器还是会一起发送Cookie, 这时, 可以显式关闭 withCredentials ; 1xhr.withCredentials = false; 需要注意的是: 如果要发送Cookie, Access-Control-Allow-Origin 就不能设为星号*, 必须指定明确的、与请求网页一致的域名 ; 同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传, 其他域名的Cookie并不会上传, 且(跨源)原网页代码中的document.cookie也无法读取服务器域名下的Cookie ; 例子域1中的代码(www.test.com/index.php)：1234567891011121314151617181920212223242526272829303132333435363738&lt;?php//Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传, 其他域名的Cookie并不会上传, 且(跨源)原网页代码中的document.cookie也无法读取服务器域名下的Cookiesetcookie('address', json_encode(['city' =&gt; 'yuncheng', 'town' =&gt; 'xiaoliang']), 0, '/', '.test.com');?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" &gt; $(document).ready(function()&#123; $.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); $(\"#btn\").click(function(k) &#123; var data = $(\"form\").serializeArray();//序列化name/value $.ajax(&#123; type: 'GET', //这里用GET url: 'http://test.test.com/index.php', dataType: 'json', //类型 data: data, success: function (result) &#123;//返回的json数据 console.log(result); //回调输出 &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=\"form\"&gt; &lt;input type=\"text\" name=\"sex\"&gt; &lt;input type=\"text\" name=\"age\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"button\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 域2中的代码(test.test.comindex.php):12345&lt;?phpheader(\"Access-Control-Allow-Origin: http://www.test.com\");header(\"Access-Control-Allow-Credentials: true\");$address = $_COOKIE['address'];echo json_encode(['name' =&gt; 'lant', 'age' =&gt; 100, 'address' =&gt; $address]); 效果: 两个注意 如果域1中在html中设置了 withCredentials 为 true : 1$.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); 那么在对应的ajax请求的域2中必须设置 1header(\"Access-Control-Allow-Credentials: true\"); 否则, 报错如下: 如果两边都不设置 withCredentials 属性的话, 也就是默认请求不带cookie, 那么即使请求方域1中设置了domain属性为 .test.com 的cookie值, 服务方(test.test.com)中也获取不到cookie, 因为域1默认请求就没有带cookie ; 参考 CORS","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"JSONP方案","slug":"sameoriginpolicy03-ajax-disabled-jsonp","date":"2015-09-18T11:27:31.000Z","updated":"2017-09-29T04:53:07.000Z","comments":true,"path":"2015/09/18/sameoriginpolicy03-ajax-disabled-jsonp/","link":"","permalink":"http://blog.renyimin.com/2015/09/18/sameoriginpolicy03-ajax-disabled-jsonp/","excerpt":"","text":"JSONP说明及注意 JSONP是服务器与客户端 跨源通信 的常用方法, 最大特点就是简单适用, 老式浏览器全部支持, 服务器改造非常小 ; 但是，JSONP只能发GET请求 ; 注意: JSONP跨域发送Cookie的话, 只用设置好cookie的domain属性为顶级域名即可 ; ajax使用jsonp跨域的时候是可以轻松像上面这样带上cookie给所跨的域的 ; 而下一篇介绍的ajax使用cors方案跨域的话, 除了设置了cookie的 document.domain 为两个地址的顶级域名, 却也不能带上cookie, 还需要注意 前端和服务端的 withCredentials 头字段 ; jsonp跨域请求案例www.test.com/index.html12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; &gt; $(document).ready(function()&#123; //注意, 此时jsonp是会带上cookie的 //当然不设置domain的话, test.test.com自然获取不到cookie document.cookie = &quot;name=value; domain=test.com&quot;; $(&quot;#btn&quot;).click(function() &#123; var data = $(&quot;form&quot;).serializeArray();//序列化name/value $.ajax(&#123; type: &apos;GET&apos;, //这里用GET url: &apos;http://test.test.com/index.php&apos;, dataType: &apos;jsonp&apos;, //类型 data: data, jsonp: &apos;callback&apos;, //jsonp回调参数，必需 async: false, success: function (result) &#123;//返回的json数据 console.log(result); //回调输出 &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; test.test.com/index.php1234567891011&lt;?php//jsonp回调参数，必需$callback = isset($_GET['callback']) ? trim($_GET['callback']) : '';$sex = isset($_GET['sex']) ? trim($_GET['sex']) : '';$age = isset($_GET['age']) ? trim($_GET['age']) : '';$data = [\"sex\" =&gt; $sex, \"age\" =&gt; $age];$res = json_encode($data); //json 数据// 不能用returnecho $callback . '(' . $res . ')'; //返回格式，必需 参考","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"同源策略的限制 -- Ajax请求不能发送","slug":"sameoriginpolicy02-ajax-disabled","date":"2015-09-17T14:30:19.000Z","updated":"2017-09-29T03:04:26.000Z","comments":true,"path":"2015/09/17/sameoriginpolicy02-ajax-disabled/","link":"","permalink":"http://blog.renyimin.com/2015/09/17/sameoriginpolicy02-ajax-disabled/","excerpt":"","text":"同源策略的限制 - Ajax请求不能发送 同源政策规定, AJAX请求只能发给同源的网址, 否则就报错 ; 除了架设服务器代理(浏览器请求同源服务器，再由后者请求外部服务), 有三种方法规避这个限制 : JSONP WebSocket CORS 疑问 这里的cookie无法读取和 后面的ajax跨域的cookie无法读取的区别呢? 首先都是跨域,???????? 参考","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"同源策略的限制 -- Cookie无法读取","slug":"sameoriginpolicy01-cookie-disabled","date":"2015-09-16T05:18:13.000Z","updated":"2017-09-29T04:56:11.000Z","comments":true,"path":"2015/09/16/sameoriginpolicy01-cookie-disabled/","link":"","permalink":"http://blog.renyimin.com/2015/09/16/sameoriginpolicy01-cookie-disabled/","excerpt":"","text":"回顾之前学习同源策略基础知识的时候, 了解了同源策略的 三种行为 限制: Cookie、LocalStorage 和 IndexDB 无法读取 DOM 无法获得 AJAX 请求不能发送 本节主要讨论 Cookie无法读取 的相关知识 ; Cookie无法读取的例子 要知道, Cookie 是服务器写入浏览器的一小段信息, 只有同源的网页才能共享 ; 注意: 本篇介绍的主要是直接访问不相同的域名(超链接模拟跨域 或者 直接打开另一个网页模拟跨域 ) 导致的Cookie无法读取的问题, 不会涉及到 Ajax请求所涉及的cookie传递问题, 这个问题属于同源策略的第三种限制 AJAX请求不能发送 ; 例子 : A网页是 http://www.test.com/index.html，B网页是 http://test.test.com/index.html : A: www.test.com/index.html (此处是使用js来设置cookie进行测试; 当然, 用服务端代码php测试也是OK的) 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; document.cookie=&quot;name=value;&quot;;&lt;/script&gt;&lt;/html&gt; B: test.test.com/index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; console.log(document.cookie);&lt;/script&gt;&lt;/html&gt; // 可以看到, 同顶级域名 的域名也获取不到不同二级域名的域锁设置的cookie //同理, 直接在http://www.test.com/index.html中超链接点击到http://test.test.com/index.html也是获取不到cookie的 ; 合理规避Cookie无法读取的限制 还是那句话, 虽然同源导致的这些限制是必要, 但是有些情况下, 其实我们是需要 合理 规避Cookie无法读取的限制的 ; 比如: 如果两个网页的顶级域名相同, 只是二级域名不同的话, 浏览器其实是允许你通过设置 document.domain 来共享 Cookie ; 例子: A网页是 http://www.test.com/index.html，B网页是 http://test.test.com/index.html, 那么只要设置相同的 document.domain，两个网页就可以共享Cookie : A: www.test.com/index.html (此处是使用js来设置cookie进行测试; 当然, 用php代码也是OK的) 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; document.cookie=&quot;name=value; domain=test.com&quot;;&lt;/script&gt;&lt;/html&gt; B: test.test.com/index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; console.log(document.cookie);&lt;/script&gt;&lt;/html&gt; 注意, 这种方法只适用于 Cookie 和 iframe 窗口, LocalStorage 和 IndexDB 无法通过这种方法来规避同源政策，而要使用之后会介绍的PostMessage API ; 摘自 阮一峰","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"浏览器的同源策略(Same origin policy)","slug":"sameoriginpolicy","date":"2015-09-15T11:58:54.000Z","updated":"2017-09-27T12:26:09.000Z","comments":true,"path":"2015/09/15/sameoriginpolicy/","link":"","permalink":"http://blog.renyimin.com/2015/09/15/sameoriginpolicy/","excerpt":"","text":"同源策略1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策； 最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”，所谓 “同源” 指的是 “三个相同” ：1.协议相同http://blog.renyimin.com 和 https://blog.renyimin.com 就不是同一个源 ； 2.域名相同http://blog.renyimin.com/test/index.php 和 http://blog.renyimin.com/welcome/index.html 就是同一个源; 但是 http://www.renyimin.com/test/index.php 和 http://blog.renyimin.com/test/index.php 就不是同一个源 ；请注意：localhost和127.0.0.1虽然都指向本机, 但也不是同一个源 ; 3.端口相同http://www.renyimin.com:8080/test/index.php 和 http://www.renyimin.com:80/test/index.php 就不是同一个源 ; 再举例来说，http://www.example.com/dir/page.html 这个网址，协议是 http://，域名是 www.example.com，端口是80（默认端口可以省略），它的同源情况如下：1234http://www.example.com/dir2/other.html：同源http://example.com/dir/other.html：不同源（域名不同）http://v2.www.example.com/dir/other.html：不同源（域名不同）http://www.example.com:81/dir/other.html：不同源（端口不同） 同源策略目的同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据; 设想这样一种情况: A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏; 更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以内置一些A网站的访问路径, 因为这样就可以拿到A网站之前存在用户本地的cookie, 这样就可以冒充用户，为所欲为，因为浏览器同时还规定，提交表单不受同源政策的限制 ; 由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了 ; 同源策略的限制范围随着互联网的发展, “同源政策”越来越严格, 目前, 如果非同源, 共有三种行为受到限制 : Cookie、LocalStorage 和 IndexDB 无法读取DOM 无法获得AJAX 请求不能发送虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响, 将详细介绍，如何合理规避上面三种限制 ; 摘自 阮一峰","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]}]}