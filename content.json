{"meta":{"title":"Lant's","subtitle":null,"description":null,"author":"Lant","url":"http://blog.renyimin.com"},"pages":[{"title":"标签","date":"2017-09-17T02:40:21.000Z","updated":"2017-09-18T09:08:03.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.renyimin.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-09-17T02:40:28.000Z","updated":"2017-09-18T09:08:09.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.renyimin.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"String常用操作 (StringUtils)","slug":"SpringFramework5/2019-05-27-15","date":"2019-05-27T11:20:11.000Z","updated":"2019-09-03T03:52:53.000Z","comments":true,"path":"2019/05/27/SpringFramework5/2019-05-27-15/","link":"","permalink":"http://blog.renyimin.com/2019/05/27/SpringFramework5/2019-05-27-15/","excerpt":"","text":"StringUtils类中的方法其实真的还是很多, 可能平时我们用的比较多的还是一些普通的方法, 其实类似文件路径, 文件名等相关操作, 以前还会专门引入common-io的FilenameUtils等额外的工具类, 原来在StringUtils中都有, 而且根据其设计的这些方法, 我们也能大概的猜出一些方法在Spring中哪些地方可能有用；最后, 其中有些方法, 还是非常常见的面试题, 比如替换字符串, 查询子串个数等, 有兴趣也可以看看Spring的具体实现。 org.apache.commons.lang3.StringUtils参考https://www.jianshu.com/p/da7d986cf19e","categories":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/tags/Spring/"}]},{"title":"","slug":"SpringFramework5/2019-05-27-17","date":"2019-05-27T10:23:39.000Z","updated":"2019-09-03T06:22:12.000Z","comments":true,"path":"2019/05/27/SpringFramework5/2019-05-27-17/","link":"","permalink":"http://blog.renyimin.com/2019/05/27/SpringFramework5/2019-05-27-17/","excerpt":"","text":"","categories":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/tags/Spring/"}]},{"title":"","slug":"SpringFramework5/2019-05-27-16","date":"2019-05-27T10:23:39.000Z","updated":"2019-09-03T06:18:25.000Z","comments":true,"path":"2019/05/27/SpringFramework5/2019-05-27-16/","link":"","permalink":"http://blog.renyimin.com/2019/05/27/SpringFramework5/2019-05-27-16/","excerpt":"","text":"","categories":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/tags/Spring/"}]},{"title":"Spring 事务控制","slug":"SpringFramework5/2019-05-25-11","date":"2019-05-25T07:20:11.000Z","updated":"2019-08-12T09:45:19.000Z","comments":true,"path":"2019/05/25/SpringFramework5/2019-05-25-11/","link":"","permalink":"http://blog.renyimin.com/2019/05/25/SpringFramework5/2019-05-25-11/","excerpt":"","text":"注解AOP的问题AOP 的 后置通知 和 最终通知 在注解配置时, 其执行顺序是有问题, 会导致事务出现问题, 先释放了事务, 然后再提交或者回滚, 是有问题的; 可以自己写环绕通知来解决 声明式事务 Spring为我们提供了一组事务控制的API (即在 spring-tx 包中)","categories":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/tags/Spring/"}]},{"title":"JdbcTemplate","slug":"SpringFramework5/2019-05-19-10","date":"2019-05-19T12:19:36.000Z","updated":"2019-08-12T09:15:56.000Z","comments":true,"path":"2019/05/19/SpringFramework5/2019-05-19-10/","link":"","permalink":"http://blog.renyimin.com/2019/05/19/SpringFramework5/2019-05-19-10/","excerpt":"","text":"概述 JdbcTemplate 是 spring 框架中提供的一个对象, 是对原始 Jdbc API 对象的简单封装 Spring 框架为我们提供了很多 操作模板类 操作关系型数据的: JdbcTemplate、HibernateTemplate 操作 nosql 数据库的: RedisTemplate 操作消息队列的: JmsTemplate 在导包的时候，除了要导入这个 spring-jdbc-5.1.4.RELEASE.jar 包外, 还需要导入一个 spring-tx-5.1.4.RELEASE.jar (它是和事务相关的) 下图仅供参考 JdbcTemplate JdbcTemplate 最基本的使用 基于 ioc, JdbcTemplate 最基本的使用 JdbcTemplate 基本的 crud 操作 JdbcTemplate 在Dao中的使用 JdbcDaoSupport 使用, 解决各个 Dao 中的重复代码","categories":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/tags/Spring/"}]},{"title":"AOP (Aspect Oriented Programming) 面向切面编程","slug":"SpringFramework5/2019-05-18-09","date":"2019-05-18T09:57:29.000Z","updated":"2019-08-30T03:49:37.000Z","comments":true,"path":"2019/05/18/SpringFramework5/2019-05-18-09/","link":"","permalink":"http://blog.renyimin.com/2019/05/18/SpringFramework5/2019-05-18-09/","excerpt":"","text":"概述 AOP 是使用 动态代理的方式 实现的 (在程序运行期间, 不用去修改源码即可对原有方法进行增强, 满足 开闭原则 ) Spring中的AOP 是通过配置来实现上一篇中的动态代理功能的 (Spring同样提供了 基于xml配置 和 基于注解 两种方式来实现AOP) Spring的AOP可以手动选择动态代理是 基于接口的 还是 基于子类的 术语 Join point 连接点: 在Spring中指的就是 委托类中的所有方法 Point cut 切入点: 代理类在 invoke 中还可以决定对 委托类 的哪些方法进行增强, 被增强的连接点就是切入点 (切入点一定是连接点, 连接点不一定是切入点) Advice 通知: 即拦截到连接点时要做的事情, 通知的类型分为 前置通知, 后置通知, 异常通知 (在 catch 块中的), 最终通知 (在 finally 块中的), 环绕通知 … 基于XML的AOP项目准备 Demo 切入点表达式写法（后置通知和异常通知只会执行一个, 最终通知无论有没有异常都会执行） 环绕通知除了通过配置的方式来实现对方法的增强, 还可以使用Spring为我们提供的 环绕通知 基于注解的AOP下面仍包含了少量的xml配置 基于注解AOP的问题发现通过注解的方式使用AOP时, 后置通知的顺序有问题, 跑到了最终通知的后面 基于注解环绕通知此时可以通过 环绕通知 解决上述问题 纯注解AOP","categories":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/tags/Spring/"}]},{"title":"静态代理, 动态代理","slug":"SpringFramework5/2019-05-18-08","date":"2019-05-18T09:36:13.000Z","updated":"2019-08-30T03:44:22.000Z","comments":true,"path":"2019/05/18/SpringFramework5/2019-05-18-08/","link":"","permalink":"http://blog.renyimin.com/2019/05/18/SpringFramework5/2019-05-18-08/","excerpt":"","text":"代理 Proxy Proxy代理模式 是一种 结构型 设计模式, 是一种常用的设计模式, 主要解决的问题是: 在直接访问对象时所带来的问题 其目的就是为某个对象提供一个代理, 以控制对该对象的访问, 代理类负责为委托类 预处理消息、过滤消息并转发消息、以及进行 被委托类执行后的 后续处理 为了保持行为的一致性, 代理类 和 委托类 通常会实现相同的接口, 所以在访问者看来两者没有丝毫的区别; 通过代理类这中间一层, 能有效控制对委托类对象的直接访问, 也可以很好地隐藏和保护委托类对象, 同时也为实施不同控制策略预留了空间, 从而在设计上获得了更大的灵活性 更通俗的说, 当两个类需要通信时, 引入第三方代理类, 将两个类的关系解耦, 让我们只了解代理类即可, 而且代理的出现还可以让我们完成与另一个类之间的关系的统一管理, 但是切记, 代理类和委托类要实现相同的接口, 因为代理真正调用的还是委托类的方法 按照代理的创建时期, 代理类可以分为两种: 静态: 由程序员创建代理类或特定工具自动生成源代码再对其编译, 在程序运行前代理类的.class文件就已经存在了 动态: 在程序运行时运用反射机制动态创建而成 下面分别用静态代理与动态代理演示一个示例: 添加打印日志的功能, 即每个方法调用之前和调用之后写入日志 静态代理DEMO 静态代理优点通过 代理 使 客户端 不需要知道实现类是什么, 怎么做的, 而客户端只需知道代理即可(解耦合), 对于如上的客户端代码, newUserManagerImpl() 可以应用 工厂 或 IOC 将它隐藏, 如上只是举个例子而已 静态代理缺点 代理类 和 委托类 实现了相同的接口, 代理类 和 委托类 也都会实现相同的方法, 这样就出现了大量的代码重复, 如果接口增加一个方法, 除了所有实现类需要实现这个方法外, 所有代理类也需要实现此方法, 增加了代码维护的复杂度 代理对象只服务于一种类型的对象, 如果要服务多类型的对象, 势必要为每一种对象都进行代理, 静态代理在程序规模稍大时就无法胜任了如上的代码是只为UserManager类的访问提供了代理, 但是如果还要为其他类如Department类提供代理的话, 就需要我们再次添加代理Department的代理类 即静态代理类只能为特定的接口(Service)服务, 如想要为多个接口服务则需要建立很多个代理类 静态代理小结代理可以对实现类进行统一的管理, 如在调用具体实现类之前, 需要打印日志等信息, 这样我们只需要添加一个代理类, 在代理类中添加打印日志的功能, 然后调用实现类, 这样就避免了修改具体实现类, 满足开闭原则; 但是如果想让不同类型的其他实现类都添加打印日志的功能的话, 就需要添加多个代理类, 并且代理类中各个方法都需要添加打印日志功能(如上的代理方法中删除, 修改, 以及查询都需要添加上打印日志的功能) 动态代理 (基于接口)根据如上的介绍, 你会发现每个代理类只能为一个接口服务, 这样程序开发中必然会产生许多的代理类, 所以我们需要的是 通过一个代理类完成全部的代理功能, 那么我们就需要用动态代理 在上面的示例中, 一个代理只能代理一种类型, 而且是在编译期就已经确定被代理的对象, 而动态代理是在运行时 通过反射机制实现动态代理, 并且能够代理各种类型的对象 在Java中要想实现 动态代理 机制, 需要 java.lang.reflect.InvocationHandler接口 和 java.lang.reflect.Proxy类 的支持 可以看到, 我们可以通过 LogHandler 代理不同类型的对象, 如果我们把对外的接口都通过动态代理来实现, 那么所有的函数调用最终都会经过 invoke函数 的转发, 因此我们就可以在这里做一些自己想做的操作, 比如日志系统、事务、拦截器、权限控制等, 这也就是AOP(面向切面编程)的基本原理 小结: 动态代理与静态代理相比较, 最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）这样, 在接口方法数量比较多的时候, 我们可以进行灵活处理, 而不需要像静态代理那样每一个方法进行中转;而且动态代理的应用使我们的类职责更加单一, 复用性更强 动态代理(基于子类)基于接口的动态代理, 委托类必须实现接口 (上面已经演示过了), 下面看基于子类的动态代理 提供者：第三方cglib库 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt;&lt;/dependency&gt; 涉及的类：Enhancer 使用 Enhancer 类中的 create 方法创建代理对象 创建代理对象的要求: 被代理类不能是最终类(不能被 final 修饰) Demo Demo 转载https://blog.csdn.net/hejingyuan6/article/details/36203505","categories":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/tags/Spring/"}]},{"title":"Spring 整合 Junit","slug":"SpringFramework5/2019-05-14-07","date":"2019-05-14T08:47:31.000Z","updated":"2019-08-30T03:32:28.000Z","comments":true,"path":"2019/05/14/SpringFramework5/2019-05-14-07/","link":"","permalink":"http://blog.renyimin.com/2019/05/14/SpringFramework5/2019-05-14-07/","excerpt":"","text":"使用Junit进行之前的测试如下, 直接加上对junit的依赖即可 问题出现 在测试类中, 每个测试方法都会有以下代码: 12// ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class); 针对上述问题, 我们需要的是程序能自动帮我们创建容器 而 junit 是无法实现的, 它甚至无法知晓我们是否使用了 spring 框架, 更不用说帮我们创建 spring 容器了 不过, junit 给我们暴露了一个注解, 可以让我们替换掉它的运行器, 这时, 我们需要依靠 spring 框架, 因为它提供了一个运行器, 可以读取配置文件(或注解)来创建容器, 我们只需要告诉它配置文件在哪就行了 Spring 整合 Junit1.使用 @RunWith 注解替换原有运行器 2.使用 @ContextConfiguration 注解 指定 spring 配置文件的位置locations属性: 用于指定xml配置文件的位置(如果是类路径下, 需要用 classpath: 表明)classes属性: 用于指定注解的类 (当不使用 xml 配置时, 需要用此属性指定注解类的位置) 3.使用 @Autowired 给测试类中的变量注入数据 demo 转载https://blog.csdn.net/hejingyuan6/article/details/36203505","categories":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/tags/Spring/"}]},{"title":"基于注解的IOC配置","slug":"SpringFramework5/2019-05-12-05","date":"2019-05-12T11:36:11.000Z","updated":"2019-08-30T02:53:00.000Z","comments":true,"path":"2019/05/12/SpringFramework5/2019-05-12-05/","link":"","permalink":"http://blog.renyimin.com/2019/05/12/SpringFramework5/2019-05-12-05/","excerpt":"","text":"Spring2.0 开始引入基于注解的配置方式, 即 Bean的定义信息可以通过在 Bean的实现类上 标注注解来实现 注解配置和 xml 配置要实现的功能都是一样的, 都是要降低程序间的耦合, 只是配置的形式不一样, 关于实际的开发中到底使用 xml 还是注解, 每家公司有着不同的使用习惯 (基于注解的配置需要 aop jar 包) 创建 spring 的 xml 配置文件并开启对注解的支持 (基于注解整合时, 导入约束时需要多导入 context 名称空间下的约束) 下面开始介绍 Spring IOC 的常用注解 用于创建Bean的注解作用和之前学的使用xml实现ioc时, 配置一个 &lt;bean id=&quot;accountService&quot; class=&quot;com.spring.study.service.impl.AccountServiceImpl&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt; 是类似的 @Component该注解用于把当前类对象存入Spring容器中属性 value: 指定 bean 的 id (如果不指定 value 属性, 默认 bean 的 id 是当前类的类名, 首字母小写) tips: 要知道, 只在类上加了 @Component 并不能完成 “将类对象存入Spring容器因为我们目前仍然是通过 new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); 来创建容器的, 因此 bean.xml 需要知道你在哪些地方使用了 @Component所以会用到新的xml标签 &lt;context:component-scan base-package=&quot;要扫描的包&quot;&gt;&lt;/context:component-scan&gt;, 用来指定将要扫描的注解的位置 另外几个注解@Controller、 @Service、 @Repository, 他们三个注解都是针对 @Component 的衍生注解, 作用及属性都一样, 只不过是提供了更加明确的语义化 @Controller: 一般用于表现层的注解 @Service: 一般用于业务层的注解 @Repository: 一般用于持久层的注解 小结相比 使用xml配置来创建bean, xml + annotation 的方式只用在xml中配置很少的内容, 然后对于需要被Spring容器管理的对象, 在其类上加上以上注解即可（但此时仍然需要在xml中进行配置, 为了说明你使用注解的地方） 用于 注入依赖bean 的注解作用和之前学的使用xml实现 ioc 时, 在 &lt;bean&gt; 下通过 &lt;property name=&quot;&quot; value=&quot;&quot;&gt;&lt;/property&gt; 或 &lt;property name=&quot;&quot; ref=&quot;&quot;&gt;&lt;/property&gt; 是类似的 @Autowired其作用是自动按照类型注入, 只要容器中有唯一的一个bean对象的类型 和 @Autowired 所修饰的要注入的变量的类型一致, 就可以注入成功; 该注解可以修饰 成员变量、方法 …… 如果容器中没有任何对象的类型与当前变量类型匹配, 则注入失败会报错 如果容器中有多个对象(的类型与当前变量类型匹配时, 会继续使用当前变量名称作为 bean的id进行匹配, 如果id都不匹配则报错) tip: 值得注意的是, 在 AccountServiceImpl 中注入 AccountDaoImpl 时, 并没有使用之前xml配置ioc时的三种方式 (并没有 setter), 这是肿么回事儿?@Autowired 方式是通过万能而无节操的反射设置属性值的…. （有空可以看看源码） @Qualifier相比于 @Autowired, @Qualifier 会同时按照 类型 和 bean的id 进行匹配属性 value : 用于指定注入bean的id @Qualifier 略微闹心, 在修饰类成员变量时, 不能单独使用, 还得使用 @Autowired tips: 它在给类成员注入时不能单独使用, 但是在给方法参数注入时可以单独使用 (如: public QueryRunner createQueryRunner(@Qualifier(&quot;ds2&quot;) DataSource dataSource){, 指明当Spring容器中有多个类型都为 DataSource 的bean对象时, 此处取name为ds2的) @Resource相比之前两种, @Resource 可以直接按照bean的id进行注入, 并且可以单独使用 但是它的属性是 name, 用来指明bean的id 基本类型 的注入 以上注解都只能注入其他bean类型的数据, 而 基本类型 和 String类型 无法使用上述注解实现 另外, 集合类型的注入只能使用 xml 配置的方式进行注入 @Value其作用用于注入 基本类型 和 String类型 的数据 属性value用于指定数据的值, 同时它还可以使用 Spring 中的 SpEL表达式 (el表达式的写法 ${表达式}) 用于改变作用范围的注解@Scope作用 和 之前学的使用xml实现ioc时, 在 &lt;bean&gt; 中使用 scope 属性是类似的 属性value: 用于指定范围, 取值为 (singleton: 默认值, 单例的、prototype: 多例的 、…) 可以用在类上(当类使用了创建bean的注解时,可以一起用), 也可以用在返回bean对象的方法上(当方法上使用了 @Bean 将bean交给Spring容器进行管理时, 可以一起使用) 用于生命周期的注解作用和之前学的使用xml实现ioc时, 在 &lt;bean&gt; 中使用 init-method、destroy-method 属性是类似的用于方法上, 指定方法为 初始化方法 或者 销毁方法 (如果是多例对象的话, 调用销毁方法没效, 因为多例的销毁是JVM进行的) @PostConstruct指定初始化方法 @PreDestroy指定销毁方法 xml + 注解 的IOC到目前为止我们仍未脱离 xml配置: 对于上面的示例中的操作, 相比 使用xml配置来 创建bean 或者 依赖注入, xml+annotation 的方式只用在xml中配置很少的内容（为了说明你使用注解的地方）, 然后对于需要被Spring容器管理的对象, 在其类上加上以上注解即可 几个问题 注解配置Ioc的问题： 试想一下, 一旦当我们所依赖的对象是其他 jar 包中的类时, 我们是无法使用 注解 方法完成bean的创建 和 注入 的, 因为我们无法在别人jar包的代码中加注解 如何将 xml配置 直接取消, 完全使用纯注解进行 IOC 配置呢 ? 纯注解配置IOC Spring的几个新注解在纯注解配置IOC时, 如果要对配置类进行拆分, 比如 公共配置类, 和多个专项配置类, 如果拆开的话, 由于主配置类文件中的扫描路径不包含 config路径, 所以会报错, 可以如下:或者 如果不希望每个配置类都配置 @Configuration, 并且在主配置类中还要修改 @ComponentScan 设置多个路径或者也不希望在 AnnotationConfigApplicationContext 中传递多个配置类该怎么办? @Import用于导入其他配置类; 属性value, 用于指定其他配置类的字节码 @PropertySource用于指定 properties 文件的路径, 属性value用来指定文件的路径 （value中的关键字classpath:表示类路径下）当使用 @Configuration 修饰的配置类, 并通过在其中的方法上使用 @Bean 来将bean对象交给Spring容器管理时, 比如在操作数据库时, 由于需要设置一些datasource的数据参数, 这些参数就写死到了 方法中 此时就需要使用 @PropertySource 并且配合 @Value来将这些基本类型进行注入 关于 Spring 注解和 XML 的选择问题 注解的优势: 配置简单, 维护方便 (我们找到类, 就相当于找到了对应的配置) XML 的优势: 修改时, 不用改源码。不涉及重新编译和部署","categories":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/tags/Spring/"}]},{"title":"基于 XML 的 IOC 配置","slug":"SpringFramework5/2019-05-12-04","date":"2019-05-12T07:07:48.000Z","updated":"2019-08-29T04:01:20.000Z","comments":true,"path":"2019/05/12/SpringFramework5/2019-05-12-04/","link":"","permalink":"http://blog.renyimin.com/2019/05/12/SpringFramework5/2019-05-12-04/","excerpt":"","text":"认识 Spring 的配置文件 Spring的配置文件 其实就是Spring容器对Bean进行生产以及关系注入的图纸, 它是Spring的基础, 如果没有配置文件的话, 则 Spring 的容器将无从谈起Spring 的配置文件 是用于指导 Spring 工厂进行 Bean 的生产、依赖关系注入及 Bean 实例分发的”图纸”, 我们必须学会并灵活应用这份”图纸”, 准确地表达自己的”生产意图”, 它是一个或多个标准的XML文档 (ApplicationContext.xml 是Spring的默认配置文件, 当容器启动时找不到其他的配置文件时, 则会尝试加载这个默认的配置文件) Spring启动时会读取 配置文件 中提供的Bean的配置信息, 并在Spring容器中生成一份相应的Bean的配置注册表, 然后根据这张注册表来实例化Bean, 装配好Bean之间的依赖关系, 为上层应用提供准备就绪的运行环境 bean的配置信息就是Bean的元数据信息, 由以下五个方面来组成: Bean的一些属性信息: 比如 数据源的连接数, 用户名和密码等等 Bean的依赖关系: Spring根据依赖关系配置完成Bean之间的装配 Bean的行为配置: 比如, 生命周期范围以及生命周期各个过程的回调函数等 Bean的创建方式定义: 主要说明是通过构造器还是工厂方法来构造Bean 有时, 一个项目中可能存在多个配置文件, 那么Spring项目加载多个配置文件的方法如下: 在配置文件中使用 import 来导入所需的配置文件 将多个配置文件构造为一个数组, 然后传递给 ApplicationContext 这两种方式都是通过调用 BeanDefinitionReader 来读取定义文件的, 在内部实现上没有任何的区别 在大型的Spring项目当中, 所有的bean配置在一个配置文件当中很不容易管理且也不利于团队的开发; 因此, 通常在开发过程当中, 我们会按照 功能模块和开发人员 来将配置文件分成多个, 这样会有利与模块的划分, 接下来我们需要使用 import 属性来引入多个配置文件到项目当中 xml 配置 ioc在项目根目录下创建任意名称的 xml 文件 (此处为 bean.xml): 给配置文件导入约束 (查看文档/spring-framework-5.1.4.RELEASE/docs/spring-framework-reference/core.html)如下就做好了准备工作 配置 &lt;bean&gt; 标签 其作用就是配置对象以让 spring 进行创建, 默认情况下它调用的是类中的无参构造函数, 如果没有无参构造函数则不能创建成功 属性: id: 给对象在容器中提供一个唯一标识, 用于获取对象 class: 指定类的全类名, 用于反射创建对象 (默认情况下调用无参构造函数) scope: 指定对象的作用范围 12345singleton: 默认值, 单例的prototype: 多例的request: WEB项目中, Spring创建一个Bean的对象, 将对象存入到request域中session: WEB项目中, Spring创建一个Bean的对象, 将对象存入到session域中global session: 作用于集群环境的会话范围, 当不是集群环境时, 则作用于session init-method: 指定类中的初始化方法名称 destroy-method: 指定类中销毁方法名称 bean 的作用范围和生命周期单例对象: scope=&quot;singleton&quot; 一个应用只有一个对象的实例, 它的作用范围就是整个应用 生命周期: 对象出生: 当容器创建时(配置文件被加载时), 对象立刻就被创建了 对象活着: 只要容器在, 对象一直活着 对象死亡: 容器销毁时, 对象就被销毁了 小结: 单例对象的生命周期和容器相同 多例对象: scope=&quot;prototype&quot; 每次访问对象时, 都会重新创建对象实例 生命周期: 对象出生: 当获取对象时, 才会创建新的对象实例 对象活着: 只要对象在使用中, 就一直活着 对象死亡: 当对象长时间不用时, 且没有别的对象使用时, 会被 java 的垃圾回收器回收了 ApplicationContext 接口的实现类 ClassPathXmlApplicationContext: 可以加载类路径下的配置文件, 否则无法加载 （实际开发中, 相比第二种而言, 这种比较常用） FileSystemXmlApplicationContext: 可以加载磁盘任意路径下的配置文件 (必须有访问权限) AnnotationConfigApplicationContext: 用于读取注解创建容器 BeanFactory 和 ApplicationContext BeanFactory 才是 Spring 容器中的顶层接口, ApplicationContext 是它的子接口下面还可以查看其实现类 两者创建对象的时间点不一样BeanFactory: 创建对象采取的是延迟加载, 什么时候get, 什么时候创建对象 （所以 多例 貌似比较适用）ApplicationContext: 只要一读取配置文件, 默认情况下就会创建对象 （所以 单例 貌似比较适用） 实际开发中更多适用 ApplicationContext 创建 Bean 的三种配置方式使用默认无参构造函数12&lt;!--在默认情况下: 它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数, 将会创建失败--&gt;&lt;bean id=&quot;accountService&quot; class=&quot;com.spring.study.service.impl.AccountServiceImpl&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt; 使用静态工厂的方法创建对象1234567891011121314/*** 模拟一个静态工厂, 创建业务层实现类*/public class StaticFactory &#123; public static IAccountService createAccountService()&#123; return new AccountServiceImpl(); &#125; &#125;&lt;!-- 此种方式是: 使用 StaticFactory 类中的静态方法 createAccountService 创建对象, 并存入 spring 容器id 属性: 指定 bean 的 id, 用于从容器中获取 class 属性: 指定静态工厂的全限定类名 factory-method 属性: 指定生产对象的静态方法--&gt;&lt;bean id=&quot;accountService&quot; class=&quot;com.spring.study.factory.InstanceFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt; 使用实例工厂的方法创建对象1234567891011121314151617/*** 模拟一个实例工厂, 创建业务层实现类* 此工厂创建对象, 必须现有工厂实例对象, 再调用方法 */public class InstanceFactory &#123;public IAccountService createAccountService()&#123; return new AccountServiceImpl(); &#125;&#125;&lt;!-- 此种方式是:先把工厂的创建交给 spring 来管理然后在使用工厂的 bean 来调用里面的方法 factory-bean 属性: 用于指定实例工厂 bean 的 idfactory-method 属性: 用于指定实例工厂中创建对象的方法--&gt;&lt;bean id=&quot;instancFactory&quot; class=&quot;com.spring.study.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;accountService&quot; factory-bean=&quot;instancFactory&quot; factory-method=&quot;createAccountService&quot;&gt;&lt;/bean&gt; Ioc (注入 Bean) 的三种方式构造函数注入 (constructor-arg)顾名思义, 就是使用类中的构造函数, 给成员变量赋值 (注意: 赋值的操作不是我们自己做的, 还是通过配置的方式, 让 spring 框架来为我们注入) set 方法注入 (property) p 名称空间注入数据 (p:)使用 p名称空间 注入数据(本质还是调用 set 方法, 即 类的属性需要有对应的setter)参考文档 /spring-framework-5.1.4.RELEASE/docs/spring-framework-reference/core.html 在xml中导入 P命名空间测试 如何注入集合属性?","categories":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/tags/Spring/"}]},{"title":"最基础的 Spring 项目","slug":"SpringFramework5/2019-05-12-03","date":"2019-05-12T06:35:09.000Z","updated":"2019-08-29T03:38:45.000Z","comments":true,"path":"2019/05/12/SpringFramework5/2019-05-12-03/","link":"","permalink":"http://blog.renyimin.com/2019/05/12/SpringFramework5/2019-05-12-03/","excerpt":"","text":"手动创建1.创建普通Java项目 2.在项目目录下创建 libs 目录 ( 右击 项目目录 —&gt; “Add as library”) 3.导入所需的 Spring 包 核心容器四个包spring-beans-5.1.4.RELEASE.jarspring-context-5.1.4.RELEASE.jarspring-core-5.1.4.RELEASE.jarspring-expression-5.1.4.RELEASE.jar 核心容器依赖的日志包commons-logging-1.2.jar ( commons-logging 相当于一个日志接口, log4j相当于该接口的实现, 如果不添加log4j包也可以, 因为commons-logging也有一个简单的实现会自动使用)log4j-1.2.17.jar 测试类包spring-test-5.1.4.RELEASE.jarjunit-4.12.jar(高于4.10版本还需要hamcrest-core.jar + hamcrest-library.jar) 测试类用到了AOP必须导入aop包spring-aop-4.1.3.RELEASE.jar 4.这样一个Spring项目所需要的最基础的环境就搭建完成了 当然, 现在一般不像上面那样创建项目, 而是选择 Maven 等构件工具来创建项目 Maven创建 (推荐)1.创建maven空项目 2.导入所需的 Spring 包Spring框架提供了很多服务, 但这些服务并不是默认为应用打开的, 应用可以按需指明使用的服务 和手动创建时一样, 不过此处是在maven项目的 pom 文件中指定对应的包坐标 3.注意: 创建Spring基础项目的话, 其实只用导入 spring-context 即可自动拉取创建基本Spring项目所需的jar包(apo:是基于注解配置IOC所要依赖的jar, spring不知道你将来会使用xml还是注解配置IOC, 所以会将aop包也导入)可以查看 spring-context 的依赖 (我们的项目依赖了 spring-context, 而spring-context依赖的包如下) 参考:https://www.cnblogs.com/mibloom/p/9871652.html","categories":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/tags/Spring/"}]},{"title":"Spring 核心 之 DI、IOC","slug":"SpringFramework5/2019-05-11-02","date":"2019-05-11T03:15:31.000Z","updated":"2019-08-29T03:29:18.000Z","comments":true,"path":"2019/05/11/SpringFramework5/2019-05-11-02/","link":"","permalink":"http://blog.renyimin.com/2019/05/11/SpringFramework5/2019-05-11-02/","excerpt":"","text":"概述 控制反转(Inversion of Control, IOC) 不是什么技术, 而是一种设计思想传统的创建对象的方法是直接通过 new 关键字, 而 Spring 则是通过 IOC 容器来创建对象, 也就是说我们将创建对象的控制权交给了 IOC 容器, 控制权发生了转移而 IOC 让程序员不再关注怎么去创建对象, 而是关注与对象创建之后的操作, 把对象的创建、初始化、销毁等工作交给Spring容器来做, 所有的类的创建、销毁都由 spring来控制, 也就是说控制对象生存周期的不再是引用它的对象, 而是spring, 对于某个具体的对象而言, 以前是它控制其他对象, 现在是所有对象都被spring控制, 所以这叫控制反转 对于 Spring框架 来说, Ioc 就是由 Spring 来负责控制对象的生命周期和对象间的关系 在传统的程序开发中, 在一个对象中, 如果要使用另外的对象, 就必须得到它 (自己new一个, 或者从JNDI中查询一个), 使用完之后还要将对象销毁(比如Connection等), 这样会导致当前对象 和 其他的接口或类藕合起来 而对于IoC, 有点像通过婚介找女朋友, 在我和女朋友之间引入了一个第三者: 婚姻介绍所。婚介管理了很多男男女女的资料, 我可以向婚介提出一个列表, 告诉它我想找个什么样的女朋友, 比如长得像李嘉欣, 身材像林熙雷, 唱歌像周杰伦, 速度像卡洛斯, 技术像齐达内之类的, 然后婚介就会按照我们的要求, 提供一个mm, 我们只需要去和她谈恋爱、结婚就行了。简单明了, 如果婚介给我们的人选不符合要求, 我们就会抛出异常。整个过程不再由我自己控制, 而是有婚介这样一个类似容器的机构来控制。 Spring所倡导的开发方式就是如此, 所有的类都会在spring容器中登记, 告诉Spring你是谁, 你需要什么, 然后spring会在系统运行到适当的时候, 把你要的东西主动给你, 同时也把你交给其他需要你的东西 Ioc 和 DI 大致可以认为是一个意思, 不同的叫法 (使用 Spring容器进行 依赖注入 后, 控制权就发生了反转 😆!) Ioc 的三种依赖注入方式后面会讲到","categories":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/tags/Spring/"}]},{"title":"Spring Framework 5 入门","slug":"SpringFramework5/2019-05-11-01","date":"2019-05-11T03:12:31.000Z","updated":"2020-03-13T02:53:56.000Z","comments":true,"path":"2019/05/11/SpringFramework5/2019-05-11-01/","link":"","permalink":"http://blog.renyimin.com/2019/05/11/SpringFramework5/2019-05-11-01/","excerpt":"","text":"当谈到 “Spring” 时，通常在说什么? 术语 “Spring” 在不同的上下文中表示不同的事物。它可以用来指代 Spring Framework 项目本身(当然一切都是从这里开始的)。随着时间的流逝，其他Spring项目已经建立在Spring Framework之上。通常，当人们说“春天”时，它们表示整个项目系列 （即Spring生态）。 JDK8+从Spring Framework 5.1开始，Spring需要JDK 8+（Java SE 8+） Spring 生态的基础Spring Framework 项目是整个Spring生态的基础，包含了Spring生态最核心的功能 为企业级开发提供了丰富的功能 控制反转(IOC) 面向切面编程(AOP) Web框架: Spring MVC？ 众多辅助及工具类? 众多服务？ 轻量级- 模块分离 单元测试？ …… 仓库地址下载并解压 spring-framework-5.1.4.RELEASE-dist.zip 后, 可以看到 Spring Framework 有 docs、libs 和 schema 文件夹 其中libs文件夹下是所需要的jar包(从Spring 5 RELEASE版本开始, Spring 提供了21个模块, 可以看到每一模块都有三个jar包, 分别为类库、文档和源码, 所以总共会有63个jar包), 在项目中引用Spring Framework时, 应该按需引用所需的类库 下图是从 spring-framework-5.1.4.RELEASE 解压包下的 docs/spring-framework-reference/images 中拿到的Spring 总共大约有 21 个模块, 而这些组件被分别整合在 核心容器(Core Container)、AOP(Aspect Oriented Programming)、设备支持(Instrmentation)、 数据访问及集成(Data Access/Integeration)、Web、报文发送(Messaging)、Test 7个模块集合中 Spirng 各模块之间的依赖关系该图是 Spring5 的包结构, 可以从中清楚看出 Spring 各个模块之间的依赖关系 另外, 因为 spring-core 依赖了 commons-logging, 而其他模块都依赖了 spring-core, 所以整个spring框架都依赖了commons-logging日志框架有多种, 也不一定使用commons-logging, 如果有自己的日志实现如 log4j, 可以排除对 commons-logging 的依赖, 否则会编译报错","categories":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.renyimin.com/tags/Spring/"}]}]}