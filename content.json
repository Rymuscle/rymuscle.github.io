{"meta":{"title":"Lant's Blog","subtitle":null,"description":null,"author":"Lant","url":"http://blog.renyimin.com"},"pages":[{"title":"标签","date":"2017-09-17T02:40:21.000Z","updated":"2017-09-18T09:08:03.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.renyimin.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-09-17T02:40:28.000Z","updated":"2017-09-18T09:08:09.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.renyimin.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Restful API 安全性相关知识 (持续完善中...)","slug":"restful--01--安全","date":"2016-07-19T04:21:08.000Z","updated":"2017-10-24T09:39:11.000Z","comments":true,"path":"2016/07/19/restful--01--安全/","link":"","permalink":"http://blog.renyimin.com/2016/07/19/restful--01--安全/","excerpt":"","text":"背景曾经在公司做过一个简单的 前后端分离 小项目, 由于项目整体业务比较简单, 所以也让我有时间重新对restful api的接口安全行知识进行了简单地梳理;当然, 文章会随着以后的积累不断进行调整和优化, 也希望大家能够多提出一些宝贵的意见一起进行交流 ; Restful API – 接口安全性(整套方案可以参考微信公众平台)1.Restful API的安全性包括的内容其实比较多, 目前我所了解的主要有:客户端的身份认证 : 判断请求来源是否合法;敏感数据的加密, 防篡改 : HTTPS, 数据加密, 签名;replay的防范 : 防止重放攻击, 在冗余重放时间(服务器间时间误差)内结合nonce参数来保证;api请求速率限制 : 为防止恶意调用(例如，限制每个用户的API的使用是在?秒内最多?次的API调用，当然速率要调整好)。 可以参考微信公众平台的接口校验规则 (可以参考微信开放平台PHP对接的demo文件):微信公众平台上有三种接口授权的安全交互方式:1.微信公众平台配置服务器时设置的 url, token 以及生成 EncodingAESKey 是为了让你确保你的公众平台服务器能够安全地 接收 来自微信服务器的请求，当然, 你也可以选择不进行校验, 不过对于你的服务器来说当然就是比较危险的, 因为一旦你的接口地址泄露, 就有可能被恶意调用; 开发者的服务器通过调用微信服务器上的基础接口, 对外提供了很多可能包含用户资料的接口, 这样就要防止外部恶意窃取和调用; 2.而微信公众平台通过AppID和AppSecret获取的access_token, 这个也是 微信服务器 为了安全起见, 授予 开发者服务器 的token, 让我们有了这个令牌才可以调用人家的接口; 属于OAuth的 Client Credentials Grant 授权方案(客户端以自己的名义, 而不是以用户的名义, 向”服务提供商”进行认证), 获取access_token的接口如下:https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET 如果你们公司有 数据中心, 支付中心, 用户中心 等比较核心的服务来为公司的各个系统提供接口支持, 那你可能就需要有一个后台 授权服务系统, 专门管理这些服务中心的接口对内部系统的授权, 可以为每个系统生成 APPID, APP_SECRET然后各系统使用APPID, APP_SECRET 到 授权服务系统 申请access_token,然后使用access_token来决定是否能调用本服务中的接口; 3. 为什么开发者服务器调用微信服务器接口的时候, 不采用上一种方式呢? 其接口本身就是开放出来供客户端服务器使用的, 都是基础性的功能接口, 而且是由能提供access_token的开发者服务器调用, 不用对参数做过多校验, 只要开发者服务器被授权就可以调用 ; 3.OAuth网页授权 (授权码模式, 客户端是以用户的名义 向”服务提供商”进行认证) 微信公众平台并没有通过APPID和APPSECRET来对客户端(我们自己的开发者服务器)进行校验, 而是通过 Token 来识别调用我们的开发者服务器的, 这个token是自主设置，与公众平台wiki中常提的access_token不是一回事, 这个token只用于验证开发者服务器; 另外, 微信公众平台使用了APPID来对传输的内容进行加密; 注意: 服务器url和token为了保证在泄露之后不被别人利用, 我们还需要对ToUserName进行校验, 验证ToUserName是否和你的公众号匹配, 否则你的公众平台服务器上的功能有可能被他人使用;) 微信的签名是使用 SHA1 生成的(参考 密码相关); 3. https://segmentfault.com/q/1010000011674185?_ea=2728292 客户端身份认证 HTTP BasicHTTP DigestAPI KEYOauthJWT 下面就简单聊聊这些认证方式: HTTP Basic可以网上自行搜索, 基本上不会采用, 因为安全性比较低; HTTP Digest想了解可以网上自行搜索, 以后可能会进行补充, 暂时未做学习; API KEYOAUTH2JWTopenid可以主要参考微信公众平台的: https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432 重点: http://blog.csdn.net/degwei/article/details/51489391http://wiki.connect.qq.com/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_server-sidehttp://wiki.open.qq.com/wiki/website/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7OpenID_OAuth2.0参考: http://www.searchsoa.com.cn/showcontent_75305.htm WSSE(WS-Security)参考文档 : https://www.ibm.com/developerworks/cn/webservices/ws-secure/ http://php-di.org/ UnionIDAppNameAppIDAppSecret(AppKey) 当应用通过OpenAPI调用腾讯开放平台资源时需要的加密串，用来验证应用的合法性。AppKey在创建应用时分配OpenID OpenID是与APP通信的用户key，跳转到应用首页后，URL后会带该参数。根据APPID以及QQ号码生成，不同的appid下同一个QQ号生成的OpenID是不一样的（目前不接受同一个开发者名下的不同应用之间对于同一个用户的OpenID的互通）。 OpenID在每个应用中都是唯一，作为用户的唯一标识，访问OpenAPI时必需传入OpenID。 qq开放平台的专业术语解释:http://wiki.open.qq.com/wiki/%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD#1.3_AppKey 参考 阮一峰","categories":[{"name":"Restful","slug":"Restful","permalink":"http://blog.renyimin.com/categories/Restful/"}],"tags":[{"name":"Restful","slug":"Restful","permalink":"http://blog.renyimin.com/tags/Restful/"}]},{"title":"API Gateway","slug":"restful--02--","date":"2016-06-17T12:21:08.000Z","updated":"2017-10-17T07:34:55.000Z","comments":true,"path":"2016/06/17/restful--02--/","link":"","permalink":"http://blog.renyimin.com/2016/06/17/restful--02--/","excerpt":"","text":"","categories":[{"name":"Restful","slug":"Restful","permalink":"http://blog.renyimin.com/categories/Restful/"}],"tags":[{"name":"Restful","slug":"Restful","permalink":"http://blog.renyimin.com/tags/Restful/"}]},{"title":"API Gateway","slug":"restful--01--api gateway","date":"2016-06-17T12:21:08.000Z","updated":"2017-10-17T07:37:03.000Z","comments":true,"path":"2016/06/17/restful--01--api gateway/","link":"","permalink":"http://blog.renyimin.com/2016/06/17/restful--01--api gateway/","excerpt":"","text":"","categories":[{"name":"Restful","slug":"Restful","permalink":"http://blog.renyimin.com/categories/Restful/"},{"name":"API Gateway","slug":"Restful/API-Gateway","permalink":"http://blog.renyimin.com/categories/Restful/API-Gateway/"}],"tags":[{"name":"Restful","slug":"Restful","permalink":"http://blog.renyimin.com/tags/Restful/"},{"name":"API Gateway","slug":"API-Gateway","permalink":"http://blog.renyimin.com/tags/API-Gateway/"}]},{"title":"Encrypt Decrypt","slug":"Encrypt and Decrypt","date":"2016-05-30T07:37:39.000Z","updated":"2017-10-24T04:51:21.000Z","comments":true,"path":"2016/05/30/Encrypt and Decrypt/","link":"","permalink":"http://blog.renyimin.com/2016/05/30/Encrypt and Decrypt/","excerpt":"","text":"常见的加密算法可以分成三类对称加密算法非对称加密算法Hash算法 对称加密指加密和解密使用相同密钥的加密算法;对称加密算法的优点在于加解密的高速度和使用长密钥时的难破解性;假设两个用户需要使用对称加密方法加密然后交换数据, 则用户最少需要2个密钥并交换使用, 如果企业内用户有n个, 则整个企业共需要n×(n-1)个密钥, 密钥的生成和分发将成为企业信息部门的恶梦;对称加密算法的安全性取决于加密密钥的保存情况, 但要求企业中每一个持有密钥的人都保守秘密是不可能的, 他们通常会有意无意的把密钥泄漏出去——如果一个用户使用的密钥被入侵者所获得, 入侵者便可以读取该用户密钥加密的所有文档, 如果整个企业共用一个加密密钥, 那整个企业文档的保密性便无从谈起; 常见的对称加密算法: DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES ; 非对称加密指加密和解密使用不同密钥的加密算法，也称为公私钥加密;假设两个用户要加密交换数据, 双方交换公钥, 使用时一方用对方的公钥加密, 另一方即可用自己的私钥解密;如果企业中有n个用户，企业需要生成n对密钥，并分发n个公钥。由于公钥是可以公开的，用户只要保管好自己的私钥即可，因此加密密钥的分发将变得十分简单。同时，由于每个用户的私钥是唯一的，其他用户除了可以可以通过信息发送者的公钥来验证信息的来源是否真实，还可以确保发送者无法否认曾发送过该信息。非对称加密的缺点是加解密速度要远远慢于对称加密, 在某些极端情况下，甚至能比非对称加密慢上1000倍 ; 常见的非对称加密算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用） Hash算法Hash算法特别的地方在于它是一种单向算法, 用户可以通过Hash算法对目标信息生成一段特定长度的唯一的Hash值，却不能通过这个Hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。常见的Hash算法: MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1","categories":[{"name":"密码","slug":"密码","permalink":"http://blog.renyimin.com/categories/密码/"}],"tags":[{"name":"密码","slug":"密码","permalink":"http://blog.renyimin.com/tags/密码/"}]},{"title":"Laravel-install-01","slug":"Laravel-install-01","date":"2016-04-15T08:34:13.000Z","updated":"2017-09-19T04:52:28.000Z","comments":true,"path":"2016/04/15/Laravel-install-01/","link":"","permalink":"http://blog.renyimin.com/2016/04/15/Laravel-install-01/","excerpt":"","text":"通过Composer下载安装可以在终端中通过Composer的==create-project==命令来创建一个新的Laravel项目:123composer create-project laravel/laravel [项目目录名] [项目版本号] --prefer-dist如果不写laravel下载下来后放置项目的目录名, 则默认为laravel; 1234567比如要下载Laravel的LTS版本(目前是Laravel5.1), 操作如下:composer create-project laravel/laravel vip 5.1.33 --prefer-dist或者composer create-project laravel/laravel vip 5.1.* --prefer-dist 应用Key的设置如果你是通过Composer或者Laravel安装器安装的话, 该key的值已经通过key:generate命令生成好了; (通常, 该字符串应该是32位长, 该key被配置在.env环境文件中(APP_KEY), 如果你还没有将.env.example文件重命名为.env, 现在立即这样做;如果应用key没有被设置, 用户sessions和其它加密数据将会有安全隐患!) 如果你不是通过composer安装的laravel, 生成key的方式如下:1先创建一个.env文件 12345然后生成应用key:bogon:laravel renyimin$ php artisan key:generateApplication key [7a7rsPOdMubimWYQRddpxEiTRuoQMScE] set successfully.bogon:laravel renyimin$ 你如果是使用Composer安装的话, 可以看到: image.png image.png nginx的设置:1$uri $uri/ /index.php?$query_string image.png 1项目根目录配置到: 项目目录的 public 目录下; 安装成功: image.png","categories":[{"name":"PHP框架","slug":"PHP框架","permalink":"http://blog.renyimin.com/categories/PHP框架/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.renyimin.com/tags/Laravel/"}]},{"title":"07 - Client Credentials Grant.","slug":"OAuth-07","date":"2016-03-24T13:07:01.000Z","updated":"2017-10-19T09:45:28.000Z","comments":true,"path":"2016/03/24/OAuth-07/","link":"","permalink":"http://blog.renyimin.com/2016/03/24/OAuth-07/","excerpt":"","text":"客户端模式（Client Credentials Grant）指客户端以自己的名义, 而不是以用户的名义, 向”服务提供商”进行认证; 严格地说, 客户端模式并不属于OAuth框架所要解决的问题; 在这种模式中, 用户直接向客户端注册, 客户端以自己的名义要求”服务提供商”提供服务, 其实不存在授权问题; 步骤如下1.客户端向认证服务器进行身份认证, 并要求一个访问令牌 ;2.认证服务器确认无误后, 向客户端提供访问令牌 ; 参考 阮一峰","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"06 - Password Credentials Grant","slug":"OAuth-06","date":"2016-03-23T04:45:07.000Z","updated":"2017-10-19T09:45:24.000Z","comments":true,"path":"2016/03/23/OAuth-06/","link":"","permalink":"http://blog.renyimin.com/2016/03/23/OAuth-06/","excerpt":"","text":"密码模式(Resource Owner Password Credentials Grant)用户向客户端提供自己的用户名和密码,客户端使用这些信息, 向”服务商提供商”索要授权; 在这种模式中, 用户必须把自己的密码给客户端, 但是客户端不得储存密码 ; 这通常用在用户对客户端高度信任的情况下, 比如客户端是操作系统的一部分, 或者由一个著名公司出品; 而认证服务器只有在其他授权模式无法执行的情况下, 才能考虑使用这种模式; 参考 阮一峰","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"05 - OAuth-implicit-grant","slug":"OAuth-05","date":"2016-03-22T12:11:19.000Z","updated":"2017-10-19T09:45:15.000Z","comments":true,"path":"2016/03/22/OAuth-05/","link":"","permalink":"http://blog.renyimin.com/2016/03/22/OAuth-05/","excerpt":"","text":"简化模式/隐式授权(implicit grant type)不通过第三方应用程序的服务器, 直接在浏览器中向认证服务器申请令牌, 跳过了”授权码”这个步骤, 因此得名; 所有步骤在浏览器中完成, 令牌对访问者是可见的, 且客户端不需要认证; 步骤如下1.客户端将用户导向认证服务器 ; 2.用户决定是否给于客户端授权 ; 3.假设用户给予授权, 认证服务器将用户导向客户端指定的”重定向URI”, 并在URI的Hash部分包含了访问令牌 ; 4.浏览器向资源服务器发出请求, 其中不包括上一步收到的Hash值 ; 5.资源服务器返回一个网页, 其中包含的代码可以获取Hash值中的令牌 ; 6.浏览器执行上一步获得的脚本, 提取出令牌 ; 7.浏览器将令牌发给客户端 ; 参考 阮一峰","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"04 - 授权码模式各阶段分析 (持续完善中...)","slug":"OAuth-04","date":"2016-03-22T11:11:10.000Z","updated":"2017-10-24T10:00:33.000Z","comments":true,"path":"2016/03/22/OAuth-04/","link":"","permalink":"http://blog.renyimin.com/2016/03/22/OAuth-04/","excerpt":"","text":"第一阶段: 第三方站点将导向授权页 第三方应用将用户导向授权页时, 传递的参数如下: response_type: 表示授权类型, 必选项, 此处由于采用的是授权码模式, 所以值固定为 “code” client_id/AppID: 表示客户端的ID, 必选项由于你可能会有多个站点需要对接OAuth授权服务器, 所以一般在授权服务平台登录之后, 是可以创建多个 应用 的 (不同的站点对接授权服务器中不同的应用);每个应用对应你的一个 第三方站点, 开放平台会为每个应用(第三方站点)生成相应的 AppID 和 AppSecret/AppKey, 主要用来验证应用的合法性; redirect_uri: 设定的重定向到第三方站点URI, 必选项 scope: 表示申请的权限范围, 可选项 state: 表示客户端的当前状态, 可以指定任意值, 认证服务器会原封不动地返回这个值 下面是各开放平台的参数对比: 新浪 QQ 微信 GitHub 蚂蚁金服 简单测试: redirect_uri在OAuth服务器中为第三方站点创建 应用 的时候, 设定的回调地址, 无论在认证服务器, 还是在第三方站点, 都会对其进行校验, 以防篡改; 新浪授权传递错误 redirect_uri 简书qq授权传递错误 redirect_uri state第三方站点会对state做校验给了一个新的弹框用来进行授权, 但是如果恶意用户复制出弹框中的url, 之后再修改state并刷新页面, 授权后发现: 从上面各平台也可以看到, 返回参数相对比较简单; 返回的code是和授权页登录的用户身份相关的; (后面的access_token也是通过code和用户身份关联起来的) 第二阶段: 通过Authorization Code获取Access Token 如果第三方站点的用户在第一阶段的授权页中选择对第三方站点授权, 那么就第三方站点就会收到授权服务器的Authorization Code, 进而进入本阶段;(每个用户在授权后, 第三方站点都需要到授权服务器上为用户获取一个access_token, 这个access_token就是以后第三方站点从授权服务器上获取用户信息的凭证了, 一般在获取到access_token令牌之后, 可以存储到session中) 本阶段, 我们在自己的第三方站点中就可以使用第一阶段的Authorization Code获取Access Token: 微信(暂不上图, 微信还涉及到了openid, 此处介绍标准OAuth, 因此先不进行介绍) qq 基本上入参就像QQ互联那样大概有5个 (需要对每个参数进行了解); 本阶段的返回参数比较有讲究, 一般为如下三个 access_token 授权令牌access_token一般在获取到之后, 第三方站点可以将其 保存到用户的session中 , 第三方站点之后要获取用户在授权服务器上的资源的时候, 就需要带上当前session中用户的access_token去获取; expires_in 该access token的有效期,单位为秒 (微信公众平台access_token有效期为2小时, qq互联平台为3个月 可以作为参考)设置access_token有效期也是为了定期修改access_token, 以提高安全性;(并且微信对获取access_token这个基础API是有限制的，每天最多请求2000次, 因为有效期为2小时, 每天2000次也足够了;) refresh_token 授权自动续期时使用 (微信公众平台refresh_token有效期为30天, qq互联平台具体不详, 可以作为参考) (可选)权限自动续期问题 注意微信公众平台: 1.若access_token已超时，那么进行refresh_token会获取一个新的access_token，新的超时时间, 并且一旦使用refresh_token来刷新access_token的话, refresh_token的过期时间也会更新(自动延期) ; 2.若access_token未超时，那么进行refresh_token不会改变access_token，但超时时间会刷新，相当于续期access_token ; 这里说的超时时间刷新, 指的自然是第三方站点和授权服务器上的超时时间都要更新了(只不过你如果只是做对接的话, 授权服务器这部分人家已经开发好了, 如果你是授权服务器也是自己开发的话, 那你就需要注意这里了) 其实第三方站点在受到授权服务器分配给当前用户的access_token之后, 假设说授权服务器返回access_token的过期时间为7200s(2小时), 那么第三方站点将access_token保存到用户session中, 并设置过期时间为6600s(中间可以有个10分钟的服务器时间差); 如果第三方站点在使用access_token为用户获取授权服务器中的资源时, 发现session中的access_token并没有过期, 那么请求后就需要为access_token续期(第三方站点和授权服务器上都要做续期) 如果第三方站点在使用access_token为用户获取授权服务器中的资源时, 发现session中的access_token过期, 则就需要使用refresh_token调用生成access_token的api接口重新生成access_token来进行续期； qq: 这样下来, 基本上第三方站点只有在大于refresh_token的过期时间都没有调用过授权服务器的话, 才需要用户重新登录; 第三阶段(比较简单): 第三方站点通过access_token获取授权平台资源服务器上的用户资源 获取access_token后，进行接口调用，有以下前提： access_token有效且未超时； 微信用户已授权给第三方应用帐号相应接口作用域(scope);也就是在授权服务器上还会使用access_token去检测对应的scope权限是否正确; 注意, 使用access_token获取用户资源的时候, 得先知道用户在资源服务器上的身份(比如id): 新浪需要使用access_token获取用户信息 腾讯需要是使用access_token获取用户openid 而微信公众平台在获取access_token之后, 会同时返回openid表示微信用户在本公众号中的唯一标识;","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"03 - OAuth2的CSRF攻击","slug":"OAuth-03","date":"2016-03-20T14:03:21.000Z","updated":"2017-10-20T01:34:34.000Z","comments":true,"path":"2016/03/20/OAuth-03/","link":"","permalink":"http://blog.renyimin.com/2016/03/20/OAuth-03/","excerpt":"","text":"假设有如下几个角色:受害者 lant ;攻击者 rymuscle ;第三方Web应用 liangren网 (它允许用户将其在 sandiruiqi网 的账号 和 liangren网 的账号进行绑定) ;OAuth2服务提供平台 sandiruiqi网 ; 攻击流程 攻击者rymuscle 登录 liangren网 并且选择使用自己的 sandiruiqi网 账号登录 ; liangren网 将 攻击者rymuscle 重定向到 sandiruiqi网 的授权页(这时可能需要 攻击者rymuscle 登录过sandiruiqi网), sandiruiqi网 的授权页向 攻击者rymuscle 显示 “是否授权liangren网访问” ; 攻击者rymuscle 在点击”同意授权”之后, 截获 sandiruiqi网 服务器返回的含有 Authorization Code 参数的HTTP响应 ; 然后 攻击者rymuscle 精心构造一个Web页面, 它会触发 liangren网 向 sandiruiqi网 发起令牌申请的请求, 而这个请求中的Authorization Code参数正是上一步 攻击者rymuscle 截获到的code ; 攻击者rymuscle 将这个Web页面放到互联网上, 等待或者诱骗受害者来访问 ; 假设正好一个受害者 lant 访问了 攻击者rymuscle 准备的这个Web页面后, 令牌申请流程在 受害者lant 的浏览器里被顺利触发, laingren网 从 sandiruiqi网 那里获取到access_token, 但是这个token以及通过它进一步获取到的用户信息却都是攻击者 攻击者rymuscle 的 ; 也就是最终 liangren网 将 攻击者rymuscle 的 sandiruiqi 账号同 lant 的 liangren网 账号关联了起来 从此以后, lant只要没有察觉到自己最初被悄悄使用了 攻击者rymuscle 的sandiruiqi网 账号登录, 那么他在 liangren网 上的所有资料, 都可以被 攻击者rymuscle 所看到, 并且 攻击者rymuscle 可能在 lant 的账号中做一些非法操作; 整体时序图分析 先看标准oauth时序图 下面是从网上copy的一张图, 从整体上来看, 这次攻击的时序图类似下图: 可以看到, 攻击的关键点在于:OAuth2的认证流程是分为好几步来完成的, 在标准oauth图的第3步, 第三方应用在收到一个GET请求时, 除了能知道当前用户的cookie, 以及URL中的Authorization Code之外, 难以分辨出这个请求到底是用户本人的意愿, 还是攻击者利用用户的身份伪造出来的请求; 于是乎, 攻击者就能使用移花接木的手段, 提前准备一个含有自己的Authorization Code的请求, 并让受害者的浏览器来接着完成后续的令牌申请流程 ; 难点(涉及到了非state参数防御): 尽管这个攻击既巧妙又隐蔽, 但是要成功进行这样的CSRF攻击也是比较困难的 : 整个攻击必须在短时间内完成, 因为OAuth2提供者颁发的Authorization Code有效期很短, OAuth2官方推荐的时间是不大于10分钟, 而一旦Authorization Code过期那么后续的攻击也就不能进行下去了; 一个Authorization Code只能被使用一次, 如果OAuth2提供者收到重复的Authorization Code, 它会拒绝当前的令牌申请请求, 不止如此, 根据OAuth2官方推荐, 它还可以把和这个已经使用过的Authorization Code相关联的access_token全部撤销掉, 进一步降低安全风险; 其实貌似只要做到Authorization Code只能被使用一次, 就可以防止csrf在此处的攻击了, 因为 rymuscle 在攻击的时候, 一旦获得 Authorization Code, 第三方站点服务器就会使用 Authorization Code 去申请access_token, 然后只要标记 Authorization Code 为已经使用, 那么 受害者lant 即使点击 攻击者rymuscle 构造好的链接也没用, 因为连接中的 Authorization Code 已经被标记为使用过了; 所以不一定非要使用下面的state参数来进行防御比如微信公众平台的OAuth授权: state参数就是可选的新浪开放平台的OAuth授权, state参数也是可选的当然, 他们不一定做的是和此处一样的防御方案, 但明显不依赖于state参数来解决问题; state参数防御: 要防止这样的攻击其实很容易, 作为第三方应用的开发者, 只需在OAuth认证过程中加入 state 参数, 并验证它的参数值即可; 在将用户重定向到OAuth2的Authorization Endpoint去的时候, 为用户生成一个随机的字符串, 并作为state参数加入到URL中 ; 在收到OAuth2服务提供者返回的Authorization Code请求的时候, 验证接收到的state参数值, 如果是正确合法的请求, 那么此时接受到的参数值应该和上一步提到的为该用户生成的state参数值完全一致, 否则就是异常请求; 但需要注意 state参数 需要具备下面几个特性: 不可预测性: 足够的随机, 使得攻击者难以猜到正确的参数值 ;如果你每次生成的state都被放在一起, 比如一个库/缓存中存在很多state;那么问题就是攻击者还是可以拿着自己的code再加上一个state, 来构造一个链接欺骗用户来点击;(假设state正好就在你的库/缓存中); 重点是关联性: state参数值可以和当前用户会话(user session)相互关联的所以应该让state和具体的用户关联起来, 虽然用户还没有登录, 但是也可以让state放到session中 ;然后攻击者要猜测出来一个state的话, 即便是已经生成过了, 但是也得正好攻击的是这个用户; 唯一性: 每个用户每次请求生成的state参数值都是唯一的 ; 时效性: state参数一旦被使用则立即失效 ; 参考 蚂蚁金服开放平台: 其实可以结合以上各种方法一起来进行防御! 参考 移花接木参考 state参数漏洞参考 阮一峰","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"02 - 授权码模式简介","slug":"OAuth-02","date":"2016-03-19T12:27:36.000Z","updated":"2017-10-19T07:45:57.000Z","comments":true,"path":"2016/03/19/OAuth-02/","link":"","permalink":"http://blog.renyimin.com/2016/03/19/OAuth-02/","excerpt":"","text":"授权码模式简介1.授权码模式(authorization code)是功能最完整、流程最严密的授权模式, 它的特点就是通过 客户端的后台服务器 与 &quot;服务提供商&quot;的认证服务器 进行互动 ; 2.通常一些开放平台使用的都是授权码模式的授权方法, 如qq互联, 微信开放平台等, 不过各自对OAuth2协议还进行了修改, 如微信和QQ还有OpenID的加入; 授权码模式运行过程 运行图 运行过程分析1.向用户取得授权许可对应图中的第1、2、3步; 2.申请访问令牌access_token令牌的申请对应图中的第4、5步; ( 一些授权平台对标准oauth2进行了部分修改, 如QQ互联, 在申请完access_token令牌之后, 还有一步是使用access_token获取openid ) 3.使用令牌获取用户数据 这一过程中涉及了不少敏感参数和数据, 例如client_secret相当于是第三方应用自己的密码, access_token某种程度上来讲就是用户的session id, 由于这些参数以及数据极其特殊, 我们当然得确保它们的安全性, HTTPS加密传输以及安全存储是必不可少的防护手段, 不过仅仅做到这些是远远不够的, 因为其实在这个流程里存在一个弱点， 容易被攻击者利用进行CSRF攻击, 稍后讲解 ;","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"01 - OAuth开放式授权 简介","slug":"OAuth-01","date":"2016-03-19T03:05:00.000Z","updated":"2017-10-23T09:56:23.000Z","comments":true,"path":"2016/03/19/OAuth-01/","link":"","permalink":"http://blog.renyimin.com/2016/03/19/OAuth-01/","excerpt":"","text":"开始之前首先需要将 API接口签名验证 和 授权 这两个概念稍微区分一下 现在基本上在网上搜索 Restful API授权认证 方面的内容, 很多文章都会罗列出 OAuth2.0, JWT, API_KEY 等方案; 但其实上述列出的方案并不是都用来解决 授权认证 问题的;授权认证: 一般指的是用户给第三方站点授权(可以是内部系统之间,也可以是第三方站点和授权服务器之间)api接口签名验证: 一般用的是 JWT 或者 API_KEY (这两个方案其实除了格式, 原理比较类似, 微信公众号开发时, 其实就采用类似这种方案保证api接口数据传输的安全性); 你的api接口为了安全起见, 都会做api接口签名验证, 但是你不一定需要做授权认证; OAuth(Open Authorization)开放式授权1.OAuth是一个关于授权(authorization)的开放网络标准, 在全世界得到广泛应用, 目前的版本是2.0版 ; 2.传统所谓的&quot;授权&quot;, 比较 简单, 直接, 暴力, 比如:用户想在一个”云冲印”网站中冲印自己Google账户中的相册, 可能就需要将自己的Google账号和密码提供给”云冲印”网站; 传统授权的弊端: 1234567891011121314151617181.如果用户在每个第三方站点都这样做, 那将会存在严重安全隐患:很多第三方网站为了后续的服务, 会保存用户的google账号和密码, 这样很不安全, 因为难免有些第三方平台会由于自己的安全问题而导致用户的google账号和密码泄露, 从而导致用户大量信息泄露;google为了防止可能存在猪一样的第三方队友, 自然不会让自己的用户使用 如此low的授权方案 去给第三方站点授权 ;2.用户无法设定 第三方站点的权利范围:第三方网站拥有了获取用户在google的资料的权力, 用户没法限制 第三方网站 获得授权的范围和有效期 ;3.用户想收回 第三方站点的权利不太方便:用户只有修改密码, 才能收回赋予 第三方网站 的权力, 否则 第三方网站 将会永久拥有用户 Google 账号的权利; 但是这样做, 又会使得其他所有获得用户授权的第三方应用程序全部失效;或者, 一些良心第三方可以设置 用户账号 和 google 账号的绑定和解绑,但不一定所有第三方都会给你做, 如果不做解绑的话, 你还真就只有前一种方法能够收回权利; 3.而OAuth的授权不会让 第三方站点 触及到用户在 google 上的帐号信息(如用户名与密码), 即第三方无需使用用户的google账号与密码就可以获得该用户在 google 上的资源, 因此 OAuth 是安全的, OAuth 是 Open Authorization(开放授权) 的简写; 为什么学习OAuth授权?1.公司的站点需要对接其他站点的开放平台; 随处可见的 QQ/微信/微博 登录比如你要做一个站点, 常规做法就需要建立一套用户注册登录体系, 但网民很反感, 因为他们可能有很多站点的用户名密码, 不太想再多一个账号了;但大家几乎都有 QQ , 微信, 人人, 豆瓣 等互联网大佬的帐号; 那我们就可以用 QQ/新浪微博… 帐号登录后, 授权给本网站呢; 公司站点作为第三方站点, 接入了支付宝相关业务(这样, 用户在本站点进行支付的时候, 就可以授权公司的站点从支付宝获取用户的账号信息,从而完成支付), 当然, 对接支付宝也需要对OAuth相关知识有一定的了解; 2.再比如SSO单点登录: 假设公司有多套内部系统, 也对应了多套后台管理系统, 比如: A系统 – A系统的后台管理系统, B系统 – B系统的后台管理系统, C系统 – C系统的后台管理系统,这样, 开发者或公司的后台管理人员可能就得在每个系统上都有自己的账号, 比较麻烦;其实这时候就应该考虑可以做一个 用户中心 系统, 然后各系统的项目leader就可以在 用户中心 创建自己系统对应的应用(还可以考虑进行一些接口权限的授权);然后各系统的用户(开发者/管理者), 只需要有个用户中心账号, 然后在用户中心进行登录, 就可以登录到其他系统;用户中心的单点登录其实就可以使用OAuth授权协议来做一个授权服务, 一旦用户登录用户中心, 就向用户发放access_token, 然后用户访问各个系统的时候, 都带着access_token去用户中心的认证服务做认证即可;(当然, SSO单点登录的方案不止使用OAuth这一种) 3.公司开发自己对外的开放平台;当然, 此时你公司自然是做大做强了, 可以对一些小公司提供福利了!! 无论以上那种场景, 你都需要对OAuth授权有一定的认识才行; OAuth – 4个角色1.资源拥有者(Resource Owner)资源所有者, 用户自己 ; 2.资源服务器(Resource Server)资源服务器, 即服务提供商存放用户生成的资源的服务器 (当然, 它与认证服务器, 可以是同一台服务器,也可以是不同的服务器) 3.认证服务器(Authorization server)认证服务器, 即服务提供商专门用来处理认证的服务器 ; 4.客户端(client)第三方站点, 本文中又称”客户端”, 即上面例子中的”云冲印”站点 ; OAuth 2.0的运行流程 运行流程图 运行流程图解 123456（A）用户打开客户端以后，客户端要求用户给予授权。（B）用户同意给予客户端授权。（C）客户端使用上一步获得的授权，向认证服务器申请令牌。（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。（E）客户端使用令牌，向资源服务器申请获取资源。（F）资源服务器确认令牌无误，同意向客户端开放资源 不难看出来, 上面六个步骤之中, B是关键, 即用户怎样才能给于客户端授权; 有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源; 引出客户端的授权模式客户端必须得到用户的授权(authorization grant), 才能获得令牌(access token), OAuth 2.0定义了四种授权方式:1.授权码模式（authorization code) 2.简化模式（implicit） 3.密码模式（resource owner password credentials） 4.客户端模式（client credentials） 参考: 阮一峰","categories":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/categories/OAuth2-0/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://blog.renyimin.com/tags/OAuth2-0/"}]},{"title":"PHP的Closure学习整理","slug":"clusore-introduction","date":"2016-03-10T06:30:15.000Z","updated":"2017-09-19T04:55:10.000Z","comments":true,"path":"2016/03/10/clusore-introduction/","link":"","permalink":"http://blog.renyimin.com/2016/03/10/clusore-introduction/","excerpt":"","text":"主要是对网上现存的一些资料做了一些简单地整理, 一方面让自己对基础知识加深印象, 一方面便于日后自己随时回顾! JavaScript中的闭包在了解PHP的闭包之前, 我们可以先简单了解一下JavaScript的闭包是怎样的? Js的作用域1.要理解闭包，首先必须理解Javascript的 变量作用域 ; 2.变量的作用域无非就是两种: 全局变量 和 局部变量 ; Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量:js12345var n=999;function f1()&#123; alert(n);&#125;f1(); // 999 另一方面, 在函数外部自然无法读取函数内的局部变量:js1234function f1()&#123; var n=999; //这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！&#125;alert(n); // error 如何从外部读取局部变量？出于种种原因, 我们有时候需要得到函数内的局部变量, 但是, 前面已经说过了, 正常情况下，这是办不到的, 只有通过变通方法才能实现; 于是, 我们可以在函数的内部, 再定义一个函数:js123456function f1()&#123; var n = 999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中, 函数f2就被包括在函数f1内部, 这时, f1内部的所有局部变量, 对f2都是可见的;但是反过来就不行, f2内部的局部变量, 对f1就是不可见的; 这就是Javascript语言特有的”链式作用域”结构(chain scope), 子对象会一级一级地向上寻找所有父对象的变量; 所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！js123456789101112131415161718192021function f1(a)&#123; var n = &apos;局部变量&apos;; function f2(c)&#123; console.log(n); console.log(a); console.log(c); &#125; return f2;&#125;var result = f1(&apos;传递给函数的参数,也成了一个局部值&apos;);result(&apos;传递给闭包的参数1&apos;);console.log(&apos;&apos;);result(&apos;传递给闭包的参数2&apos;);//结果: 局部变量 //可以看到我们就从外部取到了函数内部的局部变量传递给函数的参数,也成了一个局部值传递给闭包的参数1局部变量 //可以看到我们就从外部取到了函数内部的局部变量传递给函数的参数,也成了一个局部值传递给闭包的参数2 闭包的概念上一节代码中的f2函数, 就是闭包; 各种专业文献上对 “闭包”（closure）定义非常抽象，很难看懂; 我的理解是，闭包就是能够读取其他函数内部变量的函数; 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量, 因此可以把闭包简单理解成 “定义在一个函数内部的函数” ; 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁; 闭包的用途1.闭包可以用在许多地方, 它的最大用处有两个:12一个是前面提到的可以读取函数内部的变量; 另一个就是让这些变量的值始终保持在内存中; 2.怎么来理解上面的话呢？ 之前的代码中, result 这个变量其实就是闭包函数f2, 它一共运行了两次; 而函数f1中的局部变量一直保存在内存中, 并没有在f1调用后被自动清除; 原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后被垃圾回收机制（garbage collection）回收; 使用闭包的注意点1.由于闭包会使得函数中的变量都被保存在内存中, 内存消耗很大, 所以不能滥用闭包, 否则会造成网页的性能问题, 在IE中可能导致内存泄露, 解决方法是, 在退出函数之前, 将不使用的局部变量全部删除; 2.闭包会在父函数外部改变父函数内部变量的值; 所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method）, 把内部变量当作它的私有属性（private value）, 这时一定要小心, 不要随便改变父函数内部变量的值; js12345678910var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); // The Window js1234567891011var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); // My Object 以上参考阮一峰的博客, 阮一峰大哥真的写的很好了, 本人这里只是过一遍, 然后稍微简化了一点点, 修改了一点列子, 便于自己理解; PHP的闭包1.PHP的闭包 和 匿名函数 是在PHP5.3.0中引入, 这两个特性非常有用, 每个PHP开发者都应该掌握; 2.闭包是指在创建时, 封装周围状态的函数, 即便闭包所在的环境不存在了, 闭包中封装的状态依然存在, 这个概念如果你看了之前的JavaScript相关闭包的概念, 应该理解起来不是太难; 3.匿名函数是没有名称的的函数, 匿名函数可以赋值给变量, 还能像其他任何PHP变量那样传递, 不过匿名函数仍是函数, 因此可以调用, 还可以传入参数, 匿名函数特别适合作为函数或方法的回调; 4.理论上讲, 闭包和匿名函数是不同的概念, 不过, PHP将其视为相同的概念, 所以一般在PHP中说闭包就是匿名函数, 说匿名函数也是指闭包; 5.PHP闭包和匿名函数使用的句法虽然和普通函数相同, 但是需要注意的是, 闭包和匿名函数其实是伪装成函数的对象, 如果审查PHP闭包或匿名函数, 会发现阀门是Closure类的实例; 闭包和字符串或证书一样, 也是一等值类型 ; 创建闭包12345678&lt;?php$closure = function ($name) &#123; return sprintf('Hello %s', $name);&#125;;var_dump($closure); //object(Closure)#1 (1) &#123; [\"parameter\"]=&gt; array(1) &#123; [\"$name\"]=&gt; string(10) \"\" &#125; &#125;echo '&lt;br/&gt;';echo $closure('Josh'); //Hello Josh 闭包对象的创建就这么简单; 12建议: 之所以能调用$closure变量, 是因为这个变量的值是一个闭包, 而且闭包对象实现了__invoke()魔术方法;只要变量名后面有(), PHP就会查找并调用__invoke()方法; 通常情况下, 我们会把PHP的闭包对象当做函数和方法的回调来使用; 很多PHP的函数都会用到回调函数, 例如 array_map()和preg_replace_callback();这是使用PHP匿名函数的绝佳时机! 记住, 闭包和其他值一样, 可以作为参数出传入其他PHP函数; PHP中闭包的 附加状态1.之前我们说的 array_map()和preg_replace_callback() 对闭包的使用, 主要是把匿名函数当做回调来使用;下面我们讨论的是如何为PHP闭包附加并封装状态; 2.JavaScript开发者可能对PHP的闭包感到奇怪, 因为通过之前对JavaScript中闭包的了解, 它的闭包会自动封装应用的状态; 而PHP的闭包不会像真正的JS闭包那样自动封装应用的状态;在PHP中, 我们必须手动调用闭包对象的 use关键字 , 或者闭包对象的 bindTo()方法 来把状态附加到PHP闭包上; use关键字使用use关键字附加闭包状态比较常见, 我们先看这种方式; 使用use关键字把变量附加到闭包上时, 附加的变量会记住附加时赋给它的值:1234567891011&lt;?phpfunction enclosePerson($name)&#123; return function ($doCommand) use ($name) &#123; return sprintf('%s, %s', $name, $doCommand); &#125;;&#125;$clay = enclosePerson('Clay');echo $clay('get me sweet tea!'); 在例子中, 具名函数enclosePerson()有个名为$name参数, 这个函数返回一个闭包对象, 而且这个闭包对象封装了$name参数;即便返回的闭包对象已经跳出了enclosePerson()函数的作用域, 闭包对象也会记住$name参数的值, 因为$name变量仍在闭包中; 1使用use关键字可以把多个参数传入闭包, 此时要像php函数或方法的参数一样, 使用都好分割多个参数; Closure对象的bindTo()方法1.别忘了, php闭包是个对象(Closure对象), 与任何其他PHP对象类似, 每个闭包都可以使用$this关键字获取闭包的内部状态; 虽然闭包对象的默认状态没什么用, 只不过是有一个__invoke魔术方法和bindTo()方法而已; 但是bindTo()方法为闭包增加了一些有趣的潜力, 我们可以使用这个方法把closure对象内部的状态绑定到其他对象上; 2.bindTo()方法的第二个参数很重要, 其作用是指定绑定闭包的那个对象所属的PHP类; 因此, 闭包可以访问绑定闭包的对象中受保护和似有的成员变量; 3.其实如果经常看一些php框架源码, 你会发现, PHP框架经常使用bindTo()方法把 路由URL所映射的匿名回调函数 绑定到 应用对象上, 这么做可以在这个匿名函数中使用$this关键字引用重要的应用对象:12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass App&#123; protected $routes = []; protected $responseStatus = '200 OK'; protected $responseContentType = 'text/html'; protected $responseBody = 'Hello world'; public function addRoute($routePath, $routeCallback) &#123; $this-&gt;routes[$routePath] = $routeCallback-&gt;bindTo($this, __CLASS__); &#125; public function dispatch($currentPath) &#123; foreach($this-&gt;routes as $routePath =&gt; $callBack) &#123; if ($routePath === $currentPath) &#123; $callBack(); &#125; &#125; header('HTTP/1.1 ' . $this-&gt;responseStatus); header('Content-type: ' . $this-&gt;responseContentType); header('Content-length: ' . mb_strlen($this-&gt;responseBody)); echo $this-&gt;responseBody; &#125;&#125;$app = new App();$app-&gt;addRoute('/user/getName', function() &#123; $this-&gt;responseContentType = 'application/json;charset=utf8'; $this-&gt;responseBody = '&#123;\"name\": \"renyimin\"&#125;';&#125;);$app-&gt;dispatch('/user/getName');//结果返回: &#123;\"name\": \"renyimin\"&#125; 上面例子其实就是通过在App应用类中, 使用匿名函数的bindTo()方法将匿名函数绑定到了App对象上, 所以你就可以在绑定路由与其匿名函数的时候, 在匿名函数中来通过$this来调用App对象中的一些受保护的属性, 从而设定本路由的返回信息; 《Modern PHP》","categories":[{"name":"PHP New Features","slug":"PHP-New-Features","permalink":"http://blog.renyimin.com/categories/PHP-New-Features/"},{"name":"PHP","slug":"PHP-New-Features/PHP","permalink":"http://blog.renyimin.com/categories/PHP-New-Features/PHP/"}],"tags":[{"name":"Closure(闭包)","slug":"Closure-闭包","permalink":"http://blog.renyimin.com/tags/Closure-闭包/"}]},{"title":"01 - 认识JWT","slug":"JWT-01","date":"2016-01-07T02:05:00.000Z","updated":"2017-10-19T10:11:09.000Z","comments":true,"path":"2016/01/07/JWT-01/","link":"","permalink":"http://blog.renyimin.com/2016/01/07/JWT-01/","excerpt":"","text":"","categories":[{"name":"JWT","slug":"JWT","permalink":"http://blog.renyimin.com/categories/JWT/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"http://blog.renyimin.com/tags/JWT/"}]},{"title":"网络数据通信方式","slug":"Data-communication-method01","date":"2015-07-10T05:20:16.000Z","updated":"2017-10-16T03:46:25.000Z","comments":true,"path":"2015/07/10/Data-communication-method01/","link":"","permalink":"http://blog.renyimin.com/2015/07/10/Data-communication-method01/","excerpt":"","text":"计算机网络中传输的信息都是数字数据, 按照数据在线路上的传输方向，通信方式 可分为： 单工通信(Simplex)单向信道,信息流是单方向的发送端和接收端的身份是固定的, 发送端只能发送信息, 不能接收信息; 接收端只能接收信息, 不能发送信息 ; 常见通信遥控、遥测, 就是单工通信方式 半双工通信(Half Duplex)双向信道, 信息流是双向的没有固定发送端和接收端, 任何一端都可以发送消息给另一端 ; 同一时刻只能发送或只能接收数据所谓半双工就是指一个时间段内只有一个动作发生 ; 常见通信对讲机, 微信语音 全双工通信(Full Duplex)双向信道, 信息流是双向的没有固定发送端和接收端, 任何一端都可以发送消息给另一端 ; 发送和接收数据可以同时进行是指在发送数据的同时也能够接收数据, 可以同时进行 ;(目前的网卡一般都支持全双工) 常见通信我们平时的打电话通信就是全双工通信，你在说话的同时也能够听到对方的声音 ;","categories":[{"name":"网络","slug":"网络","permalink":"http://blog.renyimin.com/categories/网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://blog.renyimin.com/tags/网络/"}]},{"title":"polling-->服务推技术-->websocket","slug":"websocket01","date":"2015-07-10T04:40:16.000Z","updated":"2017-10-16T03:04:56.000Z","comments":true,"path":"2015/07/10/websocket01/","link":"","permalink":"http://blog.renyimin.com/2015/07/10/websocket01/","excerpt":"","text":"背景1.传统Web开发下, 我们都是使用http协议在服务器和客户端之间进行通信, 要知道http协议是一种单向的网络协议, 在建立连接之后, 只能是浏览器向服务器发出请求资源后, 服务器才能响应 ; 注意: 服务器是无法主动的推送数据给客户端的, 这也是为了安全起见 ; 2.既然传统的http请求有上述问题, 那么如下一些现代web开发的场景该如何应对?即时通信系统；即时报价系统；股票的实时行情; 3.要应对上述应用场景, 目前有很多方案可供选择, 下面将一一介绍; 传统Ajax短轮训(Polling)1.这种方案主要就是通过浏览器每隔一定时间就去向服务器发送http请求, 服务器受到请求后, 就把最新的数据返回给客户端(浏览器), 浏览器再将数据显示出来 ; 2.虽然这种方案可以满足需求, 但是却存在很多问题:(1) 可能在一段时间内的多次请求中, 服务器端的数据根本就没有更新过, 这样就导致客户端一直在空转, 这样既浪费了网络带宽, 又浪费了COU的利用率 ; (2) 针对第一个问题, 可能有人会觉得, 将客户端请求服务器的时间间隔做适当的调整就可以, 比如调整大一点, 但这样的话, 如果服务器端的数据更新很快的时候, 又不能保证客户端获取数据的实时性 ; 解决方案 – 服务器推技术服务器推技术分两类面对上面提到的实时性较高的web应用场景, “服务器推”技术有一些解决方案, 本文将这些解决方案分为两类 :(1)一类需要在浏览器端安装插件,基于套接口传送信息,或是使用 RMI、CORBA 进行远程调用 ;基于客户端套接口的 “服务器推” 技术 (2)而另一类则无须浏览器安装任何插件、基于 HTTP 长连接 ;Comet 基于客户端套接口的”服务器推”技术Flash XMLSocket如果你的Web应用的用户可以接受 只有在安装了 Flash 播放器 应用才能正常运行, 那么使用 Flash 的 XMLSocket 就是一个可行的方案: 这种方案实现的基础是:1.Flash 提供了 XMLSocket 类 ;2.JavaScript 和 Flash 的紧密结合: 在 JavaScript 可以直接调用 Flash 程序提供的接口; 具体实现方法: 在 HTML 页面中内嵌入一个使用了 XMLSocket 类的 Flash 程序, JavaScript 通过调用此 Flash 程序提供的套接口接口与服务器端的套接口进行通信, JavaScript 在收到服务器端以 XML 格式传送的信息后可以很容易地控制 HTML 页面的内容显示 ; 关于如何去构建充当了 JavaScript 与 Flash XMLSocket 桥梁的 Flash 程序，以及如何在 JavaScript 里调用 Flash 提供的接口，我们可以参考 AFLAX（Asynchronous Flash and XML）项目提供的 Socket Demo 以及 SocketJS（请参见 参考资源） Javascript 与 Flash 的紧密结合，极大增强了客户端的处理能力。从 Flash 播放器 V7.0.19 开始，已经取消了 XMLSocket 的端口必须大于 1023 的限制。Linux 平台也支持 Flash XMLSocket 方案。但此方案的 缺点 在于：(1)客户端必须安装 Flash 播放器；(2)因为 XMLSocket 没有 HTTP 隧道功能，XMLSocket 类不能自动穿过防火墙；(3)因为是使用套接口，需要设置一个通信端口，防火墙、代理服务器也可能对非 HTTP 通道端口进行限制； 不过这种方案在一些网络聊天室，网络互动游戏中已得到广泛使用。 Java Applet 套接口在客户端使用 Java Applet，通过 java.net.Socket 或 java.net.DatagramSocket 或 java.net.MulticastSocket 建立与服务器端的套接口连接, 从而实现”服务器推” ; 这种方案最大的不足在于 Java applet 在收到服务器端返回的信息后, 无法通过 JavaScript 去更新 HTML 页面的内容 ; 基于HTTP长连接的”服务器推”技术Comet 简介1.”服务器推” 是一种很早就存在的技术,以前在实现上主要是通过客户端的套接口或是服务器端的远程调用, 因为浏览器技术的发展比较缓慢,没有为”服务器推”的实现提供很好的支持,在纯浏览器的应用中很难有一个完善的方案去实现”服务器推”并用于商业程序; 2.最近几年, 因为 AJAX 技术的普及, 以及 把 IFrame 嵌在 &quot;htmlfile&quot; 的 ActiveX 组件中可以解决 IE 的加载显示问题，一些受欢迎的应用如 meebo，gmail+gtalk 在实现中使用了这项技术; 3.Alex Russell(Dojo Toolkit 的项目 Lead)称 基于 HTTP 长连接、无须在浏览器端安装插件的 “服务器推”技术为 “Comet”; 4.目前已经出现了一些成熟的 Comet 应用以及各种开源框架, 一些 Web 服务器如Jetty也在为支持大量并发的长连接进行了很多改进; 关于 Comet 技术最新的发展状况请参考关于 Comet 的 wiki。 Comet的实现模型有两类下面将介绍两种 Comet 应用的实现模型 (都是基于http长连接) :基于 AJAX 的长轮询（long-polling）方式 基于 Iframe 及 htmlfile 的流(streaming)方式 基于 AJAX 的长轮询（long-polling）方式1.AJAX 的出现使得 JavaScript 可以调用 XMLHttpRequest 对象发出 HTTP 请求，JavaScript 响应处理函数根据服务器返回的信息对 HTML 页面的显示进行更新; 2.使用 AJAX 实现”服务器推” 与 传统的 AJAX 应用不同之处在于：(1)服务器端会阻塞请求直到有数据传递或超时才返回;(2)客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后,再次发出请求,重新建立连接;(3)当客户端处理接收的数据、重新建立连接时, 服务器端可能有新的数据到达, 这些信息会被服务器端保存直到客户端重新建立连接, 客户端会一次把当前服务器端所有的信息取回; 3.基于长轮询的服务器推模型如下: 相对于”短轮询”(poll), 这种长轮询方式也可以称为”拉”(pull); 这种方案基于 AJAX，具有以下一些优点:请求异步发出;无须安装插件;IE、Mozilla FireFox 都支持 AJAX; 基于 Iframe 及 htmlfile 的流(streaming)方式1.iframe 是很早就存在的一种 HTML 标记, 通过在 HTML 页面里嵌入一个隐蔵帧,然后将这个隐蔵帧的 SRC 属性设为对一个长连接的请求, 服务器端就能源源不断地往客户端输入数据; 2.基于流方式的服务器推模型上节提到的 AJAX 方案是在 JavaScript 里处理 XMLHttpRequest 从服务器取回的数据，然后 Javascript 可以很方便的去控制 HTML 页面的显示; 同样的思路用在 iframe 方案的客户端，iframe 服务器端并不返回直接显示在页面的数据，而是返回对客户端 Javascript 函数的调用，如&lt;script type=&quot;text/javascript&quot;&gt;js_func(&#39;data from server&#39;)&lt;/script&gt;; 服务器端将返回的数据作为客户端 JavaScript 函数的参数传递, 客户端浏览器的 Javascript 引擎在收到服务器返回的 JavaScript 调用时就会去执行代码; 从图中可以看到,每次数据传送不会关闭连接,连接只会在通信出现错误时或是连接重建时关闭(一些防火墙常被设置为丢弃过长的连接,服务器端可以设置一个超时时间,超时后通知客户端重新建立连接,并关闭原来的连接); 使用 iframe 请求一个长连接有一个很明显的不足之处:IE、Morzilla Firefox 下端的进度栏都会显示加载没有完成,而且 IE 上方的图标会不停的转动,表示加载正在进行;Google 的天才们使用一个称为“htmlfile”的 ActiveX 解决了在 IE 中的加载显示问题，并将这种方法用到了 gmail+gtalk 产品中。Alex Russell 在 “What else is burried down in the depth’s of Google’s amazing JavaScript?”文章中介绍了这种方法。Zeitoun 网站提供的 comet-iframe.tar.gz，封装了一个基于 iframe 和 htmlfile 的 JavaScript comet 对象，支持 IE、Mozilla Firefox 浏览器，可以作为参考。（请参见 参考资源） 解决方案 – WebSocket1.websocket是HTML5中定义的新协议, 它实现了真正的长连接, 实现了浏览器与服务器的全双工通信;WebSocket是为解决客户端与服务端实时通信而产生的技术, websocket协议本质上是一个基于tcp的协议，是先通过HTTP/HTTPS协议发起一条特殊的http请求进行握手后, 创建一个用于交换数据的TCP连接, 此后服务端与客户端通过此TCP连接进行实时通信 ;注意:此时不再需要原HTTP协议的参与了 ; 2.摘自参考","categories":[{"name":"WebSocket","slug":"WebSocket","permalink":"http://blog.renyimin.com/categories/WebSocket/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"http://blog.renyimin.com/tags/WebSocket/"}]},{"title":"Ajax请求不能发送 -- WebSocket方案","slug":"sameoriginpolicy07-ajax-disabled-websocket","date":"2015-06-07T02:20:16.000Z","updated":"2017-09-30T01:44:34.000Z","comments":true,"path":"2015/06/07/sameoriginpolicy07-ajax-disabled-websocket/","link":"","permalink":"http://blog.renyimin.com/2015/06/07/sameoriginpolicy07-ajax-disabled-websocket/","excerpt":"","text":"简介WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信 ; 下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 例子","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"},{"name":"WebSocket","slug":"CrossDomain/WebSocket","permalink":"http://blog.renyimin.com/categories/CrossDomain/WebSocket/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://blog.renyimin.com/tags/WebSocket/"}]},{"title":"小结","slug":"sameoriginpolicy06-summary","date":"2015-05-30T13:20:16.000Z","updated":"2017-09-29T09:22:12.000Z","comments":true,"path":"2015/05/30/sameoriginpolicy06-summary/","link":"","permalink":"http://blog.renyimin.com/2015/05/30/sameoriginpolicy06-summary/","excerpt":"","text":"Jsonp 对比 CORS简单/非简单请求都可以方便实现跨域; Jsonp简单适用, 老式浏览器全部支持, 服务器端改动很小; JSONP只能发GET请求; JSONP跨子域发送Cookie的话(貌似也就是在跨子域的时候你能发发cookie), 只用设置好cookie的domain属性为顶级域名即可; CORS简单请求服务端需要设置一些允许选项; 发送请求为 GET, POST, HEAD ; 跨子域发送cookie的话(貌似也就是在跨子域的时候你能发发cookie), 不仅需要设置cookie的domain属性, 服务端和客户端都要对Credentials header属性进行设置; 跨子域的话 服务端 Access-Control-Allow-Origin 不能设置为 * , 否则会提示 :123Failed to load http://test.test.com/index.php?sex=renyimin&amp;age=100: The value of the 'Access-Control-Allow-Origin' header in the response must not be the wildcard '*' when the request's credentials mode is 'include'. Origin 'http://www.test.com' is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute. CORS非简单请求服务端需要设置一些允许选项; 发送其他请求 (PUT) .. 可以设置自定义header头 cookie方面和 CORS简单请求一样","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"Ajax请求不能发送 -- CORS方案02 (not-so-simple request)","slug":"sameoriginpolicy05-ajax-disabled-cors-not-simple","date":"2015-05-20T12:10:16.000Z","updated":"2017-09-29T09:22:02.000Z","comments":true,"path":"2015/05/20/sameoriginpolicy05-ajax-disabled-cors-not-simple/","link":"","permalink":"http://blog.renyimin.com/2015/05/20/sameoriginpolicy05-ajax-disabled-cors-not-simple/","excerpt":"","text":"非简单请求预检请求 preflight 说明 非简单请求是那种对服务器有特殊要求的请求, 比如请求方法是 PUT 或 DELETE, 或者 Content-Type 字段的类型是 application/json ; 非简单请求的CORS请求, 会在正式通信之前, 增加一次HTTP查询请求, 称为 &quot;预检&quot;请求(preflight) ; 浏览器先询问服务器, 当前网页所在的域名是否在服务器的许可名单之中, 以及可以使用哪些HTTP动词和头信息字段; 只有得到肯定答复, 浏览器才会发出正式的XMLHttpRequest请求, 否则就报错 ; 非简单请求会导致原先的一次请求变成两次, 第一次请求是 预检请求 ; “预检”请求用的请求方法是 OPTIONS，表示这个请求是用来询问的，头信息里面，关键字段是Origin，表示请求来自哪个源 ; 即使你的请求方法是 GET, POST 或者 HEAD(只是请求时自定义了一些header首部字段), 你的这个跨域请求也是 非简单请求，此时请求头显示的 ； 非简单请求的例子 www.test.com/index.php 本例子使用 PUT 来进行ajax请求, 满足 非简单请求 的条件 ; 另外, 本例还自定义了请求时的 header 首部字段, 也满足 非简单请求 的条件 ; 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" &gt; $(document).ready(function()&#123; $(\"#btn\").click(function() &#123; //序列化name/value var data = $(\"form\").serializeArray(); $.ajax(&#123; //这里用PUT, 则为 `非简单` 请求 type: 'PUT', url: 'http://test.test.com/index.php', dataType: 'json', data: data, //或者如果你自定义了一些请求时的 header 首部字段, 那么请求就也是 复杂请求 headers: &#123;\"custom-header-field\" : \"test\"&#125;, success: function (result) &#123; console.log(result); &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=\"form\"&gt; &lt;input type=\"text\" name=\"sex\"&gt; &lt;input type=\"text\" name=\"age\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"button\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; test.test.com/index.php 12345678910&lt;?php//服务器允许的 Originheader(\"Access-Control-Allow-Origin: http://www.test.com\");//服务器允许的 methodsheader(\"Access-Control-Allow-Methods: PUT, GET, POST\");//服务器允许设置的头部字段header(\"Access-Control-Allow-Headers: custom-header-field\");$arguments = file_get_contents('php://input');echo json_encode(['arguments' =&gt; $arguments]); 注意: 像上面例子的复杂跨域请求 必须: 首先和简单请求一样, 服务器端的 Access-Control-Allow-Origin 是必须设置的, 不然首先就跨不了域; 必须: 其次, 是使用了 get, post, head 之外方法的 复杂请求, 那么就必须在服务端有对应的 Access-Control-Allow-Method, 否则: 可选: 如果你自定义了 自定义首部字段 的 复杂请求, 那么也要在服务端有对应的 Access-Control-Allow-Headers, 否则: 另外需要关注的是: 如果你设置了自定义的首部字段, 那么即使你的请求类型是get, post, head, 自然也是复杂请求, 此时的HTTP请求方法显示的仍然如下: 1Request Method:OPTIONS 分析预检请求 上面www.test.com/index.php代码进行ajax请求的时候, HTTP请求的方法是PUT, 所以浏览器会发现, 这是一个非简单请求, 就自动发出一个”预检”请求, 要求服务器确认可以这样请求 ; 所以请求应该是包括预检请求和真正的请求两个请求的: 下面是这个”预检”请求的HTTP头信息 和 回应信息: 可以看到, “预检”请求用的请求方法是OPTIONS, 表示这个请求是用来询问的, 头信息里面, 关键字段是Origin, 表示请求来自哪个源;除了Origin字段，”预检”请求的头信息包括两个特殊字段:(1)Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT ;(2)Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段, 上例是X-Custom-Header ; 预检响应 从下面预检请求的截图中，可以看到预检请求的回应中, 服务器收到”预检”请求以后, 检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后，确认允许跨源请求，就可以做出回应 ; 并且预检请求部分是不会真的发送数据的: 上面的HTTP回应中，关键的是 Access-Control-Allow-Origin 字段，表示 http://www.test.com 可以请求数据, 该字段也可以设为星号，表示同意任意跨源请求 ; 123Access-Control-Allow-Origin: http://www.test.com或者Access-Control-Allow-Origin: * 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段 ; 这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest 对象的 onerror 回调函数捕获; 控制台会打印出如下的报错信息 ; 服务器还可能回应的其他CORS相关字段如下: 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 cookie方面, 其实和CORS简单请求是一样的要求 www.test.com/index.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpsetcookie('address', json_encode(['city' =&gt; 'yuncheng', 'town' =&gt; 'xiaoliang']), 0, '/', '.test.com');?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" &gt; $(document).ready(function()&#123; $.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); $(\"#btn\").click(function() &#123; //序列化name/value var data = $(\"form\").serializeArray(); $.ajax(&#123; //这里用PUT, 则为 `非简单` 请求 type: 'PUT', url: 'http://test.test.com/index.php', dataType: 'json', data: data, //或者如果你自定义了一些请求时的 header 首部字段, 那么请求就也是 复杂请求 headers: &#123;\"custom-header-field\" : \"test\"&#125;, success: function (result) &#123; console.log(result); &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=\"form\"&gt; &lt;input type=\"text\" name=\"sex\"&gt; &lt;input type=\"text\" name=\"age\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"button\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; test.test.com 12345678910111213&lt;?php//服务器允许的 Origin (如果要发送cookie的话复杂请求也不能为*)header(\"Access-Control-Allow-Origin: http://www.test.com\");//服务器允许的 methodsheader(\"Access-Control-Allow-Methods: PUT, GET, POST\");//服务器允许设置的头部字段header(\"Access-Control-Allow-Headers: custom-header-field\");//要跨子域发cookie, 这个自然不能少header(\"Access-Control-Allow-Credentials: true\");$arguments = file_get_contents('php://input');$address = $_COOKIE['address'];echo json_encode(['arguments' =&gt; $arguments, 'cookie' =&gt; $address]); 参考 CORS","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"Ajax请求不能发送 -- CORS方案01 (simple request)","slug":"sameoriginpolicy04-ajax-disabled-cors-simple","date":"2015-05-19T04:45:07.000Z","updated":"2017-09-29T09:21:55.000Z","comments":true,"path":"2015/05/19/sameoriginpolicy04-ajax-disabled-cors-simple/","link":"","permalink":"http://blog.renyimin.com/2015/05/19/sameoriginpolicy04-ajax-disabled-cors-simple/","excerpt":"","text":"CORS说明 CORS是一个W3C标准, 全称是 “跨域资源共享 “(Cross-origin resource sharing), 通俗说就是我们所熟知的跨域请求 ; 12众所周知，在以前，跨域可以采用 `代理`、`JSONP` 等方式，而在Modern浏览器面前，这些终将成为过去式，因为有了CORS ;CORS在最初接触的时候只大概了解到，通过服务器端设置Access-Control-Allow-Origin响应头，即可使指定来源像访问同源接口一样访问跨域接口，但其实CORS的规范定义远不止这些 ; 它允许 浏览器 向 跨源服务器 发出XMLHttpRequest请求, 从而克服了AJAX只能同源使用的限制 ; CORS需要浏览器和服务器同时支持 (目前, 所有浏览器都支持该功能, IE浏览器不能低于IE10) ; 整个CORS通信过程都是浏览器自动完成, 不需要用户参与 ; 对于开发者来说, CORS通信与同源的AJAX通信没有差别, 代码完全一样, 浏览器一旦发现AJAX的请求是跨源的, 就会自动添加一些附加的头信息, 有时还会多出一次附加的请求, 但用户不会有感觉; 因此，其实实现CORS通信的关键是服务器, 只要服务器实现了CORS接口，就可以跨源通信 CORS的两类请求 浏览器将CORS请求分成两类: 简单请求(simple request) 和 非简单请求(not-so-simple request) 以下为非简单请求的情况 : 12345请求以 GET, HEAD 或者 POST 以外的方法发起请求 ;或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型, 比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求 ;使用自定义请求头（比如添加诸如 X-PINGOTHER） 简单请求先看代码案例 客户端代码 www.test.com/index.html : 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; &gt; $(document).ready(function()&#123; $(&quot;#btn&quot;).click(function(k) &#123; var data = $(&quot;form&quot;).serializeArray();//序列化name/value $.ajax(&#123; type: &apos;GET&apos;, //这里用GET url: &apos;http://test.test.com/index.php&apos;, dataType: &apos;json&apos;, //类型 data: data, success: function (result) &#123;//返回的json数据 console.log(result); //回调输出 &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 服务端代码test.test.com/index.php : 123&lt;?phpheader(\"Access-Control-Allow-Origin: http://www.test.com\");echo json_encode(['name' =&gt; 'lant', 'age' =&gt; 100]); 基本流程分析浏览器直接发出CORS请求对于简单请求，浏览器直接发出CORS请求, 具体来说, 就是在头信息之中, 自动增加一个Origin字段 ; 浏览器识别出跨域AJAX简单请求浏览器发现这次跨源AJAX请求是简单请求, 就自动在头信息之中, 添加一个Origin字段: 上面的头信息中, Origin字段 用来说明本次请求来自哪个源(协议 + 域名 + 端口), 服务器根据这个值, 决定是否同意这次请求 ; 浏览器添加的Origin源不在服务器设置的许可范围如果Origin源, 不在许可范围内, 服务器让然会返回一个正常的HTTP回应, 不过浏览器会发现, 这个回应的头信息并没有包含 Access-Control-Allow-Origin 字段(详见下文), 就知道出错了, 从而抛出一个错误, 被XMLHttpRequest的onerror回调函数捕获; 注意, 这种错误无法通过状态码识别, 因为HTTP回应的状态码有可能是200 ; 浏览器添加的Origin源在服务器设置的许可范围内 当然, 如果 Origin源在服务器设置的许可范围内 , 服务器返回的响应, 就会多出如下个头信息字段(当然也不一定是所有都包含, 具体还得看服务器如何进行设置) : 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 重点分析:上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头:(1) Access-Control-Allow-Origin服务器要设置ajax请求可以跨域, 该字段是必须的, 它的值要么是请求时Origin字段的值，要么是一个，表示接受任意域名的请求;(2) Access-Control-Allow-Credentials该字段可选, 它的值是一个布尔值，表示是否允许发送Cookie, *默认情况下，Cookie不包括在CORS请求之中, 设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器;注意, 这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。(3) Access-Control-Expose-Headers该字段可选, CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 服务器端的具体设置 服务器在设置的时候, 其实就是通过header函数设置上面的三个选项! 比如之前的例子中, 如果服务器只是简单的为了实现跨域, 直接设置如下选项即可: 123&lt;?phpheader(\"Access-Control-Allow-Origin: http://www.test1.com\");echo json_encode(['name' =&gt; 'lant', 'age' =&gt; 100]); withCredentials 属性CORS请求默认不发送Cookie和HTTP认证信息 (Jsonp是会发送cookie信息的) 之前在介绍Access-Control-Allow-Credentials选项的时候提到, CORS请求默认不发送Cookie和HTTP认证信息; 如果要把Cookie发到服务器: 一方面要 服务器同意指定Access-Control-Allow-Credentials字段 : 123Access-Control-Allow-Credentials: true//php中设置如下:header(\"Access-Control-Allow-Credentials: true\"); 另一方面, 开发者必须在AJAX请求中打开 withCredentials 属性: 1234var xhr = new XMLHttpRequest();xhr.withCredentials = true;//jquery中设置withCredentials的代码如下:$.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); 需要以上两方面都做到才可以 否则，即使服务器同意发送Cookie，浏览器也不会发送, 或者，服务器要求设置Cookie，浏览器也不会处理 ; 但是, 如果省略 withCredentials 设置, 有的浏览器还是会一起发送Cookie, 这时, 可以显式关闭 withCredentials ; 1xhr.withCredentials = false; 需要注意的是: 如果要发送Cookie, Access-Control-Allow-Origin 就不能设为星号*, 必须指定明确的、与请求网页一致的域名 ; 同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传, 其他域名的Cookie并不会上传, 且(跨源)原网页代码中的document.cookie也无法读取服务器域名下的Cookie ; 例子域1中的代码(www.test.com/index.php)：1234567891011121314151617181920212223242526272829303132333435363738&lt;?php//Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传, 其他域名的Cookie并不会上传, 且(跨源)原网页代码中的document.cookie也无法读取服务器域名下的Cookiesetcookie('address', json_encode(['city' =&gt; 'yuncheng', 'town' =&gt; 'xiaoliang']), 0, '/', '.test.com');?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" &gt; $(document).ready(function()&#123; $.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); $(\"#btn\").click(function(k) &#123; var data = $(\"form\").serializeArray();//序列化name/value $.ajax(&#123; type: 'GET', //这里用GET url: 'http://test.test.com/index.php', dataType: 'json', //类型 data: data, success: function (result) &#123;//返回的json数据 console.log(result); //回调输出 &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=\"form\"&gt; &lt;input type=\"text\" name=\"sex\"&gt; &lt;input type=\"text\" name=\"age\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"button\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 域2中的代码(test.test.comindex.php):12345&lt;?phpheader(\"Access-Control-Allow-Origin: http://www.test.com\");header(\"Access-Control-Allow-Credentials: true\");$address = $_COOKIE['address'];echo json_encode(['name' =&gt; 'lant', 'age' =&gt; 100, 'address' =&gt; $address]); 效果: 两个注意 如果域1中在html中设置了 withCredentials 为 true : 1$.ajaxSetup(&#123;crossDomain: true, xhrFields: &#123;withCredentials: true&#125;&#125;); 那么在对应的ajax请求的域2中必须设置 1header(\"Access-Control-Allow-Credentials: true\"); 否则, 报错如下: 如果两边都不设置 withCredentials 属性的话, 也就是默认请求不带cookie, 那么即使请求方域1中设置了domain属性为 .test.com 的cookie值, 服务方(test.test.com)中也获取不到cookie, 因为域1默认请求就没有带cookie ; 参考 CORS","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"Ajax请求不能发送 -- JSONP方案","slug":"sameoriginpolicy03-ajax-disabled-jsonp","date":"2015-05-18T11:27:31.000Z","updated":"2017-09-29T09:21:51.000Z","comments":true,"path":"2015/05/18/sameoriginpolicy03-ajax-disabled-jsonp/","link":"","permalink":"http://blog.renyimin.com/2015/05/18/sameoriginpolicy03-ajax-disabled-jsonp/","excerpt":"","text":"JSONP说明及注意 JSONP是服务器与客户端 跨源通信 的常用方法, 最大特点就是简单适用, 老式浏览器全部支持, 服务器端改造非常小 ; 但是，JSONP只能发GET请求 ; 注意: JSONP跨子域发送Cookie的话, 只用设置好cookie的domain属性为顶级域名即可 ; ajax使用jsonp跨域的时候是可以轻松像上面这样带上cookie给所跨的域的 ; 而下一篇介绍的ajax使用cors方案跨域的话, 除了设置了cookie的 document.domain 为两个地址的顶级域名, 却也不能带上cookie, 还需要注意 前端和服务端的 withCredentials 头字段 ; jsonp跨域请求案例www.test.com/index.html12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; &gt; $(document).ready(function()&#123; //注意, 此时jsonp是会带上cookie的 //当然不设置domain的话, test.test.com自然获取不到cookie document.cookie = &quot;name=value; domain=test.com&quot;; $(&quot;#btn&quot;).click(function() &#123; var data = $(&quot;form&quot;).serializeArray();//序列化name/value $.ajax(&#123; type: &apos;GET&apos;, //这里用GET url: &apos;http://test.test.com/index.php&apos;, dataType: &apos;jsonp&apos;, //类型 data: data, jsonp: &apos;callback&apos;, //jsonp回调参数，必需 async: false, success: function (result) &#123;//返回的json数据 console.log(result); //回调输出 &#125;, timeout: 3000 &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; test.test.com/index.php1234567891011&lt;?php//jsonp回调参数，必需$callback = isset($_GET['callback']) ? trim($_GET['callback']) : '';$sex = isset($_GET['sex']) ? trim($_GET['sex']) : '';$age = isset($_GET['age']) ? trim($_GET['age']) : '';$data = [\"sex\" =&gt; $sex, \"age\" =&gt; $age];$res = json_encode($data); //json 数据// 不能用returnecho $callback . '(' . $res . ')'; //返回格式，必需 参考","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"同源策略的限制 -- Ajax请求不能发送","slug":"sameoriginpolicy02-ajax-disabled","date":"2015-05-17T14:30:19.000Z","updated":"2017-09-29T09:21:51.000Z","comments":true,"path":"2015/05/17/sameoriginpolicy02-ajax-disabled/","link":"","permalink":"http://blog.renyimin.com/2015/05/17/sameoriginpolicy02-ajax-disabled/","excerpt":"","text":"同源策略的限制 - Ajax请求不能发送 同源政策规定, AJAX请求只能发给同源的网址, 否则就报错 ; 除了架设服务器代理(浏览器请求同源服务器，再由后者请求外部服务), 有三种方法规避这个限制 : JSONP CORS WebSocket 参考","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"同源策略的限制 -- Cookie无法读取","slug":"sameoriginpolicy01-cookie-disabled","date":"2015-05-16T05:18:13.000Z","updated":"2017-09-29T10:15:22.000Z","comments":true,"path":"2015/05/16/sameoriginpolicy01-cookie-disabled/","link":"","permalink":"http://blog.renyimin.com/2015/05/16/sameoriginpolicy01-cookie-disabled/","excerpt":"","text":"回顾之前学习同源策略基础知识的时候, 了解了同源策略的 三种行为 限制: Cookie、LocalStorage 和 IndexDB 无法读取 DOM 无法获得 AJAX 请求不能发送 (注意: 这里并不会导致诸如超链接之类的请求被限制, 也就是b网站中的超链接访问a网站是不会被同源策略限制的, 这才会有CSRF攻击 ;) 本节主要讨论 Cookie无法读取 的相关知识 ; Cookie无法读取的例子 要知道, Cookie 是服务器写入浏览器的一小段信息, 只有同源的网页才能共享 ; 注意: 本篇介绍的主要是直接访问不相同的域名(超链接模拟跨域 或者 直接打开另一个网页模拟跨域 ) 导致的Cookie无法读取的问题, 不会涉及到 Ajax请求所涉及的cookie传递问题, 这个问题属于同源策略的第三种限制 AJAX请求不能发送 ; 例子 : A网页是 http://www.test.com/index.html，B网页是 http://test.test.com/index.html : A: www.test.com/index.html (此处是使用js来设置cookie进行测试; 当然, 用服务端代码php测试也是OK的) 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; document.cookie=&quot;name=value;&quot;;&lt;/script&gt;&lt;/html&gt; B: test.test.com/index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; console.log(document.cookie);&lt;/script&gt;&lt;/html&gt; // 可以看到, 同顶级域名 的域名也获取不到不同二级域名的域锁设置的cookie //同理, 直接在http://www.test.com/index.html中超链接点击到http://test.test.com/index.html也是获取不到cookie的 ; 合理规避Cookie无法读取的限制 还是那句话, 虽然同源导致的这些限制是必要, 但是有些情况下, 其实我们是需要 合理 规避Cookie无法读取的限制的 ; 比如: 如果两个网页的顶级域名相同, 只是二级域名不同的话, 浏览器其实是允许你通过设置 document.domain 来共享 Cookie ; 例子: A网页是 http://www.test.com/index.html，B网页是 http://test.test.com/index.html, 那么只要设置相同的 document.domain，两个网页就可以共享Cookie : A: www.test.com/index.html (此处是使用js来设置cookie进行测试; 当然, 用php代码也是OK的) 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; document.cookie=&quot;name=value; domain=test.com&quot;;&lt;/script&gt;&lt;/html&gt; B: test.test.com/index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;application/javascript&quot;&gt; console.log(document.cookie);&lt;/script&gt;&lt;/html&gt; 注意, 这种方法只适用于 Cookie 和 iframe 窗口, LocalStorage 和 IndexDB 无法通过这种方法来规避同源政策，而要使用之后会介绍的PostMessage API ; 摘自 阮一峰","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"浏览器的同源策略(Same origin policy)","slug":"sameoriginpolicy","date":"2015-05-15T11:58:54.000Z","updated":"2017-09-29T09:21:51.000Z","comments":true,"path":"2015/05/15/sameoriginpolicy/","link":"","permalink":"http://blog.renyimin.com/2015/05/15/sameoriginpolicy/","excerpt":"","text":"同源策略1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策； 最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”，所谓 “同源” 指的是 “三个相同” ：1.协议相同http://blog.renyimin.com 和 https://blog.renyimin.com 就不是同一个源 ； 2.域名相同http://blog.renyimin.com/test/index.php 和 http://blog.renyimin.com/welcome/index.html 就是同一个源; 但是 http://www.renyimin.com/test/index.php 和 http://blog.renyimin.com/test/index.php 就不是同一个源 ；请注意：localhost和127.0.0.1虽然都指向本机, 但也不是同一个源 ; 3.端口相同http://www.renyimin.com:8080/test/index.php 和 http://www.renyimin.com:80/test/index.php 就不是同一个源 ; 再举例来说，http://www.example.com/dir/page.html 这个网址，协议是 http://，域名是 www.example.com，端口是80（默认端口可以省略），它的同源情况如下：1234http://www.example.com/dir2/other.html：同源http://example.com/dir/other.html：不同源（域名不同）http://v2.www.example.com/dir/other.html：不同源（域名不同）http://www.example.com:81/dir/other.html：不同源（端口不同） 同源策略目的同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据; 设想这样一种情况: A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏; 更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以内置一些A网站的访问路径, 因为这样就可以拿到A网站之前存在用户本地的cookie, 这样就可以冒充用户，为所欲为，因为浏览器同时还规定，提交表单不受同源政策的限制 ; 由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了 ; 同源策略的限制范围随着互联网的发展, “同源政策”越来越严格, 目前, 如果非同源, 共有三种行为受到限制 : Cookie、LocalStorage 和 IndexDB 无法读取DOM 无法获得AJAX 请求不能发送虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响, 将详细介绍，如何合理规避上面三种限制 ; 参考 阮一峰增加了很多例子和额外思考!","categories":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/categories/CrossDomain/"}],"tags":[{"name":"CrossDomain","slug":"CrossDomain","permalink":"http://blog.renyimin.com/tags/CrossDomain/"}]},{"title":"XSS (Cross Site Scripting)","slug":"safe-xss01","date":"2015-05-09T12:15:47.000Z","updated":"2017-10-16T09:52:01.000Z","comments":true,"path":"2015/05/09/safe-xss01/","link":"","permalink":"http://blog.renyimin.com/2015/05/09/safe-xss01/","excerpt":"","text":"XSS (Cross Site Scripting 跨站脚本攻击)为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，所以将跨站脚本攻击缩写为XSS; XSS是一种网站应用程序的安全漏洞攻击, 是代码注入的一种, 它允许恶意用户将代码注入到网页上, 其他用户在观看网页时就会受到影响, 这类攻击通常包含了HTML以及用户端脚本语言; XSS与SQL注入攻击类似, SQL注入攻击是以SQL语句作为用户输入, 从而达到查询/修改/删除数据的目的; 而在xss攻击中, 是通过插入恶意脚本, 实现对用户浏览器的控制; 危害盗取cookie, 获取敏感信息; 利用植入Flash，通过crossdomain权限设置进一步获取更高权限; 或者利用Java等得到类似的操作; 利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击者）用户的身份执行一些管理动作，或执行一些如:发微博、加好友、发私信等常规操作，前段时间新浪微博就遭遇过一次XSS ; 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动; 在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果; 总体分为三类Dom-Based（Dom式）Stroed-Based（存储式/持久型）Reflex-Based（反射式/非持久型） ##场景11234567891011121314151617&lt;?phpsetcookie('name', 'renyimin');setcookie('age', 300);?&gt;&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"http://libs.baidu.com/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; &lt;input type=\"text\" name=\"address1\" value=\"\" onfocus=\"console.log(document.cookie);\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 参考参考httponlyhttp://www.cnblogs.com/h4ck0ne/p/5154622.html 信息安全","categories":[{"name":"Safe","slug":"Safe","permalink":"http://blog.renyimin.com/categories/Safe/"}],"tags":[{"name":"Safe","slug":"Safe","permalink":"http://blog.renyimin.com/tags/Safe/"}]},{"title":"CSRF (Cross-site request forgery)","slug":"safe-csrf01","date":"2015-05-05T02:20:16.000Z","updated":"2017-10-16T06:53:24.000Z","comments":true,"path":"2015/05/05/safe-csrf01/","link":"","permalink":"http://blog.renyimin.com/2015/05/05/safe-csrf01/","excerpt":"","text":"背景我们知道浏览器的同源策略对用户请求的资源是有一些行为限制的: Cookie、LocalStorage 和 IndexDB 无法读取 DOM 无法获得 AJAX 请求不能发送 但也有一些就是不在同源策略的限制范围之内; CSRF 跨站点请求伪造CSRF跨站点请求伪造(Cross—Site Request Forgery)跟XSS攻击一样, 存在巨大的危害性, 你可以这样来理解: 攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的;但是却完成了攻击者所期望的一个操作, 比如以你的名义发送邮件、发消息, 盗取你的账号, 添加系统管理员, 甚至于购买商品、虚拟货币转账等;如: 123Web A为存在CSRF漏洞的网站;Web B为攻击者构建的恶意网站;User C为Web A网站的合法用户; CSRF攻击攻击原理及过程如下: 123456用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功, 可以正常发送请求到网站A;用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B;网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A;浏览器在接收到这些攻击性代码后,根据网站B的请求,在用户不知情的情况下携带Cookie信息,向网站A发出请求;网站A并不知道该请求其实是由B发起的,所以会根据用户C的Cookie信息以C的权限处理该请求,导致来自网站B的恶意代码被执行。 CSRF攻击实例受害者 maomao 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=maomao&amp;amount=1000000&amp;for=gougou 可以使 maomao 把自己的 1000000 的存款转到 gougou 的账号下; 通常情况下, 该请求发送到网站后, 服务器会先验证该请求是否来自一个合法的 session, 并且该 session 的用户 maomao 已经成功登陆 ; 黑客 feiying 自己在该银行也有账户, 他知道银行网站中的上述 URL 可以对钱进行转帐操作, 于是 feiying 自己发送一个请求给银行: http://bank.example/withdraw?account=maomao&amp;amount=1000000&amp;for=feiying, 但是这个请求来自 feiying 而非 maomao, 他不能通过安全认证，因此该请求不会起作用 ; 但是此时，feiying 想到使用 CSRF 的攻击方式, 他先自己做一个网站, 在网站中放入如下代码: src=&quot;http://bank.example/withdraw?account=maomao&amp;amount=1000000&amp;for=feiying&quot;，并且通过广告等诱使 maomao 来访问他的网站, 当 maomao 访问该网站时, 上述 url 就会从 maomao 的浏览器发向银行, 而这个请求会附带 maomao 浏览器中的 cookie 一起发向银行服务器, 大多数情况下，该请求会失败，因为他要求 maomao 的认证信息, 但是，如果 maomao 当时恰巧刚访问他的银行后不久, 他的浏览器与银行网站之间的 session 尚未过期, 浏览器的 cookie 之中含有 maomao 的认证信息; 这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 maomao 的账号转移到 feiying 的账号, 而 maomao 当时毫不知情, 等以后 maomao 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 feiying 则可以拿到钱后逍遥法外; CSRF漏洞检测检测CSRF漏洞是一项比较繁琐的工作, 最简单的方法就是抓取一个正常请求的数据包, 去掉Referer字段后再重新提交, 如果该提交还有效, 那么基本上可以确定存在CSRF漏洞 ; 随着对CSRF漏洞研究的不断深入, 不断涌现出一些专门针对CSRF漏洞进行检测的工具, 如CSRFTester, CSRF Request Builder等 ; 以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下:使用CSRFTester进行测试时, 首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息, 然后通过在CSRFTester中修改相应的表单等信息, 重新提交, 这相当于一次伪造客户端请求;如果修改后的测试请求成功被网站服务器接受, 则说明存在CSRF漏洞, 当然此款工具也可以被用来进行CSRF攻击; 防御CSRF攻击目前防御 CSRF 攻击主要有三种策略 验证 HTTP Referer 字段根据 HTTP 协议, 在 HTTP 头中有一个字段叫 Referer, 它记录了该 HTTP 请求的来源地址; 在通常情况下, 访问一个安全受限页面的请求来自于同一个网站, 比如需要访问 http://bank.example/withdraw?account=maomao&amp;amount=1000000&amp;for=gougou, 用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件, 这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL, 通常是以 bank.example 域名开头的地址; 而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的, 如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求; 这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷; 然而，这种方法并非万无一失, Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞, 使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全, 事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值, 如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击 ;即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题, 因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中, 因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer, 当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问; 在请求地址中添加 token 并验证CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证; 要抵御 CSRF, 关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中, 可以在 HTTP 请求中以参数的形式加入一个随机产生的 token, 并在服务器端建立一个拦截器来验证这个 token, 如果请求中没有 token 或者 token 内容不正确, 则认为可能是 CSRF 攻击而拒绝该请求; 这种方法要比检查 Referer 要安全一些, token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求, 对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue, 而对于 POST 请求来说，要在 form 的最后加上 &lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;tokenvalue&quot;/&gt;, 这样就把 token 以参数的形式加入请求了, 但是, 在一个网站中, 可以接受请求的地方非常多, 要对于每一个请求都加上 token 是很麻烦的, 并且很容易漏掉, 通常使用的方法就是在每次页面加载时, 使用 javascript 遍历整个 dom 树, 对于 dom 中所有的 a 和 form 标签后加入 token, 这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token ; 该方法还有一个缺点是难以保证 token 本身的安全, 特别是在一些论坛之类支持用户自己发表内容的网站, 黑客可以在上面发布自己个人网站的地址, 由于系统也会在这个地址后面加上 token, 黑客可以在自己的网站上得到这个 token, 并马上就可以发动 CSRF 攻击, 为了避免这一点, 系统可以在添加 token 的时候增加一个判断, 如果这个链接是链到自己本站的, 就在后面添加 token, 如果是通向外网则不加;不过，即使这个 csrftoken 不以参数的形式附加在请求之中, 黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击, 这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因 ; 在 HTTP 头中自定义属性并验证这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里;通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中, 这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去; 然而这种方法的局限性非常大, XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便;另外, 对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的; 原文参考(并行会话的兼容)","categories":[{"name":"Safe","slug":"Safe","permalink":"http://blog.renyimin.com/categories/Safe/"}],"tags":[{"name":"Safe","slug":"Safe","permalink":"http://blog.renyimin.com/tags/Safe/"}]},{"title":"WEB安全之Token浅谈","slug":"web-safe-token","date":"2015-04-12T06:21:16.000Z","updated":"2017-10-16T06:47:38.000Z","comments":true,"path":"2015/04/12/web-safe-token/","link":"","permalink":"http://blog.renyimin.com/2015/04/12/web-safe-token/","excerpt":"","text":"Token一般用在两个地方: 防止表单重复提交, csrf攻击(跨站点请求伪造); 两者在原理上都是通过session token来实现的; 当客户端请求页面时, 服务器会生成一个随机数Token, 并且将Token放置到session当中, 然后将Token发给客户端(一般通过构造hidden表单), 下次客户端提交请求时, Token会随着表单一起提交到服务器端, 然后，服务器端会对Token值进行验证，判断是否和session中的Token值相等, 若相等则证明请求有效，不是伪造的, 否则, 则证明请求是非法的; 不过, 如果应用于”防止表单重复提交”，服务器端第一次验证相同过后, 会将session中的Token值更新下, 若用户重复提交, 第二次的验证判断将失败, 因为用户提交的表单中的Token没变, 但服务器端session中Token已经改变了;上面的session应用相对安全，但也较繁琐，同时当多页面多请求时，必须采用多Token同时生成的方法，这样占用更多资源，执行效率会降低。因此，也可用cookie存储验证信息的方法来代替session Token, 比如，应对”重复提交”时, 当第一次提交后便把已经提交的信息写到cookie中，当第二次提交时，由于cookie已经有提交记录，因此第二次提交会失败;不过,cookie存储有个致命弱点，如果cookie被劫持(xss攻击很容易得到用户cookie), 那么又一次gameover, 黑客将直接实现csrf攻击; 所以，安全和高效相对的; 参考","categories":[{"name":"Safe","slug":"Safe","permalink":"http://blog.renyimin.com/categories/Safe/"}],"tags":[{"name":"Safe","slug":"Safe","permalink":"http://blog.renyimin.com/tags/Safe/"}]}]}